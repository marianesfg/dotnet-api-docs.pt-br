<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="UIElement.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac569fc14f8a143a8f000734a5dc38f8d88f9280a2f.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">69fc14f8a143a8f000734a5dc38f8d88f9280a2f</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.UIElement">
          <source><ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> is a base class for WPF core level implementations building on Windows Presentation Foundation (WPF) elements and basic presentation characteristics.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> é uma classe base para implementações no nível do núcleo WPF baseada em elementos WPF (Windows Presentation Foundation) e características de apresentação básicas.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source><ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> provides a starting point for element layout characteristics, and also exposes virtual methods that derived classes can override, which can influence the layout rendering behavior of the element and its child elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> Fornece um ponto de partida para características de layout do elemento e também expõe os métodos virtuais que classes derivadas podem substituir, que pode influenciar o layout de elementos de renderização de comportamento do elemento e seus filhos.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source>Much of the input and focusing behavior for elements in general is also defined in the <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> class.</source>
          <target state="translated">Grande parte da entrada e comportamento para elementos concentrando-se em geral também é definido no <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source>This includes the events for keyboard, mouse and stylus input, and related status properties.</source>
          <target state="translated">Isso inclui os eventos de teclado, mouse e entrada de caneta e propriedades de status relacionadas.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source>Many of these events are routed events, and many of the input-related events have both a bubbling routing version as well as a tunneling version of the event.</source>
          <target state="translated">Muitos desses eventos são eventos roteados e muitos dos eventos relacionados à entrada tem dois uma bolha roteamento de versão, bem como uma versão de túnel do evento.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source>These paired events are typically the events of greatest interest to control authors.</source>
          <target state="translated">Esses eventos emparelhados normalmente são os eventos de maior interesse para autores de controle.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source><ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> also includes <ph id="ph2">[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]</ph> that relate to the <ph id="ph3">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> event model, including methods that can raise specified routed events that are sourced from an element instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> também inclui <ph id="ph2">[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]</ph> que se relacionam com o <ph id="ph3">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> modelo de evento, incluindo métodos que podem gerar especificados roteadas eventos que são originados de uma instância do elemento.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source>In terms of architecture, <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> can be considered roughly equivalent to a window handle in <ph id="ph2">[!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)]</ph> programming, or an Element in <ph id="ph3">[!INCLUDE[TLA#tla_dhtml](~/includes/tlasharptla-dhtml-md.md)]</ph> programming.</source>
          <target state="translated">Em termos de arquitetura, <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> podem ser consideradas equivalentes a um identificador de janela em <ph id="ph2">[!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)]</ph> programação ou um elemento em <ph id="ph3">[!INCLUDE[TLA#tla_dhtml](~/includes/tlasharptla-dhtml-md.md)]</ph> de programação.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source><ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> is a base element at the WPF core level.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> é um elemento base no nível de núcleo do WPF.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source>A <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> has the following capabilities that are specifically defined by the <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> class:</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> tem os seguintes recursos que são definidos especificamente pelo <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> classe:</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source>Can render as a child element (<ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> derives from <ph id="ph2">&lt;xref:System.Windows.Media.Visual&gt;</ph>, a high level graphics class)</source>
          <target state="translated">Podem ser processados como um elemento filho (<ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> deriva <ph id="ph2">&lt;xref:System.Windows.Media.Visual&gt;</ph>, uma classe de gráficos de nível alto)</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source>Contains logic that is used to size and position possible child elements of a <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> (when interpreted by a layout system)</source>
          <target state="translated">Contém a lógica que é usada para dimensionar e posicionar elementos filho possíveis de um <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> (quando interpretada por um sistema de layout)</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source>Can respond to user input (including control of where input is getting sent to via their handling of event routing, or routing of commands)</source>
          <target state="translated">Pode responder a entrada do usuário (incluindo controle de entrada em que está obtendo enviada para por meio da manipulação de evento de roteamento ou roteamento de comandos)</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source>Can raise routed events that travel a route through the logical element tree</source>
          <target state="translated">Pode gerar eventos roteados que viajam uma rota através da árvore de elementos lógicos</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source>Supports some aspects of the animation system</source>
          <target state="translated">Oferece suporte a alguns aspectos do sistema de animação</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> is the WPF framework-level implementation class that builds on <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph>, and adds specific interactions with the WPF framework level.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> é a classe de implementação de nível de framework WPF que se baseia em <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph>e adiciona específicas interações com o nível de framework do WPF.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> adds and defines the following capabilities:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> Adiciona e define os seguintes recursos:</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source>Additional framework-specific layout characteristics</source>
          <target state="translated">Características de layout específicas do framework adicionais</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source>Support for richer metadata reporting on properties</source>
          <target state="translated">Suporte para relatórios sobre propriedades de metadados mais rico</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source>Class-specific implementation of certain input base classes and their attached properties or attached events</source>
          <target state="translated">Implementação de classe específica de determinadas classes base e suas propriedades anexadas de entrada ou eventos anexados</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source>Style support</source>
          <target state="translated">Suporte de estilo</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source>Further animation support</source>
          <target state="translated">Suporte adicional de animação</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source>Another related class is <ph id="ph1">&lt;xref:System.Windows.ContentElement&gt;</ph>.</source>
          <target state="translated">Outro relacionado a classe é <ph id="ph1">&lt;xref:System.Windows.ContentElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source>The <ph id="ph1">&lt;xref:System.Windows.ContentElement&gt;</ph> class implements many of the same members as does <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph>; the difference between these two classes has to do with their intended place in the overall content model.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.ContentElement&gt;</ph> classe implementa muitos dos mesmos participantes que <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph>; a diferença entre essas duas classes tem com seu pretendido colocar no modelo de conteúdo geral.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source>A <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> derived class typically defines a relatively rigid content model, meaning that there are restrictions on what elements may be child elements in markup.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> classe derivada normalmente define um modelo de conteúdo relativamente rígido, que significa que há restrições nas quais elementos podem ser elementos filho na marcação.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source>There might be capacity for taking less restrictive child content in a <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>, but that capacity is typically centralized in designated content properties.</source>
          <target state="translated">Pode haver capacidade para colocar o conteúdo filho de menos restritivo um <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>, mas essa capacidade normalmente é centralizada nas propriedades do conteúdo designadas.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source>A <ph id="ph1">&lt;xref:System.Windows.ContentElement&gt;</ph> derived class is typically not as restrictive about content, to support scenarios such as flow-format documents.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Windows.ContentElement&gt;</ph> classe derivada normalmente não é mais restritivo sobre o conteúdo para dar suporte a cenários, como documentos em formato de fluxo.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source><ph id="ph1">&lt;xref:System.Windows.UIElement.Visibility%2A&gt;</ph> state affects all input handling by that element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.UIElement.Visibility%2A&gt;</ph> estado afeta todas as entradas tratamento por esse elemento.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source>Elements that are not visible do not participate in hit testing and do not receive input events, even if the mouse is over the bounds where the element would be if were visible.</source>
          <target state="translated">Elementos que não são visíveis não participam de teste de clique e não receber eventos de entrada, mesmo se o mouse estiver sobre os limites em que o elemento seria se eram visíveis.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.#ctor">
          <source>Creating a new instance that is actually of type <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> is uncommon in application code, because <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> is a base element.</source>
          <target state="translated">Criando uma nova instância que é realmente do tipo <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> é incomum no código do aplicativo, porque <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> é um elemento base.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.#ctor">
          <source>See <bpt id="p1">[</bpt>Base Elements Overview<ept id="p1">](~/docs/framework/wpf/advanced/base-elements-overview.md)</ept>.</source>
          <target state="translated">Consulte <bpt id="p1">[</bpt>visão geral de elementos de Base<ept id="p1">](~/docs/framework/wpf/advanced/base-elements-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="T:System.Windows.UIElement">
          <source>Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</source>
          <target state="translated">Adiciona um manipulador de eventos roteados de um evento roteado especificado, adicionando o manipulador à coleção de manipuladores no elemento atual.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)">
          <source>An identifier for the routed event to be handled.</source>
          <target state="translated">Um identificador do evento roteado a ser manipulado.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)">
          <source>A reference to the handler implementation.</source>
          <target state="translated">Uma referência à implementação do manipulador.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)">
          <source>Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</source>
          <target state="translated">Adiciona um manipulador de eventos roteados de um evento roteado especificado, adicionando o manipulador à coleção de manipuladores no elemento atual.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)">
          <source>You can add the same handler for the same event multiple times without raising an exception.</source>
          <target state="translated">Você pode adicionar o mesmo manipulador para o mesmo evento várias vezes sem gerar uma exceção.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)">
          <source>However, the handler is actually invoked multiple times when the event is handled.</source>
          <target state="translated">No entanto, o manipulador é realmente chamado várias vezes quando o evento é manipulado.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)">
          <source>Therefore, consider how this behavior might have side effects that should be accounted for in your handler implementation.</source>
          <target state="translated">Portanto, considere como esse comportamento pode ter efeitos colaterais que devem ser considerados na implementação do manipulador.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)">
          <source>You typically use this method to provide the implementation of the "add" accessor for the <ph id="ph1">[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]</ph> event access pattern of a custom routed event.</source>
          <target state="translated">Você normalmente usa esse método para fornecer a implementação do acessador "Adicionar" para o <ph id="ph1">[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]</ph> padrão de acesso do evento de um evento roteado personalizado.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)">
          <source>An identifier for the routed event to be handled.</source>
          <target state="translated">Um identificador do evento roteado a ser manipulado.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)">
          <source>A reference to the handler implementation.</source>
          <target state="translated">Uma referência à implementação do manipulador.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to register the handler such that it is invoked even when  the routed event is marked handled in its event data; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to register the handler with the default condition that it will not be invoked if the routed event is already marked handled.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para registrar o manipulador de modo que ele seja invocado mesmo quando o evento roteado estiver marcado como tratado nos dados do evento; <ph id="ph2">&lt;see langword="false" /&gt;</ph> para registrar o manipulador com a condição padrão que não será chamado se o evento roteado já estiver marcado como tratado.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)">
          <source>Do not routinely ask to rehandle a routed event.</source>
          <target state="translated">Não solicite sempre para tratar novamente um evento roteado.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)">
          <source>Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</source>
          <target state="translated">Adiciona um manipulador de eventos roteados de um evento roteado especificado, adicionando o manipulador à coleção de manipuladores no elemento atual.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)">
          <source>Specify <ph id="ph1">&lt;paramref name="handledEventsToo" /&gt;</ph> as <ph id="ph2">&lt;see langword="true" /&gt;</ph> to have the provided handler be invoked for routed event that had already been marked as handled by another element along the event route.</source>
          <target state="translated">Especifique <ph id="ph1">&lt;paramref name="handledEventsToo" /&gt;</ph> como <ph id="ph2">&lt;see langword="true" /&gt;</ph> para que o manipulador fornecido seja invocado para eventos roteados que já tenham sido marcados como manipulados por outro elemento na rota de evento.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)">
          <source>Processing low-level input events in a practical way is a complex task.</source>
          <target state="translated">O processamento de eventos de entrada de baixo nível em uma forma prática é uma tarefa complexa.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)">
          <source>Many controls implement behavior where a certain event is marked as handled, and is replaced by another more intuitive event.</source>
          <target state="translated">Muitos controles que implementam o comportamento em que um determinado evento estiver marcado como tratado e é substituído por outro evento mais intuitivo.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)">
          <source>Generally, a control will only mark a platform input event as handled if there is some design intention for doing so.</source>
          <target state="translated">Em geral, um controle só marcar um evento de entrada de plataforma como manipulado se houver algum intenção de design para fazer isso.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)">
          <source>In certain scenarios, those design intentions might not be what your particular handling of the input event requires.</source>
          <target state="translated">Em determinados cenários, as intenções de design não podem ser o que requer o tratamento específico do evento de entrada.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)">
          <source>It is for these scenarios that registering handlers with <ph id="ph1">`handledEventsToo`</ph> as <ph id="ph2">`true`</ph> is appropriate.</source>
          <target state="translated">É por esses cenários que registrar manipuladores com <ph id="ph1">`handledEventsToo`</ph> como <ph id="ph2">`true`</ph> é apropriado.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)">
          <source>But you should not do this routinely.</source>
          <target state="translated">Mas você não deve fazer isso periodicamente.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)">
          <source>Invoking handlers in response to all events even if handled will complicate your own application event processing logic.</source>
          <target state="translated">Chamar manipuladores em resposta a todos os eventos, mesmo quando manipulados complicar a sua própria lógica de processamento de eventos do aplicativo.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)">
          <source>You may see a decrease in performance if the handler logic is substantial.</source>
          <target state="translated">Você pode ver uma diminuição no desempenho se a lógica do manipulador é significativa.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)">
          <source>You should reserve the use of attaching handlers for already-handled events for situations where you have already discovered during the development process that certain controls are handling events that you still want to handle with application logic.</source>
          <target state="translated">Você deve reservar o uso de anexação de manipuladores de eventos já tratado para situações em que você já tenha descoberto durante o processo de desenvolvimento que certos controles lidar com eventos que deseja processar com a lógica do aplicativo.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)">
          <source>Another technique for avoiding the class handling behavior of certain event-control combinations is to use that event's preview alternative.</source>
          <target state="translated">Outra técnica para evitar o comportamento de algumas combinações de controle de evento de manipulação de classe é usar a alternativa de visualização do evento.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)">
          <source>For example, if <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonDown&gt;</ph> is marked handled by class handling, you might be able to add handlers for <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonDown&gt;</ph> instead.</source>
          <target state="translated">Por exemplo, se <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonDown&gt;</ph> estiver marcado como tratado pela manipulação de classe, você poderá adicionar manipuladores para <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonDown&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)">
          <source>You can add the same handler for the same event multiple times without raising an exception.</source>
          <target state="translated">Você pode adicionar o mesmo manipulador para o mesmo evento várias vezes sem gerar uma exceção.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)">
          <source>However, the handler is actually invoked multiple times when the event is handled.</source>
          <target state="translated">No entanto, o manipulador é realmente chamado várias vezes quando o evento é manipulado.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)">
          <source>Therefore, consider how this behavior might have side effects that should be accounted for in your handler implementation.</source>
          <target state="translated">Portanto, considere como esse comportamento pode ter efeitos colaterais que devem ser considerados na implementação do manipulador.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)">
          <source>You typically use this method to provide the implementation of the "add" accessor for the <ph id="ph1">[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]</ph> event access pattern of a custom routed event.</source>
          <target state="translated">Você normalmente usa esse método para fornecer a implementação do acessador "Adicionar" para o <ph id="ph1">[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]</ph> padrão de acesso do evento de um evento roteado personalizado.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)">
          <source>The following example implements a handler invoked on the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Initialized&gt;</ph> event on a page that attaches a defined handler to one of the named elements on the page using <ph id="ph2">`handledEventsToo`</ph> <ph id="ph3">`true`</ph>.</source>
          <target state="translated">O exemplo a seguir implementa um manipulador invocado no <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Initialized&gt;</ph> evento em uma página que conecta um manipulador definido para um dos elementos nomeados na página usando <ph id="ph2">`handledEventsToo`</ph> <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)">
          <source>This handler would be invoked even if another element along the route marked the shared event data as handled before reaching the handling element in the route.</source>
          <target state="translated">Este manipulador seria invocado, mesmo se outro elemento na rota marcado como os dados de evento compartilhado tratados antes de alcançar o elemento manipulador na rota.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)">
          <source>The event route that handlers are added to.</source>
          <target state="translated">A rota de eventos à qual os manipuladores são adicionados.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)">
          <source>The event data that is used to add the handlers.</source>
          <target state="translated">Os dados de evento usados para adicionar os manipuladores.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)">
          <source>This method uses the <ph id="ph1">&lt;see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /&gt;</ph> property of the event data to create the handlers.</source>
          <target state="translated">Esse método usa a propriedade <ph id="ph1">&lt;see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /&gt;</ph> dos dados do evento para criar os manipuladores.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)">
          <source>Adds handlers to the specified <ph id="ph1">&lt;see cref="T:System.Windows.EventRoute" /&gt;</ph> for the current <ph id="ph2">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> event handler collection.</source>
          <target state="translated">Adiciona manipuladores ao <ph id="ph1">&lt;see cref="T:System.Windows.EventRoute" /&gt;</ph> especificado para a coleção do manipulador de eventos <ph id="ph2">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)">
          <source>This method can be used by content host elements (either those that implement <ph id="ph1">&lt;xref:System.Windows.IContentHost&gt;</ph> or those that don't) to add handlers for child elements to the <ph id="ph2">&lt;xref:System.Windows.EventRoute&gt;</ph>.</source>
          <target state="translated">Esse método pode ser usado pelos elementos de host de conteúdo (aqueles que implementam <ph id="ph1">&lt;xref:System.Windows.IContentHost&gt;</ph> ou aqueles que não) para adicionar manipuladores para elementos filho para o <ph id="ph2">&lt;xref:System.Windows.EventRoute&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)">
          <source>Ordinarily, this is not required for <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>, because handlers are automatically added for all elements found in a completed logical tree.</source>
          <target state="translated">Em geral, isso não é necessário para <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>, pois os manipuladores são adicionados automaticamente para todos os elementos encontrados em uma árvore lógica concluída.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)">
          <source>However, in some cases where <ph id="ph1">&lt;xref:System.Windows.ContentElement&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> are mixed in templated trees, intervening elements that came from the template need to be added to a route.</source>
          <target state="translated">No entanto, em alguns casos onde <ph id="ph1">&lt;xref:System.Windows.ContentElement&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> são mesclados em árvores modeladas, elementos que veio com a modelo precisa ser adicionado a uma rota de intervenção.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)">
          <source>Both <ph id="ph1">&lt;xref:System.Windows.ContentElement&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> support a version of this method.</source>
          <target state="translated">Ambos <ph id="ph1">&lt;xref:System.Windows.ContentElement&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> suporte a uma versão desse método.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.AllowDrop">
          <source>Gets or sets a value indicating whether this element can be used as the target of a drag-and-drop operation.</source>
          <target state="translated">Obtém ou define um valor indicando se um elemento pode ser usado como o destino de uma operação de arrastar e soltar.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.AllowDrop">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.AllowDrop">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this element can be used as the target of a drag-and-drop operation; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se um elemento pode ser usado como o destino de uma operação do tipo "arrastar e soltar"; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.AllowDrop">
          <source>The default value is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O valor padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.AllowDrop">
          <source>Drag-and-drop operations are not enabled by default, and must be enabled deliberately by setting <ph id="ph1">&lt;xref:System.Windows.UIElement.AllowDrop%2A&gt;</ph> to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Operações de arrastar e soltar não estão habilitadas por padrão e deve ser habilitadas deliberadamente definindo <ph id="ph1">&lt;xref:System.Windows.UIElement.AllowDrop%2A&gt;</ph> para <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.AllowDrop">
          <source>Beyond this basic setting, drag-and-drop behavior is entirely implementation specific and is not defined by <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> or any other base element class.</source>
          <target state="translated">Além dessa configuração básica, o comportamento de arrastar e soltar inteiramente é específico da implementação e não é definido pelo <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> ou qualquer outra classe de elemento base.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.AllowDrop">
          <source>Certain controls, for example, <ph id="ph1">&lt;xref:System.Windows.Controls.RichTextBox&gt;</ph>, do have a default behavior.</source>
          <target state="translated">Alguns controles, por exemplo, <ph id="ph1">&lt;xref:System.Windows.Controls.RichTextBox&gt;</ph>, têm um comportamento padrão.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.AllowDrop">
          <source>For more information on drag and drop, see <bpt id="p1">[</bpt>Drag and Drop Overview<ept id="p1">](~/docs/framework/wpf/advanced/drag-and-drop-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre como arrastar e soltar, consulte <bpt id="p1">[</bpt>arrastar e soltar visão de geral<ept id="p1">](~/docs/framework/wpf/advanced/drag-and-drop-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.AllowDrop">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> overrides the metadata for this dependency property in its implementation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> substitui os metadados para essa propriedade de dependência em sua implementação.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.AllowDrop">
          <source>Specifically, <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> designates this property to allow property value inheritance (<ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> is <ph id="ph3">`true`</ph> in metadata).</source>
          <target state="translated">Especificamente, <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> designa essa propriedade para permitir a herança de valor de propriedade (<ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> é <ph id="ph3">`true`</ph> nos metadados).</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.AllowDrop">
          <source>Property value inheritance in this context means that if there are child elements with no other value for <ph id="ph1">&lt;xref:System.Windows.UIElement.AllowDrop%2A&gt;</ph> assigned through local values or styles, the value of the nearest parent element with this value assigned (again, either in styles, by default values, or a local value), then the value from the parent element will be assigned to all previously unassigned child elements by the property system.</source>
          <target state="translated">Herança de valor de propriedade neste contexto significa que, se houver elementos filho com nenhum outro valor para <ph id="ph1">&lt;xref:System.Windows.UIElement.AllowDrop%2A&gt;</ph> atribuído por meio de valores locais ou estilos, o valor do elemento pai mais próximo com esse valor atribuído (novamente, seja em estilos, valores padrão ou um valor local), em seguida, o valor do elemento pai será atribuído a todos os elementos filho anteriormente não atribuído pelo sistema de propriedades.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.AllowDrop">
          <source>In practice this means that you can specify whether to allow drop operations at the root element, and that value will propagate to all child elements that have not specifically assigned it as <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Na prática, isso significa que você pode especificar se deseja permitir que as operações de descarte no elemento raiz, e que o valor serão propagadas para todos os elementos filho que têm não especificamente atribuído como <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.AllowDrop">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.AllowDrop">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.AllowDrop">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.AllowDrop">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.AllowDrop">
          <source>The following markup example sets the <ph id="ph1">&lt;xref:System.Windows.UIElement.AllowDrop%2A&gt;</ph> property <ph id="ph2">`true`</ph> using an attribute on a <ph id="ph3">&lt;xref:System.Windows.Controls.TextBox&gt;</ph>, as well as setting some other related properties that in aggregate enable that <ph id="ph4">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> to be the target of a multiline text data object when it is dragged in.</source>
          <target state="translated">O exemplo a seguir de marcação define o <ph id="ph1">&lt;xref:System.Windows.UIElement.AllowDrop%2A&gt;</ph> propriedade <ph id="ph2">`true`</ph> usando um atributo em uma <ph id="ph3">&lt;xref:System.Windows.Controls.TextBox&gt;</ph>, bem como definir algumas outras propriedades que, em agregação permitem que relacionadas <ph id="ph4">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> deve ser o destino de um objeto de dados de texto de várias linhas quando ele é arrastado.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.AllowDrop">
          <source>For the complete sample, see <bpt id="p1">[</bpt>Load a Dropped File Sample<ept id="p1">](http://msdn.microsoft.com/library/be90d645-dd61-4f53-93bb-87902d086ef7)</ept>.</source>
          <target state="translated">Para o exemplo completo, consulte <bpt id="p1">[</bpt>carregar um exemplo de arquivo descartado<ept id="p1">](http://msdn.microsoft.com/library/be90d645-dd61-4f53-93bb-87902d086ef7)</ept>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.AllowDropProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.AllowDrop" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.AllowDrop" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="T:System.Windows.UIElement">
          <source>Applies an animation to a specified dependency property on this element.</source>
          <target state="translated">Aplica uma animação a uma propriedade de dependência especificada neste elemento.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.UIElement">
          <source>This method is sealed and cannot be overridden.</source>
          <target state="translated">Este método está selado e não pode ser substituído.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)">
          <source>The identifier for the property to animate.</source>
          <target state="translated">O identificador para a propriedade a ser animada.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)">
          <source>The animation clock that controls and declares the animation.</source>
          <target state="translated">O relógio de animação que controla e declara a animação.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)">
          <source>Applies an animation to a specified dependency property on this element.</source>
          <target state="translated">Aplica uma animação a uma propriedade de dependência especificada neste elemento.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)">
          <source>Any existing animations are stopped and replaced with the new animation.</source>
          <target state="translated">Todas as animações existentes são interrompidas e substituídas pela nova animação.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)">
          <source>To remove an animation from a property, specify the identifier for that property as <ph id="ph1">`dp`</ph> and specify <ph id="ph2">`clock`</ph> as <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Para remover uma animação de uma propriedade, especifique o identificador para a propriedade como <ph id="ph1">`dp`</ph> e especifique <ph id="ph2">`clock`</ph> como <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)">
          <source>This removes the animation and the animated property is set to its base value.</source>
          <target state="translated">Isso remove a animação e a propriedade animada é definida como seu valor de base.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)">
          <source>However, the originally associated animation clock is not stopped.</source>
          <target state="translated">No entanto, o relógio de animação originalmente associado não será interrompido.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)">
          <source>Any other animations assigned to that clock will continue to run.</source>
          <target state="translated">Quaisquer outras animações atribuídas a esse relógio continuará a ser executado.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)">
          <source>In the following example, a <ph id="ph1">&lt;xref:System.Windows.Shapes.Rectangle&gt;</ph> <ph id="ph2">`myAnimatedRectangle`</ph> has a particular timing animation applied to it by calling <ph id="ph3">&lt;xref:System.Windows.UIElement.ApplyAnimationClock%2A&gt;</ph> .</source>
          <target state="translated">No exemplo a seguir, uma <ph id="ph1">&lt;xref:System.Windows.Shapes.Rectangle&gt;</ph> <ph id="ph2">`myAnimatedRectangle`</ph> tem uma animação de determinado tempo aplicada a ele chamando <ph id="ph3">&lt;xref:System.Windows.UIElement.ApplyAnimationClock%2A&gt;</ph> .</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)">
          <source>The property to animate.</source>
          <target state="translated">A propriedade a ser animada.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)">
          <source>The animation clock that controls and declares the animation.</source>
          <target state="translated">O relógio de animação que controla e declara a animação.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)">
          <source>A value of the enumeration.</source>
          <target state="translated">Um valor da enumeração.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)">
          <source>The default is <ph id="ph1">&lt;see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" /&gt;</ph>, which will stop any existing animation and replace with the new one.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" /&gt;</ph>, que interromperá a animação existente, substituindo-a pela nova.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Applies an animation to a specified dependency property on this element, with the ability to specify what happens if the property already has a running animation.</source>
          <target state="translated">Aplica uma animação a uma propriedade de dependência especificada nesse elemento, com a capacidade de especificar o que ocorrerá se a propriedade já tiver uma animação em execução.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)">
          <source>To remove an animation from a property, specify the identifier for that property as <ph id="ph1">`dp`</ph> and specify <ph id="ph2">`clock`</ph> as <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Para remover uma animação de uma propriedade, especifique o identificador para a propriedade como <ph id="ph1">`dp`</ph> e especifique <ph id="ph2">`clock`</ph> como <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)">
          <source>This removes the animation and the animated property is set to its base value.</source>
          <target state="translated">Isso remove a animação e a propriedade animada é definida como seu valor de base.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)">
          <source>However, the originally associated animation clock is not stopped.</source>
          <target state="translated">No entanto, o relógio de animação originalmente associado não será interrompido.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Any other animations assigned to that clock will continue to run.</source>
          <target state="translated">Quaisquer outras animações atribuídas a esse relógio continuará a ser executado.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.AreAnyTouchesCaptured">
          <source>Gets a value that indicates whether at least one touch is captured to this element.</source>
          <target state="translated">Obtém um valor que indica se pelo menos um toque é capturado para esse elemento.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.AreAnyTouchesCaptured">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if at least one touch is captured to this element; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se pelo menos um toque for capturado para esse elemento; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.AreAnyTouchesCapturedProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.AreAnyTouchesCaptured" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.AreAnyTouchesCaptured" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.AreAnyTouchesCapturedWithin">
          <source>Gets a value that indicates whether at least one touch is captured to this element or to any child elements in its visual tree.</source>
          <target state="translated">Obtém um valor que indica se ao menos um toque é capturado nesse elemento ou elementos filho na sua árvore visual.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.AreAnyTouchesCapturedWithin">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if at least one touch is captured to this element or any child elements in its visual tree; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se pelo menos um toque é capturado para este elemento ou elementos filho na árvore visual; Caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.AreAnyTouchesCapturedWithinProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.AreAnyTouchesCapturedWithin" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.AreAnyTouchesCapturedWithin" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.AreAnyTouchesDirectlyOver">
          <source>Gets a value that indicates whether at least one touch is pressed over this element.</source>
          <target state="translated">Obtém um valor que indica se pelo menos um toque é feito sobre esse elemento.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.AreAnyTouchesDirectlyOver">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if at least one touch is pressed over this element; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se pelo menos um toque for pressionado sobre esse elemento; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.AreAnyTouchesDirectlyOverProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.AreAnyTouchesDirectlyOver" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.AreAnyTouchesDirectlyOver" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.AreAnyTouchesOver">
          <source>Gets a value that indicates whether at least one touch is pressed over this element or any child elements in its visual tree.</source>
          <target state="translated">Obtém um valor que indica se pelo menos um toque for pressionado sobre esse elemento ou elementos filho na sua árvore visual.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.AreAnyTouchesOver">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if at least one touch is pressed over this element or any child elements in its visual tree; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se pelo menos um toque for pressionado sobre esse elemento ou elementos filho na sua árvore visual; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.AreAnyTouchesOverProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.AreAnyTouchesOver" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.AreAnyTouchesOver" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>The final size that the parent computes for the child element, provided as a <ph id="ph1">&lt;see cref="T:System.Windows.Rect" /&gt;</ph> instance.</source>
          <target state="translated">O tamanho final que o elemento pai computa para o filho, fornecido como uma instância <ph id="ph1">&lt;see cref="T:System.Windows.Rect" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>Positions child elements and determines a size for a <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph>.</source>
          <target state="translated">Posiciona elementos filho e determina um tamanho para um <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>Parent elements call this method from their <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" /&gt;</ph> implementation (or a WPF framework-level equivalent) to form a recursive layout update.</source>
          <target state="translated">Elementos pai chamam esse método de sua própria implementação <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" /&gt;</ph> (ou um equivalente no nível de estrutura WPF) para formar uma atualização de layout recursiva.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>This method constitutes the second pass of a layout update.</source>
          <target state="translated">Esse método constitui a segunda passagem de uma atualização de layout.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>For WPF framework-level element deriving scenarios, behavior for <ph id="ph1">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> should not (and cannot, unless you shadow) be changed.</source>
          <target state="translated">Para o elemento de nível de framework WPF derivando cenários, o comportamento de <ph id="ph1">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> não devem (e não é possível, a menos que você sombrear) a ser alterado.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>Instead, you should override the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ArrangeOverride%2A&gt;</ph> implementation in your class.</source>
          <target state="translated">Em vez disso, você deve substituir o <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ArrangeOverride%2A&gt;</ph> implementação em sua classe.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>Your <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ArrangeOverride%2A&gt;</ph> implementation is called internally by <ph id="ph2">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> as part of default WPF framework-level layout operations.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ArrangeOverride%2A&gt;</ph> implementação é chamada internamente por <ph id="ph2">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> como parte das operações de layout de nível de framework WPF padrão.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>Your <ph id="ph1">&lt;xref:System.Windows.UIElement.ArrangeCore%2A&gt;</ph> implementation should also call <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.ArrangeOverride%2A&gt;</ph> on each child element, if it has child elements.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.ArrangeCore%2A&gt;</ph> implementação também deve chamar <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.ArrangeOverride%2A&gt;</ph> em cada elemento filho, se ele tem elementos filho.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>For WPF core-level element deriving scenarios, the behavior for <ph id="ph1">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> should not (and cannot, unless you shadow) be changed.</source>
          <target state="translated">Para o elemento de nível de núcleo do WPF derivando cenários, o comportamento de <ph id="ph1">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> não devem (e não é possível, a menos que você sombrear) a ser alterado.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>Instead, you should override <ph id="ph1">&lt;xref:System.Windows.UIElement.ArrangeCore%2A&gt;</ph> in your class.</source>
          <target state="translated">Em vez disso, você deve substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.ArrangeCore%2A&gt;</ph> na sua classe.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>Your <ph id="ph1">&lt;xref:System.Windows.UIElement.ArrangeCore%2A&gt;</ph> implementation is called internally by <ph id="ph2">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> as part of default WPF framework-level layout operations.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.ArrangeCore%2A&gt;</ph> implementação é chamada internamente por <ph id="ph2">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> como parte das operações de layout de nível de framework WPF padrão.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>However, this assumes you are using WPF framework-level layout and its layout system, which is often not the case if you are specifically deriving elements at the WPF core-level from the <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> base element class.</source>
          <target state="translated">No entanto, isso pressupõe que você estiver usando o layout de nível de framework do WPF e seu sistema de layout, que geralmente não é o caso se você estiver derivando especificamente elementos em nível de núcleo do WPF a <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> elemento classe base.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>Your <ph id="ph1">&lt;xref:System.Windows.UIElement.ArrangeCore%2A&gt;</ph> implementation should also call <ph id="ph2">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> on each child element, if it has child elements.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.ArrangeCore%2A&gt;</ph> implementação também deve chamar <ph id="ph2">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> em cada elemento filho, se ele tem elementos filho.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>Note that the WPF core-level scenario implies that you are not using a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> derived class, because <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> seals <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.ArrangeCore%2A&gt;</ph>.</source>
          <target state="translated">Observe que o cenário de nível de núcleo do WPF implica que você não estiver usando um <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> a classe derivada, porque <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> selos <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.ArrangeCore%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>Computation of WPF framework-level layout positioning in <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> consists of a <ph id="ph2">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> call and an <ph id="ph3">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> call.</source>
          <target state="translated">Computação de posicionamento de layout de nível de framework do WPF em <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> consiste em uma <ph id="ph2">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> chamar e um <ph id="ph3">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> chamar.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>During the <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> call, the layout system determines an element's size requirements using a provided <ph id="ph2">&lt;xref:System.Windows.Size&gt;</ph> (<ph id="ph3">`availableSize`</ph>) argument.</source>
          <target state="translated">Durante o <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> chamada, o sistema de layout determina os requisitos de tamanho de um elemento usando um fornecido <ph id="ph2">&lt;xref:System.Windows.Size&gt;</ph> (<ph id="ph3">`availableSize`</ph>) argumento.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>During the <ph id="ph1">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> call, the layout system finalizes the size and position of an element's bounding box.</source>
          <target state="translated">Durante o <ph id="ph1">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> chamada, o sistema de layout finaliza o tamanho e posição de um elemento da caixa delimitadora.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>For more information, see <bpt id="p1">[</bpt>Layout<ept id="p1">](~/docs/framework/wpf/advanced/layout.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>Layout<ept id="p1">](~/docs/framework/wpf/advanced/layout.md)</ept>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source><ph id="ph1">`availableSize`</ph> can be any number from zero to infinity.</source>
          <target state="translated"><ph id="ph1">`availableSize`</ph> pode ser qualquer número entre zero e infinito.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>Elements to be laid out return the minimum <ph id="ph1">&lt;xref:System.Windows.Size&gt;</ph> they require through the <ph id="ph2">`availableSize`</ph> parameter.</source>
          <target state="translated">Elemento a ser dispostos retornar o mínimo <ph id="ph1">&lt;xref:System.Windows.Size&gt;</ph> precisam por meio de <ph id="ph2">`availableSize`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>When a layout is first instantiated, it always receives a <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> call before <ph id="ph2">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph>.</source>
          <target state="translated">Quando um layout é instanciado pela primeira vez, ele sempre recebe um <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> chamar antes de <ph id="ph2">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>However, after the first layout pass, it may receive an <ph id="ph1">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> call without a <ph id="ph2">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph>; this can happen when a property that affects only <ph id="ph3">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> is changed (such as alignment), or when the parent receives an <ph id="ph4">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> without a <ph id="ph5">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph>.</source>
          <target state="translated">No entanto, após a primeira passagem de layout, pode receber um <ph id="ph1">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> chamada sem um <ph id="ph2">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph>; isso pode acontecer quando uma propriedade que só afeta <ph id="ph3">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> for alterada (como alinhamento), ou quando o pai recebe um <ph id="ph4">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> sem um <ph id="ph5">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>A <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> call will automatically invalidate an <ph id="ph2">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> call.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> chamada invalidará automaticamente um <ph id="ph2">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> chamar.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>Layout updates generally occur asynchronously (at a time determined by the layout system).</source>
          <target state="translated">As atualizações de layout geralmente ocorrem assincronamente (em um tempo determinado pelo sistema de layout).</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>An element might not immediately reflect changes to properties that affect element sizing (such as <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph>).</source>
          <target state="translated">Um elemento pode não refletir imediatamente as alterações nas propriedades que afetam o dimensionamento de elemento (como <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>Layout updates can be forced by using the <ph id="ph1">&lt;xref:System.Windows.UIElement.UpdateLayout%2A&gt;</ph> method; however, calling this function is not recommended, as it is usually unnecessary and can cause poor performance.</source>
          <target state="translated">As atualizações de layout podem ser forçadas usando o <ph id="ph1">&lt;xref:System.Windows.UIElement.UpdateLayout%2A&gt;</ph> método; no entanto, chamar essa função não é recomendável, pois ele normalmente não é necessário e pode causar baixo desempenho.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>In many situations where calling <ph id="ph1">&lt;xref:System.Windows.UIElement.UpdateLayout%2A&gt;</ph> might be appropriate, the layout system will probably already be processing updates.</source>
          <target state="translated">Em muitas situações em que a chamada <ph id="ph1">&lt;xref:System.Windows.UIElement.UpdateLayout%2A&gt;</ph> pode ser apropriado, o sistema de layout provavelmente já processará as atualizações.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>The layout system can process layout changes in a manner that can optimize all necessary updates as part of a package.</source>
          <target state="translated">O sistema de layout pode processar alterações de layout de uma maneira que pode otimizar a todas as atualizações necessárias como parte de um pacote.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>The layout system keeps two separate queues of invalid layouts, one for <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> and one for <ph id="ph2">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph>.</source>
          <target state="translated">O sistema de layout mantém duas filas separadas de layouts inválidos, uma para <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> e outra para <ph id="ph2">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>The layout queue is sorted based upon the order of elements in the visual tree.</source>
          <target state="translated">A fila de layout é classificada com base na ordem dos elementos na árvore visual.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>Elements higher in the tree are at the top of the queue, in order to avoid redundant layouts caused by repeated changes in parents.</source>
          <target state="translated">São superior da árvore de elementos na parte superior da fila, para evitar a redundância layouts causados por alterações repetidas em pais.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>Duplicate entries are automatically removed from the queue, and elements are automatically removed from the queue if they are already valid.</source>
          <target state="translated">Entradas duplicadas são automaticamente removidas da fila e os elementos são automaticamente removidos da fila se eles já são válidos.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>When updating layout, the <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> queue is emptied first, followed by the <ph id="ph2">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> queue.</source>
          <target state="translated">Ao atualizar o layout, o <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> fila é esvaziada primeiro, seguido de <ph id="ph2">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> fila.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Arrange(System.Windows.Rect)">
          <source>An element in the <ph id="ph1">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> queue will never be arranged if there is an element in the <ph id="ph2">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> queue.</source>
          <target state="translated">Um elemento de <ph id="ph1">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> fila nunca será organizada se há um elemento no <ph id="ph2">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> fila.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)">
          <source>The final area within the parent that element should use to arrange itself and its child elements.</source>
          <target state="translated">A área final no pai que esse elemento deve usar para organizar a si próprio e seus filhos.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)">
          <source>Defines the template for WPF core-level arrange layout definition.</source>
          <target state="translated">Define o modelo para a definição de layout de disposição de nível de núcleo do WPF.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)">
          <source>Overriding this method is only appropriate if you are deriving at the WPF core-level, and you are not using the WPF framework-level layout system and <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> derived class, because <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> seals <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.ArrangeCore%2A&gt;</ph>.</source>
          <target state="translated">Substituir esse método só é apropriado se estiverem sendo derivados no nível de núcleo do WPF e você não estiver usando o sistema de layout de nível de framework do WPF e <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> a classe derivada, porque <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> selos <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.ArrangeCore%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)">
          <source>If you are using the WPF framework-level layout system, the appropriate method to override for class-specific layout arrange behavior is <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ArrangeOverride%2A&gt;</ph>.</source>
          <target state="translated">Se você estiver usando o sistema de layout de nível de framework do WPF, o método apropriado para substituir para layout de classe específica organizar comportamento é <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ArrangeOverride%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)">
          <source><ph id="ph1">&lt;xref:System.Windows.UIElement.ArrangeCore%2A&gt;</ph> implementations should call the base implementation to return a size, then call the <ph id="ph2">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> method of each visible child element, and reconcile the sizes returned by these <ph id="ph3">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> calls with the size of the base implementation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.UIElement.ArrangeCore%2A&gt;</ph> implementações devem chamar a implementação base para retornar um tamanho, em seguida, chame o <ph id="ph2">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> método de cada elemento filho visível e reconciliar os tamanhos retornados por essas <ph id="ph3">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> chamadas com o tamanho da implementação base.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)">
          <source>The logic for the reconciliation aspect of a <ph id="ph1">&lt;xref:System.Windows.UIElement.ArrangeCore%2A&gt;</ph> implementation might vary, depending on the layout characteristics of your element.</source>
          <target state="translated">A lógica para o aspecto de reconciliação de um <ph id="ph1">&lt;xref:System.Windows.UIElement.ArrangeCore%2A&gt;</ph> implementação pode variar, dependendo das características do layout do seu elemento.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)">
          <source>In the following example template, <ph id="ph1">`VisualChildren`</ph> is a hypothetical property that your element might define to help enumerate its content; <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> does not define content collections at this level, the WPF framework-level architecture defers content behavior to derived elements such as specific controls or control base classes.</source>
          <target state="translated">No modelo de exemplo a seguir, <ph id="ph1">`VisualChildren`</ph> é uma propriedade hipotética que seu elemento pode definir para ajudar a enumerar seu conteúdo. <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> não definir coleções de conteúdo nesse nível, a arquitetura de nível de framework WPF adia o comportamento do conteúdo para elementos derivados, como controles específicos ou classes base.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)">
          <source>If you are developing elements at the WPF core level,you should override this method to give your WPF core-level element a unique arrange layout behavior, or to make proper layout decisions about the child elements of your elements.</source>
          <target state="translated">Se você estiver desenvolvendo elementos no nível de núcleo do WPF, você deve substituir esse método para fornecer seu elemento de nível de núcleo do WPF em uma única organizar o comportamento de layout ou fazer um layout adequado decisões sobre os elementos filho de seus elementos.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)">
          <source>An override might be necessary if those child elements are not recognizable from a defined pattern such as an <ph id="ph1">&lt;see cref="T:System.Windows.Controls.ItemCollection" /&gt;</ph>.</source>
          <target state="translated">Uma substituição pode ser necessária se os elementos filho não são reconhecidos um padrão definido como um <ph id="ph1">&lt;see cref="T:System.Windows.Controls.ItemCollection" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)">
          <source>A parent element must call the class-specific <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /&gt;</ph> on each child element, otherwise those child elements are not rendered.</source>
          <target state="translated">Um elemento pai deve chamar o classe específico <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /&gt;</ph> em cada elemento filho, caso contrário, os elementos filho não são renderizados.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="T:System.Windows.UIElement">
          <source>Starts an animation for a specified animated property on this element.</source>
          <target state="translated">Inicia uma animação de uma propriedade animada especificada neste elemento.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)">
          <source>The property to animate, which is specified as a dependency property identifier.</source>
          <target state="translated">A propriedade a ser animada, que é especificada como um identificador da propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)">
          <source>The timeline of the animation to start.</source>
          <target state="translated">A linha do tempo da animação a ser iniciada.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)">
          <source>Starts an animation for a specified animated property on this element.</source>
          <target state="translated">Inicia uma animação de uma propriedade animada especificada neste elemento.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)">
          <source>When you check whether a property is animated, note that the animation will begin and be considered animated when the first frame beyond the non-animated starting point is rendered.</source>
          <target state="translated">Quando você verifica se uma propriedade é animada, observe que a animação começará e ser considerada animado quando o primeiro quadro além do ponto de partida sem animação é renderizado.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)">
          <source>If the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Timeline.BeginTime%2A&gt;</ph> for <ph id="ph2">`animation`</ph> is <ph id="ph3">`null`</ph>, then any current animations are removed and the current value of the property is held.</source>
          <target state="translated">Se o <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Timeline.BeginTime%2A&gt;</ph> para <ph id="ph2">`animation`</ph> é <ph id="ph3">`null`</ph>, qualquer animações atuais são removidas e o valor atual da propriedade é mantido.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)">
          <source>If the entire <ph id="ph1">`animation`</ph> value is <ph id="ph2">`null`</ph>, all animations are removed from the property and the property value reverts to its base value.</source>
          <target state="translated">Se todo o <ph id="ph1">`animation`</ph> valor é <ph id="ph2">`null`</ph>, todas as animações são removidas da propriedade e o valor da propriedade será revertido para seu valor de base.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)">
          <source>However, the originally associated animation timeline is not stopped.</source>
          <target state="translated">No entanto, a linha do tempo de animação originalmente associado não será interrompida.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)">
          <source>Any other animations assigned to that timeline will continue to run.</source>
          <target state="translated">Quaisquer outras animações atribuídas a essa linha do tempo, continuará a ser executado.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)">
          <source>The following example creates an animation, assigns it, and then calls <ph id="ph1">&lt;xref:System.Windows.UIElement.BeginAnimation%2A&gt;</ph> to start it.</source>
          <target state="translated">O exemplo a seguir cria uma animação, atribui a ele e, em seguida, chama <ph id="ph1">&lt;xref:System.Windows.UIElement.BeginAnimation%2A&gt;</ph> para iniciá-lo.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)">
          <source>The property to animate, which is specified as the dependency property identifier.</source>
          <target state="translated">A propriedade a ser animada, que é especificada como o identificador da propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)">
          <source>The timeline of the animation to be applied.</source>
          <target state="translated">A linha do tempo da animação a ser aplicada.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)">
          <source>A value of the enumeration that specifies how the new animation interacts with any current (running) animations that are already affecting the property value.</source>
          <target state="translated">Um valor de enumeração que especifica como a nova animação interage com todas as animações atuais (em execução) que já estão afetando o valor da propriedade.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Starts a specific animation for a specified animated property on this element, with the option of specifying what happens if the property already has a running animation.</source>
          <target state="translated">Inicia uma animação específica para uma propriedade animada especificada neste elemento, com a opção de especificar o que acontece se a propriedade já tiver uma animação em execução.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)">
          <source>When you check whether a property is animated, note that the animation will begin and be considered animated when the first frame beyond the non-animated starting point is rendered.</source>
          <target state="translated">Quando você verifica se uma propriedade é animada, observe que a animação começará e ser considerada animado quando o primeiro quadro além do ponto de partida sem animação é renderizado.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)">
          <source>If the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Timeline.BeginTime%2A&gt;</ph> for <ph id="ph2">`animation`</ph> is <ph id="ph3">`null`</ph>, then any current animations are removed and the current value of the property is held.</source>
          <target state="translated">Se o <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Timeline.BeginTime%2A&gt;</ph> para <ph id="ph2">`animation`</ph> é <ph id="ph3">`null`</ph>, qualquer animações atuais são removidas e o valor atual da propriedade é mantido.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)">
          <source>If the entire <ph id="ph1">`animation`</ph> value is <ph id="ph2">`null`</ph>, all animations are removed from the property and the property value reverts to its base value.</source>
          <target state="translated">Se todo o <ph id="ph1">`animation`</ph> valor é <ph id="ph2">`null`</ph>, todas as animações são removidas da propriedade e o valor da propriedade será revertido para seu valor de base.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)">
          <source>However, the originally associated animation timeline is not stopped.</source>
          <target state="translated">No entanto, a linha do tempo de animação originalmente associado não será interrompida.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Any other animations assigned to that timeline will continue to run.</source>
          <target state="translated">Quaisquer outras animações atribuídas a essa linha do tempo, continuará a ser executado.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)">
          <source>The following example implements a handler that obtains an existing animation from a resource and then calls <ph id="ph1">&lt;xref:System.Windows.UIElement.BeginAnimation%2A&gt;</ph> with a specified handoff behavior.</source>
          <target state="translated">O exemplo a seguir implementa um manipulador que obtém uma animação existente de um recurso e, em seguida, chama <ph id="ph1">&lt;xref:System.Windows.UIElement.BeginAnimation%2A&gt;</ph> com um comportamento de entrega especificada.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.BitmapEffect">
          <source>Gets or sets a bitmap effect that applies directly to the rendered content for this element.</source>
          <target state="translated">Obtém ou define um efeito de bitmap aplicado diretamente ao conteúdo renderizado para este elemento.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.BitmapEffect">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.BitmapEffect">
          <source>The bitmap effect to apply.</source>
          <target state="translated">O efeito de bitmap a ser aplicado.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.BitmapEffect">
          <source><ph id="ph1">&lt;xref:System.Windows.Media.Effects.BitmapEffect&gt;</ph> is an abstract type, therefore the <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> usage requires an implemented derived class of <ph id="ph3">&lt;xref:System.Windows.Media.Effects.BitmapEffect&gt;</ph>, such as <ph id="ph4">&lt;xref:System.Windows.Media.Effects.OuterGlowBitmapEffect&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Media.Effects.BitmapEffect&gt;</ph> é um tipo abstrato, portanto o <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> uso requer uma classe derivada implementada de <ph id="ph3">&lt;xref:System.Windows.Media.Effects.BitmapEffect&gt;</ph>, como <ph id="ph4">&lt;xref:System.Windows.Media.Effects.OuterGlowBitmapEffect&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.BitmapEffect">
          <source>Note that one implemented derived class is a collection type that allows you to specify more than one sequential <ph id="ph1">&lt;xref:System.Windows.Media.Effects.BitmapEffect&gt;</ph>, using a nested tag syntax.</source>
          <target state="translated">Observe que um implementado classe derivada é um tipo de coleção que permite que você especificar mais de um sequencial <ph id="ph1">&lt;xref:System.Windows.Media.Effects.BitmapEffect&gt;</ph>, usando uma sintaxe de marca aninhada.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.BitmapEffect">
          <source>No existing derived class of <ph id="ph1">&lt;xref:System.Windows.Media.Effects.BitmapEffect&gt;</ph> supports a type converter, so the <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax that you use for this property is generally property element syntax.</source>
          <target state="translated">Nenhuma classe derivada de <ph id="ph1">&lt;xref:System.Windows.Media.Effects.BitmapEffect&gt;</ph> oferece suporte a um conversor de tipo, portanto, o <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> sintaxe usada para essa propriedade é geralmente a sintaxe de elemento de propriedade.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.BitmapEffect">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.BitmapEffect">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.BitmapEffect">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.BitmapEffect">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.BitmapEffect">
          <source>The following example sets a bitmap effect, using <ph id="ph1">&lt;xref:System.Windows.Media.Effects.BlurBitmapEffect&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir define um bitmap em vigor, usando <ph id="ph1">&lt;xref:System.Windows.Media.Effects.BlurBitmapEffect&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.BitmapEffectInput">
          <source>Gets or sets an input source for the bitmap effect that applies directly to the rendered content for this element.</source>
          <target state="translated">Obtém ou define uma fonte de entrada para o efeito de bitmap aplicado diretamente ao conteúdo renderizado para este elemento.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.BitmapEffectInput">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.BitmapEffectInput">
          <source>The source for bitmap effects.</source>
          <target state="translated">A fonte dos efeitos de bitmap.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.BitmapEffectInput">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.BitmapEffectInput">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.BitmapEffectInput">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.BitmapEffectInput">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.BitmapEffectInputProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.BitmapEffectInput" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.BitmapEffectInput" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.BitmapEffectProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.BitmapEffect" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.BitmapEffect" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.CacheMode">
          <source>Gets or sets a cached representation of the <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph>.</source>
          <target state="translated">Obtém ou define uma representação armazenada em cache do <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.CacheMode">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Media.CacheMode" /&gt;</ph> that holds a cached representation of the <ph id="ph2">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph>.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Windows.Media.CacheMode" /&gt;</ph> que contém uma representação armazenada em cache do <ph id="ph2">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.CacheMode">
          <source>Set the <ph id="ph1">&lt;xref:System.Windows.UIElement.CacheMode%2A&gt;</ph> property when you need to increase performance for content that is time consuming to render.</source>
          <target state="translated">Definir o <ph id="ph1">&lt;xref:System.Windows.UIElement.CacheMode%2A&gt;</ph> propriedade quando você precisa aumentar o desempenho para o conteúdo que é demorado para processar.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.CacheMode">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Windows.Media.BitmapCache&gt;</ph>.</source>
          <target state="translated">Para obter mais informações, consulte <ph id="ph1">&lt;xref:System.Windows.Media.BitmapCache&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.CacheModeProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.CacheMode" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.CacheMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.CaptureMouse">
          <source>Attempts to force capture of the mouse to this element.</source>
          <target state="translated">Tenta forçar a captura do mouse para esse elemento.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.CaptureMouse">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the mouse is successfully captured; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o mouse for capturado com êxito; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.CaptureMouse">
          <source>To be captured, an element must be enabled.</source>
          <target state="translated">Para ser capturada, um elemento deve ser habilitado.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.CaptureMouse">
          <source>Check whether <ph id="ph1">&lt;xref:System.Windows.UIElement.IsEnabled%2A&gt;</ph> is <ph id="ph2">`true`</ph> before you call <ph id="ph3">&lt;xref:System.Windows.UIElement.CaptureMouse%2A&gt;</ph>.</source>
          <target state="translated">Verifique se <ph id="ph1">&lt;xref:System.Windows.UIElement.IsEnabled%2A&gt;</ph> é <ph id="ph2">`true`</ph> antes de chamar <ph id="ph3">&lt;xref:System.Windows.UIElement.CaptureMouse%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.CaptureMouse">
          <source>If calling <ph id="ph1">&lt;xref:System.Windows.UIElement.CaptureMouse%2A&gt;</ph> returns <ph id="ph2">`true`</ph>, then <ph id="ph3">&lt;xref:System.Windows.UIElement.IsMouseCaptured%2A&gt;</ph> is also <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Se chamar <ph id="ph1">&lt;xref:System.Windows.UIElement.CaptureMouse%2A&gt;</ph> retorna <ph id="ph2">`true`</ph>, em seguida, <ph id="ph3">&lt;xref:System.Windows.UIElement.IsMouseCaptured%2A&gt;</ph> também é <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.CaptureMouse">
          <source>If calling <ph id="ph1">&lt;xref:System.Windows.UIElement.CaptureMouse%2A&gt;</ph> returns <ph id="ph2">`true`</ph>, then the <ph id="ph3">&lt;xref:System.Windows.UIElement.GotMouseCapture&gt;</ph> and <ph id="ph4">&lt;xref:System.Windows.UIElement.IsMouseCapturedChanged&gt;</ph> events are raised, with <ph id="ph5">&lt;xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType&gt;</ph> in the event data reported as the element where the <ph id="ph6">&lt;xref:System.Windows.UIElement.CaptureMouse%2A&gt;</ph> method is called.</source>
          <target state="translated">Se chamar <ph id="ph1">&lt;xref:System.Windows.UIElement.CaptureMouse%2A&gt;</ph> retorna <ph id="ph2">`true`</ph>, em seguida, o <ph id="ph3">&lt;xref:System.Windows.UIElement.GotMouseCapture&gt;</ph> e <ph id="ph4">&lt;xref:System.Windows.UIElement.IsMouseCapturedChanged&gt;</ph> os eventos são gerados, com <ph id="ph5">&lt;xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType&gt;</ph> no evento dados relatados como o elemento onde o <ph id="ph6">&lt;xref:System.Windows.UIElement.CaptureMouse%2A&gt;</ph> método é chamado.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.CaptureMouse">
          <source>If you force capture, you might interfere with existing captures—especially with captures that relate to drag-and-drop with the mouse.</source>
          <target state="translated">Se você forçar a captura, você pode interferir na captura existente, especialmente com capturas de que se relacionam com arrastar e soltar com o mouse.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.CaptureMouse">
          <source>To clear mouse capture from all elements, call <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType&gt;</ph> with the <ph id="ph2">`element`</ph> parameter provided as <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Para limpar a captura do mouse de todos os elementos, chame <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType&gt;</ph> com o <ph id="ph2">`element`</ph> parâmetro fornecido como <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.CaptureMouse">
          <source>The following example implements a pair of handlers for mouse and key input combination that capture (and uncapture) the mouse and enable a special mouse mode for viewing a 3D model.</source>
          <target state="translated">O exemplo a seguir implementa um par de manipuladores de mouse e teclas de entrada que capture (e uncapture) o mouse e habilitar um modo especial de mouse para exibir um modelo 3D.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.CaptureStylus">
          <source>Attempts to force capture of the stylus to this element.</source>
          <target state="translated">Tenta forçar a captura da caneta para esse elemento.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.CaptureStylus">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the stylus was successfully captured; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se a caneta for capturada com êxito; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.CaptureStylus">
          <source>The default implementation based on the underlying default stylus device always returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated">A implementação do padrão com base no dispositivo de caneta padrão subjacente sempre retorna <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.CaptureStylus">
          <source>However, if you are extending the input devices that provide the device implementation for the input system, it is possible to create a system with an alternative stylus device implementation that might return different results.</source>
          <target state="translated">No entanto, se você estiver estendendo os dispositivos de entrada que fornece a implementação de dispositivo para o sistema de entrada, é possível criar um sistema com uma implementação de dispositivo de caneta alternativo que pode retornar resultados diferentes.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.CaptureStylus">
          <source>When an element captures the stylus, it receives stylus input even if the stylus is outside its bounds.</source>
          <target state="translated">Quando um elemento captura a caneta, ele recebe entrada de caneta mesmo se a caneta está fora dos seus limites.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.CaptureStylus">
          <source>The stylus is typically captured only during drag-and-drop operations.</source>
          <target state="translated">Normalmente, a caneta é capturada somente durante as operações de arrastar e soltar.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.CaptureStylus">
          <source>Calling this method calls an underlying static <ph id="ph1">&lt;xref:System.Windows.Input.Stylus&gt;</ph> method <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.Capture%2A&gt;</ph>.</source>
          <target state="translated">Chamar este método chama uma subjacente estático <ph id="ph1">&lt;xref:System.Windows.Input.Stylus&gt;</ph> método <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.Capture%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.CaptureStylus">
          <source>The actual capture behavior is implemented by the active stylus device implementation.</source>
          <target state="translated">O comportamento real de captura é implementado pela implementação de dispositivo de caneta ativo.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.CaptureStylus">
          <source>To be captured, an element must be enabled.</source>
          <target state="translated">Para ser capturada, um elemento deve ser habilitado.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.CaptureStylus">
          <source>Check whether <ph id="ph1">&lt;xref:System.Windows.UIElement.IsEnabled%2A&gt;</ph> is <ph id="ph2">`true`</ph> return before you call <ph id="ph3">&lt;xref:System.Windows.UIElement.CaptureStylus%2A&gt;</ph>.</source>
          <target state="translated">Verifique se <ph id="ph1">&lt;xref:System.Windows.UIElement.IsEnabled%2A&gt;</ph> é <ph id="ph2">`true`</ph> retornar antes de chamar <ph id="ph3">&lt;xref:System.Windows.UIElement.CaptureStylus%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.CaptureStylus">
          <source>If calling <ph id="ph1">&lt;xref:System.Windows.UIElement.CaptureStylus%2A&gt;</ph> returns <ph id="ph2">`true`</ph>, <ph id="ph3">&lt;xref:System.Windows.UIElement.IsStylusCaptured%2A&gt;</ph> is also <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Se chamar <ph id="ph1">&lt;xref:System.Windows.UIElement.CaptureStylus%2A&gt;</ph> retorna <ph id="ph2">`true`</ph>, <ph id="ph3">&lt;xref:System.Windows.UIElement.IsStylusCaptured%2A&gt;</ph> também é <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.CaptureTouch(System.Windows.Input.TouchDevice)">
          <source>The device to capture.</source>
          <target state="translated">O dispositivo a ser capturado.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.CaptureTouch(System.Windows.Input.TouchDevice)">
          <source>Attempts to force capture of a touch to this element.</source>
          <target state="translated">Tenta forçar a captura de um toque para esse elemento.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.CaptureTouch(System.Windows.Input.TouchDevice)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified touch is captured to this element; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o toque especificado for capturado para esse elemento; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.CaptureTouch(System.Windows.Input.TouchDevice)">
          <source><ph id="ph1">&lt;xref:System.Windows.UIElement.CaptureTouch%2A&gt;</ph> will return <ph id="ph2">`false`</ph> if the <ph id="ph3">&lt;xref:System.Windows.Input.TouchDevice&gt;</ph> is currently captured to another element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.UIElement.CaptureTouch%2A&gt;</ph> retornará <ph id="ph2">`false`</ph> se o <ph id="ph3">&lt;xref:System.Windows.Input.TouchDevice&gt;</ph> capturada no momento para outro elemento.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.CaptureTouch(System.Windows.Input.TouchDevice)">
          <source>If <ph id="ph1">&lt;xref:System.Windows.UIElement.CaptureTouch%2A&gt;</ph> returns <ph id="ph2">`true`</ph>, then the <ph id="ph3">&lt;xref:System.Windows.UIElement.GotTouchCapture&gt;</ph> event is raised.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Windows.UIElement.CaptureTouch%2A&gt;</ph> retorna <ph id="ph2">`true`</ph>, em seguida, o <ph id="ph3">&lt;xref:System.Windows.UIElement.GotTouchCapture&gt;</ph> é gerado.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.CaptureTouch(System.Windows.Input.TouchDevice)">
          <source>To release capture of a single touch from this element, use the <ph id="ph1">&lt;xref:System.Windows.UIElement.ReleaseTouchCapture%2A&gt;</ph> method and specify the touch device to release.</source>
          <target state="translated">Para liberar a captura de um único toque deste elemento, use o <ph id="ph1">&lt;xref:System.Windows.UIElement.ReleaseTouchCapture%2A&gt;</ph> método e especifique o dispositivo de toque para liberar.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.CaptureTouch(System.Windows.Input.TouchDevice)">
          <source>To release all touches from this element, use the <ph id="ph1">&lt;xref:System.Windows.UIElement.ReleaseAllTouchCaptures%2A&gt;</ph> method.</source>
          <target state="translated">Para liberar todos os toques deste elemento, use o <ph id="ph1">&lt;xref:System.Windows.UIElement.ReleaseAllTouchCaptures%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.CaptureTouch(System.Windows.Input.TouchDevice)">
          <source><ph id="ph1">&lt;paramref name="touchDevice" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="touchDevice" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.Clip">
          <source>Gets or sets the geometry used to define the outline of the contents of an element.</source>
          <target state="translated">Obtém ou define a geometria usada para definir o contorno do conteúdo de um elemento.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.Clip">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Clip">
          <source>The geometry to be used for clipping area sizing.</source>
          <target state="translated">A geometria a ser usada para o dimensionamento de área de recorte.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Clip">
          <source>The default is a null <ph id="ph1">&lt;see cref="T:System.Windows.Media.Geometry" /&gt;</ph>.</source>
          <target state="translated">O padrão é um <ph id="ph1">&lt;see cref="T:System.Windows.Media.Geometry" /&gt;</ph> nulo.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Clip">
          <source>Elements outside the geometry will be visually clipped in the rendered layout.</source>
          <target state="translated">Elementos fora da geometria serão recortados visualmente no layout renderizado.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Clip">
          <source>The geometry does not have to be rectangular.</source>
          <target state="translated">A geometria não precisa ser retangular.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Clip">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Clip">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Clip">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Clip">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Clip">
          <source>This example shows how to define a framework element's <ph id="ph1">&lt;xref:System.Windows.UIElement.Clip%2A&gt;</ph> region.</source>
          <target state="translated">Este exemplo mostra como definir um elemento de framework <ph id="ph1">&lt;xref:System.Windows.UIElement.Clip%2A&gt;</ph> região.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Clip">
          <source>To define a clip, use a <ph id="ph1">&lt;xref:System.Windows.Media.Geometry&gt;</ph> (for example, an <ph id="ph2">&lt;xref:System.Windows.Media.EllipseGeometry&gt;</ph> to set the element's <ph id="ph3">&lt;xref:System.Windows.UIElement.Clip%2A&gt;</ph> property.</source>
          <target state="translated">Para definir um clip, use um <ph id="ph1">&lt;xref:System.Windows.Media.Geometry&gt;</ph> (por exemplo, um <ph id="ph2">&lt;xref:System.Windows.Media.EllipseGeometry&gt;</ph> para definir o elemento <ph id="ph3">&lt;xref:System.Windows.UIElement.Clip%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Clip">
          <source>Only the area that is within the region of the geometry will be visible.</source>
          <target state="translated">Somente a área que está dentro da região da geometria estará visível.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Clip">
          <source>The following example shows an <ph id="ph1">&lt;xref:System.Windows.Controls.Image&gt;</ph> element without a defined clip region.</source>
          <target state="translated">A exemplo a seguir mostra um <ph id="ph1">&lt;xref:System.Windows.Controls.Image&gt;</ph> elemento sem uma região clip definida.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Clip">
          <source>Because no clip region is defined, the entire image is displayed.</source>
          <target state="translated">Como nenhuma região de clip está definida, a imagem inteira será exibida.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Clip">
          <source><bpt id="p1">![</bpt>An object before applying a clip region<ept id="p1">]</ept><bpt id="p2">(~/add/media/mil-task-clip-region-noclip.png "</bpt>An object before applying a clip region<ept id="p2">")</ept></source>
          <target state="translated"><bpt id="p1">![</bpt>Um objeto antes da aplicação de uma região de clip<ept id="p1">]</ept><bpt id="p2">(~/add/media/mil-task-clip-region-noclip.png "</bpt>um objeto antes da aplicação de uma região de recorte<ept id="p2">")</ept></target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Clip">
          <source>Image with No Clip Region</source>
          <target state="translated">Imagem com nenhuma região de recorte</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Clip">
          <source>In the next example, an identical Image is created, except that it has a defined clip region.</source>
          <target state="translated">No exemplo a seguir, uma imagem idêntica é criada, exceto que ele tem uma região de clip definida.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Clip">
          <source>Only the part of the image that is within the area the <ph id="ph1">&lt;xref:System.Windows.Media.EllipseGeometry&gt;</ph> will be displayed.</source>
          <target state="translated">Somente a parte da imagem que estiver dentro da área de <ph id="ph1">&lt;xref:System.Windows.Media.EllipseGeometry&gt;</ph> será exibido.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Clip">
          <source><bpt id="p1">![</bpt>A clipped object<ept id="p1">]</ept><bpt id="p2">(~/add/media/mil-task-clip-region-ellispe.PNG "</bpt>A clipped object<ept id="p2">")</ept></source>
          <target state="translated"><bpt id="p1">![</bpt>Um objeto recortado<ept id="p1">]</ept><bpt id="p2">(~/add/media/mil-task-clip-region-ellispe.PNG "</bpt>um objeto recortado<ept id="p2">")</ept></target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Clip">
          <source>Image with an Elliptical Clip Region</source>
          <target state="translated">Imagem com uma região de Clip elíptico</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Clip">
          <source>The following example shows how animate a framework element's <ph id="ph1">&lt;xref:System.Windows.UIElement.Clip%2A&gt;</ph> region.</source>
          <target state="translated">O exemplo a seguir mostra como animar um elemento de estrutura <ph id="ph1">&lt;xref:System.Windows.UIElement.Clip%2A&gt;</ph> região.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Clip">
          <source>In this example, an <ph id="ph1">&lt;xref:System.Windows.Media.EllipseGeometry&gt;</ph> is used to define an elliptical clip region for an <ph id="ph2">&lt;xref:System.Windows.Controls.Image&gt;</ph> element.</source>
          <target state="translated">Neste exemplo, um <ph id="ph1">&lt;xref:System.Windows.Media.EllipseGeometry&gt;</ph> é usado para definir uma região elíptico de clip para um <ph id="ph2">&lt;xref:System.Windows.Controls.Image&gt;</ph> elemento.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Clip">
          <source>A <ph id="ph1">&lt;xref:System.Windows.Media.Animation.PointAnimation&gt;</ph> animates the ellipse geometry's <ph id="ph2">&lt;xref:System.Windows.Media.EllipseGeometry.Center%2A&gt;</ph> property from (0, 0) to (200, 150).</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Windows.Media.Animation.PointAnimation&gt;</ph> anima a geometria de elipse <ph id="ph2">&lt;xref:System.Windows.Media.EllipseGeometry.Center%2A&gt;</ph> propriedade de (0, 0) para (200, 150).</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Clip">
          <source>The animation starts playing after the image is loaded and repeats indefinitely.</source>
          <target state="translated">A animação começa a reproduzir depois que a imagem é carregada e repete indefinidamente.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Clip">
          <source>For the full sample, see the <bpt id="p1">[</bpt>Clip Region Sample<ept id="p1">](http://msdn.microsoft.com/library/83043a0b-f824-445f-9675-103280c5ca67)</ept>.</source>
          <target state="translated">Para o exemplo completo, consulte o <bpt id="p1">[</bpt>exemplo de região de Clip<ept id="p1">](http://msdn.microsoft.com/library/83043a0b-f824-445f-9675-103280c5ca67)</ept>.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.ClipProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.Clip" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.Clip" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.ClipToBounds">
          <source>Gets or sets a value indicating whether to clip the content of this element (or content coming from the child elements of this element) to fit into the size of the containing element.</source>
          <target state="translated">Obtém ou define um valor indicando se o conteúdo deste elemento (ou conteúdo proveniente dos filhos deste elemento) deve ser recortado para caber dentro do espaço do elemento que o contém.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.ClipToBounds">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.ClipToBounds">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the content should be clipped; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se for necessário recortar o conteúdo; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.ClipToBounds">
          <source>The default value is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O valor padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.ClipToBounds">
          <source>For child elements, <ph id="ph1">&lt;xref:System.Windows.UIElement.ClipToBounds%2A&gt;</ph> has different effects on layout behaviors depending on whether the height and width of the parent element are being determined by <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph><ph id="ph3"> / </ph><ph id="ph4">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph> or <ph id="ph5">&lt;xref:System.Windows.FrameworkElement.MaxHeight%2A&gt;</ph><ph id="ph6"> / </ph><ph id="ph7">&lt;xref:System.Windows.FrameworkElement.MaxWidth%2A&gt;</ph>.</source>
          <target state="translated">Para elementos filho, <ph id="ph1">&lt;xref:System.Windows.UIElement.ClipToBounds%2A&gt;</ph> tem efeitos diferentes nos comportamentos de layout, dependendo se a altura e largura do elemento pai estão sendo determinadas pelo <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph> <ph id="ph3"> / </ph> <ph id="ph4">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph> ou <ph id="ph5">&lt;xref:System.Windows.FrameworkElement.MaxHeight%2A&gt;</ph> <ph id="ph6"> / </ph> <ph id="ph7">&lt;xref:System.Windows.FrameworkElement.MaxWidth%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.ClipToBounds">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MaxHeight%2A&gt;</ph><ph id="ph2"> / </ph><ph id="ph3">&lt;xref:System.Windows.FrameworkElement.MaxWidth%2A&gt;</ph> of the parent element are always respected regardless of the value of <ph id="ph4">&lt;xref:System.Windows.UIElement.ClipToBounds%2A&gt;</ph> and the effective clipping will always clip the content based on these maximums.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MaxHeight%2A&gt;</ph><ph id="ph2"> / </ph><ph id="ph3">&lt;xref:System.Windows.FrameworkElement.MaxWidth%2A&gt;</ph> do elemento pai são respeitadas sempre, independentemente do valor de <ph id="ph4">&lt;xref:System.Windows.UIElement.ClipToBounds%2A&gt;</ph> e o recorte efetivo sempre recortará o conteúdo com base nesses máximos.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.ClipToBounds">
          <source>The parent's <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph><ph id="ph2"> / </ph><ph id="ph3">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph> settings will not clip the content when <ph id="ph4">&lt;xref:System.Windows.UIElement.ClipToBounds%2A&gt;</ph> is <ph id="ph5">`false`</ph>, but will clip the content if <ph id="ph6">&lt;xref:System.Windows.UIElement.ClipToBounds%2A&gt;</ph> is <ph id="ph7">`true`</ph>.</source>
          <target state="translated">O pai <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph> <ph id="ph2"> / </ph> <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph> configurações não recortará o conteúdo quando <ph id="ph4">&lt;xref:System.Windows.UIElement.ClipToBounds%2A&gt;</ph> é <ph id="ph5">`false`</ph>, mas recortará o conteúdo se <ph id="ph6">&lt;xref:System.Windows.UIElement.ClipToBounds%2A&gt;</ph> é <ph id="ph7">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.ClipToBounds">
          <source>Note that defaulting to <ph id="ph1">`false`</ph> is the general behavior as implemented in the <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> class.</source>
          <target state="translated">Observe que o padrão para <ph id="ph1">`false`</ph> é o comportamento geral, conforme implementado o <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.ClipToBounds">
          <source>It is possible for any given element that derives from <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> to override the dependency property metadata for this property in that instance to default to <ph id="ph2">`true`</ph> instead.</source>
          <target state="translated">É possível para qualquer elemento determinado que deriva de <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> para substituir os metadados de propriedade de dependência para essa propriedade na instância padrão para <ph id="ph2">`true`</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.ClipToBounds">
          <source>Several existing derived classes override this metadata and/or adjust the dependency property default value.</source>
          <target state="translated">Várias classes derivadas existentes substituem esses metadados e/ou ajustar o valor da propriedade de dependência padrão.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.ClipToBounds">
          <source><ph id="ph1">&lt;xref:System.Windows.Controls.InkCanvas&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Controls.InkPresenter&gt;</ph>, and <ph id="ph3">&lt;xref:System.Windows.Controls.Primitives.Popup&gt;</ph> each override the default value to be <ph id="ph4">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.InkCanvas&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Controls.InkPresenter&gt;</ph>, e <ph id="ph3">&lt;xref:System.Windows.Controls.Primitives.Popup&gt;</ph> cada substituir o valor padrão a ser <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.ClipToBounds">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> overrides the metadata for this dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> substitui os metadados para essa propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.ClipToBounds">
          <source>Specifically, <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> designates this property to allow property value inheritance (<ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> is <ph id="ph3">`true`</ph> in metadata).</source>
          <target state="translated">Especificamente, <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> designa essa propriedade para permitir a herança de valor de propriedade (<ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> é <ph id="ph3">`true`</ph> nos metadados).</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.ClipToBounds">
          <source>Property value inheritance in this context means that if there are child elements with no other value for <ph id="ph1">&lt;xref:System.Windows.UIElement.ClipToBounds%2A&gt;</ph> assigned through local values or styles, the value of the nearest parent element with this value assigned (again, either in styles, by default values, or a locally value), then the value from the parent element will be assigned to all unassigned child elements by the property system.</source>
          <target state="translated">Herança de valor de propriedade neste contexto significa que, se houver elementos filho com nenhum outro valor para <ph id="ph1">&lt;xref:System.Windows.UIElement.ClipToBounds%2A&gt;</ph> atribuído por meio de valores locais ou estilos, o valor do elemento pai mais próximo com esse valor atribuído (novamente, tanto em estilos, valores padrão, ou um valor localmente), em seguida, o valor do elemento pai será atribuído a todos os elementos filho não atribuído pelo sistema de propriedades.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.ClipToBounds">
          <source>In practice this means that you can specify whether to allow clip to bounds at the root element, and that value will propagate to all child elements that have not specifically assigned it as <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Na prática, isso significa que você pode especificar se deseja permitir que o clipe de limites no elemento raiz, e que o valor serão propagadas para todos os elementos filho que têm não especificamente atribuído como <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.ClipToBounds">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.ClipToBounds">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.ClipToBounds">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.ClipToBounds">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.ClipToBoundsProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.ClipToBounds" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.ClipToBounds" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.CommandBindings">
          <source>Gets a collection of <ph id="ph1">&lt;see cref="T:System.Windows.Input.CommandBinding" /&gt;</ph> objects associated with this element.</source>
          <target state="translated">Obtém uma coleção de objetos <ph id="ph1">&lt;see cref="T:System.Windows.Input.CommandBinding" /&gt;</ph> associados a esse elemento.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.CommandBindings">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Input.CommandBinding" /&gt;</ph> enables command handling for this element, and declares the linkage between a command, its events, and the handlers attached by this element.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Windows.Input.CommandBinding" /&gt;</ph> permite a manipulação de comando desse elemento e declara a ligação entre um comando, seus eventos e os manipuladores anexados por esse elemento.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.CommandBindings">
          <source>The collection of all <ph id="ph1">&lt;see cref="T:System.Windows.Input.CommandBinding" /&gt;</ph> objects.</source>
          <target state="translated">A coleção de todos os objetos <ph id="ph1">&lt;see cref="T:System.Windows.Input.CommandBinding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.CommandBindings">
          <source>Another typical way to populate the <ph id="ph1">&lt;xref:System.Windows.UIElement.CommandBindings%2A&gt;</ph> collection is to use <ph id="ph2">&lt;xref:System.Windows.Input.CommandManager&gt;</ph> methods programmatically.</source>
          <target state="translated">Outra maneira comum para preencher o <ph id="ph1">&lt;xref:System.Windows.UIElement.CommandBindings%2A&gt;</ph> coleção é usar <ph id="ph2">&lt;xref:System.Windows.Input.CommandManager&gt;</ph> métodos programaticamente.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.CommandBindings">
          <source>XAML Property Element Usage</source>
          <target state="translated">Uso do elemento propriedade XAML</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.CommandBindings">
          <source>XAML Values</source>
          <target state="translated">Valores XAML</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.CommandBindings">
          <source><bpt id="p1">*</bpt>oneOrMoreCommandBindings<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>oneOrMoreCommandBindings<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.CommandBindings">
          <source>One or more <ph id="ph1">&lt;xref:System.Windows.Input.CommandBinding&gt;</ph> elements.</source>
          <target state="translated">Um ou mais <ph id="ph1">&lt;xref:System.Windows.Input.CommandBinding&gt;</ph> elementos.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.CommandBindings">
          <source>Each of these should have a <ph id="ph1">&lt;xref:System.Windows.Input.CommandBinding.Command%2A&gt;</ph> attribute set to a known command, and attributes set for the <ph id="ph2">&lt;xref:System.Windows.Input.CommandBinding.CanExecute&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.Input.CommandBinding.Executed&gt;</ph> handler implementations.</source>
          <target state="translated">Cada um deles deve ter uma <ph id="ph1">&lt;xref:System.Windows.Input.CommandBinding.Command%2A&gt;</ph> atributo definido como um comando conhecido e os atributos definidos para o <ph id="ph2">&lt;xref:System.Windows.Input.CommandBinding.CanExecute&gt;</ph> e <ph id="ph3">&lt;xref:System.Windows.Input.CommandBinding.Executed&gt;</ph> implementações de manipulador.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.CommandBindings">
          <source>For more information see <ph id="ph1">&lt;xref:System.Windows.Input.CommandBinding&gt;</ph>.</source>
          <target state="translated">Para obter mais informações, consulte <ph id="ph1">&lt;xref:System.Windows.Input.CommandBinding&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.CommandBindings">
          <source>The following example adds a <ph id="ph1">&lt;xref:System.Windows.Input.CommandBinding&gt;</ph> to a window using markup.</source>
          <target state="translated">O exemplo a seguir adiciona um <ph id="ph1">&lt;xref:System.Windows.Input.CommandBinding&gt;</ph> para uma janela usando a marcação.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.CommandBindings">
          <source>Note that in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.Windows.Input.CommandBindingCollection&gt;</ph> is not declared in the markup as an element; the collection object is inferred by the type that the property takes, and you populate the property element with one or more <ph id="ph3">&lt;xref:System.Windows.Input.CommandBinding&gt;</ph> elements:</source>
          <target state="translated">Observe que em <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, o <ph id="ph2">&lt;xref:System.Windows.Input.CommandBindingCollection&gt;</ph> não é declarado na marcação como um elemento; o objeto da coleção é inferido pelo tipo que usa a propriedade e preencher o elemento de propriedade com um ou mais <ph id="ph3">&lt;xref:System.Windows.Input.CommandBinding&gt;</ph> elementos:</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.CommandBindings">
          <source>For more information about the <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax for collections, see <bpt id="p1">[</bpt>XAML Syntax In Detail<ept id="p1">](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre o <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> sintaxe para coleções, consulte <bpt id="p1">[</bpt>XAML sintaxe em detalhes<ept id="p1">](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)</ept>.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.CommandBindings">
          <source>The following example does essentially the same thing in code:</source>
          <target state="translated">O exemplo a seguir faz essencialmente a mesma coisa no código:</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.DesiredSize">
          <source>Gets the size that this element computed during the measure pass of the layout process.</source>
          <target state="translated">Obtém o tamanho que esse elemento calculou durante o passo de medição do processo de layout.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.DesiredSize">
          <source>The computed size, which becomes the desired size for the arrange pass.</source>
          <target state="translated">O tamanho calculado, que se torna o tamanho desejado para o passo de organização.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.DesiredSize">
          <source>The value returned by this property will only be a valid measurement if the value of the <ph id="ph1">&lt;xref:System.Windows.UIElement.IsMeasureValid%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">O valor retornado por essa propriedade será uma medida válida somente se o valor de <ph id="ph1">&lt;xref:System.Windows.UIElement.IsMeasureValid%2A&gt;</ph> é de propriedade <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.DesiredSize">
          <source><ph id="ph1">&lt;xref:System.Windows.UIElement.DesiredSize%2A&gt;</ph> is typically checked as one of the measurement factors when you implement layout behavior overrides such as <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.ArrangeOverride%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.MeasureOverride%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.Windows.UIElement.OnRender%2A&gt;</ph> (in the <ph id="ph5">&lt;xref:System.Windows.UIElement.OnRender%2A&gt;</ph> case, you might check <ph id="ph6">&lt;xref:System.Windows.UIElement.RenderSize%2A&gt;</ph> instead, but this depends on your implementation).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.UIElement.DesiredSize%2A&gt;</ph> normalmente é verificado como um dos fatores medida ao implementar o comportamento de layout, como substituições <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.ArrangeOverride%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.MeasureOverride%2A&gt;</ph>, ou <ph id="ph4">&lt;xref:System.Windows.UIElement.OnRender%2A&gt;</ph> (no <ph id="ph5">&lt;xref:System.Windows.UIElement.OnRender%2A&gt;</ph> caso, você pode verificar <ph id="ph6">&lt;xref:System.Windows.UIElement.RenderSize%2A&gt;</ph> em vez disso, mas isso depende de sua implementação).</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.DesiredSize">
          <source>Depending on the scenario, <ph id="ph1">&lt;xref:System.Windows.UIElement.DesiredSize%2A&gt;</ph> might be fully respected by your implementation logic, constraints on <ph id="ph2">&lt;xref:System.Windows.UIElement.DesiredSize%2A&gt;</ph> might be applied, and such constraints might also change other characteristics of either the parent element or child element.</source>
          <target state="translated">Dependendo do cenário, <ph id="ph1">&lt;xref:System.Windows.UIElement.DesiredSize%2A&gt;</ph> pode ser totalmente respeitado pelo sua lógica de implementação, restrições em <ph id="ph2">&lt;xref:System.Windows.UIElement.DesiredSize%2A&gt;</ph> podem ser aplicadas, e essas restrições também podem alterar outras características do elemento pai ou elemento filho.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.DesiredSize">
          <source>For example, a control that supports scrollable regions (but chooses not to derive from the WPF framework-level controls that already enable scrollable regions) could compare available size to <ph id="ph1">&lt;xref:System.Windows.UIElement.DesiredSize%2A&gt;</ph>.</source>
          <target state="translated">Por exemplo, um controle que dá suporte a regiões roláveis (mas optar por não derivar os controles de nível de framework do WPF que já habilitar áreas roláveis) poderá comparar o tamanho disponível para <ph id="ph1">&lt;xref:System.Windows.UIElement.DesiredSize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.DesiredSize">
          <source>The control could then set an internal state that enabled scrollbars in the <ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph> for that control.</source>
          <target state="translated">O controle, em seguida, foi definido um estado interno que habilitado barras de rolagem no <ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph> para o controle.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.DesiredSize">
          <source>Or, <ph id="ph1">&lt;xref:System.Windows.UIElement.DesiredSize%2A&gt;</ph> could potentially also be ignored in certain scenarios.</source>
          <target state="translated">Ou, <ph id="ph1">&lt;xref:System.Windows.UIElement.DesiredSize%2A&gt;</ph> podem também ser ignorado em determinados cenários.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.DesiredSize">
          <source>The following example shows <ph id="ph1">&lt;xref:System.Windows.UIElement.DesiredSize%2A&gt;</ph> as part of a <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.MeasureOverride%2A&gt;</ph> implementation.</source>
          <target state="translated">A exemplo a seguir mostra <ph id="ph1">&lt;xref:System.Windows.UIElement.DesiredSize%2A&gt;</ph> como parte de um <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.MeasureOverride%2A&gt;</ph> implementação.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.DesiredSize">
          <source>Notice how <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> is called immediately prior to obtaining <ph id="ph2">&lt;xref:System.Windows.UIElement.DesiredSize%2A&gt;</ph>.</source>
          <target state="translated">Observe como <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> é chamado imediatamente antes de obter <ph id="ph2">&lt;xref:System.Windows.UIElement.DesiredSize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.DesiredSize">
          <source>This assures that <ph id="ph1">&lt;xref:System.Windows.UIElement.DesiredSize%2A&gt;</ph> holds a legitimate value.</source>
          <target state="translated">Isso garante que <ph id="ph1">&lt;xref:System.Windows.UIElement.DesiredSize%2A&gt;</ph> contém um valor legítimo.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.DragEnter">
          <source>Occurs when the input system reports an underlying drag event with this element as the drag target.</source>
          <target state="translated">Ocorre quando o sistema de entrada relata um evento arrastar subjacente com este elemento como o destino de arrastar.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragEnter">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.DragEnter?displayProperty=nameWithType&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.DragEnter?displayProperty=nameWithType&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragEnter">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.DragEnter&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.DragEnter&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragEnter">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragEnter">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragEnter">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragEnter">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragEnter">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragEnter">
          <source>The corresponding tunneling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewDragEnter&gt;</ph>.</source>
          <target state="translated">O evento de túnel correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewDragEnter&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragEnter">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnDragEnter%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnDragEnter%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.DragEnterEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.DragEnter" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.DragEnter" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.DragEnterEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.DragEnterEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.DragEnterEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.DragEnterEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.DragEnterEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.DragLeave">
          <source>Occurs when the input system reports an underlying drag event with this element as the drag origin.</source>
          <target state="translated">Ocorre quando o sistema de entrada relata um evento arrastar subjacente com este elemento como a origem de arrastar.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragLeave">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType&gt;</ph> attached event for this class so that <ph id="ph2">&lt;xref:System.Windows.UIElement.DragLeave?displayProperty=nameWithType&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType&gt;</ph> evento para esta classe anexado para que <ph id="ph2">&lt;xref:System.Windows.UIElement.DragLeave?displayProperty=nameWithType&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragLeave">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.DragLeave&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.DragLeave&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragLeave">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragLeave">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragLeave">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragLeave">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragLeave">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragLeave">
          <source>The corresponding tunneling event is <ph id="ph1">&lt;xref:System.Windows.DragDrop.PreviewDragLeave&gt;</ph>.</source>
          <target state="translated">O evento de túnel correspondente é <ph id="ph1">&lt;xref:System.Windows.DragDrop.PreviewDragLeave&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragLeave">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnDragLeave%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnDragLeave%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.DragLeaveEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.DragLeave" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.DragLeave" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.DragLeaveEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.DragLeaveEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.DragLeaveEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.DragLeaveEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.DragLeaveEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.DragOver">
          <source>Occurs when the input system reports an underlying drag event with this element as the potential drop target.</source>
          <target state="translated">Ocorre quando o sistema de entrada relata um evento do tipo "arrastar" subjacente com esse elemento como a reprodução automática potencial.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragOver">
          <source>This event occurs even if the drag originates in the element bounds.</source>
          <target state="translated">Esse evento ocorre mesmo se a operação de arrastar se origina dos limites do elemento.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragOver">
          <source>If the drag starts outside the bounds and then moves inside, this event is also raised, as well as <ph id="ph1">&lt;xref:System.Windows.UIElement.DragEnter&gt;</ph> and related preview events.</source>
          <target state="translated">Se a operação de arrastar inicia fora dos limites e, em seguida, move dentro, esse evento também é gerado, bem como <ph id="ph1">&lt;xref:System.Windows.UIElement.DragEnter&gt;</ph> e Visualizar eventos relacionados.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragOver">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType&gt;</ph> attached event for this class so that <ph id="ph2">&lt;xref:System.Windows.UIElement.DragOver?displayProperty=nameWithType&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType&gt;</ph> evento para esta classe anexado para que <ph id="ph2">&lt;xref:System.Windows.UIElement.DragOver?displayProperty=nameWithType&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragOver">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.DragOver&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.DragOver&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragOver">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragOver">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragOver">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragOver">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragOver">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragOver">
          <source>The corresponding tunneling event is <ph id="ph1">&lt;xref:System.Windows.DragDrop.PreviewDragOver&gt;</ph>.</source>
          <target state="translated">O evento de túnel correspondente é <ph id="ph1">&lt;xref:System.Windows.DragDrop.PreviewDragOver&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.DragOver">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnDragOver%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnDragOver%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.DragOverEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.DragOver" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.DragOver" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.DragOverEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.DragOverEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.DragOverEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.DragOverEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.DragOverEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.Drop">
          <source>Occurs when the input system reports an underlying drop event with this element as the drop target.</source>
          <target state="translated">Ocorre quando o sistema de entrada relata um evento soltar subjacente com esse elemento sendo uma reprodução automática.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.Drop">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType&gt;</ph> attached event for this class so that <ph id="ph2">&lt;xref:System.Windows.UIElement.Drop?displayProperty=nameWithType&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType&gt;</ph> evento para esta classe anexado para que <ph id="ph2">&lt;xref:System.Windows.UIElement.Drop?displayProperty=nameWithType&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.Drop">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.Drop&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.Drop&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.Drop">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.Drop">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.Drop">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.Drop">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.Drop">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.Drop">
          <source>The corresponding tunneling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewDrop&gt;</ph>.</source>
          <target state="translated">O evento de túnel correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewDrop&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.Drop">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnDrop%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnDrop%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.DropEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.Drop" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.Drop" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.DropEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.DropEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.DropEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.DropEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.DropEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.Effect">
          <source>Gets or sets the bitmap effect to apply to the <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph>.</source>
          <target state="translated">Obtém ou define o efeito de bitmap a ser aplicado ao <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.Effect">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Effect">
          <source>An <ph id="ph1">&lt;see cref="T:System.Windows.Media.Effects.Effect" /&gt;</ph> that represents the bitmap effect.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Windows.Media.Effects.Effect" /&gt;</ph> que representa o efeito de bitmap.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Effect">
          <source>Use the <ph id="ph1">&lt;xref:System.Windows.UIElement.Effect%2A&gt;</ph> property to apply a bitmap effect to a <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph>.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Windows.UIElement.Effect%2A&gt;</ph> propriedade para aplicar um efeito de bitmap para um <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Effect">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Effect">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Effect">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Effect">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Effect">
          <source>The following XAML shows how to assign a custom <ph id="ph1">&lt;xref:System.Windows.Media.Effects.ShaderEffect&gt;</ph> to the <ph id="ph2">&lt;xref:System.Windows.UIElement.Effect%2A&gt;</ph> property.</source>
          <target state="translated">O XAML a seguir mostra como atribuir um personalizado <ph id="ph1">&lt;xref:System.Windows.Media.Effects.ShaderEffect&gt;</ph> para o <ph id="ph2">&lt;xref:System.Windows.UIElement.Effect%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.EffectProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.Effect" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.Effect" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.Focus">
          <source>Attempts to set focus to this element.</source>
          <target state="translated">Tenta definir o foco para esse elemento.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.Focus">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if keyboard focus and logical focus were set to this element; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if only logical focus was set to this element, or if the call to this method did not force the focus to change.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o foco do teclado e o foco lógico foram definidos para esse elemento; <ph id="ph2">&lt;see langword="false" /&gt;</ph> somente se o foco lógico foi definido para esse elemento ou se a chamada para esse método não forçou a mudança de foco.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Focus">
          <source>To be focusable, <ph id="ph1">&lt;xref:System.Windows.UIElement.Focusable%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.UIElement.IsEnabled%2A&gt;</ph> must both be <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Para ser Focusable é, <ph id="ph1">&lt;xref:System.Windows.UIElement.Focusable%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.UIElement.IsEnabled%2A&gt;</ph> devem ser <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Focus">
          <source>Even if an element is focusable and enabled, event handling within a specific tree, (such as for a composite control) might respond to the preview focus events by not allowing focus there, thus this method would return <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Mesmo se um elemento é a manipulação de eventos de controle e habilitada, dentro de uma árvore específica, (por exemplo, para um controle composto) pode responder a eventos de foco de visualização, não permitindo que o foco, portanto, esse método retornaria <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Focus">
          <source>Focus in general is governed by two separate concepts: keyboard focus and logical focus, which are not always identical.</source>
          <target state="translated">Foco em geral é regido pelos dois conceitos separados: foco do teclado e foco lógico, que nem sempre são idênticos.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Focus">
          <source>For more information, see <bpt id="p1">[</bpt>Focus Overview<ept id="p1">](~/docs/framework/wpf/advanced/focus-overview.md)</ept> or <bpt id="p2">[</bpt>Input Overview<ept id="p2">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>visão geral de foco<ept id="p1">](~/docs/framework/wpf/advanced/focus-overview.md)</ept> ou <bpt id="p2">[</bpt>visão geral de entrada<ept id="p2">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Focus">
          <source>If calling <ph id="ph1">&lt;xref:System.Windows.UIElement.Focus%2A&gt;</ph> returns <ph id="ph2">`true`</ph>, <ph id="ph3">&lt;xref:System.Windows.UIElement.IsKeyboardFocused%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A&gt;</ph> are also <ph id="ph5">`true`</ph>.</source>
          <target state="translated">Se chamar <ph id="ph1">&lt;xref:System.Windows.UIElement.Focus%2A&gt;</ph> retorna <ph id="ph2">`true`</ph>, <ph id="ph3">&lt;xref:System.Windows.UIElement.IsKeyboardFocused%2A&gt;</ph> e <ph id="ph4">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A&gt;</ph> também são <ph id="ph5">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Focus">
          <source>If the related properties are not already <ph id="ph1">`true`</ph>, when you call  <ph id="ph2">&lt;xref:System.Windows.UIElement.Focus%2A&gt;</ph>, one or more of the following events are raised in the following order: <ph id="ph3">&lt;xref:System.Windows.UIElement.PreviewLostKeyboardFocus&gt;</ph>, <ph id="ph4">&lt;xref:System.Windows.UIElement.PreviewGotKeyboardFocus&gt;</ph> (source is the new focus target), <ph id="ph5">&lt;xref:System.Windows.UIElement.IsKeyboardFocusedChanged&gt;</ph>, <ph id="ph6">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged&gt;</ph>, <ph id="ph7">&lt;xref:System.Windows.UIElement.LostKeyboardFocus&gt;</ph>, <ph id="ph8">&lt;xref:System.Windows.UIElement.GotKeyboardFocus&gt;</ph> (source is the new focus target).</source>
          <target state="translated">Se as propriedades relacionadas não ainda estiver <ph id="ph1">`true`</ph>, quando você chamar <ph id="ph2">&lt;xref:System.Windows.UIElement.Focus%2A&gt;</ph>, um ou mais dos seguintes eventos são gerados na seguinte ordem: <ph id="ph3">&lt;xref:System.Windows.UIElement.PreviewLostKeyboardFocus&gt;</ph>, <ph id="ph4">&lt;xref:System.Windows.UIElement.PreviewGotKeyboardFocus&gt;</ph> (origem é o novo destino de foco), <ph id="ph5">&lt;xref:System.Windows.UIElement.IsKeyboardFocusedChanged&gt;</ph>, <ph id="ph6">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged&gt;</ph>, <ph id="ph7">&lt;xref:System.Windows.UIElement.LostKeyboardFocus&gt;</ph>, <ph id="ph8">&lt;xref:System.Windows.UIElement.GotKeyboardFocus&gt;</ph> (origem é o novo destino de foco).</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Focus">
          <source>In order for this call to be successful, some other element in the application needed to have focus previously.</source>
          <target state="translated">Para esta chamada seja bem-sucedida, algum outro elemento no aplicativo precisava ter foco anteriormente.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Focus">
          <source>The following example sets focus to a <ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> referenced by <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph>, and then adjusts the position of the cursor within the <ph id="ph3">&lt;xref:System.Windows.Controls.TextBox&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir define o foco para um <ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> referenciado pelo <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph>e, em seguida, ajusta a posição do cursor dentro do <ph id="ph3">&lt;xref:System.Windows.Controls.TextBox&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.Focusable">
          <source>Gets or sets a value that indicates whether the element can receive focus.</source>
          <target state="translated">Obtém ou define um valor que indica se um elemento pode receber foco.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.Focusable">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Focusable">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the element is focusable; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o elemento for focalizável; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Focusable">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Focusable">
          <source>Only the focused element receives keyboard input.</source>
          <target state="translated">Somente o elemento focalizado recebe entrada do teclado.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Focusable">
          <source><ph id="ph1">&lt;xref:System.Windows.UIElement.Focusable%2A&gt;</ph> is the <ph id="ph2">[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]</ph> property accessor for what is in reality a dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.UIElement.Focusable%2A&gt;</ph> é o <ph id="ph2">[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]</ph> acessador de propriedade para o que é na verdade uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Focusable">
          <source>This particular dependency property quite frequently has its apparent "default" value set differently in derived element classes, particularly in controls.</source>
          <target state="translated">Essa propriedade de dependência particular com bastante frequência tem seu valor aparente "padrão" definido em classes de elemento derivado, particularmente em controles de modo diferente.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Focusable">
          <source>This commonly occurs in one of two ways:</source>
          <target state="translated">Isso geralmente ocorre em uma das seguintes maneiras:</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Focusable">
          <source>The dependency property is inherited by a particular derived class, but that derived class overrides the metadata of the dependency property and changes the property default value.</source>
          <target state="translated">A propriedade de dependência é herdada por uma determinada classe derivada, mas que derivado substituições de classe de metadados da propriedade de dependência e altera o valor padrão da propriedade.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Focusable">
          <source>A style or template is applied to an element, which sets that dependency property value differently.</source>
          <target state="translated">Um estilo ou modelo é aplicado a um elemento, que define esse valor de propriedade de dependência de maneira diferente.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Focusable">
          <source>For example, the apparent "default" of <ph id="ph1">&lt;xref:System.Windows.UIElement.Focusable%2A&gt;</ph> for a <ph id="ph2">&lt;xref:System.Windows.Controls.Button&gt;</ph> control will be <ph id="ph3">`true`</ph>, even though <ph id="ph4">&lt;xref:System.Windows.Controls.Button&gt;</ph> inherits <ph id="ph5">&lt;xref:System.Windows.UIElement.Focusable%2A&gt;</ph> as a <ph id="ph6">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> property directly from <ph id="ph7">&lt;xref:System.Windows.UIElement&gt;</ph>.</source>
          <target state="translated">Por exemplo, o aparente "padrão" de <ph id="ph1">&lt;xref:System.Windows.UIElement.Focusable%2A&gt;</ph> para um <ph id="ph2">&lt;xref:System.Windows.Controls.Button&gt;</ph> controle será <ph id="ph3">`true`</ph>, embora <ph id="ph4">&lt;xref:System.Windows.Controls.Button&gt;</ph> herda <ph id="ph5">&lt;xref:System.Windows.UIElement.Focusable%2A&gt;</ph> como um <ph id="ph6">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> propriedade diretamente do <ph id="ph7">&lt;xref:System.Windows.UIElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Focusable">
          <source>This is because the applied metadata value for the <ph id="ph1">&lt;xref:System.Windows.UIElement.Focusable%2A&gt;</ph> dependency property was overridden within the static constructor of the <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> base class, which is situated between <ph id="ph3">&lt;xref:System.Windows.Controls.Button&gt;</ph> and <ph id="ph4">&lt;xref:System.Windows.UIElement&gt;</ph> in the class hierarchy.</source>
          <target state="translated">Isso ocorre porque os metadados aplicado o valor para o <ph id="ph1">&lt;xref:System.Windows.UIElement.Focusable%2A&gt;</ph> propriedade de dependência foi substituída no construtor estático do <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> classe, que está situado entre base <ph id="ph3">&lt;xref:System.Windows.Controls.Button&gt;</ph> e <ph id="ph4">&lt;xref:System.Windows.UIElement&gt;</ph> na hierarquia de classe.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Focusable">
          <source>When inherited by <ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> or its derived classes, <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> redefines the default value of this property to be <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Quando herdado por <ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> ou suas classes derivadas, <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> redefine o valor padrão dessa propriedade para ser <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Focusable">
          <source>When inherited by <ph id="ph1">&lt;xref:System.Windows.Controls.Label&gt;</ph> (which is a <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> derived class), the default value is again redefined to be <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Quando herdado por <ph id="ph1">&lt;xref:System.Windows.Controls.Label&gt;</ph> (que é um <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> classe derivada), o valor padrão é redefinido novamente para ser <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Focusable">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Focusable">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Focusable">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Focusable">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Focusable">
          <source>The following example code illustrates a control template for a particular custom control, which sets <ph id="ph1">&lt;xref:System.Windows.UIElement.Focusable%2A&gt;</ph> <ph id="ph2">`false`</ph> on one of the elements within the template.</source>
          <target state="translated">O exemplo de código a seguir ilustra um modelo de controle para um determinado controle personalizado, que define <ph id="ph1">&lt;xref:System.Windows.UIElement.Focusable%2A&gt;</ph> <ph id="ph2">`false`</ph> em um dos elementos dentro do modelo.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Focusable">
          <source>When deriving from <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> directly (as opposed to from <ph id="ph2">&lt;see cref="T:System.Windows.Controls.Control" /&gt;</ph>), consider whether you wish your element to be focusable, because by default the element will not be focusable.</source>
          <target state="translated">Ao derivar de <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> diretamente (ao contrário de <ph id="ph2">&lt;see cref="T:System.Windows.Controls.Control" /&gt;</ph>), considere se desejar que o elemento seja Focusable é, porque, por padrão o elemento não será Focusable é.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Focusable">
          <source>If you wish your element to be focusable, override the metadata for this property within your type's static constructor as follows:</source>
          <target state="translated">Se desejar que o elemento seja Focusable é, substitua os metadados para essa propriedade em um construtor estático do tipo da seguinte maneira:</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Focusable">
          <source>where <ph id="ph1">&lt;paramref name="myElement" /&gt;</ph> should be the class name of the type that you are overriding the metadata value on.</source>
          <target state="translated">onde <ph id="ph1">&lt;paramref name="myElement" /&gt;</ph> deve ser o nome da classe do tipo que você está substituindo o valor de metadados no.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.FocusableChanged">
          <source>Occurs when the value of the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.Focusable" /&gt;</ph> property changes.</source>
          <target state="translated">Ocorre quando o valor da propriedade <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.Focusable" /&gt;</ph> muda.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.FocusableChanged">
          <source>This member is a <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> event, not a routed event.</source>
          <target state="translated">Esse membro é um <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> evento, não é um evento roteado.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.FocusableProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.Focusable" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.Focusable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.GetAnimationBaseValue(System.Windows.DependencyProperty)">
          <source>The dependency property to check.</source>
          <target state="translated">A propriedade de dependência a ser verificada.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.GetAnimationBaseValue(System.Windows.DependencyProperty)">
          <source>Returns the base property value for the specified property on this element, disregarding any possible animated value from a running or stopped animation.</source>
          <target state="translated">Retorna o valor da propriedade base da propriedade especificada neste elemento, desconsiderando qualquer possível valor animado de uma animação parada ou em execução.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.GetAnimationBaseValue(System.Windows.DependencyProperty)">
          <source>The property value as if no animations are attached to the specified dependency property.</source>
          <target state="translated">O valor da propriedade como se não houvesse nenhuma animação anexada à propriedade de dependência especificada.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.GetAnimationBaseValue(System.Windows.DependencyProperty)">
          <source>If no animations are attached to the property, then the <ph id="ph1">&lt;xref:System.Windows.UIElement.GetAnimationBaseValue%2A&gt;</ph> return value is always identical to the <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> return value.</source>
          <target state="translated">Se nenhum animações são anexadas à propriedade o <ph id="ph1">&lt;xref:System.Windows.UIElement.GetAnimationBaseValue%2A&gt;</ph> valor de retorno sempre é idêntico de <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> valor de retorno.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.GetAnimationBaseValue(System.Windows.DependencyProperty)">
          <source>If there are animations attached, then all possible animation derived values including the start and stop values are ignored, and the property value is determined based on all other possible inputs.</source>
          <target state="translated">Se houver animações anexadas, em seguida, animação possíveis todos os derivado valores, incluindo o início e parada valores são ignorados e, o valor da propriedade é determinado com base em todas as outras entradas possíveis.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.GetAnimationBaseValue(System.Windows.DependencyProperty)">
          <source>For more information, see <bpt id="p1">[</bpt>Dependency Property Value Precedence<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>Precedência do valor da propriedade de dependência<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.GetAnimationBaseValue(System.Windows.DependencyProperty)">
          <source>The following example implements a handler that reports the base value of an animated <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph> property on a <ph id="ph2">&lt;xref:System.Windows.Controls.Button&gt;</ph>, as well as the base value of a transform.</source>
          <target state="translated">O exemplo a seguir implementa um manipulador que informa o valor base de uma animação <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph> propriedade em um <ph id="ph2">&lt;xref:System.Windows.Controls.Button&gt;</ph>, bem como o valor base de uma transformação.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.GetLayoutClip(System.Windows.Size)">
          <source>The available size provided by the element.</source>
          <target state="translated">O tamanho disponível fornecido pelo elemento.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.GetLayoutClip(System.Windows.Size)">
          <source>Returns an alternative clipping geometry that represents the region that would be clipped if <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.ClipToBounds" /&gt;</ph> were set to <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Retorna uma geometria de recorte alternativa que representa a região que seria recortada se <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.ClipToBounds" /&gt;</ph> estivesse definido como <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.GetLayoutClip(System.Windows.Size)">
          <source>The potential clipping geometry.</source>
          <target state="translated">A geometria de recorte em potencial.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.GetLayoutClip(System.Windows.Size)">
          <source>The default implementation will return a legitimate value, but does not use the <ph id="ph1">`layoutSlotSize`</ph> parameter in its calculations.</source>
          <target state="translated">A implementação padrão irá retornar um valor legítimo, mas não usa o <ph id="ph1">`layoutSlotSize`</ph> parâmetro em seus cálculos.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.GetLayoutClip(System.Windows.Size)">
          <source>Instead it uses the value of <ph id="ph1">&lt;xref:System.Windows.UIElement.RenderSize%2A&gt;</ph>.</source>
          <target state="translated">Em vez disso, ele usa o valor de <ph id="ph1">&lt;xref:System.Windows.UIElement.RenderSize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.GetLayoutClip(System.Windows.Size)">
          <source>This method is substantially overridden by the immediately derived <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> class, and the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> override produces a more sophisticated behavior for general WPF framework-level elements.</source>
          <target state="translated">Esse método substancialmente é substituído por imediatamente derivada <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> classe e o <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> substituição produz um comportamento mais sofisticado para elementos de nível da estrutura gerais do WPF.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.GetLayoutClip(System.Windows.Size)">
          <source>For details, see <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.GetLayoutClip%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para obter detalhes, consulte <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.GetLayoutClip%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.GetUIParentCore">
          <source>When overridden in a derived class, returns an alternative <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> parent for this element if no visual parent exists.</source>
          <target state="translated">Quando substituído em uma classe derivada, retornará um pai <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> alternativo para esse elemento se nenhum pai visual existir.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.GetUIParentCore">
          <source>An object, if implementation of a derived class has an alternate parent connection to report.</source>
          <target state="translated">Um objeto se a implementação de uma classe derivada tiver uma conexão alternativa pai com o relatório.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.GetUIParentCore">
          <source>The default virtual implementation of this method returns <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Retorna a implementação de virtual padrão desse método <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.GetUIParentCore">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> provides a practical implementation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> Fornece uma implementação prática.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.GetUIParentCore">
          <source>Alternative parents are used for event routing, in cases where an element creates an alternative parent structure so that its events are routed in a way that diverges from the standard pattern of routing up the visual tree to the standard parent, or downward in the preview routing strategy.</source>
          <target state="translated">Pais alternativos são usados para roteamento de eventos, em casos onde um elemento cria uma estrutura pai alternativo para que seus eventos roteados de forma que diverge o padrão de roteamento na árvore visual pai padrão ou para baixo na estratégia de roteamento de visualização.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.GiveFeedback">
          <source>Occurs when the input system reports an underlying drag-and-drop event that involves this element.</source>
          <target state="translated">Ocorre quando o sistema de entrada relata um evento de arrastar e soltar subjacente que envolve este elemento.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GiveFeedback">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.GiveFeedback&gt;</ph> event allows the source of a drag event to modify the appearance of the mouse pointer in order to give the user visual feedback during a drag-and-drop operation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.GiveFeedback&gt;</ph> evento permite que a origem de um evento arrastar para modificar a aparência do ponteiro do mouse para fornecer os comentários visuais do usuário durante uma operação de arrastar e soltar.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GiveFeedback">
          <source>The visual feedback reinforces that a drag-and-drop operation is in process.</source>
          <target state="translated">Os comentários visuais reforçam que uma operação de arrastar e soltar está em processo.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GiveFeedback">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType&gt;</ph> attached event for this class so that <ph id="ph2">&lt;xref:System.Windows.UIElement.GiveFeedback&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType&gt;</ph> evento para esta classe anexado para que <ph id="ph2">&lt;xref:System.Windows.UIElement.GiveFeedback&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GiveFeedback">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.GiveFeedback&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.GiveFeedback&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GiveFeedback">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GiveFeedback">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GiveFeedback">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GiveFeedback">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GiveFeedback">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GiveFeedback">
          <source>The corresponding tunneling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewGiveFeedback&gt;</ph>.</source>
          <target state="translated">O evento de túnel correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewGiveFeedback&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GiveFeedback">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnGiveFeedback%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnGiveFeedback%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.GiveFeedbackEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.GiveFeedback" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.GiveFeedback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.GiveFeedbackEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.GiveFeedbackEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.GiveFeedbackEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.GiveFeedbackEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.GiveFeedbackEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.GotFocus">
          <source>Occurs when this element gets logical focus.</source>
          <target state="translated">Ocorre quando este elemento tem foco lógico.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotFocus">
          <source>Logical focus differs from keyboard focus if focus is deliberately forced by using a method call but the previous keyboard focus exists in a different scope.</source>
          <target state="translated">Foco lógico é diferente do foco do teclado ao foco deliberadamente é forçado por meio de uma chamada de método, mas o foco do teclado anterior existe em um escopo diferente.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotFocus">
          <source>In this scenario, keyboard focus remains where it is and the element where a <ph id="ph1">&lt;xref:System.Windows.UIElement.Focus%2A&gt;</ph> method is called still gets logical focus.</source>
          <target state="translated">Nesse cenário, o foco do teclado permanece onde é e o elemento onde um <ph id="ph1">&lt;xref:System.Windows.UIElement.Focus%2A&gt;</ph> método é chamado ainda foco lógico obtém.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotFocus">
          <source>A more precise interpretation of this event is that it is raised when the value of the <ph id="ph1">&lt;xref:System.Windows.UIElement.IsFocused%2A&gt;</ph> property of an element in the route is changed from <ph id="ph2">`false`</ph> to <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Uma interpretação mais precisa desse evento é que ele é gerado quando o valor de <ph id="ph1">&lt;xref:System.Windows.UIElement.IsFocused%2A&gt;</ph> propriedade de um elemento na rota é alterada de <ph id="ph2">`false`</ph> para <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotFocus">
          <source>Because this event uses bubbling routing, the element that receives focus might be a child element instead of the element where the event handler is actually attached.</source>
          <target state="translated">Como esse evento usa roteamento bolha, o elemento que recebe o foco pode ser um elemento de filho em vez do elemento em que o manipulador de eventos, na verdade, está anexado.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotFocus">
          <source>Check the <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> in the event data to determine the actual element that gained focus.</source>
          <target state="translated">Verifique o <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> nos dados de evento para determinar o elemento real que obteve o foco.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotFocus">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotFocus">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotFocus">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotFocus">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotFocus">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotFocus">
          <source>There is no corresponding tunneling event.</source>
          <target state="translated">Não há nenhum evento de túnel correspondente.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotFocus">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnGotFocus%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnGotFocus%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.GotFocusEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.GotFocus" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.GotFocus" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.GotFocusEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.GotFocusEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.GotFocusEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.GotFocusEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.GotFocusEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.GotKeyboardFocus">
          <source>Occurs when the keyboard is focused on this element.</source>
          <target state="translated">Ocorre quando o teclado está focalizado neste elemento.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotKeyboardFocus">
          <source><ph id="ph1">&lt;xref:System.Windows.UIElement.IsKeyboardFocusedChanged&gt;</ph> is a similar event that tracks status changes in a property that maintains the focus state for an element; the <ph id="ph2">&lt;xref:System.Windows.UIElement.GotKeyboardFocus&gt;</ph> event is raised in many of the same circumstances.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.UIElement.IsKeyboardFocusedChanged&gt;</ph> é um evento semelhante que rastreia as alterações de status em uma propriedade que mantém o estado de foco para um elemento. o <ph id="ph2">&lt;xref:System.Windows.UIElement.GotKeyboardFocus&gt;</ph> é gerado em muitas das mesmas circunstâncias.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotKeyboardFocus">
          <source>Because this event uses bubbling routing, the element that has focus might be a child element instead of the element where the event handler is actually attached.</source>
          <target state="translated">Como esse evento usa roteamento bolha, o elemento que tem o foco pode ser um elemento de filho em vez do elemento em que o manipulador de eventos, na verdade, está anexado.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotKeyboardFocus">
          <source>Check the <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> in the event data to determine the actual element that has focus.</source>
          <target state="translated">Verifique o <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> nos dados de evento para determinar o elemento que tem o foco.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotKeyboardFocus">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType&gt;</ph> attached event for this class so that <ph id="ph2">&lt;xref:System.Windows.UIElement.GotKeyboardFocus&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType&gt;</ph> evento para esta classe anexado para que <ph id="ph2">&lt;xref:System.Windows.UIElement.GotKeyboardFocus&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotKeyboardFocus">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.GotKeyboardFocus&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.GotKeyboardFocus&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotKeyboardFocus">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotKeyboardFocus">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotKeyboardFocus">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotKeyboardFocus">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotKeyboardFocus">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotKeyboardFocus">
          <source>The corresponding tunneling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewGotKeyboardFocus&gt;</ph>.</source>
          <target state="translated">O evento de túnel correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewGotKeyboardFocus&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotKeyboardFocus">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnGotKeyboardFocus%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnGotKeyboardFocus%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.GotKeyboardFocusEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.GotKeyboardFocus" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.GotKeyboardFocus" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.GotKeyboardFocusEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.GotKeyboardFocusEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.GotKeyboardFocusEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.GotKeyboardFocusEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.GotKeyboardFocusEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.GotMouseCapture">
          <source>Occurs when this element captures the mouse.</source>
          <target state="translated">Ocorre quando este elemento captura o mouse.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotMouseCapture">
          <source>When an element captures the mouse, it receives mouse input even if the mouse pointer is outside its bounds.</source>
          <target state="translated">Quando um elemento captura o mouse, ele recebe entrada do mouse, mesmo se o ponteiro do mouse está fora dos seus limites.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotMouseCapture">
          <source>The mouse is typically captured only during drag-and-drop operations and remains captured until the drop action of the drag-and-drop operation occurs.</source>
          <target state="translated">O mouse normalmente é capturado somente durante as operações de arrastar e soltar e permanece capturado até que ocorra a ação drop da operação de arrastar e soltar.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotMouseCapture">
          <source>Because this event uses bubbling routing, the element that has capture might be a child element instead of the element where the event handler is actually attached.</source>
          <target state="translated">Como esse evento usa roteamento bolha, o elemento que tem captura pode ser um elemento de filho em vez do elemento em que o manipulador de eventos, na verdade, está anexado.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotMouseCapture">
          <source>Check the <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> in the event data to determine the actual element that has mouse capture.</source>
          <target state="translated">Verifique o <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> de eventos de captura de dados para determinar o elemento que tem o mouse.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotMouseCapture">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType&gt;</ph> attached event for  this class so that <ph id="ph2">&lt;xref:System.Windows.UIElement.GotMouseCapture&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType&gt;</ph> evento para esta classe anexado para que <ph id="ph2">&lt;xref:System.Windows.UIElement.GotMouseCapture&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotMouseCapture">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.GotMouseCapture&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.GotMouseCapture&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotMouseCapture">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotMouseCapture">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotMouseCapture">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotMouseCapture">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotMouseCapture">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotMouseCapture">
          <source>There is no defined corresponding tunneling event.</source>
          <target state="translated">Não há nenhum evento de túnel correspondente definido.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotMouseCapture">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnGotMouseCapture%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnGotMouseCapture%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.GotMouseCaptureEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.GotMouseCapture" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.GotMouseCapture" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.GotMouseCaptureEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.GotMouseCaptureEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.GotMouseCaptureEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.GotMouseCaptureEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.GotMouseCaptureEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.GotStylusCapture">
          <source>Occurs when this element captures the stylus.</source>
          <target state="translated">Ocorre quando este elemento captura a caneta.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotStylusCapture">
          <source>When an element captures the stylus, it receives stylus input even if the pointer is outside its bounds.</source>
          <target state="translated">Quando um elemento captura a caneta, ele recebe entrada de caneta mesmo que o ponteiro está fora dos seus limites.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotStylusCapture">
          <source>The stylus is typically captured only during drag-and-drop operations and retains capture until the drop action of the drag-and-drop operation occurs.</source>
          <target state="translated">A caneta normalmente é capturada somente durante as operações de arrastar e soltar e retém captura até que ocorra a ação drop da operação de arrastar e soltar.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotStylusCapture">
          <source>Because this event uses bubbling routing, the element that has capture might be a child element instead of the element where the event handler is actually attached.</source>
          <target state="translated">Como esse evento usa roteamento bolha, o elemento que tem captura pode ser um elemento de filho em vez do elemento em que o manipulador de eventos, na verdade, está anexado.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotStylusCapture">
          <source>Check the <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> in the event data to determine the actual element that has capture.</source>
          <target state="translated">Verifique o <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> nos dados de evento para determinar o elemento real que tem a captura.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotStylusCapture">
          <source>This event creates an alias for the attached event for this class so that <ph id="ph1">&lt;xref:System.Windows.UIElement.GotStylusCapture&gt;</ph> is part of the class members list when <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o evento anexado para esta classe para que <ph id="ph1">&lt;xref:System.Windows.UIElement.GotStylusCapture&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotStylusCapture">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.GotStylusCapture&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.GotStylusCapture&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotStylusCapture">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotStylusCapture">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotStylusCapture">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotStylusCapture">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotStylusCapture">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotStylusCapture">
          <source>There is no defined corresponding tunneling event.</source>
          <target state="translated">Não há nenhum evento de túnel correspondente definido.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotStylusCapture">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnGotStylusCapture%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnGotStylusCapture%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.GotStylusCaptureEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.GotStylusCapture" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.GotStylusCapture" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.GotStylusCaptureEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.GotStylusCaptureEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.GotStylusCaptureEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.GotStylusCaptureEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.GotStylusCaptureEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.GotTouchCapture">
          <source>Occurs when a touch is captured to this element.</source>
          <target state="translated">Ocorre quando um toque é capturado para esse elemento.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotTouchCapture">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotTouchCapture">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotTouchCapture">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotTouchCapture">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotTouchCapture">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotTouchCapture">
          <source><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> of type <ph id="ph2">&lt;xref:System.Windows.Input.TouchEventArgs&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> do tipo <ph id="ph2">&lt;xref:System.Windows.Input.TouchEventArgs&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.GotTouchCapture">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnGotTouchCapture%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnGotTouchCapture%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.GotTouchCaptureEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.GotTouchCapture" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.GotTouchCapture" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.HasAnimatedProperties">
          <source>Gets a value indicating whether this element has any animated properties.</source>
          <target state="translated">Obtém um valor que indica se este elemento tem todas as propriedades animadas.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.HasAnimatedProperties">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this element has animations attached to any of its properties; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se este elemento tem animações anexadas a uma de suas propriedades; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.HasAnimatedProperties">
          <source>This property returns <ph id="ph1">`true`</ph> either for persistent (unclocked, always-running) animations, or for animations that have a specific timeline.</source>
          <target state="translated">Essa propriedade retorna <ph id="ph1">`true`</ph> para persistentes animações (unclocked, sempre execução) ou de animações que têm uma linha de tempo específica.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.HasEffectiveKeyboardFocus">
          <source>Gets a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> has focus.</source>
          <target state="translated">Obtém um valor que indica se o <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> tem foco.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.HasEffectiveKeyboardFocus">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> has focus; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o <ph id="ph2">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> tiver o foco; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.HasEffectiveKeyboardFocus">
          <source>Subclasses can override this property to specify when the element has keyboard focus.</source>
          <target state="translated">As subclasses podem substituir essa propriedade para especificar quando o elemento tem o foco do teclado.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.HasEffectiveKeyboardFocus">
          <source>This is useful when your <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> contains elements that can have keyboard focus and you want your element to report that it has focus.</source>
          <target state="translated">Isso é útil quando sua <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> contém elementos que podem ter o foco do teclado e você deseja que o elemento ao relatório que tem foco.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="T:System.Windows.UIElement">
          <source>Implements <ph id="ph1">&lt;see cref="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.GeometryHitTestParameters)" /&gt;</ph> to supply base element hit testing behavior.</source>
          <target state="translated">Implementa <ph id="ph1">&lt;see cref="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.GeometryHitTestParameters)" /&gt;</ph> para fornecer o comportamento do teste de clique do elemento base.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.HitTestCore(System.Windows.Media.GeometryHitTestParameters)">
          <source>Describes the hit test to perform, including the initial hit point.</source>
          <target state="translated">Descreve o teste de clique a ser executado, incluindo o ponto de clique inicial.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.HitTestCore(System.Windows.Media.GeometryHitTestParameters)">
          <source>Implements <ph id="ph1">&lt;see cref="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.GeometryHitTestParameters)" /&gt;</ph> to supply base element hit testing behavior (returning <ph id="ph2">&lt;see cref="T:System.Windows.Media.GeometryHitTestResult" /&gt;</ph>).</source>
          <target state="translated">Implementa <ph id="ph1">&lt;see cref="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.GeometryHitTestParameters)" /&gt;</ph> para fornecer o comportamento do teste de clique do elemento base (retornando <ph id="ph2">&lt;see cref="T:System.Windows.Media.GeometryHitTestResult" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.HitTestCore(System.Windows.Media.GeometryHitTestParameters)">
          <source>Results of the test, including the evaluated geometry.</source>
          <target state="translated">Resultados do teste, incluindo a geometria avaliada.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.HitTestCore(System.Windows.Media.GeometryHitTestParameters)">
          <source>See the original virtual method <ph id="ph1">&lt;xref:System.Windows.Media.Visual.HitTestCore%2A?displayProperty=nameWithType&gt;</ph> for information on overriding this method in further derived classes.</source>
          <target state="translated">Consulte o método virtual original <ph id="ph1">&lt;xref:System.Windows.Media.Visual.HitTestCore%2A?displayProperty=nameWithType&gt;</ph> para obter informações sobre como substituir esse método em ainda mais as classes derivadas.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.HitTestCore(System.Windows.Media.GeometryHitTestParameters)">
          <source>Note that several specific controls (<ph id="ph1">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph>, for example) do have distinct implementations, which override this one.</source>
          <target state="translated">Observe que vários controles específicos (<ph id="ph1">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph>, por exemplo) têm implementações diferentes, que substituem este.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.HitTestCore(System.Windows.Media.GeometryHitTestParameters)">
          <source>This method is not intended to be called from your application code.</source>
          <target state="translated">Esse método não se destina a ser chamado no código do aplicativo.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.HitTestCore(System.Windows.Media.GeometryHitTestParameters)">
          <source>This method supports internal hit testing behaviors that are exposed by various aspects of the input system (whether the mouse pointer is over an element, for example).</source>
          <target state="translated">Este método dá suporte a ocorrências teste comportamentos internos que são expostos por vários aspectos do sistema de entrada (se o ponteiro do mouse está sobre um elemento, por exemplo).</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.HitTestCore(System.Windows.Media.PointHitTestParameters)">
          <source>Describes the hit test to perform, including the initial hit point.</source>
          <target state="translated">Descreve o teste de clique a ser executado, incluindo o ponto de clique inicial.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.HitTestCore(System.Windows.Media.PointHitTestParameters)">
          <source>Implements <ph id="ph1">&lt;see cref="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.PointHitTestParameters)" /&gt;</ph> to supply base element hit testing behavior (returning <ph id="ph2">&lt;see cref="T:System.Windows.Media.HitTestResult" /&gt;</ph>).</source>
          <target state="translated">Implementa <ph id="ph1">&lt;see cref="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.PointHitTestParameters)" /&gt;</ph> para fornecer o comportamento do teste de clique do elemento base (retornando <ph id="ph2">&lt;see cref="T:System.Windows.Media.HitTestResult" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.HitTestCore(System.Windows.Media.PointHitTestParameters)">
          <source>Results of the test, including the evaluated point.</source>
          <target state="translated">Resultados do teste, incluindo o ponto avaliado.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.HitTestCore(System.Windows.Media.PointHitTestParameters)">
          <source>See the original virtual method <ph id="ph1">&lt;xref:System.Windows.Media.Visual.HitTestCore%2A?displayProperty=nameWithType&gt;</ph> for information on overriding this method in further derived classes.</source>
          <target state="translated">Consulte o método virtual original <ph id="ph1">&lt;xref:System.Windows.Media.Visual.HitTestCore%2A?displayProperty=nameWithType&gt;</ph> para obter informações sobre como substituir esse método em ainda mais as classes derivadas.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.HitTestCore(System.Windows.Media.PointHitTestParameters)">
          <source>Note that several specific controls (<ph id="ph1">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph>, for example) do have distinct implementations, which override <ph id="ph2">&lt;xref:System.Windows.UIElement.HitTestCore%2A&gt;</ph> as defined by <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph>.</source>
          <target state="translated">Observe que vários controles específicos (<ph id="ph1">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph>, por exemplo) têm implementações diferentes, que substituem <ph id="ph2">&lt;xref:System.Windows.UIElement.HitTestCore%2A&gt;</ph> conforme definido pelo <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.HitTestCore(System.Windows.Media.PointHitTestParameters)">
          <source>This method is not intended to be called from your application code.</source>
          <target state="translated">Esse método não se destina a ser chamado no código do aplicativo.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.HitTestCore(System.Windows.Media.PointHitTestParameters)">
          <source>This method supports internal hit testing behaviors that are exposed by various aspects of the input system (whether the mouse pointer is over an element, for example).</source>
          <target state="translated">Este método dá suporte a ocorrências teste comportamentos internos que são expostos por vários aspectos do sistema de entrada (se o ponteiro do mouse está sobre um elemento, por exemplo).</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.InputBindings">
          <source>Gets the collection of input bindings associated with this element.</source>
          <target state="translated">Obtém a coleção de ligações de entrada associadas a este elemento.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.InputBindings">
          <source>The collection of input bindings.</source>
          <target state="translated">A coleção de ligações de entrada.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.InputBindings">
          <source>Input bindings support the binding of commands to input devices.</source>
          <target state="translated">Suportam a associações de entrada a associação dos comandos para dispositivos de entrada.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.InputBindings">
          <source>For example, <ph id="ph1">&lt;xref:System.Windows.Input.MouseBinding&gt;</ph> implements input bindings that include properties that are particular to mouse devices.</source>
          <target state="translated">Por exemplo, <ph id="ph1">&lt;xref:System.Windows.Input.MouseBinding&gt;</ph> implementa associações que incluem propriedades que são específicas dos dispositivos de mouse de entrada.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.InputBindings">
          <source>The collection of input bindings will include both input bindings that pertain to the type as well as input bindings that are declared on the instance.</source>
          <target state="translated">A coleção de associações de entrada incluirá associações de entrada que pertencem ao tipo, bem como as associações de entrada que são declaradas na instância.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.InputBindings">
          <source>A related property, <ph id="ph1">&lt;xref:System.Windows.UIElement.CommandBindings%2A&gt;</ph>, maintains a collection of command bindings.</source>
          <target state="translated">Uma propriedade relacionada, <ph id="ph1">&lt;xref:System.Windows.UIElement.CommandBindings%2A&gt;</ph>, mantém uma coleção de associações de comando.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.InputBindings">
          <source>These differ from input bindings in that they represent the next level down of command processing - actions that are tied to known commands.</source>
          <target state="translated">Estes diferem de associações de entrada que representam o próximo nível para baixo de processamento do comando - ações que estão vinculados aos comandos conhecidos.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.InputBindings">
          <source>XAML Property Element Usage</source>
          <target state="translated">Uso do elemento propriedade XAML</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.InputBindings">
          <source>XAML Values</source>
          <target state="translated">Valores XAML</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.InputBindings">
          <source><bpt id="p1">*</bpt>oneOrMoreInputBindings<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>oneOrMoreInputBindings<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.InputBindings">
          <source>One or more <ph id="ph1">&lt;xref:System.Windows.Input.InputBinding&gt;</ph> elements (typically the <ph id="ph2">&lt;xref:System.Windows.Input.KeyBinding&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.Input.MouseBinding&gt;</ph> derived classes).</source>
          <target state="translated">Um ou mais <ph id="ph1">&lt;xref:System.Windows.Input.InputBinding&gt;</ph> elementos (normalmente o <ph id="ph2">&lt;xref:System.Windows.Input.KeyBinding&gt;</ph> ou <ph id="ph3">&lt;xref:System.Windows.Input.MouseBinding&gt;</ph> classes derivadas).</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.InputBindings">
          <source>Each of these is expected to have a <ph id="ph1">&lt;xref:System.Windows.Input.InputBinding.Command%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Input.InputBinding.Gesture%2A&gt;</ph> attribute set.</source>
          <target state="translated">Cada um deles deve ter uma <ph id="ph1">&lt;xref:System.Windows.Input.InputBinding.Command%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.Input.InputBinding.Gesture%2A&gt;</ph> conjunto de atributos.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.InputBindings">
          <source>The following example populates this property on a <ph id="ph1">&lt;xref:System.Windows.Window&gt;</ph>, with a single <ph id="ph2">&lt;xref:System.Windows.Input.KeyBinding&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir preenche essa propriedade em uma <ph id="ph1">&lt;xref:System.Windows.Window&gt;</ph>, com um único <ph id="ph2">&lt;xref:System.Windows.Input.KeyBinding&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.InputBindings">
          <source>For more information about the <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax for collections, see <bpt id="p1">[</bpt>XAML Syntax In Detail<ept id="p1">](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre o <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> sintaxe para coleções, consulte <bpt id="p1">[</bpt>XAML sintaxe em detalhes<ept id="p1">](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)</ept>.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.InputHitTest(System.Windows.Point)">
          <source>The offset coordinates within this element.</source>
          <target state="translated">As coordenadas de deslocamento dentro desse elemento.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.InputHitTest(System.Windows.Point)">
          <source>Returns the input element within the current element that is at the specified coordinates, relative to the current element's origin.</source>
          <target state="translated">Retorna o elemento de entrada no elemento atual que está nas coordenadas especificadas em relação à origem do elemento atual.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.InputHitTest(System.Windows.Point)">
          <source>The element child that is located at the given position.</source>
          <target state="translated">O filho do elemento que está localizado na posição especificada.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.InputHitTest(System.Windows.Point)">
          <source><ph id="ph1">&lt;xref:System.Windows.IInputElement&gt;</ph> is returned as the return type, because that type is a common interface for both <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.ContentElement&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.IInputElement&gt;</ph> é retornado como o tipo de retorno, porque esse tipo é uma interface comum para ambos <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> e <ph id="ph3">&lt;xref:System.Windows.ContentElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.InputHitTest(System.Windows.Point)">
          <source>You can then cast the return type appropriately, or use the interface instance for certain members that are defined by the <ph id="ph1">&lt;xref:System.Windows.IInputElement&gt;</ph> interface.</source>
          <target state="translated">Você pode converter o tipo de retorno adequadamente, ou usar a instância da interface para determinados membros que são definidos pelo <ph id="ph1">&lt;xref:System.Windows.IInputElement&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.InputHitTest(System.Windows.Point)">
          <source>This method typically is not called from your application code.</source>
          <target state="translated">Esse método normalmente não é chamado de código do aplicativo.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.InputHitTest(System.Windows.Point)">
          <source>Calling this method is only appropriate if you intend to re-implement a substantial amount of the low level input features that are already present, such as recreating mouse device logic.</source>
          <target state="translated">Chamar esse método só é apropriado se você pretende implementar novamente uma quantidade significativa dos recursos de entrada de baixo níveis que já estão presentes, como recriar a lógica de dispositivo de mouse.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.InputHitTest(System.Windows.Point)">
          <source><ph id="ph1">&lt;xref:System.Windows.IContentHost&gt;</ph> contracts an <ph id="ph2">&lt;xref:System.Windows.IContentHost.InputHitTest%2A&gt;</ph> method with the same signature, which some elements choose to implement explicitly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.IContentHost&gt;</ph> contratos de um <ph id="ph2">&lt;xref:System.Windows.IContentHost.InputHitTest%2A&gt;</ph> método com a mesma assinatura, alguns elementos optar por implementar explicitamente.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.InvalidateArrange">
          <source>Invalidates the arrange state (layout) for the element.</source>
          <target state="translated">Invalida o estado da organização (layout) do elemento.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.InvalidateArrange">
          <source>After the invalidation, the element will have its layout updated, which will occur asynchronously unless subsequently forced by <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.UpdateLayout" /&gt;</ph>.</source>
          <target state="translated">Após a invalidação, o elemento terá seu layout atualizado, o que ocorrerá de forma assíncrona a menos que posteriormente seja forçado por <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.UpdateLayout" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.InvalidateArrange">
          <source>Frequent calls to <ph id="ph1">&lt;xref:System.Windows.UIElement.InvalidateArrange%2A&gt;</ph> or in particular to <ph id="ph2">&lt;xref:System.Windows.UIElement.UpdateLayout%2A&gt;</ph> have significant performance consequences.</source>
          <target state="translated">Chamadas frequentes ao <ph id="ph1">&lt;xref:System.Windows.UIElement.InvalidateArrange%2A&gt;</ph> ou em particular para <ph id="ph2">&lt;xref:System.Windows.UIElement.UpdateLayout%2A&gt;</ph> têm consequências de desempenho significativa.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.InvalidateArrange">
          <source>Therefore, avoid calling this method unless you absolutely require precise layout state for subsequent calls to other <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> in your code.</source>
          <target state="translated">Portanto, evite chamar esse método, a menos que você precisa absolutamente estado layout preciso para chamadas subsequentes para outros <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> em seu código.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.InvalidateArrange">
          <source>An advanced scenario where you might call <ph id="ph1">&lt;xref:System.Windows.UIElement.InvalidateArrange%2A&gt;</ph> is if you are creating a <ph id="ph2">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph> for a dependency property that is not on a <ph id="ph3">&lt;xref:System.Windows.Freezable&gt;</ph> or <ph id="ph4">&lt;xref:System.Windows.FrameworkElement&gt;</ph> derived class that still influences the arrange pass of layout when it changes.</source>
          <target state="translated">Um cenário avançado, onde você pode chamar <ph id="ph1">&lt;xref:System.Windows.UIElement.InvalidateArrange%2A&gt;</ph> é se você estiver criando um <ph id="ph2">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph> para uma propriedade de dependência que não está em um <ph id="ph3">&lt;xref:System.Windows.Freezable&gt;</ph> ou <ph id="ph4">&lt;xref:System.Windows.FrameworkElement&gt;</ph> que ainda influencia a etapa de organização de layout quando altera classe derivada.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.InvalidateMeasure">
          <source>Invalidates the measurement state (layout) for the element.</source>
          <target state="translated">Invalida o estado da medida (layout) do elemento.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.InvalidateMeasure">
          <source>Calling this method also calls <ph id="ph1">&lt;xref:System.Windows.UIElement.InvalidateArrange%2A&gt;</ph> internally, there is no need to call <ph id="ph2">&lt;xref:System.Windows.UIElement.InvalidateMeasure%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.UIElement.InvalidateArrange%2A&gt;</ph> in succession.</source>
          <target state="translated">Chamar esse método também chama <ph id="ph1">&lt;xref:System.Windows.UIElement.InvalidateArrange%2A&gt;</ph> internamente, não é necessário chamar <ph id="ph2">&lt;xref:System.Windows.UIElement.InvalidateMeasure%2A&gt;</ph> e <ph id="ph3">&lt;xref:System.Windows.UIElement.InvalidateArrange%2A&gt;</ph> em sucessão.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.InvalidateMeasure">
          <source>After the invalidation, the element will have its layout updated, which will occur asynchronously, unless <ph id="ph1">&lt;xref:System.Windows.UIElement.UpdateLayout%2A&gt;</ph> is called to force a synchronous layout change.</source>
          <target state="translated">Depois de invalidação, o elemento terá seu layout atualizado, o que ocorrerá de forma assíncrona, a menos que <ph id="ph1">&lt;xref:System.Windows.UIElement.UpdateLayout%2A&gt;</ph> é chamado para forçar uma alteração de layout síncrona.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.InvalidateMeasure">
          <source>The WPF framework-level layout system does its own handling of changes in the visual tree of an element, and in most common layout invalidation cases the layout system is calling the equivalent of this method when necessary.</source>
          <target state="translated">O sistema de layout de nível de framework WPF não seu próprio tratamento de alterações na árvore visual de um elemento, e em casos mais comuns de invalidação do layout do sistema de layout está chamando o equivalente a este método quando necessário.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.InvalidateMeasure">
          <source>You should only call this method if you are producing a complete layout implementation, which does direct manipulation of the element tree, or similar advanced scenarios.</source>
          <target state="translated">Você só deve chamar esse método se estão produzindo uma implementação de concluir o layout, que direcionam a manipulação da árvore de elemento, ou similar cenários avançados.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.InvalidateMeasure">
          <source>One such advanced scenario is if you are creating a <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph> for a dependency property that is not on a <ph id="ph2">&lt;xref:System.Windows.Freezable&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.FrameworkElement&gt;</ph> derived class that still influences the measure pass of layout when it changes.</source>
          <target state="translated">Um esse cenário avançado é se você estiver criando um <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph> para uma propriedade de dependência que não está em um <ph id="ph2">&lt;xref:System.Windows.Freezable&gt;</ph> ou <ph id="ph3">&lt;xref:System.Windows.FrameworkElement&gt;</ph> que ainda influencia a passagem da medida de layout quando altera classe derivada.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.InvalidateMeasure">
          <source>Frequent calls to <ph id="ph1">&lt;xref:System.Windows.UIElement.InvalidateMeasure%2A&gt;</ph> or in particular to <ph id="ph2">&lt;xref:System.Windows.UIElement.UpdateLayout%2A&gt;</ph> have significant performance consequences.</source>
          <target state="translated">Chamadas frequentes ao <ph id="ph1">&lt;xref:System.Windows.UIElement.InvalidateMeasure%2A&gt;</ph> ou em particular para <ph id="ph2">&lt;xref:System.Windows.UIElement.UpdateLayout%2A&gt;</ph> têm consequências de desempenho significativa.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.InvalidateMeasure">
          <source>Therefore, avoid calling this method unless you absolutely require precise layout state for subsequent calls to other <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> in your code.</source>
          <target state="translated">Portanto, evite chamar esse método, a menos que você precisa absolutamente estado layout preciso para chamadas subsequentes para outros <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> em seu código.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.InvalidateVisual">
          <source>Invalidates the rendering of the element, and forces a complete new layout pass.</source>
          <target state="translated">Invalida a renderização do elemento e força uma nova passagem de layout completa.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.InvalidateVisual">
          <source><ph id="ph1">&lt;see cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" /&gt;</ph> is called after the layout cycle is completed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" /&gt;</ph> é chamado após a conclusão do ciclo de layout.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.InvalidateVisual">
          <source>This method calls <ph id="ph1">&lt;xref:System.Windows.UIElement.InvalidateArrange%2A&gt;</ph> internally.</source>
          <target state="translated">Este método chama <ph id="ph1">&lt;xref:System.Windows.UIElement.InvalidateArrange%2A&gt;</ph> internamente.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.InvalidateVisual">
          <source>This method is not generally called from your application code.</source>
          <target state="translated">Este método não é geralmente chamado de código do aplicativo.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.InvalidateVisual">
          <source>The WPF framework-level layout system does its own handling of changes in the visual tree of an element, and would be calling the equivalent of this method when necessary already.</source>
          <target state="translated">O sistema de layout de nível de framework WPF não seu próprio tratamento de alterações na árvore visual de um elemento e seria o equivalente a este método quando necessário chamar já.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.InvalidateVisual">
          <source>Calling this method is necessary only for advanced scenarios.</source>
          <target state="translated">Chamar esse método é necessário somente para cenários avançados.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.InvalidateVisual">
          <source>One such advanced scenario is if you are creating a <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph> for a dependency property that is not on a <ph id="ph2">&lt;xref:System.Windows.Freezable&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.FrameworkElement&gt;</ph> derived class that still influences the layout when it changes.</source>
          <target state="translated">Um esse cenário avançado é se você estiver criando um <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph> para uma propriedade de dependência que não está em um <ph id="ph2">&lt;xref:System.Windows.Freezable&gt;</ph> ou <ph id="ph3">&lt;xref:System.Windows.FrameworkElement&gt;</ph> que ainda influencia o layout quando altera classe derivada.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsArrangeValid">
          <source>Gets a value indicating whether the computed size and position of child elements in this element's layout are valid.</source>
          <target state="translated">Obtém um valor que indica se o tamanho e a posição calculados dos elementos filho no layout do elemento são válidos.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsArrangeValid">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the size and position of layout are valid; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o tamanho e a posição de layout forem válidos; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsArrangeValid">
          <source>You can force arrangement to be invalidated by calling <ph id="ph1">&lt;xref:System.Windows.UIElement.InvalidateArrange%2A&gt;</ph> on this element (or its parents).</source>
          <target state="translated">Você pode forçar a organização a ser invalidado chamando <ph id="ph1">&lt;xref:System.Windows.UIElement.InvalidateArrange%2A&gt;</ph> no elemento (ou seus pais).</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsArrangeValid">
          <source>This flags the layout for recomposition at such time as the layout system determines.</source>
          <target state="translated">Isso sinaliza o layout de recomposition at como determina o sistema de layout.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsArrangeValid">
          <source>Alternatively, an immediate call to <ph id="ph1">&lt;xref:System.Windows.UIElement.UpdateLayout%2A&gt;</ph> could be made, but this should only be done if it is certain that no further invalidations are pending (a large number of unnecessarily forced updates has performance consequences).</source>
          <target state="translated">Como alternativa, uma chamada de imediata para <ph id="ph1">&lt;xref:System.Windows.UIElement.UpdateLayout%2A&gt;</ph> poderia ser feita, mas isso só deve ser feito se você tiver certeza de que nenhum invalidações adicionais estão pendentes (um grande número de atualizações desnecessariamente forçadas tem consequências de desempenho).</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsArrangeValid">
          <source><ph id="ph1">&lt;xref:System.Windows.UIElement.IsArrangeValid%2A&gt;</ph> cannot be <ph id="ph2">`true`</ph> unless <ph id="ph3">&lt;xref:System.Windows.UIElement.IsMeasureValid%2A&gt;</ph> is also <ph id="ph4">`true`</ph> (in the layout process, arrangement cannot be valid without measurement first being valid).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.UIElement.IsArrangeValid%2A&gt;</ph> não pode ser <ph id="ph2">`true`</ph> , a menos que <ph id="ph3">&lt;xref:System.Windows.UIElement.IsMeasureValid%2A&gt;</ph> também é <ph id="ph4">`true`</ph> (no processo de layout, organização não pode ser válida sem medida primeiro sendo válido).</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsEnabled">
          <source>Gets or sets a value indicating whether this element is enabled in the <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.</source>
          <target state="translated">Obtém ou define um valor que indica se esse elemento está habilitado no <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsEnabled">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsEnabled">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the element is enabled; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o elemento estiver habilitado; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsEnabled">
          <source>The default value is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">O valor padrão é <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsEnabled">
          <source>Note that this property is influenced by class-specific implementations of <ph id="ph1">&lt;xref:System.Windows.UIElement.IsEnabledCore%2A&gt;</ph> on particular elements, often at runtime.</source>
          <target state="translated">Observe que essa propriedade é influenciada por implementações específicas de classe de <ph id="ph1">&lt;xref:System.Windows.UIElement.IsEnabledCore%2A&gt;</ph> em determinados elementos, geralmente em tempo de execução.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsEnabled">
          <source>Therefore, the default value listed here is sometimes not effective.</source>
          <target state="translated">Portanto, o valor padrão listado aqui, às vezes, não é eficaz.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsEnabled">
          <source>For instance, a <ph id="ph1">&lt;xref:System.Windows.Controls.Primitives.ScrollBar&gt;</ph> will be <ph id="ph2">&lt;xref:System.Windows.UIElement.IsEnabled%2A&gt;</ph> <ph id="ph3">`false`</ph> whenever it is determined that there is no need to support a scrollbar.</source>
          <target state="translated">Por exemplo, um <ph id="ph1">&lt;xref:System.Windows.Controls.Primitives.ScrollBar&gt;</ph> será <ph id="ph2">&lt;xref:System.Windows.UIElement.IsEnabled%2A&gt;</ph> <ph id="ph3">`false`</ph> sempre que for determinado que não é necessário para dar suporte a uma barra de rolagem.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsEnabled">
          <source>Attempting to set this value will also potentially be overridden by the value returned by <ph id="ph1">&lt;xref:System.Windows.UIElement.IsEnabledCore%2A&gt;</ph>.</source>
          <target state="translated">Tentativa de definir esse valor será também potencialmente substituída pelo valor retornado por <ph id="ph1">&lt;xref:System.Windows.UIElement.IsEnabledCore%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsEnabled">
          <source>Elements that are not enabled do not participate in hit testing or focus and therefore will not be sources of input events.</source>
          <target state="translated">Elementos que não estão habilitados não participam de teste de clique ou foco e, portanto, não poderá ser fontes de eventos de entrada.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsEnabled">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsEnabled">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsEnabled">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsEnabled">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsEnabled">
          <source>The following example shows a handler on one button that when executed will set <ph id="ph1">&lt;xref:System.Windows.UIElement.IsEnabled%2A&gt;</ph> <ph id="ph2">`false`</ph> on another named button <ph id="ph3">`b1`</ph>.</source>
          <target state="translated">O exemplo a seguir mostra um manipulador em um botão que quando executado definirá <ph id="ph1">&lt;xref:System.Windows.UIElement.IsEnabled%2A&gt;</ph> <ph id="ph2">`false`</ph> em outro botão nomeado <ph id="ph3">`b1`</ph>.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.IsEnabledChanged">
          <source>Occurs when the value of the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsEnabled" /&gt;</ph> property on this element changes.</source>
          <target state="translated">Ocorre quando o valor da propriedade <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsEnabled" /&gt;</ph> neste elemento é alterado.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.IsEnabledChanged">
          <source>This member is a <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> event, not a routed event.</source>
          <target state="translated">Esse membro é um <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> evento, não é um evento roteado.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsEnabledCore">
          <source>Gets a value that becomes the return value of <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsEnabled" /&gt;</ph> in derived classes.</source>
          <target state="translated">Obtém um valor que se torna o valor retornado de <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsEnabled" /&gt;</ph> em classes derivadas.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsEnabledCore">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the element is enabled; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o elemento estiver habilitado; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsEnabledCore">
          <source>The default implementation of this property caches the value and also calculates whether the parent element of this element is enabled.</source>
          <target state="translated">A implementação padrão dessa propriedade armazena o valor em cache e também calcula se o elemento pai do elemento está habilitado.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsEnabledCore">
          <source>(If the parent is not enabled, the child element cannot be effectively enabled in practical <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.) If you choose to override this implementation, make certain that you call the base implementation to preserve this behavior.</source>
          <target state="translated">(Se o pai não estiver habilitado, o elemento filho não pode ser habilitado efetivamente em práticos <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.) Se você optar por substituir essa implementação, certifique-se de que você chamar a implementação base para preservar esse comportamento.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsEnabledCore">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Controls.Primitives.ScrollBar" /&gt;</ph> class provides an existing override implementation of this property.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Controls.Primitives.ScrollBar" /&gt;</ph> classe fornece uma implementação de substituição existente dessa propriedade.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsEnabledCore">
          <source>This override determines whether the content inside the content presentation area exceeds the available area.</source>
          <target state="translated">Essa substituição é determina se o conteúdo dentro da área de apresentação do conteúdo excede a área disponível.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsEnabledCore">
          <source>If the content does exceed the area, the scrollbar portion is enabled.</source>
          <target state="translated">Se o conteúdo excede a área, a parte da barra de rolagem está habilitada.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsEnabledCore">
          <source>Otherwise, the scrollbar is not enabled.</source>
          <target state="translated">Caso contrário, a barra de rolagem não está habilitada.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.IsEnabledProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsEnabled" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsEnabled" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsFocused">
          <source>Gets a value that determines whether this element has logical focus.</source>
          <target state="translated">Obtém um valor que determina se esse elemento tem foco lógico.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsFocused">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsFocused">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this element has logical focus; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se esse elemento tiver o foco lógico; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsFocused">
          <source>Logical focus might differ from keyboard focus if an application has multiple focus divisions, such as between menu contents and the remainder of the application.</source>
          <target state="translated">Foco lógico pode diferir em foco do teclado se um aplicativo tem várias divisões de foco, como entre o conteúdo do menu e o restante do aplicativo.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsFocused">
          <source>In this scenario, keyboard focus can only be on one element of the application  UI, however, certain elements in other focus divisions might still retain logical focus.</source>
          <target state="translated">Nesse cenário, o foco do teclado pode estar somente em um elemento de interface do usuário do aplicativo, no entanto, certos elementos em outras divisões foco ainda podem manter foco lógico.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsFocused">
          <source>For more information on logical focus, see <bpt id="p1">[</bpt>Focus Overview<ept id="p1">](~/docs/framework/wpf/advanced/focus-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre o foco lógico, consulte <bpt id="p1">[</bpt>visão geral de foco<ept id="p1">](~/docs/framework/wpf/advanced/focus-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsFocused">
          <source>You do not set focus by setting this property (it is read-only).</source>
          <target state="translated">Você não definir foco definindo essa propriedade (é somente leitura).</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsFocused">
          <source>The typical use for this property is to use it as a dependency property for a <ph id="ph1">&lt;xref:System.Windows.Setter&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.EventTrigger&gt;</ph>.</source>
          <target state="translated">O uso típico dessa propriedade é usá-la como uma propriedade de dependência para um <ph id="ph1">&lt;xref:System.Windows.Setter&gt;</ph> ou <ph id="ph2">&lt;xref:System.Windows.EventTrigger&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsFocused">
          <source>To set focus programmatically, call <ph id="ph1">&lt;xref:System.Windows.UIElement.Focus%2A&gt;</ph>.</source>
          <target state="translated">Para definir o foco programaticamente, chame <ph id="ph1">&lt;xref:System.Windows.UIElement.Focus%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsFocused">
          <source>Focus can also be set by user action or by control implementations, which possibly include mouse capture behavior.</source>
          <target state="translated">Foco também pode ser definido por uma ação do usuário ou por implementações de controle, que incluem possivelmente o comportamento de captura do mouse.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsFocused">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsFocused">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsFocused">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsFocused">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsFocused">
          <source>The following example is a code handler that changes the background of a control when it is focused.</source>
          <target state="translated">O exemplo a seguir é um manipulador de código que altera o plano de fundo de um controle quando ele está focalizado.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsFocused">
          <source>Another common way to achieve this same effect is to place a <ph id="ph1">&lt;xref:System.Windows.Trigger&gt;</ph> in the <ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph> of a control; this approach does not require handling specific events with code-behind and allows designers greater access to the interactive and graphical nature of the <ph id="ph3">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>.</source>
          <target state="translated">Outra forma comum de atingir o mesmo efeito é colocar um <ph id="ph1">&lt;xref:System.Windows.Trigger&gt;</ph> no <ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph> de um controle; essa abordagem não exige a manipulação de eventos específicos com code-behind e permite que os designers maior acesso à natureza interativa e gráfica do o <ph id="ph3">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsFocused">
          <source>For an example, see <bpt id="p1">[</bpt>How to: Create an Outer Glow Effect<ept id="p1">](http://msdn.microsoft.com/library/a2ccf19a-d0dc-4e3c-88e3-95d7f7d765b1)</ept>.</source>
          <target state="translated">Para obter um exemplo, consulte <bpt id="p1">[</bpt>como: criar um efeito de brilho externo<ept id="p1">](http://msdn.microsoft.com/library/a2ccf19a-d0dc-4e3c-88e3-95d7f7d765b1)</ept>.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.IsFocusedProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsFocused" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsFocused" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsHitTestVisible">
          <source>Gets or sets a value that declares whether this element can possibly be returned as a hit test result from some portion of its rendered content.</source>
          <target state="translated">Obtém ou define um valor que declara se este elemento tem possibilidade de ser retornado como um resultado de teste de clique de alguma parte de seu conteúdo renderizado.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsHitTestVisible">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsHitTestVisible">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this element could be returned as a hit test result from at least one point; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se esse elemento puder ser retornado como um resultado do teste de clique de, pelo menos, um ponto; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsHitTestVisible">
          <source>The default value is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">O valor padrão é <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsHitTestVisible">
          <source>The effective value of this property is influenced by the relative positions of hit testable elements in the logical tree.</source>
          <target state="translated">O valor efetivo dessa propriedade é influenciado pelas posições relativas de elementos podem ser testados ocorrências na árvore lógica.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsHitTestVisible">
          <source>For instance, if an element is a child element of an element that is not hit test visible, the effective value of the property on the child will remain <ph id="ph1">`false`</ph>, even if attempting to set that value locally.</source>
          <target state="translated">Por exemplo, se um elemento é um elemento filho de um elemento que é não visível do teste de clique, o valor efetivo da propriedade no filho permanecerá <ph id="ph1">`false`</ph>, mesmo se a tentativa de definir esse valor localmente.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsHitTestVisible">
          <source>For this reason, it is important that you do not set <ph id="ph1">&lt;xref:System.Windows.UIElement.IsHitTestVisible%2A&gt;</ph> to <ph id="ph2">`false`</ph> on a composited control unless you do not want any input or hit testing on that control.</source>
          <target state="translated">Por esse motivo, é importante que você não defina <ph id="ph1">&lt;xref:System.Windows.UIElement.IsHitTestVisible%2A&gt;</ph> para <ph id="ph2">`false`</ph> em um controle composto, a menos que você não deseja qualquer entrada ou testes de colisão em que o controle.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsHitTestVisible">
          <source>For more information on hit testing, see <bpt id="p1">[</bpt>Hit Testing in the Visual Layer<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/hit-testing-in-the-visual-layer.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre teste de clique, consulte <bpt id="p1">[</bpt>Teste de clique na camada visual<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/hit-testing-in-the-visual-layer.md)</ept>.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsHitTestVisible">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsHitTestVisible">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsHitTestVisible">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsHitTestVisible">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.IsHitTestVisibleChanged">
          <source>Occurs when the value of the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsHitTestVisible" /&gt;</ph> dependency property changes on this element.</source>
          <target state="translated">Ocorre quando o valor da propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsHitTestVisible" /&gt;</ph> é alterado neste elemento.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.IsHitTestVisibleChanged">
          <source>This member is a <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> event, not a routed event.</source>
          <target state="translated">Esse membro é um <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> evento, não é um evento roteado.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.IsHitTestVisibleProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsHitTestVisible" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsHitTestVisible" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsInputMethodEnabled">
          <source>Gets a value indicating whether an input method system, such as an <ph id="ph1">[!INCLUDE[TLA#tla_ime](~/includes/tlasharptla-ime-md.md)]</ph>,  is enabled for processing the input to this element.</source>
          <target state="translated">Obtém um valor que indica se um sistema de método de entrada, como um <ph id="ph1">[!INCLUDE[TLA#tla_ime](~/includes/tlasharptla-ime-md.md)]</ph>, está habilitado para processamento de entrada para esse elemento.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsInputMethodEnabled">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if an input method is active; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se um método de entrada estiver ativo; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsInputMethodEnabled">
          <source>The default value of the underlying attached property is <ph id="ph1">&lt;see langword="true;" /&gt;</ph> however, this will be influenced by the actual state of input methods at runtime.</source>
          <target state="translated">O valor padrão da propriedade anexada subjacente é <ph id="ph1">&lt;see langword="true;" /&gt;</ph>, no entanto, isso será influenciado pelo estado real dos métodos de entrada no tempo de execução.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsInputMethodEnabled">
          <source>This property returns the value that is returned by the attached property <ph id="ph1">&lt;xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType&gt;</ph> for the currently enabled input methods (keyboard, speech, and other input devices).</source>
          <target state="translated">Essa propriedade retorna o valor retornado pela propriedade anexada <ph id="ph1">&lt;xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType&gt;</ph> para os métodos de entrada atualmente habilitados (teclado, fala e outros dispositivos de entrada).</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsKeyboardFocused">
          <source>Gets a value indicating whether this element has keyboard focus.</source>
          <target state="translated">Obtém um valor que indica se este elemento tem foco do controle.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsKeyboardFocused">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsKeyboardFocused">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this element has keyboard focus; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se esse elemento tiver o foco do teclado; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsKeyboardFocused">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsKeyboardFocused">
          <source>Changes to the determined value of this property may be accompanied by focus-related events.</source>
          <target state="translated">Alterações para o determinado valor dessa propriedade podem ser acompanhadas por eventos relacionados a foco.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsKeyboardFocused">
          <source><ph id="ph1">&lt;xref:System.Windows.UIElement.IsKeyboardFocused%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A&gt;</ph> are commonly used within class event handlers for other input-related events, for instance to determine whether the element already has keyboard focus, or to make determinations when mouse events and keyboard events occur in conjunction.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.UIElement.IsKeyboardFocused%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A&gt;</ph> são geralmente usados em manipuladores de eventos de classe para outros eventos relacionados à entrada, para a instância para determinar se o elemento já tem o foco do teclado, ou fazer decisões quando o mouse eventos e eventos de teclado ocorrem em conjunto.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsKeyboardFocused">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsKeyboardFocused">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsKeyboardFocused">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsKeyboardFocused">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.IsKeyboardFocusedChanged">
          <source>Occurs when the value of the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsKeyboardFocused" /&gt;</ph> property changes on this element.</source>
          <target state="translated">Ocorre quando o valor da propriedade <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsKeyboardFocused" /&gt;</ph> é alterado neste elemento.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.IsKeyboardFocusedChanged">
          <source>This member is a <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> event, not a routed event.</source>
          <target state="translated">Esse membro é um <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> evento, não é um evento roteado.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.IsKeyboardFocusedProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsKeyboardFocused" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsKeyboardFocused" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsKeyboardFocusWithin">
          <source>Gets a value indicating whether keyboard focus is anywhere within the element or its visual tree child elements.</source>
          <target state="translated">Obtém um valor que indica se o foco do teclado é em qualquer lugar dentro do elemento ou de seus elementos filho de árvore visual.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsKeyboardFocusWithin">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsKeyboardFocusWithin">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if keyboard focus is on the element or its child elements; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o foco do teclado está no elemento ou em seus elementos filho; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsKeyboardFocusWithin">
          <source>Changes to the value of this property typically raise the <ph id="ph1">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged&gt;</ph> event, unless a derived class has overridden <ph id="ph2">&lt;xref:System.Windows.UIElement.OnIsKeyboardFocusWithinChanged%2A&gt;</ph> to suppress the event.</source>
          <target state="translated">Alterações para o valor dessa propriedade normalmente geram o <ph id="ph1">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged&gt;</ph> evento, a menos que uma classe derivada substituiu <ph id="ph2">&lt;xref:System.Windows.UIElement.OnIsKeyboardFocusWithinChanged%2A&gt;</ph> para suprimir o evento.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsKeyboardFocusWithin">
          <source>You do not set this property directly, but you can set the focus to an element by calling <ph id="ph1">&lt;xref:System.Windows.UIElement.Focus%2A&gt;</ph>, or by making a <ph id="ph2">&lt;xref:System.Windows.UIElement.MoveFocus%2A&gt;</ph> request.</source>
          <target state="translated">Você não definir essa propriedade diretamente, mas você pode definir o foco para um elemento chamando <ph id="ph1">&lt;xref:System.Windows.UIElement.Focus%2A&gt;</ph>, ou fazendo uma <ph id="ph2">&lt;xref:System.Windows.UIElement.MoveFocus%2A&gt;</ph> solicitação.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsKeyboardFocusWithin">
          <source>Either of these method calls might change this property value.</source>
          <target state="translated">Qualquer uma dessas chamadas de método pode alterar esse valor de propriedade.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsKeyboardFocusWithin">
          <source><ph id="ph1">&lt;xref:System.Windows.UIElement.IsKeyboardFocused%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A&gt;</ph> are typically used within class event handlers for other input-related events, for instance to determine whether the element already has keyboard focus, or to make determinations when mouse events and keyboard events occur in conjunction.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.UIElement.IsKeyboardFocused%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A&gt;</ph> são geralmente usadas em manipuladores de eventos de classe para outros eventos relacionados à entrada, para a instância para determinar se o elemento já tem o foco do teclado, ou fazer decisões quando o mouse eventos e eventos de teclado ocorrem em conjunto.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsKeyboardFocusWithin">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsKeyboardFocusWithin">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsKeyboardFocusWithin">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsKeyboardFocusWithin">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.IsKeyboardFocusWithinChanged">
          <source>Occurs when the value of the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.IsKeyboardFocusWithinChanged" /&gt;</ph> property changes on this element.</source>
          <target state="translated">Ocorre quando o valor da propriedade <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.IsKeyboardFocusWithinChanged" /&gt;</ph> é alterado neste elemento.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.IsKeyboardFocusWithinChanged">
          <source>This member is a <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> event, not a routed event.</source>
          <target state="translated">Esse membro é um <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> evento, não é um evento roteado.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.IsKeyboardFocusWithinProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsKeyboardFocusWithin" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsKeyboardFocusWithin" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsManipulationEnabled">
          <source>Gets or sets a value that indicates whether manipulation events are enabled on this <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph>.</source>
          <target state="translated">Obtém ou define um valor que indica se os eventos de manipulação estão habilitados neste <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsManipulationEnabled">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if manipulation events are enabled on this <ph id="ph2">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se os eventos de manipulação estiverem habilitados neste <ph id="ph2">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph>; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsManipulationEnabled">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsManipulationEnabled">
          <source>Set this property to true if you want the <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> to receive the <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationStarting&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.UIElement.ManipulationStarted&gt;</ph>, <ph id="ph4">&lt;xref:System.Windows.UIElement.ManipulationDelta&gt;</ph>, <ph id="ph5">&lt;xref:System.Windows.UIElement.ManipulationInertiaStarting&gt;</ph>, <ph id="ph6">&lt;xref:System.Windows.UIElement.ManipulationBoundaryFeedback&gt;</ph>, and <ph id="ph7">&lt;xref:System.Windows.UIElement.ManipulationCompleted&gt;</ph> events.</source>
          <target state="translated">Defina essa propriedade como true se você quiser que o <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> para receber o <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationStarting&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.UIElement.ManipulationStarted&gt;</ph>, <ph id="ph4">&lt;xref:System.Windows.UIElement.ManipulationDelta&gt;</ph>, <ph id="ph5">&lt;xref:System.Windows.UIElement.ManipulationInertiaStarting&gt;</ph>, <ph id="ph6">&lt;xref:System.Windows.UIElement.ManipulationBoundaryFeedback&gt;</ph>, e <ph id="ph7">&lt;xref:System.Windows.UIElement.ManipulationCompleted&gt;</ph> eventos.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsManipulationEnabled">
          <source>For more information about manipulations, see the <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre manipulações, consulte o <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsManipulationEnabled">
          <source>For an example of an application that responds to manipulations, see <bpt id="p1">[</bpt>Walkthrough: Creating Your First Touch Application<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)</ept>.</source>
          <target state="translated">Para obter um exemplo de um aplicativo que responde às manipulações, consulte <bpt id="p1">[</bpt>passo a passo: Criando seu primeiro toque aplicativo<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)</ept>.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsManipulationEnabled">
          <source>The following example creates an application that has a red Rectangle.</source>
          <target state="translated">O exemplo a seguir cria um aplicativo que tenha um retângulo vermelho.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsManipulationEnabled">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.IsManipulationEnabled%2A&gt;</ph> property of the Rectangle is set to true and the application's window subscribes to the <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationStarting&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.UIElement.ManipulationDelta&gt;</ph>, and <ph id="ph4">&lt;xref:System.Windows.UIElement.ManipulationInertiaStarting&gt;</ph> events.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.IsManipulationEnabled%2A&gt;</ph> propriedades do retângulo é definida como true e o aplicativo janela assina o <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationStarting&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.UIElement.ManipulationDelta&gt;</ph>, e <ph id="ph4">&lt;xref:System.Windows.UIElement.ManipulationInertiaStarting&gt;</ph> eventos.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsManipulationEnabled">
          <source>This example is part of a larger example in <bpt id="p1">[</bpt>Walkthrough: Creating Your First Touch Application<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)</ept>.</source>
          <target state="translated">Este exemplo é parte de um exemplo maior no <bpt id="p1">[</bpt>passo a passo: Criando seu primeiro toque aplicativo<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)</ept>.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.IsManipulationEnabledProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsManipulationEnabled" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsManipulationEnabled" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsMeasureValid">
          <source>Gets a value indicating whether the current size returned by layout measure is valid.</source>
          <target state="translated">Obtém um valor que indica se o tamanho atual retornado pela medida de layout é válido.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMeasureValid">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the measure pass of layout returned a valid and current value; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o cálculo da medida de layout retornou um valor válido e atual; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMeasureValid">
          <source>You can force measurement and arrangement to be invalidated by calling <ph id="ph1">&lt;xref:System.Windows.UIElement.InvalidateMeasure%2A&gt;</ph> on this element (or any parent element up the visual tree).</source>
          <target state="translated">Você pode forçar a medida e a organização sejam invalidados chamando <ph id="ph1">&lt;xref:System.Windows.UIElement.InvalidateMeasure%2A&gt;</ph> no elemento (ou qualquer elemento pai na árvore visual).</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMeasureValid">
          <source>This designates the layout for recomposition asynchronously, occurring at a time determined by the layout system.</source>
          <target state="translated">Isso designa o layout para recomposition de forma assíncrona, que ocorrem em um momento determinado pelo sistema de layout.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMeasureValid">
          <source>Alternatively, you could make an immediate call to <ph id="ph1">&lt;xref:System.Windows.UIElement.UpdateLayout%2A&gt;</ph>.</source>
          <target state="translated">Como alternativa, você pode fazer uma chamada de imediata para <ph id="ph1">&lt;xref:System.Windows.UIElement.UpdateLayout%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMeasureValid">
          <source>However, you should only call <ph id="ph1">&lt;xref:System.Windows.UIElement.UpdateLayout%2A&gt;</ph> if it is likely that no further invalidations are pending (a large number of unnecessarily forced updates will have performance consequences).</source>
          <target state="translated">No entanto, você só deve chamar <ph id="ph1">&lt;xref:System.Windows.UIElement.UpdateLayout%2A&gt;</ph> se é provável que nenhum invalidações adicionais pendentes (um grande número de atualizações desnecessariamente forçadas terá consequências de desempenho).</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMeasureValid">
          <source>If <ph id="ph1">&lt;xref:System.Windows.UIElement.IsMeasureValid%2A&gt;</ph> is <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Windows.UIElement.IsArrangeValid%2A&gt;</ph> must also be <ph id="ph4">`false`</ph> (by the enforced logic of the layout process, arrangement cannot be valid without measurement first being valid).</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Windows.UIElement.IsMeasureValid%2A&gt;</ph> é <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Windows.UIElement.IsArrangeValid%2A&gt;</ph> também deve ser <ph id="ph4">`false`</ph> (pela lógica de imposto do processo de layout, organização não pode ser válida sem medida primeiro sendo válido).</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsMouseCaptured">
          <source>Gets a value indicating whether the mouse is captured to this element.</source>
          <target state="translated">Obtém um valor que indica se o mouse é capturado para esse elemento.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsMouseCaptured">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseCaptured">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the element has mouse capture; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o elemento tiver a captura do mouse; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseCaptured">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseCaptured">
          <source>Mouse capture state is related to in-process drag-and-drop operations.</source>
          <target state="translated">Estado de captura do mouse está relacionado a operações de arrastar e soltar no processo.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseCaptured">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseCaptured">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseCaptured">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseCaptured">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseCaptured">
          <source>The following example turns the mouse capture state on or off based on whether the mouse is already captured for the element.</source>
          <target state="translated">O exemplo a seguir o estado de captura do mouse ativa ou desativa com base em se o mouse já é capturado para o elemento.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseCaptured">
          <source>If mouse capture is elsewhere, the mouse capture is set to that element.</source>
          <target state="translated">Se a captura do mouse em outro lugar, é que a captura do mouse está definida para esse elemento.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseCaptured">
          <source>If the element had mouse capture, it is cleared by calling <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType&gt;</ph> with a null input.</source>
          <target state="translated">Se o elemento tiver captura do mouse, será apagada chamando <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType&gt;</ph> com uma entrada nula.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.IsMouseCapturedChanged">
          <source>Occurs when the value of the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsMouseCaptured" /&gt;</ph> property changes on this element.</source>
          <target state="translated">Ocorre quando o valor da propriedade <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsMouseCaptured" /&gt;</ph> é alterado neste elemento.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.IsMouseCapturedChanged">
          <source>This member is a <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> event, not a routed event.</source>
          <target state="translated">Esse membro é um <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> evento, não é um evento roteado.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.IsMouseCapturedProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsMouseCaptured" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsMouseCaptured" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsMouseCaptureWithin">
          <source>Gets a value that determines whether mouse capture is held by this element or by child elements in its visual tree.</source>
          <target state="translated">Obtém um valor que determina se a captura do mouse é mantida por esse elemento ou elementos filho em sua árvore visual.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsMouseCaptureWithin">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseCaptureWithin">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this element or a contained element has mouse capture; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se esse elemento ou um elemento contido tiver captura do mouse; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseCaptureWithin">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseCaptureWithin">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseCaptureWithin">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseCaptureWithin">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.IsMouseCaptureWithinChanged">
          <source>Occurs when the value of the <ph id="ph1">&lt;see cref="F:System.Windows.UIElement.IsMouseCaptureWithinProperty" /&gt;</ph> changes on this element.</source>
          <target state="translated">Ocorre quando o valor do <ph id="ph1">&lt;see cref="F:System.Windows.UIElement.IsMouseCaptureWithinProperty" /&gt;</ph> é alterado nesse elemento.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.IsMouseCaptureWithinChanged">
          <source>This member is a <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> event, not a routed event.</source>
          <target state="translated">Esse membro é um <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> evento, não é um evento roteado.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.IsMouseCaptureWithinProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsMouseCaptureWithin" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsMouseCaptureWithin" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsMouseDirectlyOver">
          <source>Gets a value that indicates whether the position of the mouse pointer corresponds to hit test results, which take element compositing into account.</source>
          <target state="translated">Obtém um valor que indica se a posição do ponteiro do mouse corresponde aos resultados de teste de clique, que levam em consideração a composição de elementos.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsMouseDirectlyOver">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseDirectlyOver">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the mouse pointer is over the same element result as a hit test; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o ponteiro do mouse estiver sobre o mesmo resultado do elemento que um teste de clique; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseDirectlyOver">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseDirectlyOver">
          <source>Unlike <ph id="ph1">&lt;xref:System.Windows.UIElement.IsMouseOver%2A&gt;</ph>, this property is only <ph id="ph2">`true`</ph> if the mouse pointer is over the literal element—as it is for a hit test.</source>
          <target state="translated">Ao contrário de <ph id="ph1">&lt;xref:System.Windows.UIElement.IsMouseOver%2A&gt;</ph>, essa propriedade é somente <ph id="ph2">`true`</ph> se o ponteiro do mouse está sobre o elemento literal — assim como para um teste de clique.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseDirectlyOver">
          <source>If the mouse pointer is instead over a child element, in particular over elements that are part of an element's deeper template and compositing, this property will be <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Se o ponteiro do mouse está sobre um elemento filho, em particular sobre os elementos que fazem parte de um elemento modelo mais profundo e composição, essa propriedade será <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseDirectlyOver">
          <source>Unless you know how a control is composited (for example, you use this property in a custom control template for a control that you define), this property might return unexpected results.</source>
          <target state="translated">A menos que você sabe como um controle composto (por exemplo, você usa essa propriedade em um modelo de controle personalizado para um controle que você definir), essa propriedade pode retornar resultados inesperados.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseDirectlyOver">
          <source>For most scenarios where you are not authoring controls, use <ph id="ph1">&lt;xref:System.Windows.UIElement.IsMouseOver%2A&gt;</ph> instead.</source>
          <target state="translated">Na maioria dos cenários em que você está criando não controles, use <ph id="ph1">&lt;xref:System.Windows.UIElement.IsMouseOver%2A&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseDirectlyOver">
          <source>If the mouse is captured by this element, and this property is <ph id="ph1">`true`</ph> at time of capture, this property will continue to return <ph id="ph2">`true`</ph> until mouse capture is lost and the pointer is not over its bounds.</source>
          <target state="translated">Se o mouse é capturado por esse elemento, e essa propriedade é <ph id="ph1">`true`</ph> no momento da captura, esta propriedade continuarão a retornar <ph id="ph2">`true`</ph> até que a captura do mouse é perdida e o ponteiro não é sobre seus limites.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseDirectlyOver">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseDirectlyOver">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseDirectlyOver">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseDirectlyOver">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.IsMouseDirectlyOverChanged">
          <source>Occurs when the value of the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsMouseDirectlyOver" /&gt;</ph> property changes on this element.</source>
          <target state="translated">Ocorre quando o valor da propriedade <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsMouseDirectlyOver" /&gt;</ph> é alterado neste elemento.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.IsMouseDirectlyOverChanged">
          <source>This member is a <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> event, not a routed event.</source>
          <target state="translated">Esse membro é um <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> evento, não é um evento roteado.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.IsMouseDirectlyOverProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsMouseDirectlyOver" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsMouseDirectlyOver" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsMouseOver">
          <source>Gets a value indicating whether the mouse pointer is located over this element (including child elements in the visual tree).</source>
          <target state="translated">Obtém um valor que indica se o ponteiro do mouse está localizado sobre esse elemento (incluindo os elementos filho na árvore visual).</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsMouseOver">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseOver">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if mouse pointer is over the element or its child elements; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o ponteiro do mouse estiver sobre o elemento ou seus elementos filho; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseOver">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseOver">
          <source>Typically, controls are composited such that the various elements inside the control (the visual tree) will all report the mouse state for the containing control.</source>
          <target state="translated">Normalmente, os controles são compostos, de modo que os vários elementos dentro do controle (a árvore visual) irá relatar o estado de mouse para o controle que contém.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseOver">
          <source>For example, a <ph id="ph1">&lt;xref:System.Windows.Controls.ListBox&gt;</ph> style control will report <ph id="ph2">&lt;xref:System.Windows.UIElement.IsMouseOver%2A&gt;</ph> as <ph id="ph3">`true`</ph> if the mouse is anywhere over its geometry, including any <ph id="ph4">&lt;xref:System.Windows.Controls.ListBoxItem&gt;</ph>.</source>
          <target state="translated">Por exemplo, um <ph id="ph1">&lt;xref:System.Windows.Controls.ListBox&gt;</ph> controle estilo relatará <ph id="ph2">&lt;xref:System.Windows.UIElement.IsMouseOver%2A&gt;</ph> como <ph id="ph3">`true`</ph> se o mouse em qualquer lugar em sua geometria, incluindo quaisquer <ph id="ph4">&lt;xref:System.Windows.Controls.ListBoxItem&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseOver">
          <source>Although an analogous "IsMouseOverChanged" event does not exist, several similar events do.</source>
          <target state="translated">Embora não exista um evento "IsMouseOverChanged" análogo, faça vários eventos semelhantes.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseOver">
          <source>For example, you can handle <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseEnter&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseMove&gt;</ph>, and <ph id="ph3">&lt;xref:System.Windows.UIElement.IsMouseDirectlyOverChanged&gt;</ph>.</source>
          <target state="translated">Por exemplo, você pode manipular <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseEnter&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseMove&gt;</ph>, e <ph id="ph3">&lt;xref:System.Windows.UIElement.IsMouseDirectlyOverChanged&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseOver">
          <source>If this element captures the mouse, this property remains <ph id="ph1">`true`</ph> until mouse capture is lost and the mouse pointer leaves the element bounds.</source>
          <target state="translated">Se este elemento captura o mouse, essa propriedade permanece <ph id="ph1">`true`</ph> até que a captura do mouse é perdida e o ponteiro do mouse sai dos limites do elemento.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseOver">
          <source>Some controls deliberately capture the mouse on certain actions that do not appear to directly involve the mouse.</source>
          <target state="translated">Alguns controles deliberadamente capturam o mouse sobre determinadas ações que não aparecem diretamente envolver o mouse.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseOver">
          <source>This can lead to <ph id="ph1">&lt;xref:System.Windows.UIElement.IsMouseOver%2A&gt;</ph> being <ph id="ph2">`true`</ph> even though the mouse has not apparently moved.</source>
          <target state="translated">Isso pode levar a <ph id="ph1">&lt;xref:System.Windows.UIElement.IsMouseOver%2A&gt;</ph> sendo <ph id="ph2">`true`</ph> , embora o mouse aparentemente não foi movido.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseOver">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseOver">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseOver">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseOver">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseOver">
          <source>The following example references this property as the property type of a <ph id="ph1">&lt;xref:System.Windows.Trigger&gt;</ph>, part of a <ph id="ph2">\&lt;</ph>Style.Triggers&gt; block.</source>
          <target state="translated">O exemplo a seguir faz referência a essa propriedade como o tipo de propriedade de um <ph id="ph1">&lt;xref:System.Windows.Trigger&gt;</ph>, parte de um <ph id="ph2">\&lt;</ph>Triggers &gt; bloco.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsMouseOver">
          <source>If the mouse is over the control, the control text turns blue and the cursor becomes a hand.</source>
          <target state="translated">Se o mouse estiver sobre o controle, o texto do controle azul e o cursor se torne uma mão.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.IsMouseOverProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsMouseOver" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsMouseOver" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsStylusCaptured">
          <source>Gets a value indicating whether the stylus is captured by this element.</source>
          <target state="translated">Obtém um valor que indica se a caneta é capturada por este elemento.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsStylusCaptured">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusCaptured">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the element has stylus capture; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o elemento tem captura da caneta; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusCaptured">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusCaptured">
          <source>Touch, mouse, and stylus input exist in a particular relationship.</source>
          <target state="translated">Entrada de caneta, mouse e toque existem em uma relação específica.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusCaptured">
          <source>For more information, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusCaptured">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusCaptured">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusCaptured">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusCaptured">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.IsStylusCapturedChanged">
          <source>Occurs when the value of the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsStylusCaptured" /&gt;</ph> property changes on this element.</source>
          <target state="translated">Ocorre quando o valor da propriedade <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsStylusCaptured" /&gt;</ph> é alterado neste elemento.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.IsStylusCapturedChanged">
          <source>This member is a <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> event, not a routed event.</source>
          <target state="translated">Esse membro é um <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> evento, não é um evento roteado.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.IsStylusCapturedProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsStylusCaptured" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsStylusCaptured" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsStylusCaptureWithin">
          <source>Gets a value that determines whether stylus capture is held by this element, or an element within the element bounds and its visual tree.</source>
          <target state="translated">Obtém um valor que determina se a captura da caneta é mantida por esse elemento ou um elemento nos limites do elemento e sua árvore visual.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsStylusCaptureWithin">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusCaptureWithin">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this element or a contained element has stylus capture; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se esse elemento ou um elemento contido tiver captura de caneta; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusCaptureWithin">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusCaptureWithin">
          <source>Touch, mouse, and stylus input exist in a particular relationship.</source>
          <target state="translated">Entrada de caneta, mouse e toque existem em uma relação específica.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusCaptureWithin">
          <source>For more information, see <bpt id="p1">[</bpt>Touch Input Support in Windows Vista<ept id="p1">](http://msdn.microsoft.com/library/63f1d71f-03d8-4d83-a174-e3dc7c57bad0)</ept> and <bpt id="p2">[</bpt>Input Overview<ept id="p2">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>Touch suporte de entrada no Windows Vista<ept id="p1">](http://msdn.microsoft.com/library/63f1d71f-03d8-4d83-a174-e3dc7c57bad0)</ept> e <bpt id="p2">[</bpt>visão geral de entrada<ept id="p2">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusCaptureWithin">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusCaptureWithin">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusCaptureWithin">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusCaptureWithin">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.IsStylusCaptureWithinChanged">
          <source>Occurs when the value of the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsStylusCaptureWithin" /&gt;</ph> property changes on this element.</source>
          <target state="translated">Ocorre quando o valor da propriedade <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsStylusCaptureWithin" /&gt;</ph> é alterado neste elemento.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.IsStylusCaptureWithinChanged">
          <source>This is a <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> event, not a routed event.</source>
          <target state="translated">Este é um <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> evento, não é um evento roteado.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.IsStylusCaptureWithinProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsStylusCaptureWithin" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsStylusCaptureWithin" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsStylusDirectlyOver">
          <source>Gets a value that indicates whether the stylus position corresponds to hit test results, which take element compositing into account.</source>
          <target state="translated">Obtém um valor que indica se a posição da caneta corresponde aos resultados de teste de clique, que levam em consideração a composição dos elementos.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsStylusDirectlyOver">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusDirectlyOver">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the stylus pointer is over the same element result as a hit test; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o ponteiro da caneta estiver sobre o mesmo resultado do elemento que um teste de clique; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusDirectlyOver">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusDirectlyOver">
          <source>Unlike <ph id="ph1">&lt;xref:System.Windows.UIElement.IsStylusOver%2A&gt;</ph>, this property is only <ph id="ph2">`true`</ph> if the stylus is over the element.</source>
          <target state="translated">Ao contrário de <ph id="ph1">&lt;xref:System.Windows.UIElement.IsStylusOver%2A&gt;</ph>, essa propriedade só é <ph id="ph2">`true`</ph> se a caneta está sobre o elemento.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusDirectlyOver">
          <source>If the stylus is instead over a child element or over elements that are part of an element's deeper compositing (the visual tree), this property will be <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Se a caneta está sobre um elemento filho ou sobre os elementos que fazem parte de composição de mais de um elemento (a árvore visual), essa propriedade será <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusDirectlyOver">
          <source>Unless you know how a control is composited (for example, you use this property in a custom control template for a control that you define), this property might return unexpected results.</source>
          <target state="translated">A menos que você sabe como um controle composto (por exemplo, você usa essa propriedade em um modelo de controle personalizado para um controle que você definir), essa propriedade pode retornar resultados inesperados.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusDirectlyOver">
          <source>For most scenarios where you are not authoring controls, use <ph id="ph1">&lt;xref:System.Windows.UIElement.IsStylusOver%2A&gt;</ph> instead.</source>
          <target state="translated">Na maioria dos cenários em que você está criando não controles, use <ph id="ph1">&lt;xref:System.Windows.UIElement.IsStylusOver%2A&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusDirectlyOver">
          <source>If this element has stylus capture and this property is <ph id="ph1">`true`</ph> at the time of capture, this property remains <ph id="ph2">`true`</ph> until stylus capture is lost and the stylus is not over its bounds.</source>
          <target state="translated">Se este elemento tem a captura da caneta e esta propriedade é <ph id="ph1">`true`</ph> no momento da captura, esta propriedade permanece <ph id="ph2">`true`</ph> até que a captura da caneta é perdida e não está sobre seus limites.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusDirectlyOver">
          <source>Touch, mouse, and stylus input exist in a particular relationship.</source>
          <target state="translated">Entrada de caneta, mouse e toque existem em uma relação específica.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusDirectlyOver">
          <source>For more information, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusDirectlyOver">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusDirectlyOver">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusDirectlyOver">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusDirectlyOver">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.IsStylusDirectlyOverChanged">
          <source>Occurs when the value of the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsStylusDirectlyOver" /&gt;</ph> property changes on this element.</source>
          <target state="translated">Ocorre quando o valor da propriedade <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsStylusDirectlyOver" /&gt;</ph> é alterado neste elemento.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.IsStylusDirectlyOverChanged">
          <source>This member is a <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> event, not a routed event.</source>
          <target state="translated">Esse membro é um <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> evento, não é um evento roteado.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.IsStylusDirectlyOverProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsStylusDirectlyOver" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsStylusDirectlyOver" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsStylusOver">
          <source>Gets a value indicating whether the stylus cursor is located over this element (including visual child elements).</source>
          <target state="translated">Obtém um valor que indica se o cursor da caneta está localizado sobre esse elemento (incluindo elementos filho visuais).</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsStylusOver">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusOver">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if stylus cursor is over the element or its child elements; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o cursor da caneta está sobre o elemento ou seus elementos filho; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusOver">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusOver">
          <source>If this element has stylus capture, this property will continue to return <ph id="ph1">`true`</ph> until stylus capture is lost and the pointer is out of its bounds.</source>
          <target state="translated">Se este elemento tem a captura da caneta, essa propriedade continuará retornar <ph id="ph1">`true`</ph> até que a captura da caneta é perdida e o ponteiro está fora dos seus limites.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusOver">
          <source>Touch, mouse, and stylus input exist in a particular relationship.</source>
          <target state="translated">Entrada de caneta, mouse e toque existem em uma relação específica.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusOver">
          <source>For more information, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusOver">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusOver">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusOver">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsStylusOver">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.IsStylusOverProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsStylusOver" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsStylusOver" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsVisible">
          <source>Gets a value indicating whether this element is visible in the <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.</source>
          <target state="translated">Obtém um valor que indica se esse elemento está visível no <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.IsVisible">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsVisible">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the element is visible; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o elemento estiver visível; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsVisible">
          <source>Determination of the <ph id="ph1">&lt;xref:System.Windows.UIElement.IsVisible%2A&gt;</ph> value takes all factors of layout into account.</source>
          <target state="translated">Determinar a <ph id="ph1">&lt;xref:System.Windows.UIElement.IsVisible%2A&gt;</ph> valor leva em conta a todos os fatores de layout.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsVisible">
          <source>In contrast, <ph id="ph1">&lt;xref:System.Windows.UIElement.Visibility%2A&gt;</ph>, which is a settable property, only indicates the intention to programmatically make an element visible or invisible.</source>
          <target state="translated">Por outro lado, <ph id="ph1">&lt;xref:System.Windows.UIElement.Visibility%2A&gt;</ph>, só que é uma propriedade configurável, indica a intenção de fazer programaticamente um elemento visível ou invisível.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsVisible">
          <source>Elements where <ph id="ph1">&lt;xref:System.Windows.UIElement.IsVisible%2A&gt;</ph> is <ph id="ph2">`false`</ph> do not participate in input events (or commands), do not influence either the measure or arrange passes of layout, are not focusable, are not in a tab sequence, and will not be reported in hit testing.</source>
          <target state="translated">Elementos onde <ph id="ph1">&lt;xref:System.Windows.UIElement.IsVisible%2A&gt;</ph> é <ph id="ph2">`false`</ph> participar de eventos de entrada (ou comandos), faça influenciam a medida ou organizar os passos de layout, não são Focusable é, não estão em uma sequência de guia e não serão reportadas no teste de clique não.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsVisible">
          <source>In contrast, elements where <ph id="ph1">&lt;xref:System.Windows.UIElement.IsEnabled%2A&gt;</ph> is <ph id="ph2">`false`</ph> will still participate in events and commands, and hit testing, but are also not focusable.</source>
          <target state="translated">Por outro lado, elementos onde <ph id="ph1">&lt;xref:System.Windows.UIElement.IsEnabled%2A&gt;</ph> é <ph id="ph2">`false`</ph> ainda farão parte de eventos e comandos e teste de clique, mas também não são Focusable é.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsVisible">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsVisible">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsVisible">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.IsVisible">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.IsVisibleChanged">
          <source>Occurs when the value of the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsVisible" /&gt;</ph> property changes on this element.</source>
          <target state="translated">Ocorre quando o valor da propriedade <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsVisible" /&gt;</ph> é alterado neste elemento.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.IsVisibleChanged">
          <source>This event is not raised if the element is not being rendered by the layout system, for reasons other than the value of the <ph id="ph1">&lt;xref:System.Windows.UIElement.IsVisible%2A&gt;</ph> property.</source>
          <target state="translated">Esse evento não será gerado se o elemento não está sendo processado, o sistema de layout, por motivos diferente do valor da <ph id="ph1">&lt;xref:System.Windows.UIElement.IsVisible%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.IsVisibleChanged">
          <source>For example, the element might not have an associated visual.</source>
          <target state="translated">Por exemplo, o elemento não pode ter um visual associado.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.IsVisibleChanged">
          <source>This member is a <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> event, not a routed event.</source>
          <target state="translated">Esse membro é um <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> evento, não é um evento roteado.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.IsVisibleProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsVisible" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsVisible" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.KeyDown">
          <source>Occurs when a key is pressed while focus is on this element.</source>
          <target state="translated">Ocorre quando uma tecla é pressionada enquanto o foco está neste elemento.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.KeyDown">
          <source>Key handling interacts with other platform features such as commanding and text composition.</source>
          <target state="translated">Tratamento de chaves interage com outros recursos de plataforma como composição ordenar e texto.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.KeyDown">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.KeyDown&gt;</ph> event is a lower-level text input event that might not behave as expected on certain controls.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.KeyDown&gt;</ph> é um evento de entrada de texto de nível inferior pode não funcionar como esperado em determinados controles.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.KeyDown">
          <source>This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</source>
          <target state="translated">Isso ocorre porque alguns controles tem composição de controle ou de tratamento de classe que fornece uma versão de nível mais alto de texto manipulação de entrada e eventos relacionados.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.KeyDown">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType&gt;</ph> attached event for this class so that <ph id="ph2">&lt;xref:System.Windows.UIElement.KeyDown&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType&gt;</ph> evento para esta classe anexado para que <ph id="ph2">&lt;xref:System.Windows.UIElement.KeyDown&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.KeyDown">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.KeyDown&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.KeyDown&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.KeyDown">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.KeyDown">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.KeyDown">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.KeyDown">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.KeyDown">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.KeyDown">
          <source>The corresponding tunneling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewKeyDown&gt;</ph>.</source>
          <target state="translated">O evento de túnel correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewKeyDown&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.KeyDown">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnKeyDown%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnKeyDown%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.KeyDownEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.KeyDown" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.KeyDown" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.KeyDownEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.KeyDownEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.KeyDownEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.KeyDownEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.KeyDownEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.KeyUp">
          <source>Occurs when a key is released while focus is on this element.</source>
          <target state="translated">Ocorre quando uma chave é liberada enquanto o foco está neste elemento.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.KeyUp">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType&gt;</ph> attached event for this class so that  <ph id="ph2">&lt;xref:System.Windows.UIElement.KeyUp&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType&gt;</ph> evento para esta classe anexado para que <ph id="ph2">&lt;xref:System.Windows.UIElement.KeyUp&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.KeyUp">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.KeyUp&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.KeyUp&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.KeyUp">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.KeyUp">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.KeyUp">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.KeyUp">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.KeyUp">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.KeyUp">
          <source>The corresponding tunneling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewKeyUp&gt;</ph>.</source>
          <target state="translated">O evento de túnel correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewKeyUp&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.KeyUp">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnKeyUp%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnKeyUp%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.KeyUpEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.KeyUp" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.KeyUp" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.KeyUpEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.KeyUpEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.KeyUpEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.KeyUpEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.KeyUpEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.LayoutUpdated">
          <source>Occurs when the layout of the various visual elements associated with the current <ph id="ph1">&lt;see cref="T:System.Windows.Threading.Dispatcher" /&gt;</ph> changes.</source>
          <target state="translated">Ocorre quando o layout dos vários elementos visuais associados ao <ph id="ph1">&lt;see cref="T:System.Windows.Threading.Dispatcher" /&gt;</ph> atual é alterado.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LayoutUpdated">
          <source>A layout update can occur as a result of a property change, a window resize, or an explicit user request.</source>
          <target state="translated">Uma atualização de layout pode ocorrer como resultado de uma alteração de propriedade, um redimensionamento de janela ou uma solicitação explícita do usuário.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LayoutUpdated">
          <source>This member is a <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> event, not a routed event.</source>
          <target state="translated">Esse membro é um <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> evento, não é um evento roteado.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.LostFocus">
          <source>Occurs when this element loses logical focus.</source>
          <target state="translated">Ocorre quando este elemento perde o foco lógico.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostFocus">
          <source>Logical focus differs from keyboard focus if focus is deliberately forced away by using a method call but the previous keyboard focus exists in a different scope.</source>
          <target state="translated">Foco lógico é diferente do foco do teclado, se o foco é deliberadamente forçado longe usando uma chamada de método, mas o foco do teclado anterior existe em um escopo diferente.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostFocus">
          <source>In this scenario, keyboard focus remains where it is, and the element where a <ph id="ph1">&lt;xref:System.Windows.UIElement.Focus%2A&gt;</ph> method is called still gets logical focus.</source>
          <target state="translated">Neste cenário, permanece de foco do teclado em que é e o elemento onde um <ph id="ph1">&lt;xref:System.Windows.UIElement.Focus%2A&gt;</ph> método é chamado ainda foco lógico obtém.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostFocus">
          <source>A more precise interpretation of this event is that it is raised when the value of the <ph id="ph1">&lt;xref:System.Windows.UIElement.IsFocused%2A&gt;</ph> property of an element in the route changes from <ph id="ph2">`true`</ph> to <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Uma interpretação mais precisa desse evento é que ele é gerado quando o valor de <ph id="ph1">&lt;xref:System.Windows.UIElement.IsFocused%2A&gt;</ph> alterações de propriedade de um elemento na rota de <ph id="ph2">`true`</ph> para <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostFocus">
          <source>Because this event uses bubbling routing, the element that loses focus might be a child element instead of the element where the event handler is actually attached.</source>
          <target state="translated">Como esse evento usa roteamento bolha, o elemento que perde o foco pode ser um elemento de filho em vez do elemento em que o manipulador de eventos, na verdade, está anexado.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostFocus">
          <source>Check the <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> in the event data to determine the actual element that gained focus.</source>
          <target state="translated">Verifique o <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> nos dados de evento para determinar o elemento real que obteve o foco.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostFocus">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostFocus">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostFocus">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostFocus">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostFocus">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostFocus">
          <source>There is no corresponding tunneling event.</source>
          <target state="translated">Não há nenhum evento de túnel correspondente.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostFocus">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnLostFocus%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnLostFocus%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.LostFocusEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.LostFocus" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.LostFocus" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.LostFocusEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.LostFocusEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.LostFocusEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.LostFocusEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.LostFocusEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.LostKeyboardFocus">
          <source>Occurs when the keyboard is no longer focused on this element,.</source>
          <target state="translated">Ocorre quando o teclado não está mais focalizado no elemento.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostKeyboardFocus">
          <source>Because this event uses bubbling routing, the element that lost focus might be a child element instead of the element where the event handler is actually attached.</source>
          <target state="translated">Como esse evento usa roteamento bolha, o elemento que perdeu o foco pode ser um elemento filho, em vez do elemento onde o manipulador de eventos, na verdade, está conectado.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostKeyboardFocus">
          <source>Check the <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> in the event data to determine the actual element that lost focus.</source>
          <target state="translated">Verifique o <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> nos dados de evento para determinar o elemento real que perdeu o foco.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostKeyboardFocus">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.LostKeyboardFocus&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.LostKeyboardFocus&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostKeyboardFocus">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.LostKeyboardFocus&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.LostKeyboardFocus&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostKeyboardFocus">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostKeyboardFocus">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostKeyboardFocus">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostKeyboardFocus">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostKeyboardFocus">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostKeyboardFocus">
          <source>The corresponding tunneling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewLostKeyboardFocus&gt;</ph>.</source>
          <target state="translated">O evento de túnel correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewLostKeyboardFocus&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostKeyboardFocus">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnLostKeyboardFocus%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnLostKeyboardFocus%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.LostKeyboardFocusEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.LostKeyboardFocus" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.LostKeyboardFocus" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.LostKeyboardFocusEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.LostKeyboardFocusEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.LostKeyboardFocusEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.LostKeyboardFocusEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.LostKeyboardFocusEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.LostMouseCapture">
          <source>Occurs when this element loses mouse capture.</source>
          <target state="translated">Ocorre quando este elemento perde a captura do mouse.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostMouseCapture">
          <source>When an element captures the mouse, it receives mouse input even if the pointer is outside its bounds.</source>
          <target state="translated">Quando um elemento captura o mouse, ele recebe entrada do mouse, mesmo que o ponteiro está fora dos seus limites.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostMouseCapture">
          <source>The mouse is typically captured only during drag-and-drop operations.</source>
          <target state="translated">Normalmente, o mouse é capturado somente durante as operações de arrastar e soltar.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostMouseCapture">
          <source>Because this event uses bubbling routing, the element that loses capture might be a child element instead of the element where the event handler is actually attached.</source>
          <target state="translated">Como esse evento usa roteamento bolha, o elemento perde a captura do pode ser um elemento de filho em vez do elemento em que o manipulador de eventos, na verdade, está anexado.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostMouseCapture">
          <source>Check the <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> in the event data to determine the actual element that lost capture.</source>
          <target state="translated">Verifique o <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> nos dados de evento para determinar o elemento real que perdeu captura.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostMouseCapture">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.LostMouseCapture&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.LostMouseCapture&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostMouseCapture">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.LostMouseCapture&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.LostMouseCapture&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostMouseCapture">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostMouseCapture">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostMouseCapture">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostMouseCapture">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostMouseCapture">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostMouseCapture">
          <source>There is no defined corresponding tunneling event.</source>
          <target state="translated">Não há nenhum evento de túnel correspondente definido.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostMouseCapture">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnLostMouseCapture%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnLostMouseCapture%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.LostMouseCaptureEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.LostMouseCapture" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.LostMouseCapture" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.LostMouseCaptureEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.LostMouseCaptureEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.LostMouseCaptureEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.LostMouseCaptureEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.LostMouseCaptureEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.LostStylusCapture">
          <source>Occurs when this element loses stylus capture.</source>
          <target state="translated">Ocorre quando este elemento perde a captura da caneta.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostStylusCapture">
          <source>When an element captures the stylus, it receives stylus input even if the pointer is outside its bounds.</source>
          <target state="translated">Quando um elemento captura a caneta, ele recebe entrada de caneta mesmo que o ponteiro está fora dos seus limites.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostStylusCapture">
          <source>The stylus is typically captured only during drag-and-drop operations.</source>
          <target state="translated">Normalmente, a caneta é capturada somente durante as operações de arrastar e soltar.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostStylusCapture">
          <source>Because this event uses bubbling routing, the element that loses focus might be a child element instead of the element where the event handler is actually attached.</source>
          <target state="translated">Como esse evento usa roteamento bolha, o elemento que perde o foco pode ser um elemento de filho em vez do elemento em que o manipulador de eventos, na verdade, está anexado.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostStylusCapture">
          <source>Check the <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> in the event data to determine the actual element that lost focus.</source>
          <target state="translated">Verifique o <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> nos dados de evento para determinar o elemento real que perdeu o foco.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostStylusCapture">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.LostStylusCapture&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.LostStylusCapture&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostStylusCapture">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.LostStylusCapture&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.LostStylusCapture&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostStylusCapture">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostStylusCapture">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostStylusCapture">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostStylusCapture">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostStylusCapture">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostStylusCapture">
          <source>There is no defined corresponding tunneling event.</source>
          <target state="translated">Não há nenhum evento de túnel correspondente definido.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostStylusCapture">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnLostStylusCapture%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnLostStylusCapture%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.LostStylusCaptureEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.LostStylusCapture" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.LostStylusCapture" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.LostStylusCaptureEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.LostStylusCaptureEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.LostStylusCaptureEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.LostStylusCaptureEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.LostStylusCaptureEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.LostTouchCapture">
          <source>Occurs when this element loses a touch capture.</source>
          <target state="translated">Ocorre quando este elemento perde a captura do toque.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostTouchCapture">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostTouchCapture">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostTouchCapture">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostTouchCapture">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostTouchCapture">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostTouchCapture">
          <source><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> of type <ph id="ph2">&lt;xref:System.Windows.Input.TouchEventArgs&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> do tipo <ph id="ph2">&lt;xref:System.Windows.Input.TouchEventArgs&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.LostTouchCapture">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnLostTouchCapture%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnLostTouchCapture%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.LostTouchCaptureEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.LostTouchCapture" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.LostTouchCapture" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.ManipulationBoundaryFeedback">
          <source>Occurs when the manipulation encounters a boundary.</source>
          <target state="translated">Ocorre quando a manipulação atinge um limite.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationBoundaryFeedback">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationBoundaryFeedback">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationBoundaryFeedback">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationBoundaryFeedback">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationBoundaryFeedback">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationBoundaryFeedback">
          <source><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> of type <ph id="ph2">&lt;xref:System.Windows.Input.ManipulationBoundaryFeedbackEventArgs&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> do tipo <ph id="ph2">&lt;xref:System.Windows.Input.ManipulationBoundaryFeedbackEventArgs&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.ManipulationBoundaryFeedbackEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /&gt;</ph> event.</source>
          <target state="translated">Identifica o evento <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.ManipulationCompleted">
          <source>Occurs when a manipulation and inertia on the <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> object is complete.</source>
          <target state="translated">Ocorre quando uma manipulação e inércia no objeto <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> é concluída.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationCompleted">
          <source>You can use this event to get information about the manipulation when it completes.</source>
          <target state="translated">Você pode usar esse evento para obter informações sobre a manipulação de quando ele for concluído.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationCompleted">
          <source>For example, you can use the <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationCompletedEventArgs.TotalManipulation%2A?displayProperty=nameWithType&gt;</ph> property to determine the total amount the position of the manipulation changed.</source>
          <target state="translated">Por exemplo, você pode usar o <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationCompletedEventArgs.TotalManipulation%2A?displayProperty=nameWithType&gt;</ph> propriedade para determinar a quantidade total a posição da manipulação de alterada.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationCompleted">
          <source>For more information about manipulations, see the <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre manipulações, consulte o <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationCompleted">
          <source>For an example of an application that responds to manipulations, see <bpt id="p1">[</bpt>Walkthrough: Creating Your First Touch Application<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)</ept>.</source>
          <target state="translated">Para obter um exemplo de um aplicativo que responde às manipulações, consulte <bpt id="p1">[</bpt>passo a passo: Criando seu primeiro toque aplicativo<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationCompleted">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationCompleted">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationCompleted">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationCompleted">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationCompleted">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationCompleted">
          <source><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> of type <ph id="ph2">&lt;xref:System.Windows.Input.ManipulationCompletedEventArgs&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> do tipo <ph id="ph2">&lt;xref:System.Windows.Input.ManipulationCompletedEventArgs&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.ManipulationCompletedEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.ManipulationCompleted" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.ManipulationCompleted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.ManipulationDelta">
          <source>Occurs when the input device changes position during a manipulation.</source>
          <target state="translated">Ocorre quando o dispositivo de entrada muda de posição durante uma manipulação.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationDelta">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationDelta&gt;</ph> event occurs multiple times when the user drags fingers over the screen during a manipulation and again when inertia occurs.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationDelta&gt;</ph> evento ocorre várias vezes quando o usuário arrasta dedos a tela durante uma manipulação e novamente quando inércia ocorre.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationDelta">
          <source>You can use the <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationDeltaEventArgs.IsInertial%2A&gt;</ph> property to check whether the event is occurring during inertia.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationDeltaEventArgs.IsInertial%2A&gt;</ph> propriedade para verificar se o evento ocorre durante inércia.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationDelta">
          <source>The element on with <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationDelta&gt;</ph> event occurs is not affected in any way when the event occurs.</source>
          <target state="translated">O elemento com <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationDelta&gt;</ph> evento ocorre não é afetada de qualquer forma, quando o evento ocorre.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationDelta">
          <source>You must provide the logic to the element that is to be manipulated.</source>
          <target state="translated">Você deve fornecer a lógica para o elemento a ser manipulada.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationDelta">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationDeltaEventArgs.CumulativeManipulation%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Input.ManipulationDeltaEventArgs.DeltaManipulation%2A&gt;</ph> properties, which are of type <ph id="ph3">&lt;xref:System.Windows.Input.ManipulationDelta&gt;</ph>, contain data about how the position of the manipulations change and interpreted as moving, resizing, or rotating an object.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationDeltaEventArgs.CumulativeManipulation%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.Input.ManipulationDeltaEventArgs.DeltaManipulation%2A&gt;</ph> propriedades, que são do tipo <ph id="ph3">&lt;xref:System.Windows.Input.ManipulationDelta&gt;</ph>, contêm dados sobre como alterar a posição de manipulações e interpretado como mover, redimensionar ou girar um objeto.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationDelta">
          <source>You apply that information to the element that is to be manipulated.</source>
          <target state="translated">Você pode aplicar essas informações para o elemento a ser manipulada.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationDelta">
          <source>For more information about manipulations, see the <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre manipulações, consulte o <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationDelta">
          <source>For an example of an application that responds to manipulations, see <bpt id="p1">[</bpt>Walkthrough: Creating Your First Touch Application<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)</ept>.</source>
          <target state="translated">Para obter um exemplo de um aplicativo que responde às manipulações, consulte <bpt id="p1">[</bpt>passo a passo: Criando seu primeiro toque aplicativo<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationDelta">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationDelta">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationDelta">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationDelta">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationDelta">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationDelta">
          <source><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> of type <ph id="ph2">&lt;xref:System.Windows.Input.ManipulationDeltaEventArgs&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> do tipo <ph id="ph2">&lt;xref:System.Windows.Input.ManipulationDeltaEventArgs&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationDelta">
          <source>The following example shows an event handler for the <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationDelta&gt;</ph> event.</source>
          <target state="translated">O exemplo a seguir mostra um manipulador de eventos para o <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationDelta&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationDelta">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationDeltaEventArgs.DeltaManipulation%2A&gt;</ph> property to move, resize, and rotate a <ph id="ph2">&lt;xref:System.Windows.Shapes.Rectangle&gt;</ph>.</source>
          <target state="translated">O exemplo usa o <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationDeltaEventArgs.DeltaManipulation%2A&gt;</ph> propriedade para mover, redimensionar e girar um <ph id="ph2">&lt;xref:System.Windows.Shapes.Rectangle&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationDelta">
          <source>The example also checks whether the <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationDelta&gt;</ph> event occurred during inertia and whether the rectangle is touching the edge of a window.</source>
          <target state="translated">O exemplo também verifica se o <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationDelta&gt;</ph> evento ocorreu durante inércia e se o retângulo estiver tocando a borda de uma janela.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationDelta">
          <source>If those cases are true, the application stops the manipulation to prevent the rectangle from leaving the visible area of the application.</source>
          <target state="translated">Se os casos são true, o aplicativo para a manipulação para impedir que o retângulo deixar a área visível do aplicativo.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationDelta">
          <source>This example is part of a larger example in <bpt id="p1">[</bpt>Walkthrough: Creating Your First Touch Application<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)</ept>.</source>
          <target state="translated">Este exemplo é parte de um exemplo maior no <bpt id="p1">[</bpt>passo a passo: Criando seu primeiro toque aplicativo<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.ManipulationDeltaEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.ManipulationDelta" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.ManipulationDelta" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.ManipulationInertiaStarting">
          <source>Occurs when the input device loses contact with the <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> object during a manipulation and inertia begins.</source>
          <target state="translated">Ocorre quando o dispositivo de entrada perde o contato com o objeto <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> durante uma manipulação e a inércia começa.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationInertiaStarting">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationInertiaStarting&gt;</ph> event occurs when the user lifts all of the fingers from the screen during a manipulation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationInertiaStarting&gt;</ph> evento ocorre quando o usuário retira a todos os dedos na tela durante uma manipulação.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationInertiaStarting">
          <source>For example, if a user "throws" a <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> across a surface, the user will touch the <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> to begin the action, move the finger across the screen for a short distance, and then release the <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph>.</source>
          <target state="translated">Por exemplo, se um usuário "lançar" um <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> em uma superfície, o usuário terá contato a <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> para iniciar a ação, mover o dedo na tela para uma pequena distância e, em seguida, solte o <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationInertiaStarting">
          <source>When the user releases the element, inertia begins and the <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationInertiaStarting&gt;</ph> event occurs.</source>
          <target state="translated">Quando o usuário libera o elemento, inércia começa e o <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationInertiaStarting&gt;</ph> evento ocorre.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationInertiaStarting">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> continues to receive <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationDelta&gt;</ph> events to indicate that inertia is occurring on the element.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> continua a receber <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationDelta&gt;</ph> eventos para indicar que inércia está ocorrendo no elemento.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationInertiaStarting">
          <source>You can use this event to specify the behavior of the inertia.</source>
          <target state="translated">Você pode usar esse evento para especificar o comportamento de inércia.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationInertiaStarting">
          <source>For example, you can set the initial velocity that is used when inertia begins.</source>
          <target state="translated">Por exemplo, você pode definir a velocidade inicial que é usada quando inércia começa.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationInertiaStarting">
          <source>You can also specify the amount of inertia by setting the desired deceleration or by setting the desired placement.</source>
          <target state="translated">Você também pode especificar a quantidade de inércia definindo a desaceleração desejada ou definindo o posicionamento desejado.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationInertiaStarting">
          <source>You can set these values for each type of manipulation (translation, expansion, or rotation) independently.</source>
          <target state="translated">Você pode definir esses valores para cada tipo de manipulação (tradução, expansão ou rotação) de forma independente.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationInertiaStarting">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationInertiaStartingEventArgs&gt;</ph>.</source>
          <target state="translated">Para obter mais informações, consulte <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationInertiaStartingEventArgs&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationInertiaStarting">
          <source>For more information about manipulations, see the <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre manipulações, consulte o <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationInertiaStarting">
          <source>For an example of an application that responds to manipulations, see <bpt id="p1">[</bpt>Walkthrough: Creating Your First Touch Application<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)</ept>.</source>
          <target state="translated">Para obter um exemplo de um aplicativo que responde às manipulações, consulte <bpt id="p1">[</bpt>passo a passo: Criando seu primeiro toque aplicativo<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationInertiaStarting">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationInertiaStarting">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationInertiaStarting">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationInertiaStarting">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationInertiaStarting">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationInertiaStarting">
          <source><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> of type <ph id="ph2">&lt;xref:System.Windows.Input.ManipulationInertiaStartingEventArgs&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> do tipo <ph id="ph2">&lt;xref:System.Windows.Input.ManipulationInertiaStartingEventArgs&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationInertiaStarting">
          <source>The following example shows the <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationInertiaStarting&gt;</ph> event handler and sets the desired deceleration for translation, expansion, and rotation that is used during inertia.</source>
          <target state="translated">A exemplo a seguir mostra o <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationInertiaStarting&gt;</ph> manipulador de eventos e define a desaceleração desejada para conversão, expansão e rotação que é usada durante inércia.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationInertiaStarting">
          <source>This example is part of a larger example in <bpt id="p1">[</bpt>Walkthrough: Creating Your First Touch Application<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)</ept>.</source>
          <target state="translated">Este exemplo é parte de um exemplo maior no <bpt id="p1">[</bpt>passo a passo: Criando seu primeiro toque aplicativo<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.ManipulationInertiaStartingEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.ManipulationInertiaStarting" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.ManipulationInertiaStarting" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.ManipulationStarted">
          <source>Occurs when an input device begins a manipulation on the <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> object.</source>
          <target state="translated">Ocorre quando um dispositivo de entrada começa uma manipulação no objeto <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarted">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationStarted&gt;</ph> event occurs after the <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationStarting&gt;</ph> event.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationStarted&gt;</ph> evento ocorre após o <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationStarting&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarted">
          <source>You can do the following with the <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationStartedEventArgs&gt;</ph>:</source>
          <target state="translated">Você pode fazer o seguinte com o <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationStartedEventArgs&gt;</ph>:</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarted">
          <source>Get the element that the manipulation's position is relative to by using the <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationStartedEventArgs.ManipulationContainer%2A&gt;</ph> property.</source>
          <target state="translated">Obter o elemento de posição da manipulação é relativo ao usando o <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationStartedEventArgs.ManipulationContainer%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarted">
          <source>Get the origin of the manipulation by using the <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationStartedEventArgs.ManipulationOrigin%2A&gt;</ph> property.</source>
          <target state="translated">Obter a origem da manipulação de usando o <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationStartedEventArgs.ManipulationOrigin%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarted">
          <source>Cancel the manipulation by calling the <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationStartedEventArgs.Complete%2A&gt;</ph> method.</source>
          <target state="translated">Cancelar a manipulação chamando o <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationStartedEventArgs.Complete%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarted">
          <source>For more information about manipulations, see the <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre manipulações, consulte o <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarted">
          <source>For an example of an application that responds to manipulations, see <bpt id="p1">[</bpt>Walkthrough: Creating Your First Touch Application<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)</ept>.</source>
          <target state="translated">Para obter um exemplo de um aplicativo que responde às manipulações, consulte <bpt id="p1">[</bpt>passo a passo: Criando seu primeiro toque aplicativo<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarted">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarted">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarted">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarted">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarted">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarted">
          <source><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> of type <ph id="ph2">&lt;xref:System.Windows.Input.ManipulationStartedEventArgs&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> do tipo <ph id="ph2">&lt;xref:System.Windows.Input.ManipulationStartedEventArgs&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.ManipulationStartedEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.ManipulationStarted" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.ManipulationStarted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.ManipulationStarting">
          <source>Occurs when the manipulation processor is first created.</source>
          <target state="translated">Ocorre quando o processador de manipulação é criado.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarting">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationStarting&gt;</ph> event occurs on an element that has the <ph id="ph2">&lt;xref:System.Windows.UIElement.IsManipulationEnabled%2A&gt;</ph> property set to <ph id="ph3">`true`</ph> when the user puts a finger on it.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationStarting&gt;</ph> evento ocorre em um elemento que tem o <ph id="ph2">&lt;xref:System.Windows.UIElement.IsManipulationEnabled%2A&gt;</ph> propriedade definida como <ph id="ph3">`true`</ph> quando o usuário coloca um dedo nele.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarting">
          <source>By default, subsequent manipulation events report the position of the manipulation relative to the element that has <ph id="ph1">&lt;xref:System.Windows.UIElement.IsManipulationEnabled%2A&gt;</ph> set to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Por padrão, a posição da manipulação de em relação ao elemento que tem de relatório de eventos subsequentes de manipulação de <ph id="ph1">&lt;xref:System.Windows.UIElement.IsManipulationEnabled%2A&gt;</ph> definido como <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarting">
          <source>You can specify that the position should be relative to another element by setting the <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A&gt;</ph> property.</source>
          <target state="translated">Você pode especificar que a posição deve ser relativo ao outro elemento definindo o <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarting">
          <source>For example, you can make the manipulation relative to the parent of the element.</source>
          <target state="translated">Por exemplo, você pode fazer a manipulação em relação ao pai do elemento.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarting">
          <source>You can also do the following in an event handler for <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationStarting&gt;</ph>:</source>
          <target state="translated">Você também pode fazer o seguinte em um manipulador de eventos <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationStarting&gt;</ph>:</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarting">
          <source>Specify whether the user needs more than one finger to perform the manipulations by setting the <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationStartingEventArgs.IsSingleTouchEnabled%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Especifique se o usuário precisa de mais de um dedo para executar as manipulações definindo o <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationStartingEventArgs.IsSingleTouchEnabled%2A?displayProperty=nameWithType&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarting">
          <source>Specify which types of manipulation are enabled by setting the <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationStartingEventArgs.Mode%2A?displayProperty=nameWithType&gt;</ph> property to a <ph id="ph2">&lt;xref:System.Windows.Input.ManipulationModes&gt;</ph> enumeration.</source>
          <target state="translated">Especificar quais tipos de manipulação de estão habilitados, definindo o <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationStartingEventArgs.Mode%2A?displayProperty=nameWithType&gt;</ph> propriedade para um <ph id="ph2">&lt;xref:System.Windows.Input.ManipulationModes&gt;</ph> enumeração.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarting">
          <source>Specify the center of a single-finger rotation by setting the <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationStartingEventArgs.Pivot%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Especificar o Centro de rotação de um único dedo, definindo o <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationStartingEventArgs.Pivot%2A?displayProperty=nameWithType&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarting">
          <source>Cancel the manipulation by calling the <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Cancelar a manipulação chamando o <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarting">
          <source>For more information about manipulations, see the <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre manipulações, consulte o <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarting">
          <source>For an example of an application that responds to manipulations, see <bpt id="p1">[</bpt>Walkthrough: Creating Your First Touch Application<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)</ept>.</source>
          <target state="translated">Para obter um exemplo de um aplicativo que responde às manipulações, consulte <bpt id="p1">[</bpt>passo a passo: Criando seu primeiro toque aplicativo<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarting">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarting">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarting">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarting">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarting">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarting">
          <source><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> of type <ph id="ph2">&lt;xref:System.Windows.Input.ManipulationStartingEventArgs&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> do tipo <ph id="ph2">&lt;xref:System.Windows.Input.ManipulationStartingEventArgs&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarting">
          <source>The following example shows the event handler for the <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationStarting&gt;</ph> event and sets the <ph id="ph2">&lt;xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A&gt;</ph> to the parent element that receives the manipulation events so that the coordinates of the manipulation are relative to the parent element.</source>
          <target state="translated">O exemplo a seguir mostra o manipulador de eventos para o <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationStarting&gt;</ph> eventos e define o <ph id="ph2">&lt;xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A&gt;</ph> ao elemento pai que recebe os eventos de manipulação para que as coordenadas da manipulação de em relação ao elemento pai.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.ManipulationStarting">
          <source>This example is part of a larger example in <bpt id="p1">[</bpt>Walkthrough: Creating Your First Touch Application<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)</ept>.</source>
          <target state="translated">Este exemplo é parte de um exemplo maior no <bpt id="p1">[</bpt>passo a passo: Criando seu primeiro toque aplicativo<ept id="p1">](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.ManipulationStartingEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.ManipulationStarting" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.ManipulationStarting" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.Measure(System.Windows.Size)">
          <source>The available space that a parent element can allocate a child element.</source>
          <target state="translated">O espaço disponível que um elemento pai pode alocar um elemento filho.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.Measure(System.Windows.Size)">
          <source>A child element can request a larger space than what is available; the provided size might be accommodated if scrolling is possible in the content model for the current element.</source>
          <target state="translated">Um elemento filho pode solicitar um espaço maior do que o disponível. O tamanho fornecido pode ser acomodado se a rolagem for possível no modelo de conteúdo do elemento atual.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.Measure(System.Windows.Size)">
          <source>Updates the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.DesiredSize" /&gt;</ph> of a <ph id="ph2">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph>.</source>
          <target state="translated">Atualiza <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.DesiredSize" /&gt;</ph> de um <ph id="ph2">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.Measure(System.Windows.Size)">
          <source>Parent elements call this method from their own <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)" /&gt;</ph> implementations to form a recursive layout update.</source>
          <target state="translated">Elementos pai chamam esse método de suas próprias implementações <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)" /&gt;</ph> para formar uma atualização de layout recursiva.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.Measure(System.Windows.Size)">
          <source>Calling this method constitutes the first pass (the "Measure" pass) of a layout update.</source>
          <target state="translated">Chamar esse método constitui a primeira passagem (a passagem "Medida") de uma atualização de layout.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Measure(System.Windows.Size)">
          <source>Computation of layout positioning in <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> is comprised of a <ph id="ph2">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> call and an <ph id="ph3">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> call.</source>
          <target state="translated">Cálculo de posicionamento de layout em <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> é composta de uma <ph id="ph2">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> chamar e um <ph id="ph3">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> chamar.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Measure(System.Windows.Size)">
          <source>During the <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> call, an element determines its size requirements by using an <ph id="ph2">`availableSize`</ph> input.</source>
          <target state="translated">Durante o <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> chamada, um elemento determina seus requisitos de tamanho usando um <ph id="ph2">`availableSize`</ph> entrada.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Measure(System.Windows.Size)">
          <source>During the <ph id="ph1">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> call, the element size is finalized.</source>
          <target state="translated">Durante o <ph id="ph1">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> chamada, o tamanho do elemento é finalizada.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Measure(System.Windows.Size)">
          <source><ph id="ph1">`availableSize`</ph> can be any number from zero to infinite.</source>
          <target state="translated"><ph id="ph1">`availableSize`</ph> pode ser qualquer número de zero como infinito.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Measure(System.Windows.Size)">
          <source>Elements participating in layout should return the minimum <ph id="ph1">&lt;xref:System.Windows.Size&gt;</ph> they require for a given <ph id="ph2">`availableSize`</ph>.</source>
          <target state="translated">Elementos que participam do layout devem retornar o mínimo <ph id="ph1">&lt;xref:System.Windows.Size&gt;</ph> precisam para um determinado <ph id="ph2">`availableSize`</ph>.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Measure(System.Windows.Size)">
          <source>When a layout is first instantiated, it always receives a <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> call before <ph id="ph2">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph>.</source>
          <target state="translated">Quando um layout é instanciado pela primeira vez, ele sempre recebe um <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> chamar antes de <ph id="ph2">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Measure(System.Windows.Size)">
          <source>However, after the first layout pass, it may receive an <ph id="ph1">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> call without a <ph id="ph2">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph>; this can happen when a property that affects only <ph id="ph3">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> is changed (such as alignment), or when the parent receives an <ph id="ph4">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> without a <ph id="ph5">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph>.</source>
          <target state="translated">No entanto, após a primeira passagem de layout, pode receber um <ph id="ph1">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> chamada sem um <ph id="ph2">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph>; isso pode acontecer quando uma propriedade que só afeta <ph id="ph3">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> for alterada (como alinhamento), ou quando o pai recebe um <ph id="ph4">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> sem um <ph id="ph5">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Measure(System.Windows.Size)">
          <source>A <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> call will automatically invalidate an <ph id="ph2">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> call.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> chamada invalidará automaticamente um <ph id="ph2">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> chamar.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Measure(System.Windows.Size)">
          <source>Layout updates happen asynchronously, such that the main thread is not waiting for every possible layout change.</source>
          <target state="translated">As atualizações de layout de forma assíncrona, ocorrem, de modo que o thread principal não está esperando para todas as alterações de layout possíveis.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Measure(System.Windows.Size)">
          <source>Querying an element via code-behind checking of property values may not immediately reflect changes to properties that interact with the sizing or layout characteristics (the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph> property, for example).</source>
          <target state="translated">Consultar um elemento por meio de lógica verificando valores de propriedade pode não refletir imediatamente alterações em propriedades que interagem com as características de dimensionamento ou layout (o <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph> propriedade, por exemplo).</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Measure(System.Windows.Size)">
          <source>Layout updates can be forced by using the <ph id="ph1">&lt;xref:System.Windows.UIElement.UpdateLayout%2A&gt;</ph> method.</source>
          <target state="translated">As atualizações de layout podem ser forçadas usando o <ph id="ph1">&lt;xref:System.Windows.UIElement.UpdateLayout%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Measure(System.Windows.Size)">
          <source>However, calling this method is usually unnecessary and can cause poor performance.</source>
          <target state="translated">No entanto, chamar esse método normalmente não é necessário e pode causar baixo desempenho.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Measure(System.Windows.Size)">
          <source>The layout system keeps two separate queues of invalid layouts, one for <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> and one for <ph id="ph2">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph>.</source>
          <target state="translated">O sistema de layout mantém duas filas separadas de layouts inválidos, uma para <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> e outra para <ph id="ph2">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Measure(System.Windows.Size)">
          <source>The layout queue is sorted based upon the order of elements in the visual tree of the element performing layout; elements higher in the tree are at the top of the queue, to avoid redundant layouts caused by repeated changes in parents.</source>
          <target state="translated">A fila de layout é classificada com base na ordem dos elementos na árvore visual do elemento de execução de layout; são superiores na árvore de elementos na parte superior da fila, para evitar a redundância layouts causados por alterações repetidas em pais.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Measure(System.Windows.Size)">
          <source>Duplicate entries are automatically removed from the queue, and elements are automatically removed from the queue if they are already layout-validated.</source>
          <target state="translated">Entradas duplicadas são automaticamente removidas da fila e os elementos são automaticamente removidos da fila se eles já são validados de layout.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Measure(System.Windows.Size)">
          <source>When updating layout, the <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> queue is emptied first, followed by the <ph id="ph2">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> queue.</source>
          <target state="translated">Ao atualizar o layout, o <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> fila é esvaziada primeiro, seguido de <ph id="ph2">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> fila.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.Measure(System.Windows.Size)">
          <source>An element in the <ph id="ph1">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> queue will never be arranged if there is an element in the <ph id="ph2">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> queue.</source>
          <target state="translated">Um elemento de <ph id="ph1">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> fila nunca será organizada se há um elemento no <ph id="ph2">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> fila.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)">
          <source>The available size that the parent element can allocate for the child.</source>
          <target state="translated">O tamanho disponível que o elemento pai pode alocar para o filho.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)">
          <source>When overridden in a derived class, provides measurement logic for sizing this element properly, with consideration of the size of any child element content.</source>
          <target state="translated">Quando substituído em uma classe derivada, fornece uma lógica de medida para o dimensionamento correto desse elemento, levando em consideração o tamanho do conteúdo de elementos filho.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)">
          <source>The desired size of this element in layout.</source>
          <target state="translated">O tamanho desejado desse elemento no layout.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)">
          <source>It is more common to derive an element from <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> rather than <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph>.</source>
          <target state="translated">É mais comum para derivar um elemento de <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> em vez de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)">
          <source>If you are deriving from <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, note that an override of <ph id="ph2">&lt;xref:System.Windows.UIElement.MeasureCore%2A&gt;</ph> on <ph id="ph3">&lt;xref:System.Windows.FrameworkElement&gt;</ph> seals the <ph id="ph4">&lt;xref:System.Windows.UIElement.MeasureCore%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver derivando de <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, observe que uma substituição de <ph id="ph2">&lt;xref:System.Windows.UIElement.MeasureCore%2A&gt;</ph> na <ph id="ph3">&lt;xref:System.Windows.FrameworkElement&gt;</ph> selos de <ph id="ph4">&lt;xref:System.Windows.UIElement.MeasureCore%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)">
          <source>Therefore, you only override <ph id="ph1">&lt;xref:System.Windows.UIElement.MeasureCore%2A&gt;</ph> as a means to alter layout measure characteristics if you derive from <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> through an inheritance that does not include <ph id="ph3">&lt;xref:System.Windows.FrameworkElement&gt;</ph>.</source>
          <target state="translated">Portanto, você apenas substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.MeasureCore%2A&gt;</ph> como um meio para alterar as características da medida de layout se você derivar de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> por meio de uma herança que não inclua <ph id="ph3">&lt;xref:System.Windows.FrameworkElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)">
          <source>This might be the case if you are attempting to build your own implementation on the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> core-level.</source>
          <target state="translated">Isso poderá acontecer se você estiver tentando criar sua própria implementação de <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> nível de núcleo.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)">
          <source>Otherwise, if you are deriving from <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, then the implementation template for Measure behavior is the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> implementation of .<ph id="ph3">&lt;xref:System.Windows.FrameworkElement.MeasureOverride%2A&gt;</ph>.</source>
          <target state="translated">Caso contrário, se você estiver derivando de <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, em seguida, o modelo de implementação para o comportamento de medida é o <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> implementação de.<ph id="ph3">&lt;xref:System.Windows.FrameworkElement.MeasureOverride%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)">
          <source>A parent element with child elements must call <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> on each child, otherwise these child elements are not sized or arranged and will effectively disappear from layout.</source>
          <target state="translated">Um elemento pai com elementos filho deve chamar <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> em cada filho, caso contrário, esses elementos filho não são dimensionados ou organizados e efetivamente desaparecerá do layout.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)">
          <source>A typical override of <ph id="ph1">&lt;xref:System.Windows.UIElement.MeasureCore%2A&gt;</ph> follows this approximate pattern (there is not a built-in collection called <ph id="ph2">`VisualChildren`</ph>; <ph id="ph3">`VisualChildren`</ph> is a  placeholder that represents whatever child collection your element maintains).</source>
          <target state="translated">Uma substituição típica de <ph id="ph1">&lt;xref:System.Windows.UIElement.MeasureCore%2A&gt;</ph> segue este padrão aproximado (não é uma coleção interna chamada <ph id="ph2">`VisualChildren`</ph>; <ph id="ph3">`VisualChildren`</ph> é um espaço reservado que representa qualquer coleção de filhos que mantém seu elemento).</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)">
          <source>You must call <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> on each child element.</source>
          <target state="translated">Você deve chamar <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> em cada elemento filho.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)">
          <source>Generally, your implementation should cache measurement information between the <ph id="ph1">&lt;xref:System.Windows.UIElement.MeasureCore%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.UIElement.ArrangeCore%2A&gt;</ph> method calls in the same element.</source>
          <target state="translated">Em geral, a implementação deve armazenar em cache informações de medição entre o <ph id="ph1">&lt;xref:System.Windows.UIElement.MeasureCore%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.UIElement.ArrangeCore%2A&gt;</ph> chamadas de método no mesmo elemento.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)">
          <source>Calling base implementations of <ph id="ph1">&lt;xref:System.Windows.UIElement.MeasureCore%2A&gt;</ph> is not required, but might be appropriate if the base implementation provides a desired layout capability.</source>
          <target state="translated">Chamar as implementações base de <ph id="ph1">&lt;xref:System.Windows.UIElement.MeasureCore%2A&gt;</ph> não é necessário, mas pode ser apropriado se a implementação base fornece uma funcionalidade de layout desejado.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)">
          <source>Calls to <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> on child elements should pass either the same <ph id="ph2">`availableSize`</ph> as the parent, or a subset of the area, depending on the type of layout the parent element supports.</source>
          <target state="translated">Chamadas para <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> no filho elementos devem transmitir o mesmo <ph id="ph2">`availableSize`</ph> como o pai, ou um subconjunto da área, dependendo do tipo de layout do elemento pai oferece suporte.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)">
          <source>For example, it would be valid to remove the area for an element-specific border or padding, a scrollbar, or a custom control.</source>
          <target state="translated">Por exemplo, seria válido para remover a área para uma elemento específico borda e preenchimento, uma barra de rolagem ou um controle personalizado.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)">
          <source>Implementations must be able to process a value provided for <ph id="ph1">&lt;paramref name="availableSize" /&gt;</ph> that is infinite.</source>
          <target state="translated">Implementações devem ser capazes de processar um valor fornecido para <ph id="ph1">&lt;paramref name="availableSize" /&gt;</ph> é infinito.</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)">
          <source>An infinite value indicates no requested constraints, and effectively defers measurement choice to the parent element, through recursive Measure calls.</source>
          <target state="translated">Um valor infinito não indica nenhuma restrição solicitada e efetivamente adia a escolha de medida ao elemento pai, por meio de recursiva que chama de medida.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)">
          <source>Implementations can consider the value provided for <ph id="ph1">&lt;paramref name="availableSize" /&gt;</ph> to be a soft constraint.</source>
          <target state="translated">Implementações podem considerar o valor fornecido para <ph id="ph1">&lt;paramref name="availableSize" /&gt;</ph> para ser uma restrição de software.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)">
          <source>The child element might specify a larger size, even if other aspects of application code were able to determine the current actual size of the parent element.</source>
          <target state="translated">O elemento filho pode especificar um tamanho maior, mesmo se outros aspectos do código do aplicativo foram capazes de determinar o tamanho real atual do elemento pai.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)">
          <source>The large size request is a convention that indicates that the child element is querying whether your parent element can support content scrolling within a content display region.</source>
          <target state="translated">A solicitação de tamanho grande é uma convenção que indica que o elemento filho está consultando se seu elemento pai pode dar suporte a rolagem conteúdo dentro de uma região de exibição de conteúdo.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.MouseDown">
          <source>Occurs when any mouse button is pressed while the pointer is over this element.</source>
          <target state="translated">Ocorre quando qualquer botão do mouse é pressionado enquanto o ponteiro está sobre este elemento.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseDown">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseDown&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseDown&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseDown">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseDown&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseDown&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseDown">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseDown&gt;</ph> event is often raised together with either <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseLeftButtonDown&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.UIElement.MouseRightButtonDown&gt;</ph>, which correspond to a press of one of the two standard mouse buttons.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseDown&gt;</ph> é normalmente gerado junto com o <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseLeftButtonDown&gt;</ph> ou <ph id="ph3">&lt;xref:System.Windows.UIElement.MouseRightButtonDown&gt;</ph>, que corresponde a um pressionamento de um dos dois botões de mouse padrão.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseDown">
          <source><ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonDown&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseRightButtonDown&gt;</ph> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <ph id="ph3">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> event reaches this element along the event route.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonDown&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseRightButtonDown&gt;</ph> também são eventos roteados, mas são eventos roteados diretos e o evento específico do botão apropriado é gerado quando o <ph id="ph3">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> evento atinge esse elemento na rota de evento.</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseDown">
          <source>See Remarks for <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonDown&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseRightButtonDown&gt;</ph>.</source>
          <target state="translated">Consulte os comentários para <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonDown&gt;</ph> ou <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseRightButtonDown&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseDown">
          <source>Some controls might have inherent class handling for mouse button events.</source>
          <target state="translated">Alguns controles podem ter inerente à classe de tratamento de eventos do botão do mouse.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseDown">
          <source>The left mouse button down event is the most likely event to have class handling in a control.</source>
          <target state="translated">O botão esquerdo do mouse para baixo de evento é o evento mais provável para ter um controle de manipulação de classe.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseDown">
          <source>The class handling often marks the underlying <ph id="ph1">&lt;xref:System.Windows.Input.Mouse&gt;</ph> class event as handled.</source>
          <target state="translated">A classe tratamento geralmente marca subjacente <ph id="ph1">&lt;xref:System.Windows.Input.Mouse&gt;</ph> classe de evento como manipulado.</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseDown">
          <source>Once the event is marked handled, other instance handlers that are attached to that element are not ordinarily raised.</source>
          <target state="translated">Depois que o evento é marcado como tratado, outros manipuladores de instância associados a esse elemento normalmente não são gerados.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseDown">
          <source>Any other class or instance handlers that are attached to elements in the bubbling direction towards the root in the UI tree are also not ordinarily raised.</source>
          <target state="translated">Outros classe ou instância manipuladores anexados a elementos na direção bolha na direção da raiz na árvore de interface do usuário também normalmente não são gerados.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseDown">
          <source>You can resolve the issue that is outlined in the preceding Important and still receive <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseDown&gt;</ph> events for left mouse button down events on a derived class that has class handling by using either of these solutions:</source>
          <target state="translated">Você pode resolver o problema descrito no importante anterior e ainda receber <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseDown&gt;</ph> eventos para o botão esquerdo do mouse para baixo de eventos em uma classe derivada que tem classe tratamento usando qualquer uma dessas soluções:</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseDown">
          <source>Attach handlers for the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseDown&gt;</ph> event, which is not marked as handled by the controls.</source>
          <target state="translated">Anexar manipuladores para o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseDown&gt;</ph> evento, que não está marcado como manipulados pelos controles.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseDown">
          <source>Notice that because this is a preview event, the route starts at the root and tunnels down to the control.</source>
          <target state="translated">Observe que, porque esse é um evento de visualização, a rota iniciado na raiz e túneis para o controle.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseDown">
          <source>Register a handler on the control procedurally by calling <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%2A&gt;</ph> and choosing the signature option that enables handlers to listen for events even if they are already marked as handled in the routed event data.</source>
          <target state="translated">Registrar um manipulador no controle de maneira procedural chamando <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%2A&gt;</ph> e escolhendo a opção de assinatura que permite que os manipuladores escutar eventos mesmo se eles ainda estão marcados como manipulados nos dados de evento roteado.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseDown">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseDown">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseDown">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseDown">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseDown">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseDown">
          <source>The corresponding tunneling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseDown&gt;</ph>.</source>
          <target state="translated">O evento de túnel correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseDown&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseDown">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseDown%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseDown%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.MouseDownEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseDown" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseDown" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseDownEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseDownEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseDownEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseDownEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseDownEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.MouseEnter">
          <source>Occurs when the mouse pointer enters the bounds of this element.</source>
          <target state="translated">Ocorre quando o ponteiro do mouse entra nos limites deste elemento.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseEnter">
          <source><ph id="ph1">&lt;xref:System.Windows.UIElement.MouseEnter&gt;</ph> is a  that uses the direct event handling routing strategy.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.UIElement.MouseEnter&gt;</ph> é um que usa o estratégia de roteamento de manipulação de eventos direto.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseEnter">
          <source>Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</source>
          <target state="translated">Os eventos roteados diretos não são gerados ao longo de uma rota; em vez disso, eles são manipulados no mesmo elemento em que eles são gerados.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseEnter">
          <source>However, they do enable other aspects of routed event behavior, such as event triggers in styles.</source>
          <target state="translated">No entanto, elas permitem que outros aspectos do comportamento de eventos roteados, como disparadores em estilos de eventos.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseEnter">
          <source>Although <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseEnter&gt;</ph> tracks when the mouse pointer enters the bounds of an element, this event more literally reports that the <ph id="ph2">&lt;xref:System.Windows.UIElement.IsMouseOver%2A&gt;</ph> property value has changed from <ph id="ph3">`false`</ph> to <ph id="ph4">`true`</ph> on this element.</source>
          <target state="translated">Embora <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseEnter&gt;</ph> controla quando o ponteiro do mouse entra nos limites de um elemento, esse evento mais literalmente informa que o <ph id="ph2">&lt;xref:System.Windows.UIElement.IsMouseOver%2A&gt;</ph> o valor da propriedade foi alterado de <ph id="ph3">`false`</ph> para <ph id="ph4">`true`</ph> neste elemento.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseEnter">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseEnter&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseEnter&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseEnter">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseEnter&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseEnter&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseEnter">
          <source>A <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> (or any <ph id="ph2">&lt;xref:System.Windows.Controls.Primitives.ButtonBase&gt;</ph> derived class) has native handling for a <ph id="ph3">&lt;xref:System.Windows.UIElement.KeyDown&gt;</ph> event when the button has focus, and the pressed key is the space bar.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> (ou qualquer <ph id="ph2">&lt;xref:System.Windows.Controls.Primitives.ButtonBase&gt;</ph> classe derivada) tem um tratamento nativo para um <ph id="ph3">&lt;xref:System.Windows.UIElement.KeyDown&gt;</ph> evento quando o botão tem foco e a tecla pressionada a barra de espaços.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseEnter">
          <source>The native handling raises the <ph id="ph1">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> event with the button as the source, and also captures the mouse, even though the mouse pointer does not appear to move.</source>
          <target state="translated">Gera o tratamento nativo de <ph id="ph1">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> eventos com o botão como a origem e também captura o mouse, mesmo que o ponteiro do mouse não aparecer mover.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseEnter">
          <source>As a result of the mouse capture, a <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseEnter&gt;</ph> event is also raised with the button as the source.</source>
          <target state="translated">Como resultado de captura do mouse, um <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseEnter&gt;</ph> evento também é gerado com o botão como a origem.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseEnter">
          <source>In general, if an element captures the mouse, then <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseEnter&gt;</ph> is raised, as well as <ph id="ph2">&lt;xref:System.Windows.UIElement.GotMouseCapture&gt;</ph> and possibly other control-specific events.</source>
          <target state="translated">Em geral, se um elemento captura o mouse, em seguida, <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseEnter&gt;</ph> é gerado, bem como <ph id="ph2">&lt;xref:System.Windows.UIElement.GotMouseCapture&gt;</ph> e possivelmente outros eventos de controle específicos.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseEnter">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseEnter">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseEnter">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseEnter">
          <source>Direct</source>
          <target state="translated">Direto</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseEnter">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseEnter">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseEnter%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseEnter%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.MouseEnterEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseEnter" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseEnter" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseEnterEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseEnterEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseEnterEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseEnterEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseEnterEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.MouseLeave">
          <source>Occurs when the mouse pointer leaves the bounds of this element.</source>
          <target state="translated">Ocorre quando o ponteiro do mouse sai dos limites deste elemento.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeave">
          <source><ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeave&gt;</ph> is a  that uses the direct event handling routing strategy.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeave&gt;</ph> é um que usa o estratégia de roteamento de manipulação de eventos direto.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeave">
          <source>Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</source>
          <target state="translated">Os eventos roteados diretos não são gerados ao longo de uma rota; em vez disso, eles são manipulados no mesmo elemento em que eles são gerados.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeave">
          <source>However, they do enable other aspects of routed event behavior, such as event triggers in styles.</source>
          <target state="translated">No entanto, elas permitem que outros aspectos do comportamento de eventos roteados, como disparadores em estilos de eventos.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeave">
          <source>Although <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeave&gt;</ph> tracks when the mouse leaves an element, this event more literally reports that the <ph id="ph2">&lt;xref:System.Windows.UIElement.IsMouseOver%2A&gt;</ph> property value has changed from <ph id="ph3">`true`</ph> to <ph id="ph4">`false`</ph> on this element.</source>
          <target state="translated">Embora <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeave&gt;</ph> controla quando o mouse sai um elemento, esse evento mais literalmente informa que o <ph id="ph2">&lt;xref:System.Windows.UIElement.IsMouseOver%2A&gt;</ph> o valor da propriedade foi alterado de <ph id="ph3">`true`</ph> para <ph id="ph4">`false`</ph> neste elemento.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeave">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseLeave&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseLeave&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeave">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeave&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeave&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeave">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeave">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeave">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeave">
          <source>Direct</source>
          <target state="translated">Direto</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeave">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeave">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseLeave%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseLeave%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.MouseLeaveEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseLeave" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseLeave" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseLeaveEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseLeaveEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseLeaveEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseLeaveEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseLeaveEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.MouseLeftButtonDown">
          <source>Occurs when the left mouse button is pressed while the mouse pointer is over this element.</source>
          <target state="translated">Ocorre quando o botão esquerdo do mouse é pressionado enquanto o ponteiro do mouse está sobre este elemento.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonDown">
          <source>Although this  seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>.</source>
          <target state="translated">Embora isso parece siga uma rota bolha por meio de uma árvore de elementos, na verdade é um evento roteado direto que é gerado e geradas novamente ao longo da árvore de elementos em cada <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonDown">
          <source>This event is one of several related events that report the mouse-button specifics of an underlying <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> event, which is an attached event that is processed by each element along an event route.</source>
          <target state="translated">Esse evento é um dos vários eventos relacionados que relatam as especificações de botão do mouse de uma base <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> evento, que é um evento que é processado por cada elemento de uma rota de evento.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonDown">
          <source>The event data of this event exposes the event data of the underlying <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Os dados de evento deste evento expõe os dados do evento de subjacente <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> eventos.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonDown">
          <source>If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%2A&gt;</ph>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</source>
          <target state="translated">Se esse evento é marcado como manipulado na rota de evento, os eventos específicos do botão do mouse ainda são gerados; No entanto, os manipuladores de eventos específicos de botão do mouse devem ser adicionados explicitamente chamando <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%2A&gt;</ph>, com a opção para lidar com eventos que já estão marcados como manipulados, para ser ouvintes para o evento.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonDown">
          <source>If you mark <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonDown&gt;</ph> handled, you are essentially marking <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> handled for all further listeners along the route, and on all related events.</source>
          <target state="translated">Se você marcar <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonDown&gt;</ph> tratados, você está essencialmente marcando <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> tratado para todas as outras ouvintes na rota e em todos os eventos relacionados.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonDown">
          <source>This possibly includes class-handler generated events such as <ph id="ph1">&lt;xref:System.Windows.Controls.Control.MouseDoubleClick&gt;</ph>.</source>
          <target state="translated">Isso possivelmente inclui eventos gerado pelo manipulador de classe, como <ph id="ph1">&lt;xref:System.Windows.Controls.Control.MouseDoubleClick&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonDown">
          <source>Conceptually, think of this event (and other mouse-button events on <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>) to be a mouse "service" (with the service definition provided by the <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> class).</source>
          <target state="translated">Pense conceitualmente, esse evento (e outros eventos de botão do mouse em <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>) para ser um mouse "serviço" (com a definição de serviço fornecida pelo <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> classe).</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonDown">
          <source>The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</source>
          <target state="translated">O evento adiciona a conveniência de não precisar verificar os estados de botão do mouse (esquerda-direita, para cima para baixo) dos eventos de mouse original nos dados do evento.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonDown">
          <source>For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the <ph id="ph1">[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]</ph> on the <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> class rather than those on <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph>.</source>
          <target state="translated">Para cenários mais avançados, como verificação de estados de botões não padrão, talvez seja necessário usar o <ph id="ph1">[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]</ph> no <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> classe em vez de aqueles em <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonDown">
          <source>Some control classes might have inherent class handling for mouse button events.</source>
          <target state="translated">Algumas classes de controle podem ter inerente à classe de tratamento de eventos do botão do mouse.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonDown">
          <source>The left mouse button down event is the most likely event to have class handling in a control.</source>
          <target state="translated">O botão esquerdo do mouse para baixo de evento é o evento mais provável para ter um controle de manipulação de classe.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonDown">
          <source>The class handling often marks the underlying <ph id="ph1">&lt;xref:System.Windows.Input.Mouse&gt;</ph> class event as handled.</source>
          <target state="translated">A classe tratamento geralmente marca subjacente <ph id="ph1">&lt;xref:System.Windows.Input.Mouse&gt;</ph> classe de evento como manipulado.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonDown">
          <source>Once the event is marked handled, other instance handlers that are attached to that element are not ordinarily raised.</source>
          <target state="translated">Depois que o evento é marcado como tratado, outros manipuladores de instância associados a esse elemento normalmente não são gerados.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonDown">
          <source>Any other class or instance handlers that are attached to elements in the bubbling direction towards the root in the UI tree are also not ordinarily raised.</source>
          <target state="translated">Outros classe ou instância manipuladores anexados a elementos na direção bolha na direção da raiz na árvore de interface do usuário também normalmente não são gerados.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonDown">
          <source>You can resolve the issue that is outlined in the preceding Important and still receive <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonDown&gt;</ph> events for left mouse button down events on a derived class that has class handling by using either of these solutions:</source>
          <target state="translated">Você pode resolver o problema descrito no importante anterior e ainda receber <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonDown&gt;</ph> eventos para o botão esquerdo do mouse para baixo de eventos em uma classe derivada que tem classe tratamento usando qualquer uma dessas soluções:</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonDown">
          <source>Attach handlers for the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseDown&gt;</ph> event, which is not marked as handled by the controls.</source>
          <target state="translated">Anexar manipuladores para o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseDown&gt;</ph> evento, que não está marcado como manipulados pelos controles.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonDown">
          <source>Notice that because this is a preview event, the route starts at the root and tunnels down to the control.</source>
          <target state="translated">Observe que, porque esse é um evento de visualização, a rota iniciado na raiz e túneis para o controle.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonDown">
          <source>Register a handler on the control procedurally by calling <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%2A&gt;</ph> and choosing the signature option that enables handlers to listen for events even if they are already marked as handled in the routed event data.</source>
          <target state="translated">Registrar um manipulador no controle de maneira procedural chamando <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%2A&gt;</ph> e escolhendo a opção de assinatura que permite que os manipuladores escutar eventos mesmo se eles ainda estão marcados como manipulados nos dados de evento roteado.</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonDown">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonDown">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonDown">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonDown">
          <source>Direct</source>
          <target state="translated">Direto</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonDown">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonDown">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.MouseLeftButtonDownEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseLeftButtonDown" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseLeftButtonDown" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseLeftButtonDownEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseLeftButtonDownEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseLeftButtonDownEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseLeftButtonDownEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseLeftButtonDownEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.MouseLeftButtonUp">
          <source>Occurs when the left mouse button is released while the mouse pointer is over this element.</source>
          <target state="translated">Ocorre quando o botão esquerdo do mouse é liberado enquanto o ponteiro do mouse está sobre este elemento.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonUp">
          <source>Although this  seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>.</source>
          <target state="translated">Embora isso parece siga uma rota bolha por meio de uma árvore de elementos, na verdade é um evento roteado direto que é gerado e geradas novamente ao longo da árvore de elementos em cada <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonUp">
          <source>This event is one of several related events that report the mouse-button specifics of an underlying <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph> event, which is an attached event that is processed by each element along an event route.</source>
          <target state="translated">Esse evento é um dos vários eventos relacionados que relatam as especificações de botão do mouse de uma base <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph> evento, que é um evento que é processado por cada elemento de uma rota de evento.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonUp">
          <source>The event data of this event exposes the event data of the underlying <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Os dados de evento deste evento expõe os dados do evento de subjacente <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph> eventos.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonUp">
          <source>If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%2A&gt;</ph>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</source>
          <target state="translated">Se esse evento é marcado como manipulado na rota de evento, os eventos específicos do botão do mouse ainda são gerados; No entanto, os manipuladores de eventos específicos de botão do mouse devem ser adicionados explicitamente chamando <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%2A&gt;</ph>, com a opção para lidar com eventos que já estão marcados como manipulados, para ser ouvintes para o evento.</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonUp">
          <source>If you mark <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonUp&gt;</ph> handled, you are essentially marking <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph> handled for all further listeners along the route, and on all related events.</source>
          <target state="translated">Se você marcar <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonUp&gt;</ph> tratados, você está essencialmente marcando <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph> tratado para todas as outras ouvintes na rota e em todos os eventos relacionados.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonUp">
          <source>Conceptually, think of this event (and other mouse-button events on <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>) to be a mouse "service" (with the service definition provided by the <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> class).</source>
          <target state="translated">Pense conceitualmente, esse evento (e outros eventos de botão do mouse em <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>) para ser um mouse "serviço" (com a definição de serviço fornecida pelo <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> classe).</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonUp">
          <source>The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</source>
          <target state="translated">O evento adiciona a conveniência de não precisar verificar os estados de botão do mouse (esquerda-direita, para cima para baixo) dos eventos de mouse original nos dados do evento.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonUp">
          <source>For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the <ph id="ph1">[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]</ph> on the <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> class rather than those on <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph>.</source>
          <target state="translated">Para cenários mais avançados, como verificação de estados de botões não padrão, talvez seja necessário usar o <ph id="ph1">[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]</ph> no <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> classe em vez de aqueles em <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonUp">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonUp">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonUp">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonUp">
          <source>Direct</source>
          <target state="translated">Direto</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonUp">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseLeftButtonUp">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseLeftButtonUp%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseLeftButtonUp%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.MouseLeftButtonUpEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseLeftButtonUp" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseLeftButtonUp" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseLeftButtonUpEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseLeftButtonUpEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseLeftButtonUpEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseLeftButtonUpEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseLeftButtonUpEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.MouseMove">
          <source>Occurs when the mouse pointer moves while over this element.</source>
          <target state="translated">Ocorre quando o ponteiro do mouse se move enquanto está sobre este elemento.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseMove">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseMove&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseMove&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseMove">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseMove&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseMove&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseMove">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseMove">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseMove">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseMove">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseMove">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseMove">
          <source>The corresponding tunneling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseMove&gt;</ph>.</source>
          <target state="translated">O evento de túnel correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseMove&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseMove">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseMove%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseMove%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.MouseMoveEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseMove" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseMove" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseMoveEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseMoveEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseMoveEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseMoveEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseMoveEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.MouseRightButtonDown">
          <source>Occurs when the right mouse button is pressed while the mouse pointer is over this element.</source>
          <target state="translated">Ocorre quando o botão direito do mouse é pressionado enquanto o ponteiro do mouse está sobre este elemento.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonDown">
          <source>Although this  seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>.</source>
          <target state="translated">Embora isso parece siga uma rota bolha por meio de uma árvore de elementos, na verdade é um evento roteado direto que é gerado e geradas novamente ao longo da árvore de elementos em cada <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonDown">
          <source>This event is one of several related events that report the mouse-button specifics of an underlying <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> event, which is an attached event that is processed by each element along an event route.</source>
          <target state="translated">Esse evento é um dos vários eventos relacionados que relatam as especificações de botão do mouse de uma base <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> evento, que é um evento que é processado por cada elemento de uma rota de evento.</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonDown">
          <source>The event data of this event exposes the event data of the underlying <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Os dados de evento deste evento expõe os dados do evento de subjacente <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> eventos.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonDown">
          <source>If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%2A&gt;</ph>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</source>
          <target state="translated">Se esse evento é marcado como manipulado na rota de evento, os eventos específicos do botão do mouse ainda são gerados; No entanto, os manipuladores de eventos específicos de botão do mouse devem ser adicionados explicitamente chamando <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%2A&gt;</ph>, com a opção para lidar com eventos que já estão marcados como manipulados, para ser ouvintes para o evento.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonDown">
          <source>If you mark <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseRightButtonDown&gt;</ph> handled, you are essentially marking <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> handled for all further listeners along the route, and on all related events.</source>
          <target state="translated">Se você marcar <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseRightButtonDown&gt;</ph> tratados, você está essencialmente marcando <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> tratado para todas as outras ouvintes na rota e em todos os eventos relacionados.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonDown">
          <source>This possibly includes class-handler generated events such as <ph id="ph1">&lt;xref:System.Windows.Controls.Control.MouseDoubleClick&gt;</ph>.</source>
          <target state="translated">Isso possivelmente inclui eventos gerado pelo manipulador de classe, como <ph id="ph1">&lt;xref:System.Windows.Controls.Control.MouseDoubleClick&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonDown">
          <source>Conceptually, think of this event (and other mouse-button events on <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>) to be a mouse "service" (with the service definition provided by the <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> class).</source>
          <target state="translated">Pense conceitualmente, esse evento (e outros eventos de botão do mouse em <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>) para ser um mouse "serviço" (com a definição de serviço fornecida pelo <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> classe).</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonDown">
          <source>The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</source>
          <target state="translated">O evento adiciona a conveniência de não precisar verificar os estados de botão do mouse (esquerda-direita, para cima para baixo) dos eventos de mouse original nos dados do evento.</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonDown">
          <source>For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the <ph id="ph1">[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]</ph> on the <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> class rather than those on <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph>.</source>
          <target state="translated">Para cenários mais avançados, como verificação de estados de botões não padrão, talvez seja necessário usar o <ph id="ph1">[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]</ph> no <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> classe em vez de aqueles em <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonDown">
          <source>Right button mouse events frequently have native handling in application scenarios.</source>
          <target state="translated">Eventos do botão direito do mouse frequentemente têm tratamento nativo em cenários de aplicativo.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonDown">
          <source>For instance, a right mouse button down might display a context menu.</source>
          <target state="translated">Por exemplo, um botão direito do mouse para baixo pode exibir um menu de contexto.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonDown">
          <source>See <bpt id="p1">[</bpt>ContextMenu Overview<ept id="p1">](~/docs/framework/wpf/controls/contextmenu-overview.md)</ept>.</source>
          <target state="translated">Consulte <bpt id="p1">[</bpt>visão geral do ContextMenu<ept id="p1">](~/docs/framework/wpf/controls/contextmenu-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonDown">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonDown">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonDown">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonDown">
          <source>Direct</source>
          <target state="translated">Direto</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonDown">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonDown">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseRightButtonDown%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseRightButtonDown%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.MouseRightButtonDownEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseRightButtonDown" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseRightButtonDown" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseRightButtonDownEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseRightButtonDownEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseRightButtonDownEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseRightButtonDownEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseRightButtonDownEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.MouseRightButtonUp">
          <source>Occurs when the right mouse button is released while the mouse pointer is over this element.</source>
          <target state="translated">Ocorre quando o botão direito do mouse é liberado enquanto o ponteiro do mouse está sobre este elemento.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonUp">
          <source>Although this  seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>.</source>
          <target state="translated">Embora isso parece siga uma rota bolha por meio de uma árvore de elementos, na verdade é um evento roteado direto que é gerado e geradas novamente ao longo da árvore de elementos em cada <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonUp">
          <source>This event is one of several related events that report the mouse-button specifics of an underlying <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph> event, which is an attached event that is processed by each element along an event route.</source>
          <target state="translated">Esse evento é um dos vários eventos relacionados que relatam as especificações de botão do mouse de uma base <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph> evento, que é um evento que é processado por cada elemento de uma rota de evento.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonUp">
          <source>The event data of this event exposes the event data of the underlying <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Os dados de evento deste evento expõe os dados do evento de subjacente <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph> eventos.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonUp">
          <source>If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%2A&gt;</ph>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</source>
          <target state="translated">Se esse evento é marcado como manipulado na rota de evento, os eventos específicos do botão do mouse ainda são gerados; No entanto, os manipuladores de eventos específicos de botão do mouse devem ser adicionados explicitamente chamando <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%2A&gt;</ph>, com a opção para lidar com eventos que já estão marcados como manipulados, para ser ouvintes para o evento.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonUp">
          <source>If you mark <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseRightButtonUp&gt;</ph> handled, you are essentially marking <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> handled for all further listeners along the route, and on all related events.</source>
          <target state="translated">Se você marcar <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseRightButtonUp&gt;</ph> tratados, você está essencialmente marcando <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> tratado para todas as outras ouvintes na rota e em todos os eventos relacionados.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonUp">
          <source>Conceptually, think of this event (and other mouse-button events on <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>) to be a mouse "service" (with the service definition provided by the <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> class).</source>
          <target state="translated">Pense conceitualmente, esse evento (e outros eventos de botão do mouse em <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>) para ser um mouse "serviço" (com a definição de serviço fornecida pelo <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> classe).</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonUp">
          <source>The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</source>
          <target state="translated">O evento adiciona a conveniência de não precisar verificar os estados de botão do mouse (esquerda-direita, para cima para baixo) dos eventos de mouse original nos dados do evento.</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonUp">
          <source>For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the <ph id="ph1">[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]</ph> on the <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> class rather than those on <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph>.</source>
          <target state="translated">Para cenários mais avançados, como verificação de estados de botões não padrão, talvez seja necessário usar o <ph id="ph1">[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]</ph> no <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> classe em vez de aqueles em <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonUp">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonUp">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonUp">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonUp">
          <source>Direct</source>
          <target state="translated">Direto</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonUp">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseRightButtonUp">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseRightButtonUp%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseRightButtonUp%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.MouseRightButtonUpEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseRightButtonUp" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseRightButtonUp" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseRightButtonUpEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseRightButtonUpEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseRightButtonUpEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseRightButtonUpEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseRightButtonUpEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.MouseUp">
          <source>Occurs when any mouse button is released over this element.</source>
          <target state="translated">Ocorre quando qualquer botão do mouse é liberado sobre este elemento.</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseUp">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseUp&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseUp&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseUp">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseUp&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseUp&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseUp">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseUp&gt;</ph> event is often raised together with either <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseLeftButtonUp&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.UIElement.MouseRightButtonUp&gt;</ph>, which correspond to a release of one of the two standard mouse buttons.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseUp&gt;</ph> é normalmente gerado junto com o <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseLeftButtonUp&gt;</ph> ou <ph id="ph3">&lt;xref:System.Windows.UIElement.MouseRightButtonUp&gt;</ph>, que corresponde a uma versão de um dos dois botões de mouse padrão.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseUp">
          <source><ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonUp&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseRightButtonUp&gt;</ph> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <ph id="ph3">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> event reaches this element along the event route.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonUp&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseRightButtonUp&gt;</ph> também são eventos roteados, mas são eventos roteados diretos e o evento específico do botão apropriado é gerado quando o <ph id="ph3">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> evento atinge esse elemento na rota de evento.</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseUp">
          <source>See Remarks for <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonUp&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseRightButtonUp&gt;</ph>.</source>
          <target state="translated">Consulte os comentários para <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonUp&gt;</ph> ou <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseRightButtonUp&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseUp">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseUp">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseUp">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseUp">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseUp">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseUp">
          <source>The corresponding tunneling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseUp&gt;</ph>.</source>
          <target state="translated">O evento de túnel correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseUp&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseUp">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseUp%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseUp%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.MouseUpEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseUp" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseUp" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseUpEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseUpEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseUpEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseUpEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseUpEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.MouseWheel">
          <source>Occurs when the user rotates the mouse wheel while the mouse pointer is over this element.</source>
          <target state="translated">Ocorre quando o usuário gira a roda do mouse enquanto o ponteiro do mouse está sobre este elemento.</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseWheel">
          <source>Focus or mouse capture take precedence over where the mouse pointer is; therefore, if you receive the <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseWheel&gt;</ph> event from a focused or captured element, the mouse pointer might actually be over another element.</source>
          <target state="translated">Captura de foco ou mouse têm precedência sobre onde o ponteiro do mouse é; Portanto, se você receber o <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseWheel&gt;</ph> evento de um elemento focalizado ou capturado, o ponteiro do mouse, na verdade, pode ser em outro elemento.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseWheel">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseWheel&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseWheel&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseWheel">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseWheel&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseWheel&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseWheel">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseWheel">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseWheel">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseWheel">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseWheel">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseWheel">
          <source>The corresponding tunneling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseWheel&gt;</ph>.</source>
          <target state="translated">O evento de túnel correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseWheel&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.MouseWheel">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseWheel%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseWheel%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.MouseWheelEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseWheel" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseWheel" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseWheelEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseWheelEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseWheelEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseWheelEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.MouseWheelEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source>A traversal request, which contains a property that indicates either a mode to traverse in existing tab order, or a direction to move visually.</source>
          <target state="translated">Uma solicitação de passagem, que contém uma propriedade que indica um modo para percorrer uma ordem de tabulação existente ou uma direção de movimentação visualmente.</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source>Attempts to move focus from this element to another element.</source>
          <target state="translated">Tenta mover o foco deste para outro elemento.</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source>The direction to move focus is specified by a guidance direction, which is interpreted within the organization of the visual parent for this element.</source>
          <target state="translated">A direção para mover o foco é especificada por uma direção de diretrizes, que é interpretada dentro da organização do pai visual deste elemento.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the requested traversal was performed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se a passagem solicitada foi executada; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source>Make sure you check the return value of this method.</source>
          <target state="translated">Certifique-se de que verificar o valor de retorno deste método.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source>A return value of <ph id="ph1">`false`</ph> might be returned if the traversal runs into a tab stop that is defined by a control's composition, and the traversal request did not request to wrap.</source>
          <target state="translated">Um valor de retorno <ph id="ph1">`false`</ph> pode ser retornado se o percurso é executado em uma parada de tabulação é definida pela composição de um controle e a solicitação de passagem não solicitou a encapsular.</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)">
          <source>The event data to the access key event.</source>
          <target state="translated">Os dados de evento para o evento de chave de acesso.</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)">
          <source>The event data reports which key was invoked, and indicate whether the <ph id="ph1">&lt;see cref="T:System.Windows.Input.AccessKeyManager" /&gt;</ph> object that controls the sending of these events also sent this access key invocation to other elements.</source>
          <target state="translated">Os relatórios de dados de evento cuja chave foi chamada e indica se o objeto <ph id="ph1">&lt;see cref="T:System.Windows.Input.AccessKeyManager" /&gt;</ph> que controla o envio desses eventos também envia essa chamada de chave de acesso a outros elementos.</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)">
          <source>Provides class handling for when an access key that is meaningful for this element is invoked.</source>
          <target state="translated">Fornece tratamento de classes para quando uma chave de acesso que seja significativa para esse elemento é chamada.</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)">
          <source>There is no actual AccessKey event in the <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> class, or elsewhere, which you can raise or attach handlers for.</source>
          <target state="translated">Não há nenhum evento AccessKey real no <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> classe, ou em outro local, que você pode gerar ou anexar manipuladores para.</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)">
          <source>Instead, the event is originated via a dedicated manager class, <ph id="ph1">&lt;xref:System.Windows.Input.AccessKeyManager&gt;</ph>, which post-processes all input to search for access keys that are applicable to the entire input model.</source>
          <target state="translated">Em vez disso, o evento foi originado por meio de uma classe de gerente dedicado, <ph id="ph1">&lt;xref:System.Windows.Input.AccessKeyManager&gt;</ph>, que processa após todas as entradas para procurar as chaves de acesso que se aplicam a todo o modelo de entrada.</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)">
          <source>The default implementation of this method in <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> sets keyboard focus to this element (by calling <ph id="ph2">&lt;see cref="M:System.Windows.UIElement.Focus" /&gt;</ph>).</source>
          <target state="translated">A implementação padrão desse método na <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> define o foco para esse elemento de teclado (chamando <ph id="ph2">&lt;see cref="M:System.Windows.UIElement.Focus" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)">
          <source>Implementations should perpetuate this behavior if they are focusable, because it is an expected behavior for accessibility scenarios.</source>
          <target state="translated">Implementações devem perpetuar esse comportamento se eles estiverem Focusable é, porque ele é um comportamento esperado para cenários de acessibilidade.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)">
          <source>Note that the base implementation does nothing with the passed event data and raises no further event; it just sets the focus.</source>
          <target state="translated">Observe que a implementação base não faz nada com os dados passados pelo evento e não gera nenhum evento adicional; Ele define apenas o foco.</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)">
          <source>The child element that is being resized.</source>
          <target state="translated">O elemento filho que está sendo redimensionado.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)">
          <source>Supports layout behavior when a child element is resized.</source>
          <target state="translated">Dá suporte ao comportamento de layout quando um elemento filho é redimensionado.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)">
          <source>This method is typically not called by your application code.</source>
          <target state="translated">Normalmente, este método não é chamado pelo código do aplicativo.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)">
          <source>It is exposed so that derived element classes can make further checks on their own possibly invalid layout state.</source>
          <target state="translated">Ele é exposto para que esse elemento derivado classes podem tornar mais verifica no seu próprio estado layout possivelmente inválida.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)">
          <source>Classes could also attempt optimizations to minimize the processing time for a layout pass based on size changes to child elements.</source>
          <target state="translated">Classes também poderá tentar otimizações para minimizar o tempo de processamento de uma passagem de layout com base nas alterações de tamanho para elementos filho.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)">
          <source>An example derived element class that implements <ph id="ph1">&lt;xref:System.Windows.UIElement.OnChildDesiredSizeChanged%2A&gt;</ph> is the <ph id="ph2">&lt;xref:System.Windows.Controls.Grid&gt;</ph> control.</source>
          <target state="translated">Derivado de um exemplo de classe de elemento que implementa <ph id="ph1">&lt;xref:System.Windows.UIElement.OnChildDesiredSizeChanged%2A&gt;</ph> é o <ph id="ph2">&lt;xref:System.Windows.Controls.Grid&gt;</ph> controle.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)">
          <source>The <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)" /&gt;</ph> method has the default implementation of calling <ph id="ph2">&lt;see cref="M:System.Windows.UIElement.InvalidateMeasure" /&gt;</ph> on itself.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)" /&gt;</ph> a implementação padrão de chamada do método tem <ph id="ph2">&lt;see cref="M:System.Windows.UIElement.InvalidateMeasure" /&gt;</ph> em si mesmo.</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)">
          <source>A typical implementation would be: do whatever optimization your own element supports, and then typically call base <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)" /&gt;</ph> from at least one of the code branches (the one that indicated "dirty" state per your own measure caching logic).</source>
          <target state="translated">Uma implementação típica seria: fazer qualquer otimização seu próprio elemento oferece suporte e, em seguida, normalmente chama base <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)" /&gt;</ph> de pelo menos uma das ramificações de código (aquele indicado "sujo" estado por sua própria lógica de cache de medida).</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)">
          <source>This method is only called in the layout processing if it was the child itself that originated the size changes.</source>
          <target state="translated">Esse método é chamado somente no layout de processamento se fosse o próprio filho que originou as alterações de tamanho.</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)">
          <source>Otherwise, if the parent element initiates the <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" /&gt;</ph> pass, according to the layout system rules, the parent is recalculating layout already.</source>
          <target state="translated">Caso contrário, se o elemento pai inicia o <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" /&gt;</ph> passar, de acordo com as regras do sistema de layout, o pai é recalcular layout já.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)">
          <source>The layout system processes layout in the order of child-to-parent, so no return to parent element sizing from the child element layout calls is necessary.</source>
          <target state="translated">O sistema de layout processa layout na ordem filho-pai, portanto, não retornar ao dimensionamento do elemento pai em chamadas de layout do elemento filho é necessário.</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnCreateAutomationPeer">
          <source>Returns class-specific <ph id="ph1">&lt;see cref="T:System.Windows.Automation.Peers.AutomationPeer" /&gt;</ph> implementations for the <ph id="ph2">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> infrastructure.</source>
          <target state="translated">Retorna implementações de <ph id="ph1">&lt;see cref="T:System.Windows.Automation.Peers.AutomationPeer" /&gt;</ph> específicas à classe para a infra-estrutura de <ph id="ph2">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnCreateAutomationPeer">
          <source>The type-specific <ph id="ph1">&lt;see cref="T:System.Windows.Automation.Peers.AutomationPeer" /&gt;</ph> implementation.</source>
          <target state="translated">A implementação de <ph id="ph1">&lt;see cref="T:System.Windows.Automation.Peers.AutomationPeer" /&gt;</ph> específica ao tipo.</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnCreateAutomationPeer">
          <source>The implementation of this method is typically to call the constructor of a specific <ph id="ph1">&lt;see cref="T:System.Windows.Automation.Peers.AutomationPeer" /&gt;</ph> implementation, and return it as the return value.</source>
          <target state="translated">A implementação deste método é normalmente chamar o construtor de um determinado <ph id="ph1">&lt;see cref="T:System.Windows.Automation.Peers.AutomationPeer" /&gt;</ph> implementação e retorná-lo como o valor de retorno.</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnCreateAutomationPeer">
          <source>All <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> derived classes should implement this method in order to provide their own specific <ph id="ph2">&lt;see cref="T:System.Windows.Automation.Peers.AutomationPeer" /&gt;</ph> implementations to the <ph id="ph3">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> infrastructure.</source>
          <target state="translated">Todos os <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> classes derivadas devem implementar esse método para fornecer sua próprias específico <ph id="ph2">&lt;see cref="T:System.Windows.Automation.Peers.AutomationPeer" /&gt;</ph> implementações para o <ph id="ph3">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> infraestrutura.</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnCreateAutomationPeer">
          <source>For details on implementing this pattern, see <ph id="ph1">&lt;see cref="T:System.Windows.Automation.Peers.AutomationPeer" /&gt;</ph>.</source>
          <target state="translated">Para obter detalhes sobre como implementar esse padrão, consulte <ph id="ph1">&lt;see cref="T:System.Windows.Automation.Peers.AutomationPeer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.DragEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.DragEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.DragDrop.DragEnter" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.DragDrop.DragEnter" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.DragEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.DragEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.DragDrop.DragLeave" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.DragDrop.DragLeave" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.DragEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.DragEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.DragDrop.DragOver" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.DragDrop.DragOver" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.DragEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.DragEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.DragDrop.DragEnter" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.DragDrop.DragEnter" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.GiveFeedbackEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.GiveFeedbackEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.DragDrop.GiveFeedback" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.DragDrop.GiveFeedback" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph> that contains event data.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph> que contém dados do evento.</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>This event data must contain the identifier for the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.GotFocus" /&gt;</ph> event.</source>
          <target state="translated">Esses dados de evento devem conter o identificador para o evento <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.GotFocus" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>Raises the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.GotFocus" /&gt;</ph> routed event by using the event data provided.</source>
          <target state="translated">Gera o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.GotFocus" /&gt;</ph> usando os dados de evento fornecidos.</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>This method, although virtual, does have a default implementation that raises the event.</source>
          <target state="translated">Esse método, embora virtuais, têm uma implementação padrão que gera o evento.</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>This On* method implementation is intended to raise the event, and this same method implementation is invoked internally to raise the event when the <ph id="ph1">&lt;xref:System.Windows.UIElement.IsFocused%2A&gt;</ph> property value changes.</source>
          <target state="translated">Isso em * implementação do método destina-se para gerar o evento, e essa mesma implementação de método é chamada internamente para gerar o evento quando o <ph id="ph1">&lt;xref:System.Windows.UIElement.IsFocused%2A&gt;</ph> alterações de valor de propriedade.</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.OnGotFocus%2A&gt;</ph> implementation differs from some other <ph id="ph2">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> On* implementations, which only provide a convenient way to add class handling for that event.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.OnGotFocus%2A&gt;</ph> implementação difere de outros <ph id="ph2">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> em * implementações, que apenas fornecem uma maneira conveniente para Adicionar classe de tratamento de evento.</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>Unless you have a deliberate and unusual need to not raise the focus events, make sure that your implementation calls the base implementation.</source>
          <target state="translated">A menos que você tenha uma necessidade incomuns e deliberada para não gerar os eventos de foco, certifique-se de que sua implementação chama a implementação base.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>Otherwise, the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.GotFocus" /&gt;</ph> event is not raised during typical user operations that ordinarily set focus to this element.</source>
          <target state="translated">Caso contrário, o <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.GotFocus" /&gt;</ph> evento não é gerado durante operações de usuário comum que normalmente definir o foco para esse elemento.</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>If you do not intend your element to be focusable, you can prevent the element from being focusable by setting <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.Focusable" /&gt;</ph> to <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Se você não pretende ser Focusable é o elemento, você pode impedir que o elemento que está sendo Focusable é definindo <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.Focusable" /&gt;</ph> para <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)">
          <source>Provides class handling for the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.GotTouchCapture" /&gt;</ph> routed event that occurs when a touch is captured to this element.</source>
          <target state="translated">Fornece tratamento de classes para os eventos roteados <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.GotTouchCapture" /&gt;</ph> que ocorrem quando um toque é capturado para esse elemento.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.OnGotTouchCapture%2A&gt;</ph> method has no default implementation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.OnGotTouchCapture%2A&gt;</ph> método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnGotTouchCapture%2A&gt;</ph> in a derived class to handle the <ph id="ph2">&lt;xref:System.Windows.UIElement.GotTouchCapture&gt;</ph> event.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnGotTouchCapture%2A&gt;</ph> em uma classe derivada para manipular o <ph id="ph2">&lt;xref:System.Windows.UIElement.GotTouchCapture&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)">
          <source>Be sure to call the base class’s <ph id="ph1">&lt;xref:System.Windows.UIElement.OnGotTouchCapture%2A&gt;</ph> method so that base classes receive the event.</source>
          <target state="translated">Certifique-se de chamar a classe base <ph id="ph1">&lt;xref:System.Windows.UIElement.OnGotTouchCapture%2A&gt;</ph> método para classes de base que receber o evento.</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.IsKeyboardFocusedChanged" /&gt;</ph> event is raised on this element.</source>
          <target state="translated">Invocado quando um evento <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.IsKeyboardFocusedChanged" /&gt;</ph> sem tratamento é gerado nesse elemento.</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This virtual method is raised when the value of the <ph id="ph1">&lt;xref:System.Windows.UIElement.IsKeyboardFocused%2A&gt;</ph> dependency property changes.</source>
          <target state="translated">Esse método virtual é gerado quando o valor de <ph id="ph1">&lt;xref:System.Windows.UIElement.IsKeyboardFocused%2A&gt;</ph> alterações de propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The virtual method is raised first and can manipulate the event data as necessary.</source>
          <target state="translated">O método virtual é gerado pela primeira vez e pode manipular os dados de evento conforme necessário.</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Then the <ph id="ph1">&lt;xref:System.Windows.UIElement.IsKeyboardFocusedChanged&gt;</ph> event is raised with that same event data instance.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.IsKeyboardFocusedChanged&gt;</ph> é gerado com essa mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Notice that the  <ph id="ph1">&lt;xref:System.Windows.UIElement.IsKeyboardFocusedChanged&gt;</ph> event is not a routed event.</source>
          <target state="translated">Observe que o <ph id="ph1">&lt;xref:System.Windows.UIElement.IsKeyboardFocusedChanged&gt;</ph> não é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Therefore, you cannot mark it as handled in the class handler.</source>
          <target state="translated">Portanto, você não pode marcá-lo tratados no manipulador de classe.</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>You may call base either before or after your special handling, depending on your requirements.</source>
          <target state="translated">Você pode chamar base antes ou depois do tratamento especial, dependendo dos seus requisitos.</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Invoked just before the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.IsKeyboardFocusWithinChanged" /&gt;</ph> event is raised by this element.</source>
          <target state="translated">Invocado pouco antes do evento <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.IsKeyboardFocusWithinChanged" /&gt;</ph> ser gerado por este elemento.</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This virtual method is raised when the value of the <ph id="ph1">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A&gt;</ph> dependency property changes .</source>
          <target state="translated">Esse método virtual é gerado quando o valor de <ph id="ph1">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A&gt;</ph> alterações de propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The virtual method is raised first and can manipulate the event data as necessary.</source>
          <target state="translated">O método virtual é gerado pela primeira vez e pode manipular os dados de evento conforme necessário.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Then the <ph id="ph1">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged&gt;</ph> event is raised with that same event data instance.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged&gt;</ph> é gerado com essa mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Notice that the <ph id="ph1">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged&gt;</ph> event is not a routed event.</source>
          <target state="translated">Observe que o <ph id="ph1">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged&gt;</ph> não é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Therefore, you cannot mark it as handled in the class handler.</source>
          <target state="translated">Portanto, você não pode marcá-lo tratados no manipulador de classe.</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>You may call base either before or after your special handling, depending on your requirements.</source>
          <target state="translated">Você pode chamar base antes ou depois do tratamento especial, dependendo dos seus requisitos.</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.IsMouseCapturedChanged" /&gt;</ph> event is raised on this element.</source>
          <target state="translated">Invocado quando um evento <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.IsMouseCapturedChanged" /&gt;</ph> sem tratamento é gerado nesse elemento.</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This virtual method is raised when the value of the <ph id="ph1">&lt;xref:System.Windows.UIElement.IsMouseCaptured%2A&gt;</ph> dependency property changes its value.</source>
          <target state="translated">Esse método virtual é gerado quando o valor da <ph id="ph1">&lt;xref:System.Windows.UIElement.IsMouseCaptured%2A&gt;</ph> seu valor de propriedade de dependência é alterado.</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The virtual method is raised first and can manipulate the event data as necessary.</source>
          <target state="translated">O método virtual é gerado pela primeira vez e pode manipular os dados de evento conforme necessário.</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Then the <ph id="ph1">&lt;xref:System.Windows.UIElement.IsMouseCapturedChanged&gt;</ph> event is raised with that same event data instance.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.IsMouseCapturedChanged&gt;</ph> é gerado com essa mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Notice that the <ph id="ph1">&lt;xref:System.Windows.UIElement.IsMouseCapturedChanged&gt;</ph> event is not a routed event; Therefore, you cannot mark it as handled in the class handler.</source>
          <target state="translated">Observe que o <ph id="ph1">&lt;xref:System.Windows.UIElement.IsMouseCapturedChanged&gt;</ph> não é um evento roteado; Portanto, você não pode marcá-lo tratados no manipulador de classe.</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>You may call base either before or after your special handling, depending on your requirements.</source>
          <target state="translated">Você pode chamar base antes ou depois do tratamento especial, dependendo dos seus requisitos.</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.IsMouseCaptureWithinChanged" /&gt;</ph> event is raised on this element.</source>
          <target state="translated">Invocado quando um evento <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.IsMouseCaptureWithinChanged" /&gt;</ph> sem tratamento é gerado nesse elemento.</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This virtual method is raised when the value of the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsMouseCaptureWithin" /&gt;</ph> dependency property changes its value.</source>
          <target state="translated">Esse método virtual é gerado quando o valor da <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.IsMouseCaptureWithin" /&gt;</ph> seu valor de propriedade de dependência é alterado.</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The virtual method is raised first and can manipulate the event data as necessary.</source>
          <target state="translated">O método virtual é gerado pela primeira vez e pode manipular os dados de evento conforme necessário.</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Then the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.IsMouseCaptureWithinChanged" /&gt;</ph> event is raised with that same event data instance.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.IsMouseCaptureWithinChanged" /&gt;</ph> é gerado com essa mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Notice that the event is not a routed event; Therefore,  you cannot mark it as handled in the class handler.</source>
          <target state="translated">Observe que o evento não é um evento roteado. Portanto, você não pode marcá-lo tratados no manipulador de classe.</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>You may call base either before or after your special handling, depending on your requirements.</source>
          <target state="translated">Você pode chamar base antes ou depois do tratamento especial, dependendo dos seus requisitos.</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.IsMouseDirectlyOverChanged" /&gt;</ph> event is raised on this element.</source>
          <target state="translated">Invocado quando um evento <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.IsMouseDirectlyOverChanged" /&gt;</ph> sem tratamento é gerado nesse elemento.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This virtual method is raised when the value of the <ph id="ph1">&lt;xref:System.Windows.UIElement.IsMouseDirectlyOver%2A&gt;</ph> dependency property changes its value.</source>
          <target state="translated">Esse método virtual é gerado quando o valor da <ph id="ph1">&lt;xref:System.Windows.UIElement.IsMouseDirectlyOver%2A&gt;</ph> seu valor de propriedade de dependência é alterado.</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The virtual method is raised first and can manipulate the event data as necessary.</source>
          <target state="translated">O método virtual é gerado pela primeira vez e pode manipular os dados de evento conforme necessário.</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Then the <ph id="ph1">&lt;xref:System.Windows.UIElement.IsMouseDirectlyOverChanged&gt;</ph> event is raised with that same event data instance.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.IsMouseDirectlyOverChanged&gt;</ph> é gerado com essa mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Notice that the <ph id="ph1">&lt;xref:System.Windows.UIElement.IsMouseDirectlyOverChanged&gt;</ph> event is not a routed event.</source>
          <target state="translated">Observe que o <ph id="ph1">&lt;xref:System.Windows.UIElement.IsMouseDirectlyOverChanged&gt;</ph> não é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Therefore, you cannot mark it as handled in the class handler.</source>
          <target state="translated">Portanto, você não pode marcá-lo tratados no manipulador de classe.</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>You may call base either before or after your special handling, depending on your requirements.</source>
          <target state="translated">Você pode chamar base antes ou depois do tratamento especial, dependendo dos seus requisitos.</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.IsStylusCapturedChanged" /&gt;</ph> event is raised on this element.</source>
          <target state="translated">Invocado quando um evento <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.IsStylusCapturedChanged" /&gt;</ph> sem tratamento é gerado nesse elemento.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This virtual method is raised when the value of the <ph id="ph1">&lt;xref:System.Windows.UIElement.IsStylusCaptured%2A&gt;</ph> dependency property changes its value.</source>
          <target state="translated">Esse método virtual é gerado quando o valor da <ph id="ph1">&lt;xref:System.Windows.UIElement.IsStylusCaptured%2A&gt;</ph> seu valor de propriedade de dependência é alterado.</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The virtual method is raised first and can manipulate the event data as necessary.</source>
          <target state="translated">O método virtual é gerado pela primeira vez e pode manipular os dados de evento conforme necessário.</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Then the <ph id="ph1">&lt;xref:System.Windows.UIElement.IsStylusCapturedChanged&gt;</ph> event is raised with that same event data instance.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.IsStylusCapturedChanged&gt;</ph> é gerado com essa mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Notice that the event is not a routed event.</source>
          <target state="translated">Observe que o evento não é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Therefore, you cannot mark it as handled in the class handler.</source>
          <target state="translated">Portanto, você não pode marcá-lo tratados no manipulador de classe.</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>You may call base either before or after your special handling, depending on your requirements.</source>
          <target state="translated">Você pode chamar base antes ou depois do tratamento especial, dependendo dos seus requisitos.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.IsStylusCaptureWithinChanged" /&gt;</ph> event is raised on this element.</source>
          <target state="translated">Invocado quando um evento <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.IsStylusCaptureWithinChanged" /&gt;</ph> sem tratamento é gerado nesse elemento.</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This virtual method is raised when the value of the <ph id="ph1">&lt;xref:System.Windows.UIElement.IsStylusCaptureWithin%2A&gt;</ph> dependency property changes its value.</source>
          <target state="translated">Esse método virtual é gerado quando o valor da <ph id="ph1">&lt;xref:System.Windows.UIElement.IsStylusCaptureWithin%2A&gt;</ph> seu valor de propriedade de dependência é alterado.</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The virtual method is raised first and can manipulate the event data as necessary.</source>
          <target state="translated">O método virtual é gerado pela primeira vez e pode manipular os dados de evento conforme necessário.</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Then the <ph id="ph1">&lt;xref:System.Windows.UIElement.IsStylusCaptureWithinChanged&gt;</ph> event is raised with that same event data instance.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.IsStylusCaptureWithinChanged&gt;</ph> é gerado com essa mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Notice that the event is not a routed event.</source>
          <target state="translated">Observe que o evento não é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Therefore, you cannot mark it as handled in the class handler.</source>
          <target state="translated">Portanto, você não pode marcá-lo tratados no manipulador de classe.</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>You may call base either before or after your special handling, depending on your requirements.</source>
          <target state="translated">Você pode chamar base antes ou depois do tratamento especial, dependendo dos seus requisitos.</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.IsStylusDirectlyOverChanged" /&gt;</ph> event is raised on this element.</source>
          <target state="translated">Invocado quando um evento <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.IsStylusDirectlyOverChanged" /&gt;</ph> sem tratamento é gerado nesse elemento.</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This virtual method is raised when the value of the <ph id="ph1">&lt;xref:System.Windows.UIElement.IsStylusDirectlyOver%2A&gt;</ph> dependency property changes its value.</source>
          <target state="translated">Esse método virtual é gerado quando o valor da <ph id="ph1">&lt;xref:System.Windows.UIElement.IsStylusDirectlyOver%2A&gt;</ph> seu valor de propriedade de dependência é alterado.</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The virtual method is raised first and can manipulate the event data as necessary.</source>
          <target state="translated">O método virtual é gerado pela primeira vez e pode manipular os dados de evento conforme necessário.</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Then the <ph id="ph1">&lt;xref:System.Windows.UIElement.IsStylusDirectlyOverChanged&gt;</ph> event is raised with that same event data instance.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.IsStylusDirectlyOverChanged&gt;</ph> é gerado com essa mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Notice that the event is not a routed event.</source>
          <target state="translated">Observe que o evento não é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Therefore you cannot mark it as handled in the class handler.</source>
          <target state="translated">Portanto, você não pode marcá-lo tratados no manipulador de classe.</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>You may call base either before or after your special handling, depending on your requirements.</source>
          <target state="translated">Você pode chamar base antes ou depois do tratamento especial, dependendo dos seus requisitos.</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.KeyEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.KeyEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Keyboard.KeyDown" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Keyboard.KeyDown" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>Keystrokes are handled by a dedicated input manager.</source>
          <target state="translated">Pressionamentos de teclas são tratados por um Gerenciador de entrada dedicado.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>Other programming features that rely on keystrokes, for example, input and command bindings, might handle the keystroke before it is exposed as a general keystroke.</source>
          <target state="translated">Outros recursos de programação que dependem de pressionamentos de tecla, por exemplo, associações de entrada e de comando, podem manipular os pressionamentos de teclas antes que ele é exposto como um pressionamento de tecla geral.</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>If these input system features mark the event as handled, then <ph id="ph1">&lt;xref:System.Windows.UIElement.OnKeyDown%2A&gt;</ph> is not invoked.</source>
          <target state="translated">Se esses entrada recursos do sistema marcar o evento como manipulado, em seguida, <ph id="ph1">&lt;xref:System.Windows.UIElement.OnKeyDown%2A&gt;</ph> não é invocada.</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.KeyEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.KeyEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Keyboard.KeyUp" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Keyboard.KeyUp" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>Keystrokes are handled by a dedicated input manager.</source>
          <target state="translated">Pressionamentos de teclas são tratados por um Gerenciador de entrada dedicado.</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>Other programming features that rely on keystrokes, for example, input and command bindings, might handle the keystroke before it is exposed as a general keystroke.</source>
          <target state="translated">Outros recursos de programação que dependem de pressionamentos de tecla, por exemplo, associações de entrada e de comando, podem manipular os pressionamentos de teclas antes que ele é exposto como um pressionamento de tecla geral.</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>If these input system features mark the event as handled, then <ph id="ph1">&lt;xref:System.Windows.UIElement.OnKeyUp%2A&gt;</ph> is not invoked.</source>
          <target state="translated">Se esses entrada recursos do sistema marcar o evento como manipulado, em seguida, <ph id="ph1">&lt;xref:System.Windows.UIElement.OnKeyUp%2A&gt;</ph> não é invocada.</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnLostFocus(System.Windows.RoutedEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph> that contains event data.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph> que contém dados do evento.</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnLostFocus(System.Windows.RoutedEventArgs)">
          <source>This event data must contain the identifier for the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.LostFocus" /&gt;</ph> event.</source>
          <target state="translated">Esses dados de evento devem conter o identificador para o evento <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.LostFocus" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnLostFocus(System.Windows.RoutedEventArgs)">
          <source>Raises the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.LostFocus" /&gt;</ph> routed event by using the event data that is provided.</source>
          <target state="translated">Gera o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.LostFocus" /&gt;</ph> usando os dados de evento fornecidos.</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostFocus(System.Windows.RoutedEventArgs)">
          <source>This method, although virtual, does have a default implementation that raises the event.</source>
          <target state="translated">Esse método, embora virtuais, têm uma implementação padrão que gera o evento.</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostFocus(System.Windows.RoutedEventArgs)">
          <source>This On* method implementation is intended to raise the event, and this same method implementation is invoked internally to raise the event when the <ph id="ph1">&lt;xref:System.Windows.UIElement.IsFocused%2A&gt;</ph> property value changes.</source>
          <target state="translated">Isso em * implementação do método destina-se para gerar o evento, e essa mesma implementação de método é chamada internamente para gerar o evento quando o <ph id="ph1">&lt;xref:System.Windows.UIElement.IsFocused%2A&gt;</ph> alterações de valor de propriedade.</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostFocus(System.Windows.RoutedEventArgs)">
          <source>This implementation differs from some other <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> On* implementations, which only provide a convenient way to add class handling for that event.</source>
          <target state="translated">Essa implementação é diferente do outro <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> em * implementações, que apenas fornecem uma maneira conveniente para Adicionar classe de tratamento de evento.</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostFocus(System.Windows.RoutedEventArgs)">
          <source>Unless you have a deliberate and unusual need to not raise the focus events, make sure that your implementation calls the base implementation.</source>
          <target state="translated">A menos que você tenha uma necessidade incomuns e deliberada para não gerar os eventos de foco, certifique-se de que sua implementação chama a implementação base.</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostFocus(System.Windows.RoutedEventArgs)">
          <source>Otherwise, the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.LostFocus" /&gt;</ph> event is not raised during typical user operations that ordinarily set focus to this element.</source>
          <target state="translated">Caso contrário, o <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.LostFocus" /&gt;</ph> evento não é gerado durante operações de usuário comum que normalmente definir o foco para esse elemento.</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostFocus(System.Windows.RoutedEventArgs)">
          <source>If you do not intend your element to be focusable, you can prevent the element from being focusable by setting <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.Focusable" /&gt;</ph> to <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Se você não pretende ser Focusable é o elemento, você pode impedir que o elemento que está sendo Focusable é definindo <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.Focusable" /&gt;</ph> para <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /&gt;</ph> that contains event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /&gt;</ph> que contém dados do evento.</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseEventArgs" /&gt;</ph> that contains event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseEventArgs" /&gt;</ph> que contém dados do evento.</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> that contains event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> que contém dados do evento.</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)">
          <source>Provides class handling for the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.LostTouchCapture" /&gt;</ph> routed event that occurs when this element loses a touch capture.</source>
          <target state="translated">Fornece tratamento de classes para o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.LostTouchCapture" /&gt;</ph> que ocorre quando este elemento perde a captura de toque.</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.OnLostTouchCapture%2A&gt;</ph> method has no default implementation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.OnLostTouchCapture%2A&gt;</ph> método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnLostTouchCapture%2A&gt;</ph> in a derived class to handle the <ph id="ph2">&lt;xref:System.Windows.UIElement.LostTouchCapture&gt;</ph> event.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnLostTouchCapture%2A&gt;</ph> em uma classe derivada para manipular o <ph id="ph2">&lt;xref:System.Windows.UIElement.LostTouchCapture&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)">
          <source>Be sure to call the base class’s <ph id="ph1">&lt;xref:System.Windows.UIElement.OnLostTouchCapture%2A&gt;</ph> method so that base classes receive the event.</source>
          <target state="translated">Certifique-se de chamar a classe base <ph id="ph1">&lt;xref:System.Windows.UIElement.OnLostTouchCapture%2A&gt;</ph> método para classes de base que receber o evento.</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)">
          <source>The data for the event.</source>
          <target state="translated">Os dados do evento.</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)">
          <source>Called when the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /&gt;</ph> event occurs.</source>
          <target state="translated">Chamado quando o evento <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /&gt;</ph> ocorre.</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationBoundaryFeedback%2A&gt;</ph> method has no default implementation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationBoundaryFeedback%2A&gt;</ph> método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationBoundaryFeedback%2A&gt;</ph> in a derived class to handle the <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationBoundaryFeedback&gt;</ph> event.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationBoundaryFeedback%2A&gt;</ph> em uma classe derivada para manipular o <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationBoundaryFeedback&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)">
          <source>Be sure to call the <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationBoundaryFeedback%2A&gt;</ph> method of the base class so that base classes receive the event.</source>
          <target state="translated">Certifique-se de chamar o <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationBoundaryFeedback%2A&gt;</ph> método da classe base para classes de base que receber o evento.</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnManipulationCompleted(System.Windows.Input.ManipulationCompletedEventArgs)">
          <source>The data for the event.</source>
          <target state="translated">Os dados do evento.</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnManipulationCompleted(System.Windows.Input.ManipulationCompletedEventArgs)">
          <source>Called when the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.ManipulationCompleted" /&gt;</ph> event occurs.</source>
          <target state="translated">Chamado quando o evento <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.ManipulationCompleted" /&gt;</ph> ocorre.</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnManipulationCompleted(System.Windows.Input.ManipulationCompletedEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationCompleted%2A&gt;</ph> method has no default implementation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationCompleted%2A&gt;</ph> método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnManipulationCompleted(System.Windows.Input.ManipulationCompletedEventArgs)">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationCompleted%2A&gt;</ph> in a derived class to handle the <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationCompleted&gt;</ph> event.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationCompleted%2A&gt;</ph> em uma classe derivada para manipular o <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationCompleted&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnManipulationCompleted(System.Windows.Input.ManipulationCompletedEventArgs)">
          <source>Be sure to call the <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationCompleted%2A&gt;</ph> method of the base class so that base classes receive the event.</source>
          <target state="translated">Certifique-se de chamar o <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationCompleted%2A&gt;</ph> método da classe base para classes de base que receber o evento.</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnManipulationDelta(System.Windows.Input.ManipulationDeltaEventArgs)">
          <source>The data for the event.</source>
          <target state="translated">Os dados do evento.</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnManipulationDelta(System.Windows.Input.ManipulationDeltaEventArgs)">
          <source>Called when the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.ManipulationDelta" /&gt;</ph> event occurs.</source>
          <target state="translated">Chamado quando o evento <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.ManipulationDelta" /&gt;</ph> ocorre.</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnManipulationDelta(System.Windows.Input.ManipulationDeltaEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationDelta%2A&gt;</ph> method has no default implementation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationDelta%2A&gt;</ph> método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnManipulationDelta(System.Windows.Input.ManipulationDeltaEventArgs)">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationDelta%2A&gt;</ph> in a derived class to handle the <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationDelta&gt;</ph> event.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationDelta%2A&gt;</ph> em uma classe derivada para manipular o <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationDelta&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnManipulationDelta(System.Windows.Input.ManipulationDeltaEventArgs)">
          <source>Be sure to call the <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationDelta%2A&gt;</ph> method of the base class so that base classes receive the event.</source>
          <target state="translated">Certifique-se de chamar o <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationDelta%2A&gt;</ph> método da classe base para classes de base que receber o evento.</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnManipulationInertiaStarting(System.Windows.Input.ManipulationInertiaStartingEventArgs)">
          <source>The data for the event.</source>
          <target state="translated">Os dados do evento.</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnManipulationInertiaStarting(System.Windows.Input.ManipulationInertiaStartingEventArgs)">
          <source>Called when the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.ManipulationInertiaStarting" /&gt;</ph> event occurs.</source>
          <target state="translated">Chamado quando o evento <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.ManipulationInertiaStarting" /&gt;</ph> ocorre.</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnManipulationInertiaStarting(System.Windows.Input.ManipulationInertiaStartingEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationInertiaStarting%2A&gt;</ph> method has no default implementation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationInertiaStarting%2A&gt;</ph> método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnManipulationInertiaStarting(System.Windows.Input.ManipulationInertiaStartingEventArgs)">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationInertiaStarting%2A&gt;</ph> in a derived class to handle the <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationInertiaStarting&gt;</ph> event.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationInertiaStarting%2A&gt;</ph> em uma classe derivada para manipular o <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationInertiaStarting&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnManipulationInertiaStarting(System.Windows.Input.ManipulationInertiaStartingEventArgs)">
          <source>Be sure to call the <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationInertiaStarting%2A&gt;</ph> method of the base class so that base classes receive the event.</source>
          <target state="translated">Certifique-se de chamar o <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationInertiaStarting%2A&gt;</ph> método da classe base para classes de base que receber o evento.</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnManipulationStarted(System.Windows.Input.ManipulationStartedEventArgs)">
          <source>The data for the event.</source>
          <target state="translated">Os dados do evento.</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnManipulationStarted(System.Windows.Input.ManipulationStartedEventArgs)">
          <source>Called when the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.ManipulationStarted" /&gt;</ph> event occurs.</source>
          <target state="translated">Chamado quando o evento <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.ManipulationStarted" /&gt;</ph> ocorre.</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnManipulationStarted(System.Windows.Input.ManipulationStartedEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationStarted%2A&gt;</ph> method has no default implementation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationStarted%2A&gt;</ph> método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnManipulationStarted(System.Windows.Input.ManipulationStartedEventArgs)">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationStarted%2A&gt;</ph> in a derived class to handle the <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationStarted&gt;</ph> event.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationStarted%2A&gt;</ph> em uma classe derivada para manipular o <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationStarted&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnManipulationStarted(System.Windows.Input.ManipulationStartedEventArgs)">
          <source>Be sure to call the <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationStarted%2A&gt;</ph> method of the base class so that base classes receive the event.</source>
          <target state="translated">Certifique-se de chamar o <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationStarted%2A&gt;</ph> método da classe base para classes de base que receber o evento.</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnManipulationStarting(System.Windows.Input.ManipulationStartingEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Input.ManipulationStartingEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Windows.Input.ManipulationStartingEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnManipulationStarting(System.Windows.Input.ManipulationStartingEventArgs)">
          <source>Provides class handling for the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.ManipulationStarting" /&gt;</ph> routed event that occurs when the manipulation processor is first created.</source>
          <target state="translated">Fornece tratamento de classes para o evento <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.ManipulationStarting" /&gt;</ph> roteado que ocorre quando o processador de manipulação é criado pela primeira vez.</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnManipulationStarting(System.Windows.Input.ManipulationStartingEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationStarting%2A&gt;</ph> method has no default implementation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationStarting%2A&gt;</ph> método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnManipulationStarting(System.Windows.Input.ManipulationStartingEventArgs)">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationStarting%2A&gt;</ph> in a derived class to handle the <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationStarting&gt;</ph> event.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationStarting%2A&gt;</ph> em uma classe derivada para manipular o <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationStarting&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnManipulationStarting(System.Windows.Input.ManipulationStartingEventArgs)">
          <source>Be sure to call the base class’s <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationStarting%2A&gt;</ph> method so that base classes receive the event.</source>
          <target state="translated">Certifique-se de chamar a classe base <ph id="ph1">&lt;xref:System.Windows.UIElement.OnManipulationStarting%2A&gt;</ph> método para classes de base que receber o evento.</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseButtonEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseButtonEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>This event data reports details about the mouse button that was pressed and the handled state.</source>
          <target state="translated">Esses dados de evento relatam detalhes sobre o botão do mouse que foi pressionado e o estado tratado.</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Mouse.MouseDown" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Mouse.MouseDown" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Mouse button actions are also handled by a dedicated input manager.</source>
          <target state="translated">Ações de botão do mouse também são manipuladas por um Gerenciador de entrada dedicado.</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</source>
          <target state="translated">Outros recursos de programação que dependem de ações de botão do mouse, como entrada e associações de comando, podem chamar manipuladores para a ação antes que ele é exposto como uma ação de botão do mouse geral.</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>If these input system features mark the <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> event as handled, <ph id="ph2">&lt;xref:System.Windows.UIElement.OnMouseDown%2A&gt;</ph> is not invoked.</source>
          <target state="translated">Se esses marca de recursos do sistema de entrada de <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> eventos tratados, <ph id="ph2">&lt;xref:System.Windows.UIElement.OnMouseDown%2A&gt;</ph> não é invocada.</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>If you use this class handler to mark the event as handled, you potentially impact the following events: <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonDown&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseRightButtonDown&gt;</ph>.</source>
          <target state="translated">Se você usar esse manipulador da classe para marcar o evento como manipulado, você potencial para afetar os seguintes eventos: <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonDown&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseRightButtonDown&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Either of these events may be raised on the receiving element when <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> is received.</source>
          <target state="translated">Um desses eventos podem ser gerado no elemento de recebimento quando <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> é recebida.</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</source>
          <target state="translated">Se você marcar este evento tratados no tratamento de classe, subevents ainda são gerados; No entanto, eles passam o estado manipulado nos dados do evento.</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29&gt;</ph> with <ph id="ph2">`handledEventsToo`</ph> <ph id="ph3">`true`</ph> in order to attach handlers.</source>
          <target state="translated">Se o evento é tratado na manipulação de classe, os manipuladores de instância para os subevents não serão chamados a menos que explicitamente <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29&gt;</ph> com <ph id="ph2">`handledEventsToo`</ph> <ph id="ph3">`true`</ph> para anexar manipuladores.</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Class handlers also are not invoked unless those class handlers were registered with the <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29&gt;</ph> signature with <ph id="ph2">`handledEventsToo`</ph> <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Manipuladores de classe também não serão chamados a menos que esses manipuladores de classe foram registrados com o <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29&gt;</ph> assinatura <ph id="ph2">`handledEventsToo`</ph> <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>By handling <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseDown%2A&gt;</ph>, you are implying that your class handling accounted for all possible mouse button down actions.</source>
          <target state="translated">Manipulando <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseDown%2A&gt;</ph>, você está indicando que o tratamento de classe levados em conta todos os botão possíveis para baixo de ações.</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</source>
          <target state="translated">Esse comportamento pode ser indesejado; Portanto, tenha cuidado ao usar esse método virtual para marcar eventos como manipulados.</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Each of the button-specific direct events also has a virtual On* method; consider whether overriding these button-specific class handlers might be more appropriate.</source>
          <target state="translated">Cada um dos eventos específicos de botão diretos também tem uma máquina virtual * método; Considere se substituir esses manipuladores de botão específico de classe pode ser mais apropriada.</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Mouse.MouseEnter" /&gt;</ph> attached event is raised on this element.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Mouse.MouseEnter" /&gt;</ph> sem tratamento é gerado nesse elemento.</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)">
          <source>You may call base either before or after your special handling, depending on your requirements.</source>
          <target state="translated">Você pode chamar base antes ou depois do tratamento especial, dependendo dos seus requisitos.</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)">
          <source>In this case the matching event is a routed event, with a direct routing strategy.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado, com uma estratégia de roteamento direto.</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)">
          <source>Marking the event as handled is still useful for preventing the typical instance handlers (those that do not specify <ph id="ph1">`handledEventsToo`</ph>) from being invoked.</source>
          <target state="translated">Marcar o evento como tratado ainda é útil para que os manipuladores de instância típica (aquelas que não especificam <ph id="ph1">`handledEventsToo`</ph>) seja chamado.</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Mouse.MouseLeave" /&gt;</ph> attached event is raised on this element.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Mouse.MouseLeave" /&gt;</ph> sem tratamento é gerado nesse elemento.</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)">
          <source>You may call base either before or after your special handling, depending on your requirements.</source>
          <target state="translated">Você pode chamar base antes ou depois do tratamento especial, dependendo dos seus requisitos.</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)">
          <source>In this case the matching event is a routed event, with a direct routing strategy.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado, com uma estratégia de roteamento direto.</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)">
          <source>Marking the event as handled is still useful for preventing the typical instance handlers (those that do not specify <ph id="ph1">`handledEventsToo`</ph>) from being invoked.</source>
          <target state="translated">Marcar o evento como tratado ainda é útil para que os manipuladores de instância típica (aquelas que não especificam <ph id="ph1">`handledEventsToo`</ph>) seja chamado.</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseButtonEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseButtonEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>The event data reports that the left mouse button was pressed.</source>
          <target state="translated">Os dados do evento relatam que o botão esquerdo do mouse foi pressionado.</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseLeftButtonDown" /&gt;</ph> routed event is raised on this element.</source>
          <target state="translated">Invocado quando um evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseLeftButtonDown" /&gt;</ph> sem tratamento é gerado nesse elemento.</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonDown&gt;</ph> event appears to travel a bubbling route but actually travels in an indirect way.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonDown&gt;</ph> evento parece viajam bolha, mas realmente passa de uma maneira indireta.</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> is the underlying event that is bubble routed, and each <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> along the event route uses identical handling to raise the direct routed event <ph id="ph3">&lt;xref:System.Windows.UIElement.MouseLeftButtonDown&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> o evento subjacente que é roteada de bolha, e cada <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> ao longo do evento rota usa tratamento idêntico para gerar o evento roteado direto <ph id="ph3">&lt;xref:System.Windows.UIElement.MouseLeftButtonDown&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Although you can mark the <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonDown&gt;</ph> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</source>
          <target state="translated">Embora você pode marcar a <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonDown&gt;</ph> evento como manipulado para fins deste elemento, o estado manipulado não perpetuar a outros elementos na rota de evento.</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify <ph id="ph1">`handledEventsToo`</ph>) from being invoked.</source>
          <target state="translated">No entanto, você talvez queira marcar o evento como manipulado para evitar que os manipuladores de instância geral (aquelas que não especificou <ph id="ph1">`handledEventsToo`</ph>) seja chamado.</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>The default implementation for general mouse event handling in <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> listens for <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> and converts it to an appropriate local event.</source>
          <target state="translated">A implementação padrão para eventos de mouse geral tratamento em <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> escuta <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> e o converte em um evento local apropriado.</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>If you want to override this logic, you must create a derived class.</source>
          <target state="translated">Se você deseja substituir essa lógica, você deve criar uma classe derivada.</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>In the static constructor of your derived class, register an alternative class handler for <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">No construtor estático da classe derivada, registra um manipulador de classe alternativo para <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>You cannot change the mouse handling behavior of <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> by overriding <ph id="ph2">&lt;xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A&gt;</ph>.</source>
          <target state="translated">Você não pode alterar o comportamento de manipulação de mouse <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> , substituindo <ph id="ph2">&lt;xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Alternatively, you can override this method in order to change event handling for a specific mouse state.</source>
          <target state="translated">Como alternativa, você pode substituir esse método para alterar a manipulação de eventos para um estado específico de mouse.</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Whether you choose to call the base implementation depends on your scenario.</source>
          <target state="translated">Se você optar por chamar a implementação base depende de seu cenário.</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A&gt;</ph>.</source>
          <target state="translated">Falha ao chamar base desabilita a manipulação de entrada padrão para o evento do mouse em classes ancestral que também pretende invocar <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>For example, you can derive from <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> and override <ph id="ph2">&lt;xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A&gt;</ph> in your derived class without calling the base implementation; however, this override disables the <ph id="ph3">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> event.</source>
          <target state="translated">Por exemplo, você pode derivar de <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> e substituir <ph id="ph2">&lt;xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A&gt;</ph> em sua classe derivada sem chamar a implementação base; no entanto, isso substituir desabilita o <ph id="ph3">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseButtonEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseButtonEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>The event data reports that the left mouse button was released.</source>
          <target state="translated">Os dados do evento relatam que o botão esquerdo foi liberado.</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseLeftButtonUp" /&gt;</ph> routed event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseLeftButtonUp" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonUp&gt;</ph> event appears to travel a bubbling route but actually travels in an indirect way.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonUp&gt;</ph> evento parece viajam bolha, mas realmente passa de uma maneira indireta.</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph> is the underlying event that is bubble routed, and each <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> along the event route uses identical handling to raise the direct routed event <ph id="ph3">&lt;xref:System.Windows.UIElement.MouseLeftButtonUp&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph> o evento subjacente que é roteada de bolha, e cada <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> ao longo do evento rota usa tratamento idêntico para gerar o evento roteado direto <ph id="ph3">&lt;xref:System.Windows.UIElement.MouseLeftButtonUp&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Although you can mark the <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonUp&gt;</ph> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</source>
          <target state="translated">Embora você pode marcar a <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonUp&gt;</ph> evento como manipulado para fins deste elemento, o estado manipulado não perpetuar a outros elementos na rota de evento.</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify <ph id="ph1">`handledEventsToo`</ph>) from being invoked.</source>
          <target state="translated">No entanto, você talvez queira marcar o evento como manipulado para evitar que os manipuladores de instância geral (aquelas que não especificou <ph id="ph1">`handledEventsToo`</ph>) seja chamado.</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>The default implementation for general mouse event handling in <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> listens for <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph> and converts it to an appropriate local event.</source>
          <target state="translated">A implementação padrão para eventos de mouse geral tratamento em <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> escuta <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph> e o converte em um evento local apropriado.</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>If you want to override this logic, you must create a derived class.</source>
          <target state="translated">Se você deseja substituir essa lógica, você deve criar uma classe derivada.</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>In the static constructor of your derived class, register an alternative class handler for <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">No construtor estático da classe derivada, registra um manipulador de classe alternativo para <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>You cannot change the mouse handling behavior of <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> by overriding <ph id="ph2">&lt;xref:System.Windows.UIElement.OnMouseLeftButtonUp%2A&gt;</ph>.</source>
          <target state="translated">Você não pode alterar o comportamento de manipulação de mouse <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> , substituindo <ph id="ph2">&lt;xref:System.Windows.UIElement.OnMouseLeftButtonUp%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Mouse.MouseMove" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Mouse.MouseMove" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseButtonEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseButtonEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>The event data reports that the right mouse button was pressed.</source>
          <target state="translated">Os dados do evento relatam que o botão direito do mouse foi pressionado.</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseRightButtonDown" /&gt;</ph> routed event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseRightButtonDown" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseRightButtonDown&gt;</ph> event appears to travel a bubbling route but actually travels in an indirect way.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseRightButtonDown&gt;</ph> evento parece viajam bolha, mas realmente passa de uma maneira indireta.</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> is the underlying event that is bubble routed, and each <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> along the event route uses identical handling to raise the direct routed event <ph id="ph3">&lt;xref:System.Windows.UIElement.MouseRightButtonDown&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> o evento subjacente que é roteada de bolha, e cada <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> ao longo do evento rota usa tratamento idêntico para gerar o evento roteado direto <ph id="ph3">&lt;xref:System.Windows.UIElement.MouseRightButtonDown&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Although you can mark the <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseRightButtonDown&gt;</ph> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</source>
          <target state="translated">Embora você pode marcar a <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseRightButtonDown&gt;</ph> evento como manipulado para fins deste elemento, o estado manipulado não perpetuar a outros elementos na rota de evento.</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify <ph id="ph1">`handledEventsToo`</ph>) from being invoked.</source>
          <target state="translated">No entanto, você talvez queira marcar o evento como manipulado para evitar que os manipuladores de instância geral (aquelas que não especificou <ph id="ph1">`handledEventsToo`</ph>) seja chamado.</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>The default implementation for general mouse event handling in <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> listens for <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> and converts it to an appropriate local event.</source>
          <target state="translated">A implementação padrão para eventos de mouse geral tratamento em <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> escuta <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph> e o converte em um evento local apropriado.</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>If you want to override this logic, you must create a derived class.</source>
          <target state="translated">Se você deseja substituir essa lógica, você deve criar uma classe derivada.</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>In the static constructor of your derived class, register an alternative class handler for <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">No construtor estático da classe derivada, registra um manipulador de classe alternativo para <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>You cannot change the mouse handling behavior of <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> by overriding <ph id="ph2">&lt;xref:System.Windows.UIElement.OnMouseRightButtonDown%2A&gt;</ph>.</source>
          <target state="translated">Você não pode alterar o comportamento de manipulação de mouse <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> , substituindo <ph id="ph2">&lt;xref:System.Windows.UIElement.OnMouseRightButtonDown%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Alternatively, you can override this method in order to change event handling for a specific mouse state.</source>
          <target state="translated">Como alternativa, você pode substituir esse método para alterar a manipulação de eventos para um estado específico de mouse.</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Whether you choose to call the base implementation depends on your scenario.</source>
          <target state="translated">Se você optar por chamar a implementação base depende de seu cenário.</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseRightButtonDown%2A&gt;</ph>.</source>
          <target state="translated">Falha ao chamar base desabilita a manipulação de entrada padrão para o evento do mouse em classes ancestral que também pretende invocar <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseRightButtonDown%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>For example, you can derive from <ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> and override <ph id="ph2">&lt;xref:System.Windows.UIElement.OnMouseRightButtonDown%2A&gt;</ph> in your derived class without calling base; however, this override disables the context menu services on your control, which are part of the <ph id="ph3">&lt;xref:System.Windows.Controls.Control&gt;</ph> default behavior.</source>
          <target state="translated">Por exemplo, você pode derivar de <ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> e substituir <ph id="ph2">&lt;xref:System.Windows.UIElement.OnMouseRightButtonDown%2A&gt;</ph> em sua classe derivada sem base chamada; no entanto, essa substituição desativa os serviços de menu de contexto do controle, que fazem parte do <ph id="ph3">&lt;xref:System.Windows.Controls.Control&gt;</ph> comportamento padrão.</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseButtonEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseButtonEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>The event data reports that the right mouse button was released.</source>
          <target state="translated">Os dados do evento relatam que o botão direito do mouse foi liberado.</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseRightButtonUp" /&gt;</ph> routed event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.MouseRightButtonUp" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseRightButtonUp&gt;</ph> event appears to travel a bubbling route but actually travels in an indirect way.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseRightButtonUp&gt;</ph> evento parece viajam bolha, mas realmente passa de uma maneira indireta.</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph> is the underlying event that is bubble routed, and each <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> along the event route uses identical handling to raise the direct routed event <ph id="ph3">&lt;xref:System.Windows.UIElement.MouseRightButtonUp&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph> o evento subjacente que é roteada de bolha, e cada <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> ao longo do evento rota usa tratamento idêntico para gerar o evento roteado direto <ph id="ph3">&lt;xref:System.Windows.UIElement.MouseRightButtonUp&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Although you can mark the <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseRightButtonUp&gt;</ph> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</source>
          <target state="translated">Embora você pode marcar a <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseRightButtonUp&gt;</ph> evento como manipulado para fins deste elemento, o estado manipulado não perpetuar a outros elementos na rota de evento.</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify <ph id="ph1">`handledEventsToo`</ph>) from being invoked.</source>
          <target state="translated">No entanto, você talvez queira marcar o evento como manipulado para evitar que os manipuladores de instância geral (aquelas que não especificou <ph id="ph1">`handledEventsToo`</ph>) seja chamado.</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>The default implementation for general mouse event handling in <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> listens for <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph> and converts it to an appropriate local event.</source>
          <target state="translated">A implementação padrão para eventos de mouse geral tratamento em <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> escuta <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph> e o converte em um evento local apropriado.</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>If you want to override this logic, you must create a derived class.</source>
          <target state="translated">Se você deseja substituir essa lógica, você deve criar uma classe derivada.</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>In the static constructor of your derived class, register an alternative class handler for <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">No construtor estático da classe derivada, registra um manipulador de classe alternativo para <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>You cannot change the mouse handling behavior of <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> by overriding <ph id="ph2">&lt;xref:System.Windows.UIElement.OnMouseRightButtonUp%2A&gt;</ph>.</source>
          <target state="translated">Você não pode alterar o comportamento de manipulação de mouse <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> , substituindo <ph id="ph2">&lt;xref:System.Windows.UIElement.OnMouseRightButtonUp%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseButtonEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseButtonEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>The event data reports that the mouse button was released.</source>
          <target state="translated">Os dados do evento relatam que o botão do mouse foi liberado.</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Mouse.MouseUp" /&gt;</ph> routed event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Mouse.MouseUp" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Mouse button actions are also handled by a dedicated input manager.</source>
          <target state="translated">Ações de botão do mouse também são manipuladas por um Gerenciador de entrada dedicado.</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</source>
          <target state="translated">Outros recursos de programação que dependem de ações de botão do mouse, como entrada e associações de comando, podem chamar manipuladores para a ação antes que ele é exposto como uma ação de botão do mouse geral.</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>If these input system features mark the <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph> event as handled, <ph id="ph2">&lt;xref:System.Windows.UIElement.OnMouseUp%2A&gt;</ph> is not invoked.</source>
          <target state="translated">Se esses marca de recursos do sistema de entrada de <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph> eventos tratados, <ph id="ph2">&lt;xref:System.Windows.UIElement.OnMouseUp%2A&gt;</ph> não é invocada.</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>If you use this class handler to mark the event as handled, you potentially impact the following events: <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonUp&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseRightButtonUp&gt;</ph>.</source>
          <target state="translated">Se você usar esse manipulador da classe para marcar o evento como manipulado, você potencial para afetar os seguintes eventos: <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseLeftButtonUp&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.UIElement.MouseRightButtonUp&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Either of these events might be raised on the receiving element when <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph> is received.</source>
          <target state="translated">Um desses eventos pode ser gerado no elemento de recebimento quando <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType&gt;</ph> é recebida.</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</source>
          <target state="translated">Se você marcar este evento tratados no tratamento de classe, subevents ainda são gerados; No entanto, eles passam o estado manipulado nos dados do evento.</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29&gt;</ph> with <ph id="ph2">`handledEventsToo`</ph> <ph id="ph3">`true`</ph> in order to attach handlers.</source>
          <target state="translated">Se o evento é tratado na manipulação de classe, os manipuladores de instância para os subevents não serão chamados a menos que explicitamente <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29&gt;</ph> com <ph id="ph2">`handledEventsToo`</ph> <ph id="ph3">`true`</ph> para anexar manipuladores.</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Class handlers also are not invoked unless those class handlers were registered with the <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29&gt;</ph> signature with <ph id="ph2">`handledEventsToo`</ph> <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Manipuladores de classe também não serão chamados a menos que esses manipuladores de classe foram registrados com o <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29&gt;</ph> assinatura <ph id="ph2">`handledEventsToo`</ph> <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>By handling <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseUp%2A&gt;</ph>, you are implying that your class handling accounted for all possible mouse button up actions.</source>
          <target state="translated">Manipulando <ph id="ph1">&lt;xref:System.Windows.UIElement.OnMouseUp%2A&gt;</ph>, é indicando que o tratamento de classe levados em conta todos os botão possíveis ações.</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</source>
          <target state="translated">Esse comportamento pode ser indesejado; Portanto, tenha cuidado ao usar esse método virtual para marcar eventos como manipulados.</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Each of the button-specific direct events also has a virtual On* method; consider whether overriding these button-specific class handlers might be more appropriate.</source>
          <target state="translated">Cada um dos eventos específicos de botão diretos também tem uma máquina virtual * método; Considere se substituir esses manipuladores de botão específico de classe pode ser mais apropriada.</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseWheelEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseWheelEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Mouse.MouseWheel" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Mouse.MouseWheel" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.DragEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.DragEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.DragDrop.PreviewDragEnter" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.DragDrop.PreviewDragEnter" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)">
          <source>Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</source>
          <target state="translated">Outro cenário que é específico para eventos de visualização é para marcá-los tratado para que os manipuladores de classe de bolha correspondentes não serão chamados.</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.DragEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.DragEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.DragDrop.PreviewDragLeave" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.DragDrop.PreviewDragLeave" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)">
          <source>Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</source>
          <target state="translated">Outro cenário que é específico para eventos de visualização é para marcá-los tratado para que os manipuladores de classe de bolha correspondentes não serão chamados.</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.DragEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.DragEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.DragDrop.PreviewDragOver" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.DragDrop.PreviewDragOver" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)">
          <source>Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</source>
          <target state="translated">Outro cenário que é específico para eventos de visualização é para marcá-los tratado para que os manipuladores de classe de bolha correspondentes não serão chamados.</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.DragEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.DragEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.DragDrop.PreviewDrop" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.DragDrop.PreviewDrop" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)">
          <source>Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</source>
          <target state="translated">Outro cenário que é específico para eventos de visualização é para marcá-los tratado para que os manipuladores de classe de bolha correspondentes não serão chamados.</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.GiveFeedbackEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.GiveFeedbackEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)">
          <source>Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</source>
          <target state="translated">Outro cenário que é específico para eventos de visualização é para marcá-los tratado para que os manipuladores de classe de bolha correspondentes não serão chamados.</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</source>
          <target state="translated">Outro cenário que é específico para eventos de visualização é para marcá-los tratado para que os manipuladores de classe de bolha correspondentes não serão chamados.</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.KeyEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.KeyEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)">
          <source>Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</source>
          <target state="translated">Outro cenário que é específico para eventos de visualização é para marcá-los tratado para que os manipuladores de classe de bolha correspondentes não serão chamados.</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.KeyEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.KeyEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)">
          <source>Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</source>
          <target state="translated">Outro cenário que é específico para eventos de visualização é para marcá-los tratado para que os manipuladores de classe de bolha correspondentes não serão chamados.</target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
          <source>Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</source>
          <target state="translated">Outro cenário que é específico para eventos de visualização é para marcá-los tratado para que os manipuladores de classe de bolha correspondentes não serão chamados.</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseButtonEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseButtonEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>The event data reports that one or more mouse buttons were pressed.</source>
          <target state="translated">Os dados de evento relatam que um ou mais botões do mouse foram pressionados.</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /&gt;</ph> attached routed event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento roteado anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Mouse button actions are also handled by a dedicated input manager.</source>
          <target state="translated">Ações de botão do mouse também são manipuladas por um Gerenciador de entrada dedicado.</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</source>
          <target state="translated">Outros recursos de programação que dependem de ações de botão do mouse, como entrada e associações de comando, podem chamar manipuladores para a ação antes que ele é exposto como uma ação de botão do mouse geral.</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>If these input system features mark the <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> event as handled, <ph id="ph2">&lt;xref:System.Windows.UIElement.OnPreviewMouseDown%2A&gt;</ph> is not invoked.</source>
          <target state="translated">Se esses marca de recursos do sistema de entrada de <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> eventos tratados, <ph id="ph2">&lt;xref:System.Windows.UIElement.OnPreviewMouseDown%2A&gt;</ph> não é invocada.</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>If you use this class handler to mark the event as handled, you potentially impact the following events: <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonDown&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonDown&gt;</ph>.</source>
          <target state="translated">Se você usar esse manipulador da classe para marcar o evento como manipulado, você potencial para afetar os seguintes eventos: <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonDown&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonDown&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Either of these events may be raised on the receiving element when <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> is received.</source>
          <target state="translated">Um desses eventos podem ser gerado no elemento de recebimento quando <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> é recebida.</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</source>
          <target state="translated">Se você marcar este evento tratados no tratamento de classe, subevents ainda são gerados; No entanto, eles passam o estado manipulado nos dados do evento.</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29&gt;</ph> with <ph id="ph2">`handledEventsToo`</ph> <ph id="ph3">`true`</ph> in order to attach handlers.</source>
          <target state="translated">Se o evento é tratado na manipulação de classe, os manipuladores de instância para os subevents não serão chamados a menos que explicitamente <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29&gt;</ph> com <ph id="ph2">`handledEventsToo`</ph> <ph id="ph3">`true`</ph> para anexar manipuladores.</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Class handlers also are not invoked unless those class handlers were registered with the <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29&gt;</ph> signature with <ph id="ph2">`handledEventsToo`</ph> <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Manipuladores de classe também não serão chamados a menos que esses manipuladores de classe foram registrados com o <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29&gt;</ph> assinatura <ph id="ph2">`handledEventsToo`</ph> <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>By handling <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewMouseDown%2A&gt;</ph>, you are implying that your class handling accounted for all possible mouse button down actions.</source>
          <target state="translated">Manipulando <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewMouseDown%2A&gt;</ph>, você está indicando que o tratamento de classe levados em conta todos os botão possíveis para baixo de ações.</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</source>
          <target state="translated">Esse comportamento pode ser indesejado; Portanto, tenha cuidado ao usar esse método virtual para marcar eventos como manipulados.</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Each of the button-specific direct events also has a virtual On* method; consider whether overriding these button-specific class handlers might be more appropriate.</source>
          <target state="translated">Cada um dos eventos específicos de botão diretos também tem uma máquina virtual * método; Considere se substituir esses manipuladores de botão específico de classe pode ser mais apropriada.</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</source>
          <target state="translated">Outro cenário que é específico para eventos de visualização é para marcá-los tratado para que os manipuladores de classe de bolha correspondentes não serão chamados.</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseButtonEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseButtonEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>The event data reports that the left mouse button was pressed.</source>
          <target state="translated">Os dados do evento relatam que o botão esquerdo do mouse foi pressionado.</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" /&gt;</ph> routed event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonDown&gt;</ph> event appears to travel a tunneling route but actually travels in an indirect way.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonDown&gt;</ph> evento parece uma rota de túnel de viagem, mas realmente passa de uma maneira indireta.</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> is the underlying event that is tunnel routed, and each <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> along the event route uses identical handling to raise the direct routed event <ph id="ph3">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonDown&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> é o evento subjacente que é roteado de túnel e cada <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> ao longo do evento rota usa tratamento idêntico para gerar o evento roteado direto <ph id="ph3">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonDown&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Although you can mark the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonDown&gt;</ph> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</source>
          <target state="translated">Embora você pode marcar a <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonDown&gt;</ph> evento como manipulado para fins deste elemento, o estado manipulado não perpetuar a outros elementos na rota de evento.</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify <ph id="ph1">`handledEventsToo`</ph>) from being invoked.</source>
          <target state="translated">No entanto, você talvez queira marcar o evento como manipulado para evitar que os manipuladores de instância geral (aquelas que não especificou <ph id="ph1">`handledEventsToo`</ph>) seja chamado.</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>The default implementation for general mouse event handling in <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> listens for <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> and converts it to an appropriate local event.</source>
          <target state="translated">A implementação padrão para eventos de mouse geral tratamento em <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> escuta <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> e o converte em um evento local apropriado.</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>If you want to override this logic, you must create a derived class.</source>
          <target state="translated">Se você deseja substituir essa lógica, você deve criar uma classe derivada.</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>In the static constructor of your derived class, register an alternative class handler for <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">No construtor estático da classe derivada, registra um manipulador de classe alternativo para <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>You cannot change the mouse handling behavior of <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> by overriding <ph id="ph2">&lt;xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A&gt;</ph>.</source>
          <target state="translated">Você não pode alterar o comportamento de manipulação de mouse <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> , substituindo <ph id="ph2">&lt;xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Alternatively, you can override this method in order to change event handling for a specific mouse state.</source>
          <target state="translated">Como alternativa, você pode substituir esse método para alterar a manipulação de eventos para um estado específico de mouse.</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Whether you choose to call the base implementation depends on your scenario.</source>
          <target state="translated">Se você optar por chamar a implementação base depende de seu cenário.</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A&gt;</ph>.</source>
          <target state="translated">Falha ao chamar base desabilita a manipulação de entrada padrão para o evento do mouse em classes ancestral que também pretende invocar <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>For example, you can derive from <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> and override <ph id="ph2">&lt;xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A&gt;</ph> in your derived class without calling the base implementation; however, this override disables the <ph id="ph3">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> event.</source>
          <target state="translated">Por exemplo, você pode derivar de <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> e substituir <ph id="ph2">&lt;xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A&gt;</ph> em sua classe derivada sem chamar a implementação base; no entanto, isso substituir desabilita o <ph id="ph3">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseButtonEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseButtonEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>The event data reports that the left mouse button was released.</source>
          <target state="translated">Os dados do evento relatam que o botão esquerdo foi liberado.</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonUp" /&gt;</ph> routed event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonUp" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonUp&gt;</ph> event appears to travel a tunneling route but actually travels in an indirect way.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonUp&gt;</ph> evento parece uma rota de túnel de viagem, mas realmente passa de uma maneira indireta.</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> is the underlying event that is tunnel routed, and each <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> along the event route uses identical handling to raise the direct routed event <ph id="ph3">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonUp&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> é o evento subjacente que é roteado de túnel e cada <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> ao longo do evento rota usa tratamento idêntico para gerar o evento roteado direto <ph id="ph3">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonUp&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Although you can mark the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonUp&gt;</ph> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</source>
          <target state="translated">Embora você pode marcar a <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonUp&gt;</ph> evento como manipulado para fins deste elemento, o estado manipulado não perpetuar a outros elementos na rota de evento.</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify <ph id="ph1">`handledEventsToo`</ph>) from being invoked.</source>
          <target state="translated">No entanto, você talvez queira marcar o evento como manipulado para evitar que os manipuladores de instância geral (aquelas que não especificou <ph id="ph1">`handledEventsToo`</ph>) seja chamado.</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>The default implementation for general mouse event handling in <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> listens for <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> and converts it to an appropriate local event.</source>
          <target state="translated">A implementação padrão para eventos de mouse geral tratamento em <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> escuta <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> e o converte em um evento local apropriado.</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>If you want to override this logic, you must create a derived class.</source>
          <target state="translated">Se você deseja substituir essa lógica, você deve criar uma classe derivada.</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>In the static constructor of your derived class, register an alternative class handler for <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">No construtor estático da classe derivada, registra um manipulador de classe alternativo para <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>You cannot change the mouse handling behavior of <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> by overriding <ph id="ph2">&lt;xref:System.Windows.UIElement.OnPreviewMouseLeftButtonUp%2A&gt;</ph>.</source>
          <target state="translated">Você não pode alterar o comportamento de manipulação de mouse <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> , substituindo <ph id="ph2">&lt;xref:System.Windows.UIElement.OnPreviewMouseLeftButtonUp%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)">
          <source>Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</source>
          <target state="translated">Outro cenário que é específico para eventos de visualização é para marcá-los tratado para que os manipuladores de classe de bolha correspondentes não serão chamados.</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseButtonEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseButtonEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>The event data reports that the right mouse button was pressed.</source>
          <target state="translated">Os dados do evento relatam que o botão direito do mouse foi pressionado.</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewMouseRightButtonDown" /&gt;</ph> routed event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewMouseRightButtonDown" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonDown&gt;</ph> event appears to travel a tunneling route but actually travels in an indirect way.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonDown&gt;</ph> evento parece uma rota de túnel de viagem, mas realmente passa de uma maneira indireta.</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> is the underlying event that is tunnel routed, and each <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> along the event route uses identical handling to raise the direct routed event <ph id="ph3">&lt;xref:System.Windows.UIElement.MouseRightButtonDown&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> é o evento subjacente que é roteado de túnel e cada <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> ao longo do evento rota usa tratamento idêntico para gerar o evento roteado direto <ph id="ph3">&lt;xref:System.Windows.UIElement.MouseRightButtonDown&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Although you can mark the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonDown&gt;</ph> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</source>
          <target state="translated">Embora você pode marcar a <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonDown&gt;</ph> evento como manipulado para fins deste elemento, o estado manipulado não perpetuar a outros elementos na rota de evento.</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify <ph id="ph1">`handledEventsToo`</ph>) from being invoked.</source>
          <target state="translated">No entanto, você talvez queira marcar o evento como manipulado para evitar que os manipuladores de instância geral (aquelas que não especificou <ph id="ph1">`handledEventsToo`</ph>) seja chamado.</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>The default implementation for general mouse event handling in <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> listens for <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> and converts it to an appropriate local event.</source>
          <target state="translated">A implementação padrão para eventos de mouse geral tratamento em <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> escuta <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> e o converte em um evento local apropriado.</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>If you want to override this logic, you must create a derived class.</source>
          <target state="translated">Se você deseja substituir essa lógica, você deve criar uma classe derivada.</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>In the static constructor of your derived class, register an alternative class handler for <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">No construtor estático da classe derivada, registra um manipulador de classe alternativo para <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>You cannot change the mouse handling behavior of <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> by overriding <ph id="ph2">&lt;xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A&gt;</ph>.</source>
          <target state="translated">Você não pode alterar o comportamento de manipulação de mouse <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> , substituindo <ph id="ph2">&lt;xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Alternatively, you can override this method in order to change event handling for a specific mouse state.</source>
          <target state="translated">Como alternativa, você pode substituir esse método para alterar a manipulação de eventos para um estado específico de mouse.</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Whether you choose to call the base implementation depends on your scenario.</source>
          <target state="translated">Se você optar por chamar a implementação base depende de seu cenário.</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A&gt;</ph>.</source>
          <target state="translated">Falha ao chamar base desabilita a manipulação de entrada padrão para o evento do mouse em classes ancestral que também pretende invocar <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
          <source>For example, you can derive from <ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> and override <ph id="ph2">&lt;xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A&gt;</ph> in your derived class without calling base; however, this override disables the context menu services on your control, which are part of the <ph id="ph3">&lt;xref:System.Windows.Controls.Control&gt;</ph> default behavior.</source>
          <target state="translated">Por exemplo, você pode derivar de <ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> e substituir <ph id="ph2">&lt;xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A&gt;</ph> em sua classe derivada sem base chamada; no entanto, essa substituição desativa os serviços de menu de contexto do controle, que fazem parte do <ph id="ph3">&lt;xref:System.Windows.Controls.Control&gt;</ph> comportamento padrão.</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseButtonEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseButtonEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>The event data reports that the right mouse button was released.</source>
          <target state="translated">Os dados do evento relatam que o botão direito do mouse foi liberado.</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewMouseRightButtonUp" /&gt;</ph> routed event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewMouseRightButtonUp" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonUp&gt;</ph> event appears to travel a tunneling route but actually travels in an indirect way.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonUp&gt;</ph> evento parece uma rota de túnel de viagem, mas realmente passa de uma maneira indireta.</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> is the underlying event that is tunnel routed, and each <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> along the event route uses identical handling to raise the direct routed event <ph id="ph3">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonUp&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> é o evento subjacente que é roteado de túnel e cada <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> ao longo do evento rota usa tratamento idêntico para gerar o evento roteado direto <ph id="ph3">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonUp&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Although you can mark the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonUp&gt;</ph> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</source>
          <target state="translated">Embora você pode marcar a <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonUp&gt;</ph> evento como manipulado para fins deste elemento, o estado manipulado não perpetuar a outros elementos na rota de evento.</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify <ph id="ph1">`handledEventsToo`</ph>) from being invoked.</source>
          <target state="translated">No entanto, você talvez queira marcar o evento como manipulado para evitar que os manipuladores de instância geral (aquelas que não especificou <ph id="ph1">`handledEventsToo`</ph>) seja chamado.</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>The default implementation for general mouse event handling in <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> listens for <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> and converts it to an appropriate local event.</source>
          <target state="translated">A implementação padrão para eventos de mouse geral tratamento em <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> escuta <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> e o converte em um evento local apropriado.</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>If you want to override this logic, you must create a derived class.</source>
          <target state="translated">Se você deseja substituir essa lógica, você deve criar uma classe derivada.</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>In the static constructor of your derived class, register an alternative class handler for <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">No construtor estático da classe derivada, registra um manipulador de classe alternativo para <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>You cannot change the mouse handling behavior of <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> by overriding <ph id="ph2">&lt;xref:System.Windows.UIElement.OnPreviewMouseRightButtonUp%2A&gt;</ph>.</source>
          <target state="translated">Você não pode alterar o comportamento de manipulação de mouse <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> , substituindo <ph id="ph2">&lt;xref:System.Windows.UIElement.OnPreviewMouseRightButtonUp%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseButtonEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseButtonEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>The event data reports that one or more mouse buttons were released.</source>
          <target state="translated">Os dados de evento informam que um ou mais botões do mouse foram soltos.</target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Mouse button actions are also handled by a dedicated input manager.</source>
          <target state="translated">Ações de botão do mouse também são manipuladas por um Gerenciador de entrada dedicado.</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</source>
          <target state="translated">Outros recursos de programação que dependem de ações de botão do mouse, como entrada e associações de comando, podem chamar manipuladores para a ação antes que ele é exposto como uma ação de botão do mouse geral.</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>If these input system features mark the <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> event as handled, <ph id="ph2">&lt;xref:System.Windows.UIElement.OnPreviewMouseUp%2A&gt;</ph> is not invoked.</source>
          <target state="translated">Se esses marca de recursos do sistema de entrada de <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> eventos tratados, <ph id="ph2">&lt;xref:System.Windows.UIElement.OnPreviewMouseUp%2A&gt;</ph> não é invocada.</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>If you use this class handler to mark the event as handled, you potentially impact the following events: <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonUp&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonUp&gt;</ph>.</source>
          <target state="translated">Se você usar esse manipulador da classe para marcar o evento como manipulado, você potencial para afetar os seguintes eventos: <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonUp&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonUp&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Either of these events might be raised on the receiving element when <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> is received.</source>
          <target state="translated">Um desses eventos pode ser gerado no elemento de recebimento quando <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> é recebida.</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</source>
          <target state="translated">Se você marcar este evento tratados no tratamento de classe, subevents ainda são gerados; No entanto, eles passam o estado manipulado nos dados do evento.</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29&gt;</ph> with <ph id="ph2">`handledEventsToo`</ph> <ph id="ph3">`true`</ph> in order to attach handlers.</source>
          <target state="translated">Se o evento é tratado na manipulação de classe, os manipuladores de instância para os subevents não serão chamados a menos que explicitamente <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29&gt;</ph> com <ph id="ph2">`handledEventsToo`</ph> <ph id="ph3">`true`</ph> para anexar manipuladores.</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Class handlers also are not invoked unless those class handlers were registered with the <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29&gt;</ph> signature with <ph id="ph2">`handledEventsToo`</ph> <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Manipuladores de classe também não serão chamados a menos que esses manipuladores de classe foram registrados com o <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29&gt;</ph> assinatura <ph id="ph2">`handledEventsToo`</ph> <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>By handling <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewMouseUp%2A&gt;</ph>, you are implying that your class handling accounted for all possible mouse button up actions.</source>
          <target state="translated">Manipulando <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewMouseUp%2A&gt;</ph>, é indicando que o tratamento de classe levados em conta todos os botão possíveis ações.</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</source>
          <target state="translated">Esse comportamento pode ser indesejado; Portanto, tenha cuidado ao usar esse método virtual para marcar eventos como manipulados.</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Each of the button-specific direct events also has a virtual On* method; consider whether overriding these button-specific class handlers might be more appropriate.</source>
          <target state="translated">Cada um dos eventos específicos de botão diretos também tem uma máquina virtual * método; Considere se substituir esses manipuladores de botão específico de classe pode ser mais apropriada.</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseWheelEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.MouseWheelEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
          <source>Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</source>
          <target state="translated">Outro cenário que é específico para eventos de visualização é para marcá-los tratado para que os manipuladores de classe de bolha correspondentes não serão chamados.</target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.QueryContinueDragEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.QueryContinueDragEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)">
          <source>Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</source>
          <target state="translated">Outro cenário que é específico para eventos de visualização é para marcá-los tratado para que os manipuladores de classe de bolha correspondentes não serão chamados.</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusButtonEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusButtonEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)">
          <source>Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</source>
          <target state="translated">Outro cenário que é específico para eventos de visualização é para marcá-los tratado para que os manipuladores de classe de bolha correspondentes não serão chamados.</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusButtonEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusButtonEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)">
          <source>Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</source>
          <target state="translated">Outro cenário que é específico para eventos de visualização é para marcá-los tratado para que os manipuladores de classe de bolha correspondentes não serão chamados.</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusDownEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusDownEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)">
          <source>Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</source>
          <target state="translated">Outro cenário que é específico para eventos de visualização é para marcá-los tratado para que os manipuladores de classe de bolha correspondentes não serão chamados.</target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)">
          <source>Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</source>
          <target state="translated">Outro cenário que é específico para eventos de visualização é para marcá-los tratado para que os manipuladores de classe de bolha correspondentes não serão chamados.</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)">
          <source>Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</source>
          <target state="translated">Outro cenário que é específico para eventos de visualização é para marcá-los tratado para que os manipuladores de classe de bolha correspondentes não serão chamados.</target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)">
          <source>Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</source>
          <target state="translated">Outro cenário que é específico para eventos de visualização é para marcá-los tratado para que os manipuladores de classe de bolha correspondentes não serão chamados.</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)">
          <source>Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</source>
          <target state="translated">Outro cenário que é específico para eventos de visualização é para marcá-los tratado para que os manipuladores de classe de bolha correspondentes não serão chamados.</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)">
          <source>Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</source>
          <target state="translated">Outro cenário que é específico para eventos de visualização é para marcá-los tratado para que os manipuladores de classe de bolha correspondentes não serão chamados.</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)">
          <source>Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</source>
          <target state="translated">Outro cenário que é específico para eventos de visualização é para marcá-los tratado para que os manipuladores de classe de bolha correspondentes não serão chamados.</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.TextCompositionEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.TextCompositionEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)">
          <source>Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</source>
          <target state="translated">Outro cenário que é específico para eventos de visualização é para marcá-los tratado para que os manipuladores de classe de bolha correspondentes não serão chamados.</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)">
          <source>Provides class handling for the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewTouchDown" /&gt;</ph> routed event that occurs when a touch presses this element.</source>
          <target state="translated">Fornece tratamento de classes para os eventos roteados <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewTouchDown" /&gt;</ph> que ocorrem quando um toque pressiona esse elemento.</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewTouchDown%2A&gt;</ph> method has no default implementation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewTouchDown%2A&gt;</ph> método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewTouchDown%2A&gt;</ph> in a derived class to handle the <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewTouchDown&gt;</ph> event.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewTouchDown%2A&gt;</ph> em uma classe derivada para manipular o <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewTouchDown&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)">
          <source>Be sure to call the base class’s <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewTouchDown%2A&gt;</ph> method so that base classes receive the event.</source>
          <target state="translated">Certifique-se de chamar a classe base <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewTouchDown%2A&gt;</ph> método para classes de base que receber o evento.</target>       </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)">
          <source>Provides class handling for the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewTouchMove" /&gt;</ph> routed event that occurs when a touch moves while inside this element.</source>
          <target state="translated">Fornece manipulação de classes para o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewTouchMove" /&gt;</ph> que ocorre quando há uma movimentação de toque nesse elemento.</target>       </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewTouchMove%2A&gt;</ph> method has no default implementation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewTouchMove%2A&gt;</ph> método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewTouchMove%2A&gt;</ph> in a derived class to handle the <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewTouchMove&gt;</ph> event.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewTouchMove%2A&gt;</ph> em uma classe derivada para manipular o <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewTouchMove&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)">
          <source>Be sure to call the base class’s <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewTouchMove%2A&gt;</ph> method so that base classes receive the event.</source>
          <target state="translated">Certifique-se de chamar a classe base <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewTouchMove%2A&gt;</ph> método para classes de base que receber o evento.</target>       </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)">
          <source>Provides class handling for the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewTouchUp" /&gt;</ph> routed event that occurs when a touch is released inside this element.</source>
          <target state="translated">Fornece tratamento de classe para os eventos roteados <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewTouchUp" /&gt;</ph> que ocorrem quando um toque é liberado dentro desse elemento.</target>       </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewTouchUp%2A&gt;</ph> method has no default implementation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewTouchUp%2A&gt;</ph> método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewTouchUp%2A&gt;</ph> in a derived class to handle the <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewTouchUp&gt;</ph> event.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewTouchUp%2A&gt;</ph> em uma classe derivada para manipular o <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewTouchUp&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)">
          <source>Be sure to call the base class’s <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewTouchUp%2A&gt;</ph> method so that base classes receive the event.</source>
          <target state="translated">Certifique-se de chamar a classe base <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewTouchUp%2A&gt;</ph> método para classes de base que receber o evento.</target>       </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.QueryContinueDragEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.QueryContinueDragEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.DragDrop.QueryContinueDrag" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.DragDrop.QueryContinueDrag" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.QueryCursorEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.QueryCursorEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Mouse.QueryCursor" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Mouse.QueryCursor" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)">
          <source>The drawing instructions for a specific element.</source>
          <target state="translated">As instruções de desenho para um elemento específico.</target>       </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)">
          <source>This context is provided to the layout system.</source>
          <target state="translated">Esse contexto é fornecido para o sistema de layout.</target>       </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)">
          <source>When overridden in a derived class, participates in rendering operations that are directed by the layout system.</source>
          <target state="translated">Quando substituído em uma classe derivada, participa de operações de renderização direcionadas pelo sistema de layout.</target>       </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)">
          <source>The rendering instructions for this element are not used directly when this method is invoked, and are instead preserved for later asynchronous use by layout and drawing.</source>
          <target state="translated">As instruções de renderização para esse elemento não são usadas diretamente quando este método é invocado e, em vez disso, são preservadas para serem usadas posteriormente de forma assíncrona pelo layout e desenho.</target>       </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)">
          <source>This method has no default implementation in the <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> class.</source>
          <target state="translated">Este método não tem nenhuma implementação padrão <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)">
          <source>The following code example shows a possible implementation for a panel derived class.</source>
          <target state="translated">O exemplo de código a seguir mostra uma possível implementação de uma classe derivada de painel.</target>       </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)">
          <source>The <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" /&gt;</ph> method can be overridden to add further graphical elements (not previously defined in a logical tree) to a rendered element, such as effects or adorners.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" /&gt;</ph> método pode ser substituído para adicionar mais elementos gráficos (não foi definidos em uma árvore lógica) para um elemento renderizado, como efeitos ou adorners.</target>       </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Media.DrawingContext" /&gt;</ph> object is passed as an argument, which provides methods for drawing shapes, text, images or videos.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Windows.Media.DrawingContext" /&gt;</ph> objeto é passado como um argumento, que fornece métodos para desenhar formas, texto, imagens ou vídeos.</target>       </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)">
          <source>The packaged parameters (<ph id="ph1">&lt;see cref="T:System.Windows.SizeChangedInfo" /&gt;</ph>), which includes old and new sizes, and which dimension actually changes.</source>
          <target state="translated">Os parâmetros empacotados (<ph id="ph1">&lt;see cref="T:System.Windows.SizeChangedInfo" /&gt;</ph>), que incluem tamanhos novos e antigos e cuja dimensão é realmente alterada.</target>       </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)">
          <source>When overridden in a derived class, participates in rendering operations that are directed by the layout system.</source>
          <target state="translated">Quando substituído em uma classe derivada, participa de operações de renderização direcionadas pelo sistema de layout.</target>       </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)">
          <source>This method is invoked after layout update, and before rendering, if the element's <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.RenderSize" /&gt;</ph> has changed as a result of layout update.</source>
          <target state="translated">Esse método será invocado após a atualização do layout e antes da renderização se o <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.RenderSize" /&gt;</ph> do elemento tiver sido alterado como resultado da atualização do layout.</target>       </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)">
          <source>A typical WPF framework-level element uses the override implementation from <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>.</source>
          <target state="translated">Um elemento de nível de framework WPF típico usa a implementação de substituição de <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> implementation invalidates the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph> properties and handles the basics of remaking the layout.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> implementação invalida o <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph> e <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph> propriedades e manipula os fundamentos de refazendo o layout.</target>       </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)">
          <source>Overriding <ph id="ph1">&lt;xref:System.Windows.UIElement.OnRenderSizeChanged%2A&gt;</ph> at the <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> level implies that your element implementation is deliberately not using the WPF framework-level implementation, and therefore your element must handle layout logic more directly, typically by writing a replacement layout system.</source>
          <target state="translated">Substituindo <ph id="ph1">&lt;xref:System.Windows.UIElement.OnRenderSizeChanged%2A&gt;</ph> no <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> nível implica que sua implementação de elemento não está usando a implementação de nível de framework do WPF e, portanto, o elemento deve lidar com lógica de layout mais diretamente, normalmente, escrevendo um sistema de layout de substituição.</target>       </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusButtonEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusButtonEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusButtonEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusButtonEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusDownEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusDownEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.StylusDown" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.StylusDown" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.StylusEnter" /&gt;</ph> attached event is raised by this element.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.StylusEnter" /&gt;</ph> sem tratamento é gerado por esse elemento.</target>       </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)">
          <source>You may call base either before or after your special handling, depending on your requirements.</source>
          <target state="translated">Você pode chamar base antes ou depois do tratamento especial, dependendo dos seus requisitos.</target>       </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)">
          <source>The purpose of this method is similar to <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante ao <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)">
          <source>Marking the event as handled is still useful for preventing typical instance handlers (those that do not specify <ph id="ph1">`handledEventsToo`</ph>) from being invoked.</source>
          <target state="translated">Marcar o evento como tratado ainda é útil para que os manipuladores de instância típica (aquelas que não especificam <ph id="ph1">`handledEventsToo`</ph>) seja chamado.</target>       </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.StylusInRange" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.StylusInRange" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.StylusLeave" /&gt;</ph> attached event is raised by this element.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.StylusLeave" /&gt;</ph> sem tratamento é gerado por esse elemento.</target>       </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)">
          <source>You may call base either before or after your special handling, depending on your requirements.</source>
          <target state="translated">Você pode chamar base antes ou depois do tratamento especial, dependendo dos seus requisitos.</target>       </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)">
          <source>The purpose of this method is similar to <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante ao <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)">
          <source>Marking the event as handled is still useful for preventing typical instance handlers (those that do not specify <ph id="ph1">`handledEventsToo`</ph>) from being invoked.</source>
          <target state="translated">Marcar o evento como tratado ainda é útil para que os manipuladores de instância típica (aquelas que não especificam <ph id="ph1">`handledEventsToo`</ph>) seja chamado.</target>       </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusMove(System.Windows.Input.StylusEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusMove(System.Windows.Input.StylusEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.StylusMove" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.StylusMove" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusMove(System.Windows.Input.StylusEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusMove(System.Windows.Input.StylusEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusMove(System.Windows.Input.StylusEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusMove(System.Windows.Input.StylusEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusMove(System.Windows.Input.StylusEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusMove(System.Windows.Input.StylusEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusMove(System.Windows.Input.StylusEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusMove(System.Windows.Input.StylusEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusMove(System.Windows.Input.StylusEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusMove(System.Windows.Input.StylusEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusUp(System.Windows.Input.StylusEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.StylusEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusUp(System.Windows.Input.StylusEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.StylusUp" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.Stylus.StylusUp" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnStylusUp(System.Windows.Input.StylusEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusUp(System.Windows.Input.StylusEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusUp(System.Windows.Input.StylusEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusUp(System.Windows.Input.StylusEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusUp(System.Windows.Input.StylusEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusUp(System.Windows.Input.StylusEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusUp(System.Windows.Input.StylusEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusUp(System.Windows.Input.StylusEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusUp(System.Windows.Input.StylusEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnStylusUp(System.Windows.Input.StylusEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Input.TextCompositionEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Input.TextCompositionEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)">
          <source>Invoked when an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /&gt;</ph> attached event reaches an element in its route that is derived from this class.</source>
          <target state="translated">Invocado quando um evento anexado <ph id="ph1">&lt;see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /&gt;</ph> sem tratamento atinge um elemento em sua rota que deriva dessa classe.</target>       </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente esse método para adicionar tratamento de classe a esse evento.</target>       </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Esse método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)">
          <source>Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</source>
          <target state="translated">Como uma classe intermediária na herança pode implementar esse método, é recomendável que você chamar a implementação base em sua implementação.</target>       </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)">
          <source>The purpose of this method is similar to the <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</source>
          <target state="translated">O objetivo deste método é semelhante de <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> padrão de evento em * métodos: esse método fornece os meios para manipular o evento correspondente de classes derivadas, estabelecendo um manipulador de classe em vez de um manipulador de instância.</target>       </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">Nesse caso, o evento correspondente é um evento roteado.</target>       </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</source>
          <target state="translated">O padrão de implementação dos métodos On * é diferente para eventos roteados porque um evento roteado pode ser gerado por um elemento filho, que não é necessariamente o elemento que invocará manipuladores.</target>       </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)">
          <source>Therefore, your implementation needs to examine the source properties of the event data.</source>
          <target state="translated">Portanto, sua implementação precisa examinar as propriedades da fonte de dados do evento.</target>       </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)">
          <source>It should not try to reraise the event in most cases.</source>
          <target state="translated">Ele não deve tentar reraise o evento na maioria dos casos.</target>       </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)">
          <source>Either by overriding this method or by registering class handlers with <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, derived classes of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> can call private class handler methods when the event is received along the event route.</source>
          <target state="translated">Substituir este método ou registrando classe manipuladores com <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>, classes derivadas de <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> pode chamar os métodos do manipulador de classe privada quando o evento é recebido na rota de evento.</target>       </trans-unit>
        <trans-unit id="2503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)">
          <source>One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</source>
          <target state="translated">É um cenário onde a manipulação de classe é apropriada manipular os dados de evento e marcar o evento roteado como manipulado.</target>       </trans-unit>
        <trans-unit id="2504" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnTouchDown(System.Windows.Input.TouchEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2505" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnTouchDown(System.Windows.Input.TouchEventArgs)">
          <source>Provides class handling for the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.TouchDown" /&gt;</ph> routed event that occurs when a touch presses inside this element.</source>
          <target state="translated">Fornece tratamento de classes para os eventos roteados <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.TouchDown" /&gt;</ph> que ocorrem quando há um toque nesse elemento.</target>       </trans-unit>
        <trans-unit id="2506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnTouchDown(System.Windows.Input.TouchEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchDown%2A&gt;</ph> method has no default implementation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchDown%2A&gt;</ph> método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnTouchDown(System.Windows.Input.TouchEventArgs)">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchDown%2A&gt;</ph> in a derived class to handle the <ph id="ph2">&lt;xref:System.Windows.UIElement.TouchDown&gt;</ph> event.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchDown%2A&gt;</ph> em uma classe derivada para manipular o <ph id="ph2">&lt;xref:System.Windows.UIElement.TouchDown&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="2508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnTouchDown(System.Windows.Input.TouchEventArgs)">
          <source>Be sure to call the base class’s <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchDown%2A&gt;</ph> method so that base classes receive the event.</source>
          <target state="translated">Certifique-se de chamar a classe base <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchDown%2A&gt;</ph> método para classes de base que receber o evento.</target>       </trans-unit>
        <trans-unit id="2509" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2510" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)">
          <source>Provides class handling for the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.TouchEnter" /&gt;</ph> routed event that occurs when a touch moves from outside to inside the bounds of this element.</source>
          <target state="translated">Fornece tratamento de classes para os eventos roteados de <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.TouchEnter" /&gt;</ph> que ocorre quando um toque é movido de fora para dentro dos limites deste elemento.</target>       </trans-unit>
        <trans-unit id="2511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchEnter%2A&gt;</ph> method has no default implementation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchEnter%2A&gt;</ph> método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchEnter%2A&gt;</ph> in a derived class to handle the <ph id="ph2">&lt;xref:System.Windows.UIElement.TouchEnter&gt;</ph> event.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchEnter%2A&gt;</ph> em uma classe derivada para manipular o <ph id="ph2">&lt;xref:System.Windows.UIElement.TouchEnter&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="2513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)">
          <source>Be sure to call the base class’s <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchEnter%2A&gt;</ph> method so that base classes receive the event.</source>
          <target state="translated">Certifique-se de chamar a classe base <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchEnter%2A&gt;</ph> método para classes de base que receber o evento.</target>       </trans-unit>
        <trans-unit id="2514" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2515" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)">
          <source>Provides class handling for the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.TouchLeave" /&gt;</ph> routed event that occurs when a touch moves from inside to outside the bounds of this <ph id="ph2">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph>.</source>
          <target state="translated">Fornece tratamento de classe para os eventos roteados <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.TouchLeave" /&gt;</ph> que ocorre quando um toque é movido de dentro para fora dos limites deste <ph id="ph2">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchLeave%2A&gt;</ph> method has no default implementation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchLeave%2A&gt;</ph> método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchLeave%2A&gt;</ph> in a derived class to handle the <ph id="ph2">&lt;xref:System.Windows.UIElement.TouchLeave&gt;</ph> event.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchLeave%2A&gt;</ph> em uma classe derivada para manipular o <ph id="ph2">&lt;xref:System.Windows.UIElement.TouchLeave&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="2518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)">
          <source>Be sure to call the base class’s <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchLeave%2A&gt;</ph> method so that base classes receive the event.</source>
          <target state="translated">Certifique-se de chamar a classe base <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchLeave%2A&gt;</ph> método para classes de base que receber o evento.</target>       </trans-unit>
        <trans-unit id="2519" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnTouchMove(System.Windows.Input.TouchEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2520" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnTouchMove(System.Windows.Input.TouchEventArgs)">
          <source>Provides class handling for the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.TouchMove" /&gt;</ph> routed event that occurs when a touch moves while inside this element.</source>
          <target state="translated">Fornece manipulação de classes para o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.TouchMove" /&gt;</ph> que ocorre quando há uma movimentação de toque nesse elemento.</target>       </trans-unit>
        <trans-unit id="2521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnTouchMove(System.Windows.Input.TouchEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchMove%2A&gt;</ph> method has no default implementation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchMove%2A&gt;</ph> método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnTouchMove(System.Windows.Input.TouchEventArgs)">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchMove%2A&gt;</ph> in a derived class to handle the <ph id="ph2">&lt;xref:System.Windows.UIElement.TouchMove&gt;</ph> event.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchMove%2A&gt;</ph> em uma classe derivada para manipular o <ph id="ph2">&lt;xref:System.Windows.UIElement.TouchMove&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="2523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnTouchMove(System.Windows.Input.TouchEventArgs)">
          <source>Be sure to call the base class’s <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchMove%2A&gt;</ph> method so that base classes receive the event.</source>
          <target state="translated">Certifique-se de chamar a classe base <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchMove%2A&gt;</ph> método para classes de base que receber o evento.</target>       </trans-unit>
        <trans-unit id="2524" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnTouchUp(System.Windows.Input.TouchEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchEventArgs" /&gt;</ph> que contém os dados do evento.</target>       </trans-unit>
        <trans-unit id="2525" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnTouchUp(System.Windows.Input.TouchEventArgs)">
          <source>Provides class handling for the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.TouchUp" /&gt;</ph> routed event that occurs when a touch is released inside this element.</source>
          <target state="translated">Fornece tratamento de classe para os eventos roteados <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.TouchUp" /&gt;</ph> que ocorrem quando um toque é liberado dentro desse elemento.</target>       </trans-unit>
        <trans-unit id="2526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnTouchUp(System.Windows.Input.TouchEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchUp%2A&gt;</ph> method has no default implementation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchUp%2A&gt;</ph> método não tem nenhuma implementação padrão.</target>       </trans-unit>
        <trans-unit id="2527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnTouchUp(System.Windows.Input.TouchEventArgs)">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchUp%2A&gt;</ph> in a derived class to handle the <ph id="ph2">&lt;xref:System.Windows.UIElement.TouchUp&gt;</ph> event.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchUp%2A&gt;</ph> em uma classe derivada para manipular o <ph id="ph2">&lt;xref:System.Windows.UIElement.TouchUp&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="2528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnTouchUp(System.Windows.Input.TouchEventArgs)">
          <source>Be sure to call the base class’s <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchUp%2A&gt;</ph> method so that base classes receive the event.</source>
          <target state="translated">Certifique-se de chamar a classe base <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchUp%2A&gt;</ph> método para classes de base que receber o evento.</target>       </trans-unit>
        <trans-unit id="2529" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)">
          <source>The previous parent.</source>
          <target state="translated">O pai anterior.</target>       </trans-unit>
        <trans-unit id="2530" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)">
          <source>This may be provided as <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph> did not have a parent element previously.</source>
          <target state="translated">Pode ser fornecido como <ph id="ph1">&lt;see langword="null" /&gt;</ph> se o <ph id="ph2">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph> não teve um elemento pai anteriormente.</target>       </trans-unit>
        <trans-unit id="2531" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)">
          <source>Invoked when the parent element of this <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> reports a change to its underlying visual parent.</source>
          <target state="translated">Invocado quando o elemento pai desse <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> relata uma alteração ao seu pai visual subjacente.</target>       </trans-unit>
        <trans-unit id="2532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)">
          <source>If you override this method, always call the base implementation.</source>
          <target state="translated">Se você substituir esse método, sempre chame a implementação base.</target>       </trans-unit>
        <trans-unit id="2533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)">
          <source>The default base implementation performs some internal maintenance of reverse-inherited property state.</source>
          <target state="translated">A implementação base padrão executa algumas manutenção interna do estado de propriedade herdada inversa.</target>       </trans-unit>
        <trans-unit id="2534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)">
          <source>Failing to call the base implementation will invalidate this state.</source>
          <target state="translated">Falha ao chamar a implementação base invalidará nesse estado.</target>       </trans-unit>
        <trans-unit id="2535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)">
          <source>This method overrides <ph id="ph1">&lt;see cref="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" /&gt;</ph>.</source>
          <target state="translated">Este método substitui <ph id="ph1">&lt;see cref="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)">
          <source><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> and <ph id="ph2">&lt;see cref="T:System.Windows.Window" /&gt;</ph> both also override the <ph id="ph3">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> implementation of <ph id="ph4">&lt;see cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" /&gt;</ph>, and <ph id="ph5">&lt;see cref="T:System.Windows.Window" /&gt;</ph> seals it.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> e <ph id="ph2">&lt;see cref="T:System.Windows.Window" /&gt;</ph> ambos também substituem o <ph id="ph3">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> implementação de <ph id="ph4">&lt;see cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" /&gt;</ph>, e <ph id="ph5">&lt;see cref="T:System.Windows.Window" /&gt;</ph> lacra-lo.</target>       </trans-unit>
        <trans-unit id="2537" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.Opacity">
          <source>Gets or sets the opacity factor applied to the entire <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> when it is rendered in the <ph id="ph2">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.</source>
          <target state="translated">Obtém ou define o fator de opacidade aplicado a todo o <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> quando ele é renderizado no <ph id="ph2">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="2538" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.Opacity">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="2539" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Opacity">
          <source>The opacity factor.</source>
          <target state="translated">O fator de opacidade.</target>       </trans-unit>
        <trans-unit id="2540" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Opacity">
          <source>Default opacity is 1.0.</source>
          <target state="translated">Opacidade padrão é 1.0.</target>       </trans-unit>
        <trans-unit id="2541" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Opacity">
          <source>Expected values are between 0.0 and 1.0.</source>
          <target state="translated">Os valores esperados estão entre 0.0 e 1.0.</target>       </trans-unit>
        <trans-unit id="2542" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Opacity">
          <source>The 1.0 default value is the default provided by the initial metadata of this dependency property on the <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> class.</source>
          <target state="translated">O valor padrão de 1,0 é o padrão fornecido pelos metadados inicial dessa propriedade de dependência no <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="2543" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Opacity">
          <source>Other derived classes may potentially change this default value by overriding the metadata from within their class constructor.</source>
          <target state="translated">Outras classes derivadas potencialmente podem alterar esse valor padrão, substituindo os metadados de dentro de seu construtor de classe.</target>       </trans-unit>
        <trans-unit id="2544" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Opacity">
          <source>The value of <ph id="ph1">&lt;xref:System.Windows.UIElement.Opacity%2A&gt;</ph> won't be applied to actual layout unless the element is also visible (<ph id="ph2">&lt;xref:System.Windows.UIElement.IsVisible%2A&gt;</ph> is <ph id="ph3">`true`</ph>).</source>
          <target state="translated">O valor de <ph id="ph1">&lt;xref:System.Windows.UIElement.Opacity%2A&gt;</ph> não será aplicado ao layout real, a menos que o elemento também é visível (<ph id="ph2">&lt;xref:System.Windows.UIElement.IsVisible%2A&gt;</ph> é <ph id="ph3">`true`</ph>).</target>       </trans-unit>
        <trans-unit id="2545" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Opacity">
          <source><ph id="ph1">&lt;xref:System.Windows.UIElement.Opacity%2A&gt;</ph> is applied from parent elements on down the element tree to child elements, but the visible effects of the nested opacity settings aren't indicated in the property value of individual child elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.UIElement.Opacity%2A&gt;</ph> foi aplicado de elementos pai abaixo da árvore de elemento para elementos filho, mas os efeitos visíveis a opacidade aninhada configurações não são indicadas no valor da propriedade de elementos filho individuais.</target>       </trans-unit>
        <trans-unit id="2546" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Opacity">
          <source>For instance, if a list has a 50% (0.5) opacity and one of its list items has its own opacity set to 20% (0.2), the net visible opacity for that list item will be rendered as if it were 10% (0.1), but the property value of the list item <ph id="ph1">&lt;xref:System.Windows.UIElement.Opacity%2A&gt;</ph> property would still be 0.2 when queried.</source>
          <target state="translated">Por exemplo, se uma lista tem uma opacidade de 50% (0,5) e um de seus itens de lista tem seu próprio opacidade definida como 20% (0.2), a opacidade net visível para aquele item de lista será renderizada como se fosse 10% (0,1), mas o valor da propriedade do item da lista <ph id="ph1">&lt;xref:System.Windows.UIElement.Opacity%2A&gt;</ph> propriedade ainda será 0,2 quando consultado.</target>       </trans-unit>
        <trans-unit id="2547" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Opacity">
          <source>Even if the declared or evaluated opacity is 0, an element still participates in input events and commands, and is potentially focusable.</source>
          <target state="translated">Mesmo se a opacidade declarada ou avaliada for 0, um elemento ainda participa de comandos e eventos de entrada e é potencialmente Focusable é.</target>       </trans-unit>
        <trans-unit id="2548" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Opacity">
          <source>This aspect can be useful, for instance you can use an opacity-zero object (such as a shape) for masking underlying objects with transparent elements.</source>
          <target state="translated">Esse aspecto pode ser útil, por exemplo, você pode usar um objeto de opacidade de zero (como uma forma) para mascaramento objetos subjacentes com elementos transparentes.</target>       </trans-unit>
        <trans-unit id="2549" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Opacity">
          <source>The opacity-zero object can then handle all the input event processing for an underlying area.</source>
          <target state="translated">O objeto de opacidade de zero, em seguida, pode controlar todas as entrada processamento de eventos em uma área subjacente.</target>       </trans-unit>
        <trans-unit id="2550" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Opacity">
          <source>However, the <ph id="ph1">`Background`</ph> or <ph id="ph2">`Fill`</ph> of the object or shape should be set to a value, even if it is <ph id="ph3">&lt;xref:System.Windows.Media.Brushes.Transparent%2A&gt;</ph>, otherwise hit testing is not enabled, and no events are received.</source>
          <target state="translated">No entanto, o <ph id="ph1">`Background`</ph> ou <ph id="ph2">`Fill`</ph> do objeto ou da forma deve ser definido como um valor, mesmo se ele for <ph id="ph3">&lt;xref:System.Windows.Media.Brushes.Transparent%2A&gt;</ph>, caso contrário, o teste de clique não está habilitado e não há eventos são recebidos.</target>       </trans-unit>
        <trans-unit id="2551" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Opacity">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="2552" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Opacity">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="2553" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Opacity">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="2554" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Opacity">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="2555" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.OpacityMask">
          <source>Gets or sets an opacity mask, as a <ph id="ph1">&lt;see cref="T:System.Windows.Media.Brush" /&gt;</ph> implementation that is applied to any alpha-channel masking for the rendered content of this element.</source>
          <target state="translated">Obtém ou define uma máscara de opacidade como uma implementação de <ph id="ph1">&lt;see cref="T:System.Windows.Media.Brush" /&gt;</ph> que é aplicada a qualquer mascaramento de canal alfa para o conteúdo renderizado deste elemento.</target>       </trans-unit>
        <trans-unit id="2556" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.OpacityMask">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="2557" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.OpacityMask">
          <source>The brush to use for opacity masking.</source>
          <target state="translated">O pincel a ser usado para o mascaramento de opacidade.</target>       </trans-unit>
        <trans-unit id="2558" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.OpacityMask">
          <source>This property only uses whatever the alpha channel value is for the supplied <ph id="ph1">&lt;xref:System.Windows.Media.Brush&gt;</ph>.</source>
          <target state="translated">Esta propriedade usa apenas o que é o valor de canal alfa para fornecido <ph id="ph1">&lt;xref:System.Windows.Media.Brush&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2559" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.OpacityMask">
          <source>The other channels of the <ph id="ph1">&lt;xref:System.Windows.Media.Brush&gt;</ph>'s rendered content (Red, Green, or Blue) are ignored.</source>
          <target state="translated">Os outros canais do <ph id="ph1">&lt;xref:System.Windows.Media.Brush&gt;</ph>processada do conteúdo (vermelho, verde e azul) são ignorados.</target>       </trans-unit>
        <trans-unit id="2560" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.OpacityMask">
          <source>The most typical <ph id="ph1">&lt;xref:System.Windows.Media.Brush&gt;</ph> for this purpose is an <ph id="ph2">&lt;xref:System.Windows.Media.ImageBrush&gt;</ph>, which can be used for a variety of photo masking techniques such as a vignette.</source>
          <target state="translated">A mais comum <ph id="ph1">&lt;xref:System.Windows.Media.Brush&gt;</ph> para essa finalidade é um <ph id="ph2">&lt;xref:System.Windows.Media.ImageBrush&gt;</ph>, que pode ser usado para uma variedade de foto técnicas como um vignette de mascaramento.</target>       </trans-unit>
        <trans-unit id="2561" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.OpacityMask">
          <source>But any defined <ph id="ph1">&lt;xref:System.Windows.Media.Brush&gt;</ph> (such as <ph id="ph2">&lt;xref:System.Windows.Media.LinearGradientBrush&gt;</ph>) can be used.</source>
          <target state="translated">Mas qualquer definido <ph id="ph1">&lt;xref:System.Windows.Media.Brush&gt;</ph> (como <ph id="ph2">&lt;xref:System.Windows.Media.LinearGradientBrush&gt;</ph>) pode ser usado.</target>       </trans-unit>
        <trans-unit id="2562" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.OpacityMask">
          <source>In <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>, this property value can use an inline syntax that is specific to each implementation of the <ph id="ph2">&lt;xref:System.Windows.Media.Brush&gt;</ph> abstract class.</source>
          <target state="translated">Em <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>, esse valor de propriedade pode usar uma sintaxe embutida que é específica para cada implementação do <ph id="ph2">&lt;xref:System.Windows.Media.Brush&gt;</ph> classe abstrata.</target>       </trans-unit>
        <trans-unit id="2563" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.OpacityMask">
          <source>For more information, see <bpt id="p1">[</bpt>Painting with Solid Colors and Gradients Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/painting-with-solid-colors-and-gradients-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>pintura com cores sólidas e visão geral de gradientes<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/painting-with-solid-colors-and-gradients-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2564" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.OpacityMask">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="2565" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.OpacityMask">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="2566" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.OpacityMask">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="2567" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.OpacityMask">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="2568" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.OpacityMask">
          <source>The following markup example shows an <ph id="ph1">&lt;xref:System.Windows.Media.ImageBrush&gt;</ph> opacity mask applied to another <ph id="ph2">&lt;xref:System.Windows.Controls.Image&gt;</ph>.</source>
          <target state="translated">O exemplo de marcação a seguir mostra um <ph id="ph1">&lt;xref:System.Windows.Media.ImageBrush&gt;</ph> máscara de opacidade aplicada para outro <ph id="ph2">&lt;xref:System.Windows.Controls.Image&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2569" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.OpacityMaskProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.OpacityMask" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.OpacityMask" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2570" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.OpacityProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.Opacity" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.Opacity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2571" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.PersistId">
          <source>Gets a value that uniquely identifies this element.</source>
          <target state="translated">Obtém um valor que identifica esse objeto de forma exclusiva.</target>       </trans-unit>
        <trans-unit id="2572" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.PersistId">
          <source>The unique identifier for this element.</source>
          <target state="translated">O identificador exclusivo desse elemento.</target>       </trans-unit>
        <trans-unit id="2573" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.PersistId">
          <source><ph id="ph1">&lt;xref:System.Windows.UIElement.PersistId%2A&gt;</ph> uniquely identifies each element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.UIElement.PersistId%2A&gt;</ph> identifica exclusivamente cada elemento.</target>       </trans-unit>
        <trans-unit id="2574" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.PersistId">
          <source>An element keeps the same <ph id="ph1">&lt;xref:System.Windows.UIElement.PersistId%2A&gt;</ph> every time the same <ph id="ph2">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> is loaded (including binary representations).</source>
          <target state="translated">Um elemento mantém o mesmo <ph id="ph1">&lt;xref:System.Windows.UIElement.PersistId%2A&gt;</ph> toda vez que o mesmo <ph id="ph2">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> é carregado (incluindo representações binárias).</target>       </trans-unit>
        <trans-unit id="2575" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.PersistId">
          <source>This identifier is used for internal loading, parsing and serialization requirements.</source>
          <target state="translated">Esse identificador é usado para obter os requisitos de carregamento, análise e serialização internos.</target>       </trans-unit>
        <trans-unit id="2576" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.PersistId">
          <source>It is not intended to be used by your application code.</source>
          <target state="translated">Ele não se destina a ser usado pelo código do aplicativo.</target>       </trans-unit>
        <trans-unit id="2577" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.PersistId">
          <source>This property has no relationship to the <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> result for any given instance.</source>
          <target state="translated">Essa propriedade não tem relação com o <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> resultado para uma determinada instância.</target>       </trans-unit>
        <trans-unit id="2578" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>The direction of the requested focus traversal.</source>
          <target state="translated">A direção da passagem do foco solicitada.</target>       </trans-unit>
        <trans-unit id="2579" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>When overridden in a derived class, returns the element that would receive focus for a specified focus traversal direction, without actually moving focus to that element.</source>
          <target state="translated">Quando substituído em uma classe derivada, retorna o elemento que deve receber o foco para uma direção de passagem do foco especificada, sem realmente mover o foco para esse elemento.</target>       </trans-unit>
        <trans-unit id="2580" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>The element that would have received focus if <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" /&gt;</ph> were actually invoked.</source>
          <target state="translated">O elemento que teria recebido foco, se <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" /&gt;</ph> realmente fosse invocado.</target>       </trans-unit>
        <trans-unit id="2581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>The default implementation of this method in this class is incomplete, and always returns <ph id="ph1">`null`</ph>.</source>
          <target state="translated">A implementação padrão desse método nessa classe incompleta e sempre retorna <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2582" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewDragEnter">
          <source>Occurs when the input system reports an underlying drag event with this element as the drag target.</source>
          <target state="translated">Ocorre quando o sistema de entrada relata um evento arrastar subjacente com este elemento como o destino de arrastar.</target>       </trans-unit>
        <trans-unit id="2583" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDragEnter">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewDragEnter&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewDragEnter&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="2584" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDragEnter">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewDragEnter&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewDragEnter&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="2585" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDragEnter">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="2586" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDragEnter">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="2587" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDragEnter">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="2588" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDragEnter">
          <source>Tunneling</source>
          <target state="translated">Túnel</target>       </trans-unit>
        <trans-unit id="2589" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDragEnter">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="2590" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDragEnter">
          <source>The corresponding bubbling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.DragEnter&gt;</ph>.</source>
          <target state="translated">O evento correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.DragEnter&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2591" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDragEnter">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewDragEnter%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewDragEnter%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="2592" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewDragEnterEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewDragEnter" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewDragEnter" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2593" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewDragEnterEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="2594" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewDragEnterEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="2595" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewDragEnterEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="2596" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewDragEnterEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2597" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewDragEnterEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2598" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewDragLeave">
          <source>Occurs when the input system reports an underlying drag event with this element as the drag origin.</source>
          <target state="translated">Ocorre quando o sistema de entrada relata um evento arrastar subjacente com este elemento como a origem de arrastar.</target>       </trans-unit>
        <trans-unit id="2599" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDragLeave">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewDragLeave&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewDragLeave&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="2600" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDragLeave">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewDragLeave&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewDragLeave&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="2601" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDragLeave">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="2602" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDragLeave">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="2603" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDragLeave">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="2604" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDragLeave">
          <source>Tunneling</source>
          <target state="translated">Túnel</target>       </trans-unit>
        <trans-unit id="2605" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDragLeave">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="2606" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDragLeave">
          <source>The corresponding bubbling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.DragLeave&gt;</ph>.</source>
          <target state="translated">O evento correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.DragLeave&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2607" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDragLeave">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewDragLeave%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewDragLeave%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="2608" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewDragLeaveEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewDragLeave" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewDragLeave" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2609" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewDragLeaveEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="2610" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewDragLeaveEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="2611" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewDragLeaveEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="2612" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewDragLeaveEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2613" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewDragLeaveEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2614" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewDragOver">
          <source>Occurs when the input system reports an underlying drag event with this element as the potential drop target.</source>
          <target state="translated">Ocorre quando o sistema de entrada relata um evento do tipo "arrastar" subjacente com esse elemento como a reprodução automática potencial.</target>       </trans-unit>
        <trans-unit id="2615" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDragOver">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewDragOver&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewDragOver&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="2616" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDragOver">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewDragOver&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewDragOver&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="2617" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDragOver">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="2618" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDragOver">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="2619" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDragOver">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="2620" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDragOver">
          <source>Tunneling</source>
          <target state="translated">Túnel</target>       </trans-unit>
        <trans-unit id="2621" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDragOver">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="2622" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDragOver">
          <source>The corresponding bubbling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.DragOver&gt;</ph>.</source>
          <target state="translated">O evento correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.DragOver&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2623" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDragOver">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewDragOver%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewDragOver%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="2624" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewDragOverEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewDragOver" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewDragOver" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2625" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewDragOverEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="2626" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewDragOverEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="2627" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewDragOverEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="2628" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewDragOverEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2629" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewDragOverEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2630" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewDrop">
          <source>Occurs when the input system reports an underlying drop event with this element as the drop target.</source>
          <target state="translated">Ocorre quando o sistema de entrada relata um evento soltar subjacente com esse elemento sendo uma reprodução automática.</target>       </trans-unit>
        <trans-unit id="2631" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDrop">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewDrop&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewDrop&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="2632" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDrop">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewDrop&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewDrop&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="2633" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDrop">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="2634" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDrop">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="2635" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDrop">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="2636" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDrop">
          <source>Tunneling</source>
          <target state="translated">Túnel</target>       </trans-unit>
        <trans-unit id="2637" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDrop">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="2638" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDrop">
          <source>The corresponding bubbling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.Drop&gt;</ph>.</source>
          <target state="translated">O evento correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.Drop&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2639" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewDrop">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewDrop%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewDrop%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="2640" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewDropEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewDrop" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewDrop" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2641" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewDropEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="2642" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewDropEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="2643" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewDropEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="2644" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewDropEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2645" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewDropEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2646" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewGiveFeedback">
          <source>Occurs when a drag-and-drop operation is started.</source>
          <target state="translated">Ocorre quando uma operação de arrastar e soltar se inicia.</target>       </trans-unit>
        <trans-unit id="2647" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewGiveFeedback">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewGiveFeedback&gt;</ph> event enables the source of a drag event to modify the appearance of the mouse pointer, in order to give the user visual feedback during a drag-and-drop operation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewGiveFeedback&gt;</ph> evento permite que a origem de um evento arrastar para modificar a aparência do ponteiro do mouse, para fornecer os comentários visuais do usuário durante uma operação de arrastar e soltar.</target>       </trans-unit>
        <trans-unit id="2648" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewGiveFeedback">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewGiveFeedback&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewGiveFeedback&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="2649" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewGiveFeedback">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewGiveFeedback&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewGiveFeedback&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="2650" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewGiveFeedback">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="2651" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewGiveFeedback">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="2652" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewGiveFeedback">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="2653" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewGiveFeedback">
          <source>Tunneling</source>
          <target state="translated">Túnel</target>       </trans-unit>
        <trans-unit id="2654" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewGiveFeedback">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="2655" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewGiveFeedback">
          <source>The corresponding bubbling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.GiveFeedback&gt;</ph>.</source>
          <target state="translated">O evento correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.GiveFeedback&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2656" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewGiveFeedback">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewGiveFeedback%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewGiveFeedback%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="2657" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewGiveFeedbackEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewGiveFeedback" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewGiveFeedback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2658" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewGiveFeedbackEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="2659" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewGiveFeedbackEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="2660" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewGiveFeedbackEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="2661" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewGiveFeedbackEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2662" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewGiveFeedbackEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2663" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewGotKeyboardFocus">
          <source>Occurs when the keyboard is focused on this element.</source>
          <target state="translated">Ocorre quando o teclado está focalizado neste elemento.</target>       </trans-unit>
        <trans-unit id="2664" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewGotKeyboardFocus">
          <source>Because this event uses tunneling routing, the element that has focus might be a child element instead of the element where the event handler is actually attached.</source>
          <target state="translated">Como esse evento usa o encapsulamento de roteamento, o elemento que tem o foco seja um elemento filho, em vez do elemento onde o manipulador de eventos, na verdade, está conectado.</target>       </trans-unit>
        <trans-unit id="2665" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewGotKeyboardFocus">
          <source>Check the <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> in the event data to determine the actual element that has focus.</source>
          <target state="translated">Verifique o <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> nos dados de evento para determinar o elemento que tem o foco.</target>       </trans-unit>
        <trans-unit id="2666" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewGotKeyboardFocus">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewGotKeyboardFocus&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewGotKeyboardFocus&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="2667" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewGotKeyboardFocus">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewGotKeyboardFocus&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewGotKeyboardFocus&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="2668" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewGotKeyboardFocus">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="2669" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewGotKeyboardFocus">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="2670" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewGotKeyboardFocus">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="2671" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewGotKeyboardFocus">
          <source>Tunneling</source>
          <target state="translated">Túnel</target>       </trans-unit>
        <trans-unit id="2672" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewGotKeyboardFocus">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="2673" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewGotKeyboardFocus">
          <source>The corresponding bubbling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.GotKeyboardFocus&gt;</ph>.</source>
          <target state="translated">O evento correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.GotKeyboardFocus&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2674" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewGotKeyboardFocus">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewGotKeyboardFocus%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewGotKeyboardFocus%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="2675" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewGotKeyboardFocusEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewGotKeyboardFocus" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewGotKeyboardFocus" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2676" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewGotKeyboardFocusEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="2677" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewGotKeyboardFocusEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="2678" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewGotKeyboardFocusEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="2679" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewGotKeyboardFocusEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2680" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewGotKeyboardFocusEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2681" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewKeyDown">
          <source>Occurs when a key is pressed while focus is on this element.</source>
          <target state="translated">Ocorre quando uma tecla é pressionada enquanto o foco está neste elemento.</target>       </trans-unit>
        <trans-unit id="2682" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewKeyDown">
          <source>Key handling interacts with other platform features such as commanding and text composition.</source>
          <target state="translated">Tratamento de chaves interage com outros recursos de plataforma como composição ordenar e texto.</target>       </trans-unit>
        <trans-unit id="2683" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewKeyDown">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.KeyDown&gt;</ph> event is a lower-level text input event that might not behave as expected on certain controls.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.KeyDown&gt;</ph> é um evento de entrada de texto de nível inferior pode não funcionar como esperado em determinados controles.</target>       </trans-unit>
        <trans-unit id="2684" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewKeyDown">
          <source>This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</source>
          <target state="translated">Isso ocorre porque alguns controles tem composição de controle ou de tratamento de classe que fornece uma versão de nível mais alto de texto manipulação de entrada e eventos relacionados.</target>       </trans-unit>
        <trans-unit id="2685" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewKeyDown">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewKeyDown&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewKeyDown&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="2686" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewKeyDown">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewKeyDown&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewKeyDown&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="2687" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewKeyDown">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="2688" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewKeyDown">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="2689" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewKeyDown">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="2690" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewKeyDown">
          <source>Tunneling</source>
          <target state="translated">Túnel</target>       </trans-unit>
        <trans-unit id="2691" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewKeyDown">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="2692" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewKeyDown">
          <source>The corresponding bubbling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.KeyDown&gt;</ph>.</source>
          <target state="translated">O evento correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.KeyDown&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2693" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewKeyDown">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewKeyDown%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewKeyDown%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="2694" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewKeyDownEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewKeyDown" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewKeyDown" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2695" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewKeyDownEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="2696" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewKeyDownEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="2697" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewKeyDownEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="2698" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewKeyDownEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2699" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewKeyDownEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2700" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewKeyUp">
          <source>Occurs when a key is released while focus is on this element.</source>
          <target state="translated">Ocorre quando uma chave é liberada enquanto o foco está neste elemento.</target>       </trans-unit>
        <trans-unit id="2701" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewKeyUp">
          <source>Key handling interacts with other platform features such as commanding and text composition.</source>
          <target state="translated">Tratamento de chaves interage com outros recursos de plataforma como composição ordenar e texto.</target>       </trans-unit>
        <trans-unit id="2702" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewKeyUp">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.KeyUp&gt;</ph> event is a lower-level text input event that might not behave as expected on certain controls.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.KeyUp&gt;</ph> é um evento de entrada de texto de nível inferior pode não funcionar como esperado em determinados controles.</target>       </trans-unit>
        <trans-unit id="2703" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewKeyUp">
          <source>This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</source>
          <target state="translated">Isso ocorre porque alguns controles tem composição de controle ou de tratamento de classe que fornece uma versão de nível mais alto de texto manipulação de entrada e eventos relacionados.</target>       </trans-unit>
        <trans-unit id="2704" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewKeyUp">
          <source>For details, check the documentation for individual controls.</source>
          <target state="translated">Para obter detalhes, consulte a documentação para os controles individuais.</target>       </trans-unit>
        <trans-unit id="2705" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewKeyUp">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewKeyUp&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewKeyUp&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="2706" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewKeyUp">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewKeyUp&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewKeyUp&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="2707" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewKeyUp">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="2708" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewKeyUp">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="2709" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewKeyUp">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="2710" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewKeyUp">
          <source>Tunneling</source>
          <target state="translated">Túnel</target>       </trans-unit>
        <trans-unit id="2711" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewKeyUp">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="2712" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewKeyUp">
          <source>The corresponding bubbling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.KeyUp&gt;</ph>.</source>
          <target state="translated">O evento correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.KeyUp&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2713" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewKeyUp">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewKeyUp%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewKeyUp%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="2714" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewKeyUpEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewKeyUp" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewKeyUp" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2715" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewKeyUpEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="2716" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewKeyUpEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="2717" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewKeyUpEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="2718" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewKeyUpEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2719" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewKeyUpEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2720" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewLostKeyboardFocus">
          <source>Occurs when the keyboard is no longer focused on this element.</source>
          <target state="translated">Ocorre quando o teclado não está mais focalizado neste elemento.</target>       </trans-unit>
        <trans-unit id="2721" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewLostKeyboardFocus">
          <source>Because this event uses tunneling routing, the element that lost focus might be a child element instead of the element where the event handler is actually attached.</source>
          <target state="translated">Como esse evento usa o encapsulamento de roteamento, o elemento que perdeu o foco pode ser um elemento filho, em vez do elemento em que o manipulador de eventos, na verdade, está anexado.</target>       </trans-unit>
        <trans-unit id="2722" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewLostKeyboardFocus">
          <source>Check the <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> in the event data to determine the actual element that lost focus.</source>
          <target state="translated">Verifique o <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> nos dados de evento para determinar o elemento real que perdeu o foco.</target>       </trans-unit>
        <trans-unit id="2723" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewLostKeyboardFocus">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewLostKeyboardFocus&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewLostKeyboardFocus&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="2724" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewLostKeyboardFocus">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewLostKeyboardFocus&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewLostKeyboardFocus&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="2725" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewLostKeyboardFocus">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="2726" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewLostKeyboardFocus">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="2727" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewLostKeyboardFocus">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="2728" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewLostKeyboardFocus">
          <source>Tunneling</source>
          <target state="translated">Túnel</target>       </trans-unit>
        <trans-unit id="2729" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewLostKeyboardFocus">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="2730" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewLostKeyboardFocus">
          <source>The corresponding bubbling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.LostKeyboardFocus&gt;</ph>.</source>
          <target state="translated">O evento correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.LostKeyboardFocus&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2731" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewLostKeyboardFocus">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewLostKeyboardFocus%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewLostKeyboardFocus%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="2732" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewLostKeyboardFocusEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewLostKeyboardFocus" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewLostKeyboardFocus" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2733" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewLostKeyboardFocusEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="2734" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewLostKeyboardFocusEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="2735" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewLostKeyboardFocusEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="2736" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewLostKeyboardFocusEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2737" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewLostKeyboardFocusEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2738" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewMouseDown">
          <source>Occurs when any mouse button is pressed while the pointer is over this element.</source>
          <target state="translated">Ocorre quando qualquer botão do mouse é pressionado enquanto o ponteiro está sobre este elemento.</target>       </trans-unit>
        <trans-unit id="2739" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseDown">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewMouseDown&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewMouseDown&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="2740" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseDown">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseDown&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseDown&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="2741" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseDown">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseDown&gt;</ph> event is often raised together with either <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonDown&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonDown&gt;</ph>, which correspond to a press of one of the two standard mouse buttons.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseDown&gt;</ph> é normalmente gerado junto com o <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonDown&gt;</ph> ou <ph id="ph3">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonDown&gt;</ph>, que corresponde a um pressionamento de um dos dois botões de mouse padrão.</target>       </trans-unit>
        <trans-unit id="2742" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseDown">
          <source><ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonDown&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonDown&gt;</ph> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <ph id="ph3">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> event reaches this element along the event route.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonDown&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonDown&gt;</ph> também são eventos roteados, mas são eventos roteados diretos e o evento específico do botão apropriado é gerado quando o <ph id="ph3">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> evento atinge esse elemento na rota de evento.</target>       </trans-unit>
        <trans-unit id="2743" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseDown">
          <source>See Remarks for <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonDown&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonDown&gt;</ph>.</source>
          <target state="translated">Consulte os comentários para <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonDown&gt;</ph> ou <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonDown&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2744" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseDown">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="2745" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseDown">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="2746" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseDown">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="2747" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseDown">
          <source>Tunneling</source>
          <target state="translated">Túnel</target>       </trans-unit>
        <trans-unit id="2748" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseDown">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="2749" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseDown">
          <source>The corresponding bubbling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseDown&gt;</ph>.</source>
          <target state="translated">O evento correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseDown&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2750" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseDown">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewMouseDown%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewMouseDown%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="2751" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewMouseDownEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewMouseDown" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewMouseDown" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2752" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseDownEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="2753" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseDownEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="2754" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseDownEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="2755" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseDownEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2756" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseDownEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2757" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonDown">
          <source>Occurs when the left mouse button is pressed while the mouse pointer is over this element.</source>
          <target state="translated">Ocorre quando o botão esquerdo do mouse é pressionado enquanto o ponteiro do mouse está sobre este elemento.</target>       </trans-unit>
        <trans-unit id="2758" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonDown">
          <source>Although this  seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>.</source>
          <target state="translated">Embora isso parece siga uma rota de túnel por meio de uma árvore de elementos, na verdade é um evento roteado direto que é gerado e geradas novamente ao longo da árvore de elementos em cada <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2759" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonDown">
          <source>This event is one of several related events that report the mouse-button specifics of an underlying <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> event, which is an attached event that is processed by each element along an event route.</source>
          <target state="translated">Esse evento é um dos vários eventos relacionados que relatam as especificações de botão do mouse de uma base <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> evento, que é um evento que é processado por cada elemento de uma rota de evento.</target>       </trans-unit>
        <trans-unit id="2760" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonDown">
          <source>The event data of this event exposes the event data of the underlying <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Os dados de evento deste evento expõe os dados do evento de subjacente <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> eventos.</target>       </trans-unit>
        <trans-unit id="2761" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonDown">
          <source>If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%2A&gt;</ph>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</source>
          <target state="translated">Se esse evento é marcado como manipulado na rota de evento, os eventos específicos do botão do mouse ainda são gerados; No entanto, os manipuladores de eventos específicos de botão do mouse devem ser adicionados explicitamente chamando <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%2A&gt;</ph>, com a opção para lidar com eventos que já estão marcados como manipulados, para ser ouvintes para o evento.</target>       </trans-unit>
        <trans-unit id="2762" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonDown">
          <source>If you mark <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonDown&gt;</ph> handled, you are essentially marking <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> handled for all further listeners along the route, and on all related events.</source>
          <target state="translated">Se você marcar <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonDown&gt;</ph> tratados, você está essencialmente marcando <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> tratado para todas as outras ouvintes na rota e em todos os eventos relacionados.</target>       </trans-unit>
        <trans-unit id="2763" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonDown">
          <source>This possibly includes class-handler generated events such as <ph id="ph1">&lt;xref:System.Windows.Controls.Control.PreviewMouseDoubleClick&gt;</ph>.</source>
          <target state="translated">Isso possivelmente inclui eventos gerado pelo manipulador de classe, como <ph id="ph1">&lt;xref:System.Windows.Controls.Control.PreviewMouseDoubleClick&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2764" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonDown">
          <source>Conceptually, think of this event (and other mouse-button events on <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>) to be a mouse "service" (with the service definition provided by the <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> class).</source>
          <target state="translated">Pense conceitualmente, esse evento (e outros eventos de botão do mouse em <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>) para ser um mouse "serviço" (com a definição de serviço fornecida pelo <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> classe).</target>       </trans-unit>
        <trans-unit id="2765" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonDown">
          <source>The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</source>
          <target state="translated">O evento adiciona a conveniência de não precisar verificar os estados de botão do mouse (esquerda-direita, para cima para baixo) dos eventos de mouse original nos dados do evento.</target>       </trans-unit>
        <trans-unit id="2766" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonDown">
          <source>For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the <ph id="ph1">[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]</ph> on the <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> class rather than those on <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph>.</source>
          <target state="translated">Para cenários mais avançados, como verificação de estados de botões não padrão, talvez seja necessário usar o <ph id="ph1">[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]</ph> no <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> classe em vez de aqueles em <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2767" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonDown">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="2768" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonDown">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="2769" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonDown">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="2770" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonDown">
          <source>Direct</source>
          <target state="translated">Direto</target>       </trans-unit>
        <trans-unit id="2771" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonDown">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="2772" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonDown">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="2773" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewMouseLeftButtonDownEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2774" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseLeftButtonDownEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="2775" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseLeftButtonDownEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="2776" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseLeftButtonDownEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="2777" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseLeftButtonDownEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2778" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseLeftButtonDownEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2779" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonUp">
          <source>Occurs when the left mouse button is released while the mouse pointer is over this element.</source>
          <target state="translated">Ocorre quando o botão esquerdo do mouse é liberado enquanto o ponteiro do mouse está sobre este elemento.</target>       </trans-unit>
        <trans-unit id="2780" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonUp">
          <source>Although this  seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>.</source>
          <target state="translated">Embora isso parece siga uma rota de túnel por meio de uma árvore de elementos, na verdade é um evento roteado direto que é gerado e geradas novamente ao longo da árvore de elementos em cada <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2781" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonUp">
          <source>This event is one of several related events that report the mouse-button specifics of an underlying <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> event, which is an attached event that is processed by each element along an event route.</source>
          <target state="translated">Esse evento é um dos vários eventos relacionados que relatam as especificações de botão do mouse de uma base <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> evento, que é um evento que é processado por cada elemento de uma rota de evento.</target>       </trans-unit>
        <trans-unit id="2782" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonUp">
          <source>The event data of this event exposes the event data of the underlying <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Os dados de evento deste evento expõe os dados do evento de subjacente <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> eventos.</target>       </trans-unit>
        <trans-unit id="2783" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonUp">
          <source>If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%2A&gt;</ph>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</source>
          <target state="translated">Se esse evento é marcado como manipulado na rota de evento, os eventos específicos do botão do mouse ainda são gerados; No entanto, os manipuladores de eventos específicos de botão do mouse devem ser adicionados explicitamente chamando <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%2A&gt;</ph>, com a opção para lidar com eventos que já estão marcados como manipulados, para ser ouvintes para o evento.</target>       </trans-unit>
        <trans-unit id="2784" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonUp">
          <source>If you mark <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonUp&gt;</ph> handled, you are essentially marking <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> handled for all further listeners along the route, and on all related events.</source>
          <target state="translated">Se você marcar <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonUp&gt;</ph> tratados, você está essencialmente marcando <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> tratado para todas as outras ouvintes na rota e em todos os eventos relacionados.</target>       </trans-unit>
        <trans-unit id="2785" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonUp">
          <source>Conceptually, think of this event (and other mouse-button events on <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>) to be a mouse "service" (with the service definition provided by the <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> class).</source>
          <target state="translated">Pense conceitualmente, esse evento (e outros eventos de botão do mouse em <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>) para ser um mouse "serviço" (com a definição de serviço fornecida pelo <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> classe).</target>       </trans-unit>
        <trans-unit id="2786" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonUp">
          <source>The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</source>
          <target state="translated">O evento adiciona a conveniência de não precisar verificar os estados de botão do mouse (esquerda-direita, para cima para baixo) dos eventos de mouse original nos dados do evento.</target>       </trans-unit>
        <trans-unit id="2787" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonUp">
          <source>For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the <ph id="ph1">[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]</ph> on the <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> class rather than those on <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph>.</source>
          <target state="translated">Para cenários mais avançados, como verificação de estados de botões não padrão, talvez seja necessário usar o <ph id="ph1">[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]</ph> no <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> classe em vez de aqueles em <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2788" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonUp">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="2789" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonUp">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="2790" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonUp">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="2791" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonUp">
          <source>Direct</source>
          <target state="translated">Direto</target>       </trans-unit>
        <trans-unit id="2792" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonUp">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="2793" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseLeftButtonUp">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewMouseLeftButtonUp%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewMouseLeftButtonUp%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="2794" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewMouseLeftButtonUpEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonUp" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonUp" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2795" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseLeftButtonUpEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="2796" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseLeftButtonUpEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="2797" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseLeftButtonUpEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="2798" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseLeftButtonUpEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2799" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseLeftButtonUpEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2800" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewMouseMove">
          <source>Occurs when the mouse pointer moves while the mouse pointer is over this element.</source>
          <target state="translated">Ocorre quando o ponteiro do mouse se move enquanto está sobre este elemento.</target>       </trans-unit>
        <trans-unit id="2801" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseMove">
          <source>This event occurs both when the mouse pointer first enters into the element bounds, and also when the mouse pointer moves while still remaining within the element bounds.</source>
          <target state="translated">Esse evento ocorre quando o ponteiro do mouse entra pela primeira vez dos limites do elemento, e também quando o ponteiro do mouse se move enquanto ainda resta dentro dos limites do elemento.</target>       </trans-unit>
        <trans-unit id="2802" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseMove">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewMouseMove&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewMouseMove&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="2803" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseMove">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseMove&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseMove&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="2804" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseMove">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="2805" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseMove">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="2806" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseMove">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="2807" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseMove">
          <source>Tunneling</source>
          <target state="translated">Túnel</target>       </trans-unit>
        <trans-unit id="2808" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseMove">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="2809" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseMove">
          <source>The corresponding bubbling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseMove&gt;</ph>.</source>
          <target state="translated">O evento correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseMove&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2810" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseMove">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewMouseMove%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewMouseMove%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="2811" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewMouseMoveEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewMouseMove" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewMouseMove" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2812" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseMoveEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="2813" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseMoveEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="2814" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseMoveEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="2815" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseMoveEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2816" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseMoveEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2817" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewMouseRightButtonDown">
          <source>Occurs when the right mouse button is pressed while the mouse pointer is over this element.</source>
          <target state="translated">Ocorre quando o botão direito do mouse é pressionado enquanto o ponteiro do mouse está sobre este elemento.</target>       </trans-unit>
        <trans-unit id="2818" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonDown">
          <source>Although this  seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>.</source>
          <target state="translated">Embora isso parece siga uma rota de túnel por meio de uma árvore de elementos, na verdade é um evento roteado direto que é gerado e geradas novamente ao longo da árvore de elementos em cada <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2819" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonDown">
          <source>This event is one of several related events that report the mouse-button specifics of an underlying <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> event, which is an attached event that is processed by each element along an event route.</source>
          <target state="translated">Esse evento é um dos vários eventos relacionados que relatam as especificações de botão do mouse de uma base <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> evento, que é um evento que é processado por cada elemento de uma rota de evento.</target>       </trans-unit>
        <trans-unit id="2820" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonDown">
          <source>The event data of this event exposes the event data of the underlying <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Os dados de evento deste evento expõe os dados do evento de subjacente <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> eventos.</target>       </trans-unit>
        <trans-unit id="2821" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonDown">
          <source>If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%2A&gt;</ph>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</source>
          <target state="translated">Se esse evento é marcado como manipulado na rota de evento, os eventos específicos do botão do mouse ainda são gerados; No entanto, os manipuladores de eventos específicos de botão do mouse devem ser adicionados explicitamente chamando <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%2A&gt;</ph>, com a opção para lidar com eventos que já estão marcados como manipulados, para ser ouvintes para o evento.</target>       </trans-unit>
        <trans-unit id="2822" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonDown">
          <source>If you mark <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonDown&gt;</ph> handled, you are essentially marking <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> handled for all further listeners along the route, and on all related events.</source>
          <target state="translated">Se você marcar <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonDown&gt;</ph> tratados, você está essencialmente marcando <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType&gt;</ph> tratado para todas as outras ouvintes na rota e em todos os eventos relacionados.</target>       </trans-unit>
        <trans-unit id="2823" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonDown">
          <source>This possibly includes class-handler generated events such as <ph id="ph1">&lt;xref:System.Windows.Controls.Control.PreviewMouseDoubleClick&gt;</ph>.</source>
          <target state="translated">Isso possivelmente inclui eventos gerado pelo manipulador de classe, como <ph id="ph1">&lt;xref:System.Windows.Controls.Control.PreviewMouseDoubleClick&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2824" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonDown">
          <source>Conceptually, think of this event (and other mouse-button events on <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>) to be a mouse "service" (with the service definition provided by the <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> class).</source>
          <target state="translated">Pense conceitualmente, esse evento (e outros eventos de botão do mouse em <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>) para ser um mouse "serviço" (com a definição de serviço fornecida pelo <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> classe).</target>       </trans-unit>
        <trans-unit id="2825" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonDown">
          <source>The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</source>
          <target state="translated">O evento adiciona a conveniência de não precisar verificar os estados de botão do mouse (esquerda-direita, para cima para baixo) dos eventos de mouse original nos dados do evento.</target>       </trans-unit>
        <trans-unit id="2826" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonDown">
          <source>For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the <ph id="ph1">[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]</ph> on the <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> class rather than those on <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph>.</source>
          <target state="translated">Para cenários mais avançados, como verificação de estados de botões não padrão, talvez seja necessário usar o <ph id="ph1">[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]</ph> no <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> classe em vez de aqueles em <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2827" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonDown">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="2828" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonDown">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="2829" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonDown">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="2830" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonDown">
          <source>Direct</source>
          <target state="translated">Direto</target>       </trans-unit>
        <trans-unit id="2831" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonDown">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="2832" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonDown">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="2833" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewMouseRightButtonDownEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewMouseRightButtonDown" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewMouseRightButtonDown" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2834" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseRightButtonDownEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="2835" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseRightButtonDownEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="2836" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseRightButtonDownEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="2837" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseRightButtonDownEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2838" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseRightButtonDownEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2839" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewMouseRightButtonUp">
          <source>Occurs when the right mouse button is released while the mouse pointer is over this element.</source>
          <target state="translated">Ocorre quando o botão direito do mouse é liberado enquanto o ponteiro do mouse está sobre este elemento.</target>       </trans-unit>
        <trans-unit id="2840" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonUp">
          <source>Although this  seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>.</source>
          <target state="translated">Embora isso parece siga uma rota de túnel por meio de uma árvore de elementos, na verdade é um evento roteado direto que é gerado e geradas novamente ao longo da árvore de elementos em cada <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2841" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonUp">
          <source>This event is one of several related events that report the mouse-button specifics of an underlying <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> event, which is an attached event that is processed by each element along an event route.</source>
          <target state="translated">Esse evento é um dos vários eventos relacionados que relatam as especificações de botão do mouse de uma base <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> evento, que é um evento que é processado por cada elemento de uma rota de evento.</target>       </trans-unit>
        <trans-unit id="2842" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonUp">
          <source>The event data of this event exposes the event data of the underlying <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Os dados de evento deste evento expõe os dados do evento de subjacente <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> eventos.</target>       </trans-unit>
        <trans-unit id="2843" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonUp">
          <source>If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%2A&gt;</ph>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</source>
          <target state="translated">Se esse evento é marcado como manipulado na rota de evento, os eventos específicos do botão do mouse ainda são gerados; No entanto, os manipuladores de eventos específicos de botão do mouse devem ser adicionados explicitamente chamando <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%2A&gt;</ph>, com a opção para lidar com eventos que já estão marcados como manipulados, para ser ouvintes para o evento.</target>       </trans-unit>
        <trans-unit id="2844" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonUp">
          <source>If you mark <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonUp&gt;</ph> handled, you are essentially marking <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> handled for all further listeners along the route, and on all related events.</source>
          <target state="translated">Se você marcar <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonUp&gt;</ph> tratados, você está essencialmente marcando <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> tratado para todas as outras ouvintes na rota e em todos os eventos relacionados.</target>       </trans-unit>
        <trans-unit id="2845" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonUp">
          <source>Conceptually, think of this event (and other mouse-button events on <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>) to be a mouse "service" (with the service definition provided by the <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> class).</source>
          <target state="translated">Pense conceitualmente, esse evento (e outros eventos de botão do mouse em <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>) para ser um mouse "serviço" (com a definição de serviço fornecida pelo <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> classe).</target>       </trans-unit>
        <trans-unit id="2846" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonUp">
          <source>The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</source>
          <target state="translated">O evento adiciona a conveniência de não precisar verificar os estados de botão do mouse (esquerda-direita, para cima para baixo) dos eventos de mouse original nos dados do evento.</target>       </trans-unit>
        <trans-unit id="2847" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonUp">
          <source>For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the <ph id="ph1">[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]</ph> on the <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> class rather than those on <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph>.</source>
          <target state="translated">Para cenários mais avançados, como verificação de estados de botões não padrão, talvez seja necessário usar o <ph id="ph1">[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]</ph> no <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> classe em vez de aqueles em <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2848" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonUp">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="2849" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonUp">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="2850" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonUp">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="2851" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonUp">
          <source>Direct</source>
          <target state="translated">Direto</target>       </trans-unit>
        <trans-unit id="2852" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonUp">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="2853" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseRightButtonUp">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewMouseRightButtonUp%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewMouseRightButtonUp%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="2854" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewMouseRightButtonUpEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewMouseRightButtonUp" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewMouseRightButtonUp" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2855" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseRightButtonUpEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="2856" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseRightButtonUpEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="2857" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseRightButtonUpEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="2858" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseRightButtonUpEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2859" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseRightButtonUpEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2860" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewMouseUp">
          <source>Occurs when any mouse button is released while the mouse pointer is over this element.</source>
          <target state="translated">Ocorre quando qualquer botão do mouse é liberado enquanto o ponteiro do mouse está sobre este elemento.</target>       </trans-unit>
        <trans-unit id="2861" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseUp">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewMouseUp&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewMouseUp&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="2862" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseUp">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseUp&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseUp&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="2863" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseUp">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseUp&gt;</ph> event is often raised together with either <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonUp&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonUp&gt;</ph>, which correspond to a press of one of the two standard mouse buttons.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseUp&gt;</ph> é normalmente gerado junto com o <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonUp&gt;</ph> ou <ph id="ph3">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonUp&gt;</ph>, que corresponde a um pressionamento de um dos dois botões de mouse padrão.</target>       </trans-unit>
        <trans-unit id="2864" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseUp">
          <source><ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonUp&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonUp&gt;</ph> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <ph id="ph3">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> event reaches this element along the event route.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonUp&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonUp&gt;</ph> também são eventos roteados, mas são eventos roteados diretos e o evento específico do botão apropriado é gerado quando o <ph id="ph3">&lt;xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType&gt;</ph> evento atinge esse elemento na rota de evento.</target>       </trans-unit>
        <trans-unit id="2865" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseUp">
          <source>See Remarks for <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonUp&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonUp&gt;</ph>.</source>
          <target state="translated">Consulte os comentários para <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonUp&gt;</ph> ou <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewMouseRightButtonUp&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2866" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseUp">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="2867" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseUp">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="2868" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseUp">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="2869" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseUp">
          <source>Tunneling</source>
          <target state="translated">Túnel</target>       </trans-unit>
        <trans-unit id="2870" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseUp">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="2871" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseUp">
          <source>The corresponding bubbling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseUp&gt;</ph>.</source>
          <target state="translated">O evento correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseUp&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2872" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseUp">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewMouseUp%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewMouseUp%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="2873" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewMouseUpEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewMouseUp" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewMouseUp" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2874" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseUpEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="2875" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseUpEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="2876" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseUpEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="2877" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseUpEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2878" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseUpEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2879" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewMouseWheel">
          <source>Occurs when the user rotates the mouse wheel while the mouse pointer is over this element.</source>
          <target state="translated">Ocorre quando o usuário gira a roda do mouse enquanto o ponteiro do mouse está sobre este elemento.</target>       </trans-unit>
        <trans-unit id="2880" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseWheel">
          <source>Focus or mouse capture take precedence over where the mouse pointer is; therefore, if you receive this event from a focused or captured element, the mouse pointer might actually be over another element.</source>
          <target state="translated">Captura de foco ou mouse têm precedência sobre onde o ponteiro do mouse é; Portanto, se você receber esse evento de um elemento focalizado ou capturado, o ponteiro do mouse, na verdade, pode ser em outro elemento.</target>       </trans-unit>
        <trans-unit id="2881" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseWheel">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewMouseMove&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewMouseMove&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="2882" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseWheel">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseMove&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewMouseMove&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="2883" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseWheel">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="2884" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseWheel">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="2885" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseWheel">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="2886" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseWheel">
          <source>Tunneling</source>
          <target state="translated">Túnel</target>       </trans-unit>
        <trans-unit id="2887" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseWheel">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="2888" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseWheel">
          <source>The corresponding bubbling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseWheel&gt;</ph>.</source>
          <target state="translated">O evento correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.MouseWheel&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2889" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewMouseWheel">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewMouseWheel%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewMouseWheel%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="2890" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewMouseWheelEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewMouseWheel" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewMouseWheel" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2891" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseWheelEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="2892" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseWheelEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="2893" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseWheelEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="2894" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseWheelEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2895" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewMouseWheelEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2896" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewQueryContinueDrag">
          <source>Occurs when there is a change in the keyboard or mouse button state during a drag-and-drop operation.</source>
          <target state="translated">Ocorre quando há uma alteração no estado do botão do teclado ou do mouse durante uma operação de arrastar e soltar.</target>       </trans-unit>
        <trans-unit id="2897" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewQueryContinueDrag">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewQueryContinueDrag&gt;</ph> event enables the drag source to declare whether the drag-and-drop operation should be canceled.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewQueryContinueDrag&gt;</ph> evento permite que a fonte declarar se a operação de arrastar e soltar deve ser cancelada.</target>       </trans-unit>
        <trans-unit id="2898" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewQueryContinueDrag">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewQueryContinueDrag&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewQueryContinueDrag&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="2899" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewQueryContinueDrag">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewQueryContinueDrag&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewQueryContinueDrag&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="2900" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewQueryContinueDrag">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="2901" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewQueryContinueDrag">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="2902" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewQueryContinueDrag">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="2903" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewQueryContinueDrag">
          <source>Tunneling</source>
          <target state="translated">Túnel</target>       </trans-unit>
        <trans-unit id="2904" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewQueryContinueDrag">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="2905" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewQueryContinueDrag">
          <source>The corresponding bubbling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.QueryContinueDrag&gt;</ph>.</source>
          <target state="translated">O evento correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.QueryContinueDrag&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2906" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewQueryContinueDrag">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewQueryContinueDrag%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewQueryContinueDrag%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="2907" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewQueryContinueDragEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewQueryContinueDrag" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewQueryContinueDrag" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2908" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewQueryContinueDragEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="2909" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewQueryContinueDragEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="2910" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewQueryContinueDragEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="2911" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewQueryContinueDragEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2912" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewQueryContinueDragEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2913" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewStylusButtonDown">
          <source>Occurs when the stylus button is pressed while the pointer is over this element.</source>
          <target state="translated">Ocorre quando o botão da caneta é pressionado enquanto o ponteiro está sobre este elemento.</target>       </trans-unit>
        <trans-unit id="2914" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusButtonDown">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewStylusButtonDown&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewStylusButtonDown&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="2915" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusButtonDown">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusButtonDown&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusButtonDown&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="2916" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusButtonDown">
          <source>Touch, mouse, and stylus input exist in a particular relationship.</source>
          <target state="translated">Entrada de caneta, mouse e toque existem em uma relação específica.</target>       </trans-unit>
        <trans-unit id="2917" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusButtonDown">
          <source>For more information, see <bpt id="p1">[</bpt>Touch Input Support in Windows Vista<ept id="p1">](http://msdn.microsoft.com/library/63f1d71f-03d8-4d83-a174-e3dc7c57bad0)</ept> and <bpt id="p2">[</bpt>Input Overview<ept id="p2">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>Touch suporte de entrada no Windows Vista<ept id="p1">](http://msdn.microsoft.com/library/63f1d71f-03d8-4d83-a174-e3dc7c57bad0)</ept> e <bpt id="p2">[</bpt>visão geral de entrada<ept id="p2">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2918" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusButtonDown">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="2919" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusButtonDown">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="2920" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusButtonDown">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="2921" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusButtonDown">
          <source>Tunneling</source>
          <target state="translated">Túnel</target>       </trans-unit>
        <trans-unit id="2922" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusButtonDown">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="2923" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusButtonDown">
          <source>The corresponding bubbling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusButtonDown&gt;</ph>.</source>
          <target state="translated">O evento correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusButtonDown&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2924" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusButtonDown">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewStylusButtonDown%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewStylusButtonDown%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="2925" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewStylusButtonDownEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewStylusButtonDown" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewStylusButtonDown" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2926" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusButtonDownEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="2927" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusButtonDownEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="2928" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusButtonDownEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="2929" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusButtonDownEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2930" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusButtonDownEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2931" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewStylusButtonUp">
          <source>Occurs when the stylus button is released while the pointer is over this element.</source>
          <target state="translated">Ocorre quando o botão da caneta é liberado enquanto o ponteiro está sobre este elemento.</target>       </trans-unit>
        <trans-unit id="2932" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusButtonUp">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewStylusButtonUp&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewStylusButtonUp&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="2933" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusButtonUp">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusButtonUp&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusButtonUp&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="2934" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusButtonUp">
          <source>Touch, mouse, and stylus input exist in a particular relationship.</source>
          <target state="translated">Entrada de caneta, mouse e toque existem em uma relação específica.</target>       </trans-unit>
        <trans-unit id="2935" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusButtonUp">
          <source>For more information, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2936" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusButtonUp">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="2937" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusButtonUp">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="2938" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusButtonUp">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="2939" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusButtonUp">
          <source>Tunneling</source>
          <target state="translated">Túnel</target>       </trans-unit>
        <trans-unit id="2940" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusButtonUp">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="2941" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusButtonUp">
          <source>The corresponding bubbling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusButtonUp&gt;</ph>.</source>
          <target state="translated">O evento correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusButtonUp&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2942" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusButtonUp">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewStylusButtonUp%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewStylusButtonUp%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="2943" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewStylusButtonUpEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewStylusButtonUp" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewStylusButtonUp" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2944" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusButtonUpEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="2945" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusButtonUpEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="2946" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusButtonUpEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="2947" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusButtonUpEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2948" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusButtonUpEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2949" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewStylusDown">
          <source>Occurs when the stylus touches the digitizer while it is over this element.</source>
          <target state="translated">Ocorre quando a caneta toca o digitalizador enquanto está sobre este elemento.</target>       </trans-unit>
        <trans-unit id="2950" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusDown">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewStylusDown&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewStylusDown&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="2951" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusDown">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusDown&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusDown&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="2952" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusDown">
          <source>Touch, mouse, and stylus input exist in a particular relationship.</source>
          <target state="translated">Entrada de caneta, mouse e toque existem em uma relação específica.</target>       </trans-unit>
        <trans-unit id="2953" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusDown">
          <source>For more information, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2954" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusDown">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="2955" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusDown">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="2956" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusDown">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="2957" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusDown">
          <source>Tunneling</source>
          <target state="translated">Túnel</target>       </trans-unit>
        <trans-unit id="2958" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusDown">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="2959" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusDown">
          <source>The corresponding bubbling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusDown&gt;</ph>.</source>
          <target state="translated">O evento correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusDown&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2960" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusDown">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewStylusDown%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewStylusDown%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="2961" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewStylusDownEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewStylusDown" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewStylusDown" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2962" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusDownEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="2963" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusDownEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="2964" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusDownEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="2965" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusDownEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2966" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusDownEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2967" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewStylusInAirMove">
          <source>Occurs when the stylus moves over an element without actually touching the digitizer.</source>
          <target state="translated">Ocorre quando a caneta se move sobre um elemento sem tocar de fato o digitalizador.</target>       </trans-unit>
        <trans-unit id="2968" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusInAirMove">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewStylusInAirMove&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewStylusInAirMove&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="2969" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusInAirMove">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusInAirMove&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusInAirMove&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="2970" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusInAirMove">
          <source>Touch, mouse, and stylus input exist in a particular relationship.</source>
          <target state="translated">Entrada de caneta, mouse e toque existem em uma relação específica.</target>       </trans-unit>
        <trans-unit id="2971" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusInAirMove">
          <source>For more information, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2972" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusInAirMove">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="2973" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusInAirMove">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="2974" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusInAirMove">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="2975" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusInAirMove">
          <source>Tunneling</source>
          <target state="translated">Túnel</target>       </trans-unit>
        <trans-unit id="2976" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusInAirMove">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="2977" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusInAirMove">
          <source>The corresponding bubbling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusInAirMove&gt;</ph>.</source>
          <target state="translated">O evento correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusInAirMove&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2978" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusInAirMove">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewStylusInAirMove%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewStylusInAirMove%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="2979" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewStylusInAirMoveEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewStylusInAirMove" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewStylusInAirMove" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2980" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusInAirMoveEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="2981" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusInAirMoveEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="2982" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusInAirMoveEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="2983" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusInAirMoveEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2984" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusInAirMoveEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2985" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewStylusInRange">
          <source>Occurs when the stylus is close enough to the digitizer to be detected, while over this element.</source>
          <target state="translated">Ocorre quando a caneta está sobre este elemento e perto o suficiente do digitalizador para ser detectada.</target>       </trans-unit>
        <trans-unit id="2986" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusInRange">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewStylusInRange&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewStylusInRange&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="2987" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusInRange">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusInRange&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusInRange&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="2988" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusInRange">
          <source>Touch, mouse, and stylus input exist in a particular relationship.</source>
          <target state="translated">Entrada de caneta, mouse e toque existem em uma relação específica.</target>       </trans-unit>
        <trans-unit id="2989" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusInRange">
          <source>For more information, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2990" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusInRange">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="2991" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusInRange">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="2992" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusInRange">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="2993" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusInRange">
          <source>Tunneling</source>
          <target state="translated">Túnel</target>       </trans-unit>
        <trans-unit id="2994" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusInRange">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="2995" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusInRange">
          <source>The corresponding bubbling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusInRange&gt;</ph>.</source>
          <target state="translated">O evento correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusInRange&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2996" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusInRange">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewStylusInRange%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewStylusInRange%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="2997" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewStylusInRangeEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewStylusInRange" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewStylusInRange" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2998" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusInRangeEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="2999" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusInRangeEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="3000" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusInRangeEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="3001" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusInRangeEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3002" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusInRangeEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3003" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewStylusMove">
          <source>Occurs when the stylus moves while over the element.</source>
          <target state="translated">Ocorre quando a caneta se move enquanto está sobre o elemento.</target>       </trans-unit>
        <trans-unit id="3004" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewStylusMove">
          <source>The stylus must move while being detected by the digitizer to raise this event, otherwise, <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewStylusInAirMove" /&gt;</ph> is raised instead.</source>
          <target state="translated">A caneta deverá se mover enquanto estiver sendo detectada pelo digitalizador para gerar este evento, caso contrário, <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewStylusInAirMove" /&gt;</ph> será gerado.</target>       </trans-unit>
        <trans-unit id="3005" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusMove">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewStylusMove&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewStylusMove&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="3006" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusMove">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusMove&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusMove&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="3007" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusMove">
          <source>Touch, mouse, and stylus input exist in a particular relationship.</source>
          <target state="translated">Entrada de caneta, mouse e toque existem em uma relação específica.</target>       </trans-unit>
        <trans-unit id="3008" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusMove">
          <source>For more information, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3009" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusMove">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="3010" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusMove">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3011" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusMove">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="3012" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusMove">
          <source>Tunneling</source>
          <target state="translated">Túnel</target>       </trans-unit>
        <trans-unit id="3013" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusMove">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="3014" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusMove">
          <source>The corresponding bubbling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusMove&gt;</ph>.</source>
          <target state="translated">O evento correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusMove&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3015" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusMove">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewStylusMove%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewStylusMove%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="3016" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewStylusMoveEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewStylusMove" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewStylusMove" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3017" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusMoveEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="3018" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusMoveEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="3019" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusMoveEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="3020" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusMoveEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3021" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusMoveEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3022" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewStylusOutOfRange">
          <source>Occurs when the stylus is too far from the digitizer to be detected.</source>
          <target state="translated">Ocorre quando a caneta está longe demais do digitalizador para ser detectada.</target>       </trans-unit>
        <trans-unit id="3023" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusOutOfRange">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewStylusOutOfRange&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewStylusOutOfRange&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="3024" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusOutOfRange">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusOutOfRange&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusOutOfRange&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="3025" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusOutOfRange">
          <source>Touch, mouse, and stylus input exist in a particular relationship.</source>
          <target state="translated">Entrada de caneta, mouse e toque existem em uma relação específica.</target>       </trans-unit>
        <trans-unit id="3026" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusOutOfRange">
          <source>For more information, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3027" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusOutOfRange">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="3028" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusOutOfRange">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3029" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusOutOfRange">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="3030" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusOutOfRange">
          <source>Tunneling</source>
          <target state="translated">Túnel</target>       </trans-unit>
        <trans-unit id="3031" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusOutOfRange">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="3032" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusOutOfRange">
          <source>The corresponding bubbling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusOutOfRange&gt;</ph>.</source>
          <target state="translated">O evento correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusOutOfRange&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3033" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusOutOfRange">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewStylusOutOfRange%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewStylusOutOfRange%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="3034" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewStylusOutOfRangeEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewStylusOutOfRange" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewStylusOutOfRange" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3035" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusOutOfRangeEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="3036" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusOutOfRangeEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="3037" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusOutOfRangeEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="3038" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusOutOfRangeEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3039" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusOutOfRangeEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3040" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewStylusSystemGesture">
          <source>Occurs when a user performs one of several stylus gestures.</source>
          <target state="translated">Ocorre quando o usuário executa um dos diversos gestos da caneta.</target>       </trans-unit>
        <trans-unit id="3041" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusSystemGesture">
          <source>For information about stylus gestures, see <ph id="ph1">&lt;xref:System.Windows.Input.SystemGesture&gt;</ph>.</source>
          <target state="translated">Para obter informações sobre gestos da caneta, consulte <ph id="ph1">&lt;xref:System.Windows.Input.SystemGesture&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3042" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusSystemGesture">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewStylusSystemGesture&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewStylusSystemGesture&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="3043" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusSystemGesture">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusSystemGesture&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusSystemGesture&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="3044" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusSystemGesture">
          <source>Touch, mouse, and stylus input exist in a particular relationship.</source>
          <target state="translated">Entrada de caneta, mouse e toque existem em uma relação específica.</target>       </trans-unit>
        <trans-unit id="3045" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusSystemGesture">
          <source>For more information, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3046" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusSystemGesture">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="3047" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusSystemGesture">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3048" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusSystemGesture">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="3049" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusSystemGesture">
          <source>Tunneling</source>
          <target state="translated">Túnel</target>       </trans-unit>
        <trans-unit id="3050" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusSystemGesture">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="3051" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusSystemGesture">
          <source>The corresponding bubbling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusSystemGesture&gt;</ph>.</source>
          <target state="translated">O evento correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusSystemGesture&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3052" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusSystemGesture">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewStylusSystemGesture%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewStylusSystemGesture%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="3053" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewStylusSystemGestureEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewStylusSystemGesture" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewStylusSystemGesture" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3054" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusSystemGestureEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="3055" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusSystemGestureEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="3056" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusSystemGestureEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="3057" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusSystemGestureEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3058" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusSystemGestureEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3059" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewStylusUp">
          <source>Occurs when the user raises the stylus off the digitizer while the stylus is over this element.</source>
          <target state="translated">Ocorre quando o usuário retira a caneta do digitalizador enquanto ela está sobre esse elemento.</target>       </trans-unit>
        <trans-unit id="3060" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusUp">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewStylusDown&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewStylusDown&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="3061" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusUp">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusDown&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusDown&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="3062" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusUp">
          <source>Touch, mouse, and stylus input exist in a particular relationship.</source>
          <target state="translated">Entrada de caneta, mouse e toque existem em uma relação específica.</target>       </trans-unit>
        <trans-unit id="3063" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusUp">
          <source>For more information, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3064" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusUp">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="3065" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusUp">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3066" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusUp">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="3067" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusUp">
          <source>Tunneling</source>
          <target state="translated">Túnel</target>       </trans-unit>
        <trans-unit id="3068" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusUp">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="3069" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusUp">
          <source>The corresponding bubbling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusUp&gt;</ph>.</source>
          <target state="translated">O evento correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusUp&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3070" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewStylusUp">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewStylusUp%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewStylusUp%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="3071" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewStylusUpEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewStylusUp" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewStylusUp" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3072" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusUpEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="3073" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusUpEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="3074" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusUpEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="3075" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusUpEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3076" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewStylusUpEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3077" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewTextInput">
          <source>Occurs when this element gets text in a device-independent manner.</source>
          <target state="translated">Ocorre quando este elemento obtém texto de forma independente de dispositivo.</target>       </trans-unit>
        <trans-unit id="3078" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTextInput">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewTextInput&gt;</ph> event allows a component or application to listen for text input in a device-independent manner.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewTextInput&gt;</ph> evento permite que um componente ou aplicativo para escutar a entrada de texto de forma independente de dispositivo.</target>       </trans-unit>
        <trans-unit id="3079" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTextInput">
          <source>The keyboard is the primary means of <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewTextInput&gt;</ph>; but speech, handwriting, and other input devices can also generate <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewTextInput&gt;</ph>.</source>
          <target state="translated">O teclado é o principal meio de <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewTextInput&gt;</ph>; mas fala, manuscrito e outros dispositivos de entrada também podem gerar <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewTextInput&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3080" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTextInput">
          <source>Because of key combinations—either in default keyboards or through input method editors—multiple key events may raise just one text input event.</source>
          <target state="translated">Por causa de combinações de teclas — em teclados padrão ou por meio de editores de método de entrada — vários eventos de chave podem gerar um evento de entrada de texto.</target>       </trans-unit>
        <trans-unit id="3081" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTextInput">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewTextInput&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.PreviewTextInput&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="3082" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTextInput">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewTextInput&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewTextInput&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="3083" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTextInput">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="3084" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTextInput">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3085" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTextInput">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="3086" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTextInput">
          <source>Tunneling</source>
          <target state="translated">Túnel</target>       </trans-unit>
        <trans-unit id="3087" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTextInput">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="3088" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTextInput">
          <source>The corresponding bubbling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.TextInput&gt;</ph>.</source>
          <target state="translated">O evento correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.TextInput&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3089" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTextInput">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewTextInput%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewTextInput%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="3090" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewTextInputEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewTextInput" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewTextInput" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3091" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewTextInputEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="3092" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewTextInputEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="3093" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewTextInputEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="3094" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewTextInputEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3095" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.PreviewTextInputEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3096" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewTouchDown">
          <source>Occurs when a finger touches the screen while the finger is over this element.</source>
          <target state="translated">Ocorre quando um dedo toca a tela enquanto está sobre esse elemento.</target>       </trans-unit>
        <trans-unit id="3097" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchDown">
          <source>By default, the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewTouchDown&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.UIElement.TouchDown&gt;</ph> events do not occur until a finger touches the screen and moves.</source>
          <target state="translated">Por padrão, o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewTouchDown&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.UIElement.TouchDown&gt;</ph> eventos não ocorrer até que um dedo toca na tela e move.</target>       </trans-unit>
        <trans-unit id="3098" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchDown">
          <source>Pressing a finger on the screen and holding it without moving it causes the press and hold behavior of a <ph id="ph1">&lt;xref:System.Windows.Input.Stylus&gt;</ph>.</source>
          <target state="translated">Pressionando um dedo na tela, mantendo sem movê-lo faz com que o pressionamento e manter o comportamento de um <ph id="ph1">&lt;xref:System.Windows.Input.Stylus&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3099" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchDown">
          <source>The press and hold behavior is equivalent to a mouse right-click.</source>
          <target state="translated">O comportamento pressione e segure a tecla é equivalente a um clique do mouse.</target>       </trans-unit>
        <trans-unit id="3100" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchDown">
          <source>To cause the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewTouchDown&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.UIElement.TouchDown&gt;</ph> events to occur as soon as a finger touches the screen, set the <ph id="ph3">&lt;xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType&gt;</ph> attached property to <ph id="ph4">`false`</ph> for this element.</source>
          <target state="translated">Para fazer com que o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewTouchDown&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.UIElement.TouchDown&gt;</ph> eventos ocorrer como um dedo toca a tela, defina o <ph id="ph3">&lt;xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType&gt;</ph> anexado a propriedade <ph id="ph4">`false`</ph> para este elemento.</target>       </trans-unit>
        <trans-unit id="3101" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchDown">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="3102" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchDown">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3103" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchDown">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="3104" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchDown">
          <source>Tunneling</source>
          <target state="translated">Túnel</target>       </trans-unit>
        <trans-unit id="3105" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchDown">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="3106" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchDown">
          <source><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> of type <ph id="ph2">&lt;xref:System.Windows.Input.TouchEventArgs&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> do tipo <ph id="ph2">&lt;xref:System.Windows.Input.TouchEventArgs&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3107" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchDown">
          <source>The corresponding bubbling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.TouchDown&gt;</ph>.</source>
          <target state="translated">O evento correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.TouchDown&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3108" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchDown">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewTouchDown%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewTouchDown%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="3109" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewTouchDownEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewTouchDown" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewTouchDown" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3110" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewTouchMove">
          <source>Occurs when a finger moves on the screen while the finger is over this element.</source>
          <target state="translated">Ocorre quando um dedo se move na tela enquanto está sobre esse elemento.</target>       </trans-unit>
        <trans-unit id="3111" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchMove">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="3112" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchMove">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3113" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchMove">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="3114" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchMove">
          <source>Tunneling</source>
          <target state="translated">Túnel</target>       </trans-unit>
        <trans-unit id="3115" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchMove">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="3116" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchMove">
          <source><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> of type <ph id="ph2">&lt;xref:System.Windows.Input.TouchEventArgs&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> do tipo <ph id="ph2">&lt;xref:System.Windows.Input.TouchEventArgs&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3117" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchMove">
          <source>The corresponding bubbling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.TouchMove&gt;</ph>.</source>
          <target state="translated">O evento correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.TouchMove&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3118" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchMove">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewTouchMove%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewTouchMove%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="3119" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewTouchMoveEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewTouchMove" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewTouchMove" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3120" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.PreviewTouchUp">
          <source>Occurs when a finger is raised off of the screen while the finger is over this element.</source>
          <target state="translated">Ocorre quando um dedo é gerado fora da tela enquanto o dedo está sobre este elemento.</target>       </trans-unit>
        <trans-unit id="3121" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchUp">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="3122" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchUp">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3123" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchUp">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="3124" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchUp">
          <source>Tunneling</source>
          <target state="translated">Túnel</target>       </trans-unit>
        <trans-unit id="3125" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchUp">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="3126" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchUp">
          <source><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> of type <ph id="ph2">&lt;xref:System.Windows.Input.TouchEventArgs&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> do tipo <ph id="ph2">&lt;xref:System.Windows.Input.TouchEventArgs&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3127" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchUp">
          <source>The corresponding bubbling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.TouchUp&gt;</ph>.</source>
          <target state="translated">O evento correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.TouchUp&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3128" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.PreviewTouchUp">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewTouchUp%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnPreviewTouchUp%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="3129" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.PreviewTouchUpEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewTouchUp" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.PreviewTouchUp" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3130" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.QueryContinueDrag">
          <source>Occurs when there is a change in the keyboard or mouse button state during a drag-and-drop operation.</source>
          <target state="translated">Ocorre quando há uma alteração no estado do botão do teclado ou do mouse durante uma operação de arrastar e soltar.</target>       </trans-unit>
        <trans-unit id="3131" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryContinueDrag">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.QueryContinueDrag&gt;</ph> event enables the drag source to determine whether the drag-and-drop operation should be canceled.</source>
          <target state="translated">O evento <ph id="ph1">&lt;xref:System.Windows.UIElement.QueryContinueDrag&gt;</ph> permite que a fonte de arrastar determine se a operação do tipo "arrastar e soltar" deve ser cancelada.</target>       </trans-unit>
        <trans-unit id="3132" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryContinueDrag">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.QueryContinueDrag&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.QueryContinueDrag&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="3133" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryContinueDrag">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.QueryContinueDrag&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.QueryContinueDrag&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="3134" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryContinueDrag">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="3135" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryContinueDrag">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3136" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryContinueDrag">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="3137" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryContinueDrag">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="3138" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryContinueDrag">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="3139" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryContinueDrag">
          <source>The corresponding tunneling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewQueryContinueDrag&gt;</ph>.</source>
          <target state="translated">O evento de túnel correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewQueryContinueDrag&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3140" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryContinueDrag">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnQueryContinueDrag%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnQueryContinueDrag%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="3141" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.QueryContinueDragEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.QueryContinueDrag" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.QueryContinueDrag" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.QueryContinueDragEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="3143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.QueryContinueDragEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="3144" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.QueryContinueDragEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="3145" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.QueryContinueDragEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3146" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.QueryContinueDragEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3147" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.QueryCursor">
          <source>Occurs when the cursor is requested to display.</source>
          <target state="translated">Ocorre quando a exibição do cursor é solicitada.</target>       </trans-unit>
        <trans-unit id="3148" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.QueryCursor">
          <source>This event is raised on an element each time that the mouse pointer moves to a new location, which means the cursor object might need to be changed based on its new position.</source>
          <target state="translated">Este evento é gerado em um elemento toda vez que o ponteiro do mouse se move para uma nova localização, o que significa que o objeto de cursor talvez precise ser alterado de acordo com sua nova posição.</target>       </trans-unit>
        <trans-unit id="3149" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryCursor">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.QueryCursor&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.QueryCursor&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="3150" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryCursor">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.QueryCursor&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.QueryCursor&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="3151" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryCursor">
          <source>The cursor being referred to by this event name is not necessarily the text cursor (sometimes known as the insertion point).</source>
          <target state="translated">O cursor está sendo referenciado por este nome de evento não é necessariamente o cursor de texto (também conhecido como o ponto de inserção).</target>       </trans-unit>
        <trans-unit id="3152" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryCursor">
          <source>Instead, the cursor in this context is the object that declares the onscreen graphical display related to several possible input-related devices or concepts in <ph id="ph1">[!INCLUDE[TLA2#tla_win](~/includes/tla2sharptla-win-md.md)]</ph> programming.</source>
          <target state="translated">Em vez disso, o cursor neste contexto é o objeto que declara a exibição gráfica na tela relacionada a vários dispositivos possíveis relacionados a entrada ou conceitos em <ph id="ph1">[!INCLUDE[TLA2#tla_win](~/includes/tla2sharptla-win-md.md)]</ph> de programação.</target>       </trans-unit>
        <trans-unit id="3153" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryCursor">
          <source>That object is represented by the <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph> class in <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>.</source>
          <target state="translated">Esse objeto é representado pelo <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph> classe em <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="3154" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryCursor">
          <source>The <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> input system enables you to change this cursor when it represents the onscreen position of the mouse pointer.</source>
          <target state="translated">O <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> sistema de entrada permite que você altere esse cursor quando ele representa a posição na tela do ponteiro do mouse.</target>       </trans-unit>
        <trans-unit id="3155" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryCursor">
          <source>You can use predefined values from the <ph id="ph1">&lt;xref:System.Windows.Input.Cursors&gt;</ph> enumeration, or you can declare a custom cursor as an image file.</source>
          <target state="translated">Você pode usar valores predefinidos do <ph id="ph1">&lt;xref:System.Windows.Input.Cursors&gt;</ph> enumeração, ou você pode declarar um cursor personalizado como um arquivo de imagem.</target>       </trans-unit>
        <trans-unit id="3156" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryCursor">
          <source>Listening for the <ph id="ph1">&lt;xref:System.Windows.UIElement.QueryCursor&gt;</ph> event is not an efficient technique for cursor management.</source>
          <target state="translated">Aguardando o <ph id="ph1">&lt;xref:System.Windows.UIElement.QueryCursor&gt;</ph> evento não é uma técnica eficiente para o gerenciamento de cursor.</target>       </trans-unit>
        <trans-unit id="3157" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryCursor">
          <source>Instead, each element should define its own cursor behavior with <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Cursor%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ForceCursor%2A&gt;</ph>.</source>
          <target state="translated">Em vez disso, cada elemento deve definir seu próprio comportamento de cursor com <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Cursor%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ForceCursor%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3158" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryCursor">
          <source>You should only rely on <ph id="ph1">&lt;xref:System.Windows.UIElement.QueryCursor&gt;</ph> if you are not using the WPF framework-level base elements, or in extraordinary circumstances where defining cursor behavior on a per-element basis does not meet your needs.</source>
          <target state="translated">Você só deve confiar no <ph id="ph1">&lt;xref:System.Windows.UIElement.QueryCursor&gt;</ph> se você não estiver usando os elementos de base de nível de framework do WPF, ou em extraordinários circunstâncias em que define o comportamento do cursor em uma base por elemento não atender às suas necessidades.</target>       </trans-unit>
        <trans-unit id="3159" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryCursor">
          <source>For more information on implementing cursor behavior in response to <ph id="ph1">&lt;xref:System.Windows.UIElement.QueryCursor&gt;</ph>, see <ph id="ph2">&lt;xref:System.Windows.Input.QueryCursorEventHandler&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como implementar o comportamento do cursor em resposta a <ph id="ph1">&lt;xref:System.Windows.UIElement.QueryCursor&gt;</ph>, consulte <ph id="ph2">&lt;xref:System.Windows.Input.QueryCursorEventHandler&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3160" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryCursor">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="3161" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryCursor">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3162" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryCursor">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="3163" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryCursor">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="3164" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryCursor">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="3165" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryCursor">
          <source>There is no defined corresponding tunneling event.</source>
          <target state="translated">Não há nenhum evento de túnel correspondente definido.</target>       </trans-unit>
        <trans-unit id="3166" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.QueryCursor">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnQueryCursor%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnQueryCursor%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="3167" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.QueryCursorEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.QueryCursor" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.QueryCursor" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3168" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.QueryCursorEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="3169" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.QueryCursorEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="3170" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.QueryCursorEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="3171" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.QueryCursorEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3172" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.QueryCursorEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3173" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph> that contains the event data and also identifies the event to raise.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph> que contém os dados do evento e também identifica o evento a ser acionado.</target>       </trans-unit>
        <trans-unit id="3174" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)">
          <source>Raises a specific routed event.</source>
          <target state="translated">Aciona um evento roteado específico.</target>       </trans-unit>
        <trans-unit id="3175" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.RoutedEvent" /&gt;</ph> to be raised is identified within the <ph id="ph2">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph> instance that is provided (as the <ph id="ph3">&lt;see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /&gt;</ph> property of that event data).</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.RoutedEvent" /&gt;</ph> a ser gerado é identificado na instância <ph id="ph2">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph> fornecida (como a propriedade <ph id="ph3">&lt;see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /&gt;</ph> desses dados de eventos).</target>       </trans-unit>
        <trans-unit id="3176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)">
          <source>The <ph id="ph1">`e`</ph> parameter is typed as the common base type for all routed event data; however, the event data should be given as the most specific event data type that is available for the event being raised, because <ph id="ph2">&lt;xref:System.Windows.RoutedEventArgs&gt;</ph> derived classes contain the actual specific data properties that are intended for the specific event when it is raised.</source>
          <target state="translated">O <ph id="ph1">`e`</ph> parâmetro seja tipado como o tipo de base comum para todos os dados de eventos roteados; no entanto, os dados de evento devem ser dadas como o tipo de dados de evento mais específico que está disponível para o evento que está sendo gerado, pois <ph id="ph2">&lt;xref:System.Windows.RoutedEventArgs&gt;</ph> classes derivadas contêm as propriedades específicas de dados reais que se destinam-se para o evento específico quando ele é gerado.</target>       </trans-unit>
        <trans-unit id="3177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs&gt;</ph> is not just the state properties for the event; it also identifies which routed event to raise.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs&gt;</ph> não é apenas as propriedades de estado para o evento; Ele também identifica quais eventos roteados para gerar.</target>       </trans-unit>
        <trans-unit id="3178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)">
          <source>This event-raising pattern and the routed event data both differ from <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> events and data classes, which typically just contain properties that are related to the event.</source>
          <target state="translated">Esse padrão de gerar o evento e os dados de eventos roteados ambos diferem <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> classes de eventos e dados, que normalmente contêm apenas as propriedades que são relacionadas ao evento.</target>       </trans-unit>
        <trans-unit id="3179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)">
          <source>The following example creates event data, appends the event identifier to the data, and then uses the event data instance to raise a custom routed event.</source>
          <target state="translated">O exemplo a seguir cria dados de evento, anexa o identificador de evento para os dados e, em seguida, usa a instância de dados de evento para gerar um evento roteado personalizado.</target>       </trans-unit>
        <trans-unit id="3180" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.ReleaseAllTouchCaptures">
          <source>Releases all captured touch devices from this element.</source>
          <target state="translated">Libera todos os dispositivos de toque capturados desse elemento.</target>       </trans-unit>
        <trans-unit id="3181" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.ReleaseMouseCapture">
          <source>Releases the mouse capture, if this element held the capture.</source>
          <target state="translated">Libera a captura do mouse, se esse elemento tiver mantido a captura.</target>       </trans-unit>
        <trans-unit id="3182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ReleaseMouseCapture">
          <source>If this element did not hold the capture, calling this method has no effect.</source>
          <target state="translated">Se esse elemento não continha a captura, chamar este método não tem nenhum efeito.</target>       </trans-unit>
        <trans-unit id="3183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ReleaseMouseCapture">
          <source>Consider checking the value of <ph id="ph1">&lt;xref:System.Windows.UIElement.IsMouseCaptured%2A&gt;</ph> before you call this method.</source>
          <target state="translated">Considere a possibilidade de marcar o valor do <ph id="ph1">&lt;xref:System.Windows.UIElement.IsMouseCaptured%2A&gt;</ph> antes de chamar esse método.</target>       </trans-unit>
        <trans-unit id="3184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ReleaseMouseCapture">
          <source>The following example is the parallel to the example given for <ph id="ph1">&lt;xref:System.Windows.UIElement.CaptureMouse%2A&gt;</ph>: it handles mouse button up to release mouse capture and re-enable moving the mouse.</source>
          <target state="translated">O exemplo seguinte é paralelo para o exemplo fornecido para <ph id="ph1">&lt;xref:System.Windows.UIElement.CaptureMouse%2A&gt;</ph>: ele lida com o botão do mouse até a versão de captura do mouse e habilite novamente a movimentação do mouse.</target>       </trans-unit>
        <trans-unit id="3185" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.ReleaseStylusCapture">
          <source>Releases the stylus device capture, if this element held the capture.</source>
          <target state="translated">Libera a captura do dispositivo de caneta, se esse elemento tiver mantido a captura.</target>       </trans-unit>
        <trans-unit id="3186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ReleaseStylusCapture">
          <source>If this element did not hold the capture, calling this method has no effect.</source>
          <target state="translated">Se esse elemento não continha a captura, chamar este método não tem nenhum efeito.</target>       </trans-unit>
        <trans-unit id="3187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ReleaseStylusCapture">
          <source>Consider checking the value of <ph id="ph1">&lt;xref:System.Windows.UIElement.IsStylusCaptured%2A&gt;</ph> before you call this method.</source>
          <target state="translated">Considere a possibilidade de marcar o valor do <ph id="ph1">&lt;xref:System.Windows.UIElement.IsStylusCaptured%2A&gt;</ph> antes de chamar esse método.</target>       </trans-unit>
        <trans-unit id="3188" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)">
          <source>The device to release.</source>
          <target state="translated">O dispositivo a ser liberado.</target>       </trans-unit>
        <trans-unit id="3189" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)">
          <source>Attempts to release the specified touch device from this element.</source>
          <target state="translated">Tenta liberar o dispositivo de toque especificado desse elemento.</target>       </trans-unit>
        <trans-unit id="3190" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the touch device is released; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o dispositivo de toque estiver liberado; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3191" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)">
          <source><ph id="ph1">&lt;paramref name="touchDevice" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="touchDevice" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3192" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)">
          <source>The identifier of the routed event for which the handler is attached.</source>
          <target state="translated">O identificador do evento roteado ao qual o manipulador está anexado.</target>       </trans-unit>
        <trans-unit id="3193" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)">
          <source>The specific handler implementation to remove from the event handler collection on this element.</source>
          <target state="translated">A implementação do manipulador específico para remover da coleção de manipuladores de eventos neste elemento.</target>       </trans-unit>
        <trans-unit id="3194" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)">
          <source>Removes the specified routed event handler from this element.</source>
          <target state="translated">Remove o manipulador de eventos roteados especificado desse elemento.</target>       </trans-unit>
        <trans-unit id="3195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)">
          <source>The most common scenario for using this <ph id="ph1">[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]</ph> is when you implement the <ph id="ph2">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> "wrapper" event that is associated with a custom routed event, specifically when you implement the "remove" logic for handlers at the <ph id="ph3">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> level.</source>
          <target state="translated">O cenário mais comum para usar esta <ph id="ph1">[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]</ph> é quando você implementa o <ph id="ph2">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> evento "wrapper" que está associado um evento roteado personalizado, especialmente quando você implementar a lógica de "remover" para manipuladores no <ph id="ph3">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> nível.</target>       </trans-unit>
        <trans-unit id="3196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)">
          <source>The example that follows this remarks section illustrates this scenario.</source>
          <target state="translated">O exemplo a seguir esta seção ilustra esse cenário de comentários.</target>       </trans-unit>
        <trans-unit id="3197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)">
          <source>Calling this method has no effect if there were no handlers registered with criteria that matches the input parameters for the method call.</source>
          <target state="translated">Chamar esse método não tem nenhum efeito se não houvesse nenhum manipulador registrado com os critérios que corresponde aos parâmetros de entrada para a chamada do método.</target>       </trans-unit>
        <trans-unit id="3198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)">
          <source>If more than one handler is attached that matched the criteria, only the first handler in the event handler store is removed.</source>
          <target state="translated">Se mais de um manipulador é anexado que correspondem aos critérios, somente o primeiro manipulador no evento de armazenamento do manipulador é removido.</target>       </trans-unit>
        <trans-unit id="3199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)">
          <source>This behavior is consistent with <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> behavior of the <ph id="ph2">`-=`</ph> operator.</source>
          <target state="translated">Esse comportamento é consistente com <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> comportamento do <ph id="ph2">`-=`</ph> operador.</target>       </trans-unit>
        <trans-unit id="3200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)">
          <source>Neither <ph id="ph1">`routedEvent`</ph> nor <ph id="ph2">`handler`</ph> may be <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Nem <ph id="ph1">`routedEvent`</ph> nem <ph id="ph2">`handler`</ph> pode ser <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="3201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)">
          <source>Attempting to provide either value as <ph id="ph1">`null`</ph> will raise an exception.</source>
          <target state="translated">Tentativa de fornecer um valor como <ph id="ph1">`null`</ph> gerará uma exceção.</target>       </trans-unit>
        <trans-unit id="3202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)">
          <source>This method ignores the <ph id="ph1">`handledEventsToo`</ph> parameter information, which is provided if the handler was first added with the <ph id="ph2">&lt;xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29&gt;</ph> signature that enables handling of already-handled events.</source>
          <target state="translated">Esse método ignora o <ph id="ph1">`handledEventsToo`</ph> informações de parâmetro, que são fornecidas quando o manipulador foi inicialmente adicionada com o <ph id="ph2">&lt;xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29&gt;</ph> assinatura que permite a manipulação de eventos já tratado.</target>       </trans-unit>
        <trans-unit id="3203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)">
          <source>Either type of handler is removed.</source>
          <target state="translated">O tipo de manipulador é removido.</target>       </trans-unit>
        <trans-unit id="3204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Windows.UIElement.RemoveHandler%2A&gt;</ph> as part of an event wrapper definition.</source>
          <target state="translated">O exemplo a seguir usa <ph id="ph1">&lt;xref:System.Windows.UIElement.RemoveHandler%2A&gt;</ph> como parte de uma definição de wrapper de evento.</target>       </trans-unit>
        <trans-unit id="3205" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.RenderSize">
          <source>Gets (or sets) the final render size of this element.</source>
          <target state="translated">Obtém (ou define) o tamanho de renderização final deste elemento.</target>       </trans-unit>
        <trans-unit id="3206" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderSize">
          <source>The rendered size for this element.</source>
          <target state="translated">O tamanho renderizado para este elemento.</target>       </trans-unit>
        <trans-unit id="3207" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderSize">
          <source>Do not attempt to set this property, either in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> or in code, if using the WPF framework-level layout system.</source>
          <target state="translated">Não tente definir essa propriedade em <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> ou no código, se usar o sistema de layout de nível de framework WPF.</target>       </trans-unit>
        <trans-unit id="3208" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderSize">
          <source>Nearly all typical application scenarios will use this layout system.</source>
          <target state="translated">Quase todos os cenários de aplicativo típico usará este sistema de layout.</target>       </trans-unit>
        <trans-unit id="3209" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderSize">
          <source>The layout system will not respect sizes set in the <ph id="ph1">&lt;xref:System.Windows.UIElement.RenderSize%2A&gt;</ph> property directly.</source>
          <target state="translated">O sistema de layout não respeitará tamanhos definidos no arquivo de <ph id="ph1">&lt;xref:System.Windows.UIElement.RenderSize%2A&gt;</ph> propriedade diretamente.</target>       </trans-unit>
        <trans-unit id="3210" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderSize">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.RenderSize%2A&gt;</ph> property is declared writable only to enable certain WPF core-level bridging cases that deliberately circumvent the typical layout protocols, such as support for the <ph id="ph2">&lt;xref:System.Windows.Documents.Adorner&gt;</ph> class.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.RenderSize%2A&gt;</ph> propriedade for declarada como gravável apenas para habilitar certo casos que deliberadamente desviar os protocolos de layout comuns, como suporte para a ponte de nível de núcleo do WPF a <ph id="ph2">&lt;xref:System.Windows.Documents.Adorner&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="3211" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderSize">
          <source>This property can be used for checking the applicable render size within layout system overrides such as <ph id="ph1">&lt;xref:System.Windows.UIElement.OnRender%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.UIElement.GetLayoutClip%2A&gt;</ph>.</source>
          <target state="translated">Essa propriedade pode ser usada para verificar o tamanho de renderização aplicáveis no sistema de layout, como substituições <ph id="ph1">&lt;xref:System.Windows.UIElement.OnRender%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Windows.UIElement.GetLayoutClip%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3212" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderSize">
          <source>A more common scenario is handling the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.SizeChanged&gt;</ph> event with the class handler override or the <ph id="ph2">&lt;xref:System.Windows.UIElement.OnRenderSizeChanged%2A&gt;</ph> event.</source>
          <target state="translated">Um cenário mais comum é tratar a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.SizeChanged&gt;</ph> substituir eventos com o manipulador de classe ou o <ph id="ph2">&lt;xref:System.Windows.UIElement.OnRenderSizeChanged%2A&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="3213" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderSize">
          <source>The following example shows how a custom adorner uses the <ph id="ph1">&lt;xref:System.Windows.UIElement.RenderSize%2A&gt;</ph> value in order to create and size the rectangle graphic that defines the adorner, as part of its <ph id="ph2">&lt;xref:System.Windows.UIElement.OnRender%2A&gt;</ph> implementation.</source>
          <target state="translated">O exemplo a seguir mostra como um adorner personalizado usa o <ph id="ph1">&lt;xref:System.Windows.UIElement.RenderSize%2A&gt;</ph> valor para criar e dimensionar o gráfico de retângulo que define o adorno, como parte de seu <ph id="ph2">&lt;xref:System.Windows.UIElement.OnRender%2A&gt;</ph> implementação.</target>       </trans-unit>
        <trans-unit id="3214" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.RenderTransform">
          <source>Gets or sets transform information that affects the rendering position of this element.</source>
          <target state="translated">Obtém ou define informações de transformação que afetam a posição da renderização desse elemento.</target>       </trans-unit>
        <trans-unit id="3215" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.RenderTransform">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="3216" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransform">
          <source>Describes the specifics of the desired render transform.</source>
          <target state="translated">Descreve as especificações de transformação de renderização desejadas.</target>       </trans-unit>
        <trans-unit id="3217" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransform">
          <source>The default is <ph id="ph1">&lt;see cref="P:System.Windows.Media.Transform.Identity" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see cref="P:System.Windows.Media.Transform.Identity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3218" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransform">
          <source>A render transform does not regenerate layout size or render size information.</source>
          <target state="translated">Uma transformação de renderização não regenerar o tamanho de layout ou processar informações de tamanho.</target>       </trans-unit>
        <trans-unit id="3219" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransform">
          <source>Render transforms are typically intended for animating or applying a temporary effect to an element.</source>
          <target state="translated">Renderizar transformações destinam-se normalmente para animação ou aplicação de um efeito temporário a um elemento.</target>       </trans-unit>
        <trans-unit id="3220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransform">
          <source>For example, the element might zoom when focused or moused over, or might jitter on load to draw the eye to that part of the <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.</source>
          <target state="translated">Por exemplo, o elemento pode aplicar zoom quando focalizado ou moused sobre ou talvez tremulação na carga para chamar a atenção para essa parte do <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="3221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransform">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="3222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransform">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransform">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="3224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransform">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="3225" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source>Gets or sets the center point of any possible render transform declared by <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.RenderTransform" /&gt;</ph>, relative to the bounds of the element.</source>
          <target state="translated">Obtém ou define o ponto central de qualquer transformação de renderização possível declarada por <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.RenderTransform" /&gt;</ph>, em relação aos limites do elemento.</target>       </trans-unit>
        <trans-unit id="3226" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="3227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source>The value that declares the render transform.</source>
          <target state="translated">O valor que declara a transformação de renderização.</target>       </trans-unit>
        <trans-unit id="3228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source>The default value is a <ph id="ph1">&lt;see cref="T:System.Windows.Point" /&gt;</ph> with coordinates (0,0).</source>
          <target state="translated">O valor padrão é um <ph id="ph1">&lt;see cref="T:System.Windows.Point" /&gt;</ph> com coordenadas (0,0).</target>       </trans-unit>
        <trans-unit id="3229" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source><ph id="ph1">&lt;xref:System.Windows.UIElement.RenderTransformOrigin%2A&gt;</ph> has a somewhat nonstandard use of the <ph id="ph2">&lt;xref:System.Windows.Point&gt;</ph> structure value, in that the <ph id="ph3">&lt;xref:System.Windows.Point&gt;</ph> does not represent an absolute location in a coordinate system.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.UIElement.RenderTransformOrigin%2A&gt;</ph> tem um uso um pouco diferente do padrão da <ph id="ph2">&lt;xref:System.Windows.Point&gt;</ph> estrutura de valor, em que o <ph id="ph3">&lt;xref:System.Windows.Point&gt;</ph> não representa um local absoluto em um sistema de coordenadas.</target>       </trans-unit>
        <trans-unit id="3230" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source>Instead, values between 0 and 1 are interpreted as a factor for the range of the current element in each x,y axis.</source>
          <target state="translated">Em vez disso, os valores entre 0 e 1 são interpretados como um fator para o intervalo do elemento atual em cada x, o eixo y.</target>       </trans-unit>
        <trans-unit id="3231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source>For example, (0.5,0.5) will cause the render transform to be centered on the element, or (1,1) would place the render transform at the bottom right corner of the element.</source>
          <target state="translated">Por exemplo, (0.5,0.5) fará com que a transformação de renderização centralizado no elemento, ou (1,1) colocaria a transformação de renderização na parte inferior direita canto do elemento.</target>       </trans-unit>
        <trans-unit id="3232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source><ph id="ph1">&lt;xref:System.Double.NaN&gt;</ph> is not an accepted value.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Double.NaN&gt;</ph> não é um valor aceito.</target>       </trans-unit>
        <trans-unit id="3233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source>Values beyond 0 and 1 are also accepted, and will result in more unconventional transform effects.</source>
          <target state="translated">Valores além de 0 e 1 também são aceitos e resultarão em mais efeitos de transformação não convencionais.</target>       </trans-unit>
        <trans-unit id="3234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source>For instance, if you set <ph id="ph1">&lt;xref:System.Windows.UIElement.RenderTransformOrigin%2A&gt;</ph> to be (5,5), and then apply a <ph id="ph2">&lt;xref:System.Windows.Media.RotateTransform&gt;</ph>, the rotation point will be well outside the bounds of the element itself.</source>
          <target state="translated">Por exemplo, se você definir <ph id="ph1">&lt;xref:System.Windows.UIElement.RenderTransformOrigin%2A&gt;</ph> (5,5) e, em seguida, aplicar um <ph id="ph2">&lt;xref:System.Windows.Media.RotateTransform&gt;</ph>, o ponto de rotação será bem fora dos limites do elemento.</target>       </trans-unit>
        <trans-unit id="3235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source>The transform will spin your element around in a big circle that originates beyond bottom right.</source>
          <target state="translated">A transformação irá girar o elemento ao redor em um círculo grande que se origina além da parte inferior direita.</target>       </trans-unit>
        <trans-unit id="3236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source>The origin might be somewhere inside its parent element and could possibly be possibly out of frame or view.</source>
          <target state="translated">A origem pode estar em algum lugar dentro de seu elemento pai e poderia ser possivelmente sem quadro ou exibição.</target>       </trans-unit>
        <trans-unit id="3237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source>Negative point values are similar, these will go beyond the top left bounds.</source>
          <target state="translated">Valores negativos ponto são semelhantes, eles ultrapassará o superior esquerdo dos limites.</target>       </trans-unit>
        <trans-unit id="3238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source>Render transforms do not affect layout, and are typically used to animate or apply a temporary effect to an element.</source>
          <target state="translated">Renderizar transformações não afetam o layout e normalmente são usadas para animar ou aplicar um efeito temporário a um elemento.</target>       </trans-unit>
        <trans-unit id="3239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source>XAML Attribute Usage</source>
          <target state="translated">Uso do Atributo XAML</target>       </trans-unit>
        <trans-unit id="3240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source>XAML Property Element Usage</source>
          <target state="translated">Uso do elemento propriedade XAML</target>       </trans-unit>
        <trans-unit id="3241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source>XAML Values</source>
          <target state="translated">Valores XAML</target>       </trans-unit>
        <trans-unit id="3242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source><bpt id="p1">*</bpt>xOrigin<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>xOrigin<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="3243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source>The horizontal origin factor.</source>
          <target state="translated">O fator de origem horizontal.</target>       </trans-unit>
        <trans-unit id="3244" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source>This is typically given as a value between 0 and 1.</source>
          <target state="translated">Isso geralmente é fornecido como um valor entre 0 e 1.</target>       </trans-unit>
        <trans-unit id="3245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source>See Remarks.</source>
          <target state="translated">Consulte Observações.</target>       </trans-unit>
        <trans-unit id="3246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source><bpt id="p1">*</bpt>yOrigin<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>yOrigin<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="3247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source>The vertical origin factor.</source>
          <target state="translated">O fator de origem vertical.</target>       </trans-unit>
        <trans-unit id="3248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source>This is typically given as a value between 0 and 1.</source>
          <target state="translated">Isso geralmente é fornecido como um valor entre 0 e 1.</target>       </trans-unit>
        <trans-unit id="3249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source>See Remarks.</source>
          <target state="translated">Consulte Observações.</target>       </trans-unit>
        <trans-unit id="3250" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="3251" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3252" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="3253" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="3254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.RenderTransformOrigin">
          <source>The following example builds up elements in code, applies a <ph id="ph1">&lt;xref:System.Windows.UIElement.RenderTransformOrigin%2A&gt;</ph>, and then applies a  <ph id="ph2">&lt;xref:System.Windows.UIElement.RenderTransform%2A&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir cria os elementos no código, aplica um <ph id="ph1">&lt;xref:System.Windows.UIElement.RenderTransformOrigin%2A&gt;</ph>e, em seguida, aplica um <ph id="ph2">&lt;xref:System.Windows.UIElement.RenderTransform%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3255" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.RenderTransformOriginProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.RenderTransformOrigin" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.RenderTransformOrigin" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3256" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.RenderTransformProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.RenderTransform" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.RenderTransform" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3257" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.ShouldSerializeCommandBindings">
          <source>Returns whether serialization processes should serialize the contents of the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.CommandBindings" /&gt;</ph> property on instances of this class.</source>
          <target state="translated">Indica se os processos de serialização devem serializar o conteúdo da propriedade <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.CommandBindings" /&gt;</ph> em instâncias dessa classe.</target>       </trans-unit>
        <trans-unit id="3258" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.ShouldSerializeCommandBindings">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Windows.UIElement.CommandBindings" /&gt;</ph> property value should be serialized; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o valor da propriedade <ph id="ph2">&lt;see cref="P:System.Windows.UIElement.CommandBindings" /&gt;</ph> precisar ser serializado; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ShouldSerializeCommandBindings">
          <source>This will return <ph id="ph1">`true`</ph> if <ph id="ph2">&lt;xref:System.Windows.UIElement.CommandBindings%2A&gt;</ph> is locally set.</source>
          <target state="translated">Isso retornará <ph id="ph1">`true`</ph> se <ph id="ph2">&lt;xref:System.Windows.UIElement.CommandBindings%2A&gt;</ph> é definido localmente.</target>       </trans-unit>
        <trans-unit id="3260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ShouldSerializeCommandBindings">
          <source>This <ph id="ph1">`ShouldSerialize`</ph> method is provided because the <ph id="ph2">&lt;xref:System.Windows.UIElement.CommandBindings%2A&gt;</ph> property does not have a simple default value.</source>
          <target state="translated">Isso <ph id="ph1">`ShouldSerialize`</ph> método é fornecido, pois o <ph id="ph2">&lt;xref:System.Windows.UIElement.CommandBindings%2A&gt;</ph> propriedade não tem um valor padrão simples.</target>       </trans-unit>
        <trans-unit id="3261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ShouldSerializeCommandBindings">
          <source>This method indicates whether the property has changed from its default value.</source>
          <target state="translated">Este método indica se a propriedade foi alterado do valor padrão.</target>       </trans-unit>
        <trans-unit id="3262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ShouldSerializeCommandBindings">
          <source>You typically invoke this method if you are either developing a designer or developing your own control incorporating a <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>.</source>
          <target state="translated">Normalmente você invoca esse método se você estiver desenvolvendo um designer ou desenvolver seu próprio controle incorporando um <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ShouldSerializeCommandBindings">
          <source>For more information, see <bpt id="p1">[</bpt>Defining Default Values with the ShouldSerialize and Reset Methods<ept id="p1">](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>definindo valores padrão com o ShouldSerialize e os métodos de redefinição<ept id="p1">](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3264" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.ShouldSerializeInputBindings">
          <source>Returns whether serialization processes should serialize the contents of the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.InputBindings" /&gt;</ph> property on instances of this class.</source>
          <target state="translated">Indica se os processos de serialização devem serializar o conteúdo da propriedade <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.InputBindings" /&gt;</ph> em instâncias dessa classe.</target>       </trans-unit>
        <trans-unit id="3265" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.ShouldSerializeInputBindings">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Windows.UIElement.InputBindings" /&gt;</ph> property value should be serialized; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o valor da propriedade <ph id="ph2">&lt;see cref="P:System.Windows.UIElement.InputBindings" /&gt;</ph> precisar ser serializado; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ShouldSerializeInputBindings">
          <source>This will return <ph id="ph1">`true`</ph> if <ph id="ph2">&lt;xref:System.Windows.UIElement.InputBindings%2A&gt;</ph> is locally set.</source>
          <target state="translated">Isso retornará <ph id="ph1">`true`</ph> se <ph id="ph2">&lt;xref:System.Windows.UIElement.InputBindings%2A&gt;</ph> é definido localmente.</target>       </trans-unit>
        <trans-unit id="3267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ShouldSerializeInputBindings">
          <source>This <ph id="ph1">`ShouldSerialize`</ph> method is provided because the <ph id="ph2">&lt;xref:System.Windows.UIElement.InputBindings%2A&gt;</ph> property does not have a simple default value.</source>
          <target state="translated">Isso <ph id="ph1">`ShouldSerialize`</ph> método é fornecido, pois o <ph id="ph2">&lt;xref:System.Windows.UIElement.InputBindings%2A&gt;</ph> propriedade não tem um valor padrão simples.</target>       </trans-unit>
        <trans-unit id="3268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ShouldSerializeInputBindings">
          <source>This method indicates whether the property has changed from its default value.</source>
          <target state="translated">Este método indica se a propriedade foi alterado do valor padrão.</target>       </trans-unit>
        <trans-unit id="3269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ShouldSerializeInputBindings">
          <source>You typically invoke this method if you are either developing a designer or developing your own control incorporating a <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>.</source>
          <target state="translated">Normalmente você invoca esse método se você estiver desenvolvendo um designer ou desenvolver seu próprio controle incorporando um <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.ShouldSerializeInputBindings">
          <source>For more information, see <bpt id="p1">[</bpt>Defining Default Values with the ShouldSerialize and Reset Methods<ept id="p1">](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>definindo valores padrão com o ShouldSerialize e os métodos de redefinição<ept id="p1">](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3271" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.SnapsToDevicePixels">
          <source>Gets or sets a value that determines whether rendering for this element should use device-specific pixel settings during rendering.</source>
          <target state="translated">Obtém ou define um valor que determina se a renderização para esse elemento deve usar configurações de pixel específica do dispositivo durante a renderização.</target>       </trans-unit>
        <trans-unit id="3272" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.SnapsToDevicePixels">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="3273" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.SnapsToDevicePixels">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the element should render in accordance to device pixels; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o elemento precisar renderizar de acordo com os pixels do dispositivo; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3274" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.SnapsToDevicePixels">
          <source>The default as declared on <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> is <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão como declarado em <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph> é <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3275" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.SnapsToDevicePixels">
          <source>You can set this property to <ph id="ph1">`true`</ph> on your root element to enable pixel snap rendering throughout the UI.</source>
          <target state="translated">Você pode definir essa propriedade <ph id="ph1">`true`</ph> em seu elemento raiz para habilitar o pixel snap renderização na interface do usuário.</target>       </trans-unit>
        <trans-unit id="3276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.SnapsToDevicePixels">
          <source>For devices operating at greater than 96 <ph id="ph1">[!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)]</ph>, pixel snap rendering can minimize anti-aliasing visual artifacts in the vicinity of single-unit solid lines.</source>
          <target state="translated">Para dispositivos operando com maior 96 <ph id="ph1">[!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)]</ph>, pixel snap renderização pode minimizar artefatos de suavização visual perto linhas sólidas de única unidade.</target>       </trans-unit>
        <trans-unit id="3277" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.SnapsToDevicePixels">
          <source>When inherited by <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> or any possible derived classes, <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> overrides the metadata for this dependency property to set the <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> metadata property to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Quando herdado por <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> ou qualquer possível classes derivadas, <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> substitui os metadados para essa propriedade de dependência definir o <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> propriedade de metadados para <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3278" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.SnapsToDevicePixels">
          <source>What this achieves is that only the outermost element in a subtree needs to specify <ph id="ph1">&lt;xref:System.Windows.UIElement.SnapsToDevicePixels%2A&gt;</ph> as <ph id="ph2">`true`</ph>, and all child elements of that subtree will then report <ph id="ph3">&lt;xref:System.Windows.UIElement.SnapsToDevicePixels%2A&gt;</ph> as <ph id="ph4">`true`</ph> and will have the <ph id="ph5">&lt;xref:System.Windows.UIElement.SnapsToDevicePixels%2A&gt;</ph> visual effect.</source>
          <target state="translated">O que gera é que apenas o elemento externo em uma subárvore precisa especificar <ph id="ph1">&lt;xref:System.Windows.UIElement.SnapsToDevicePixels%2A&gt;</ph> como <ph id="ph2">`true`</ph>, e, em seguida, todos os elementos filho de que subárvore relatará <ph id="ph3">&lt;xref:System.Windows.UIElement.SnapsToDevicePixels%2A&gt;</ph> como <ph id="ph4">`true`</ph> e terá o <ph id="ph5">&lt;xref:System.Windows.UIElement.SnapsToDevicePixels%2A&gt;</ph> efeito visual.</target>       </trans-unit>
        <trans-unit id="3279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.SnapsToDevicePixels">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="3280" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.SnapsToDevicePixels">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3281" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.SnapsToDevicePixels">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="3282" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.SnapsToDevicePixels">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="3283" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.SnapsToDevicePixelsProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.SnapsToDevicePixels" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.SnapsToDevicePixels" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3284" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.StylusButtonDown">
          <source>Occurs when the stylus button is pressed while the pointer is over this element.</source>
          <target state="translated">Ocorre quando o botão da caneta é pressionado enquanto o ponteiro está sobre este elemento.</target>       </trans-unit>
        <trans-unit id="3285" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusButtonDown">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.StylusButtonDown&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.StylusButtonDown&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="3286" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusButtonDown">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusButtonDown&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusButtonDown&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="3287" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusButtonDown">
          <source>Touch, mouse, and stylus input exist in a particular relationship.</source>
          <target state="translated">Entrada de caneta, mouse e toque existem em uma relação específica.</target>       </trans-unit>
        <trans-unit id="3288" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusButtonDown">
          <source>For more information, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3289" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusButtonDown">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="3290" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusButtonDown">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3291" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusButtonDown">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="3292" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusButtonDown">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="3293" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusButtonDown">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="3294" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusButtonDown">
          <source>The corresponding tunneling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusButtonDown&gt;</ph>.</source>
          <target state="translated">O evento de túnel correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusButtonDown&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3295" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusButtonDown">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnStylusButtonDown%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnStylusButtonDown%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="3296" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.StylusButtonDownEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.StylusButtonDown" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.StylusButtonDown" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3297" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusButtonDownEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="3298" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusButtonDownEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="3299" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusButtonDownEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="3300" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusButtonDownEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3301" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusButtonDownEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3302" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.StylusButtonUp">
          <source>Occurs when the stylus button is released while the pointer is over this element.</source>
          <target state="translated">Ocorre quando o botão da caneta é liberado enquanto o ponteiro está sobre este elemento.</target>       </trans-unit>
        <trans-unit id="3303" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusButtonUp">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.StylusButtonUp&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.StylusButtonUp&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="3304" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusButtonUp">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusButtonUp&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusButtonUp&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="3305" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusButtonUp">
          <source>Touch, mouse, and stylus input exist in a particular relationship.</source>
          <target state="translated">Entrada de caneta, mouse e toque existem em uma relação específica.</target>       </trans-unit>
        <trans-unit id="3306" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusButtonUp">
          <source>For more information, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3307" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusButtonUp">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="3308" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusButtonUp">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3309" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusButtonUp">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="3310" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusButtonUp">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="3311" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusButtonUp">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="3312" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusButtonUp">
          <source>The corresponding tunneling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusButtonUp&gt;</ph>.</source>
          <target state="translated">O evento de túnel correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusButtonUp&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3313" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusButtonUp">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnStylusButtonUp%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnStylusButtonUp%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="3314" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.StylusButtonUpEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.StylusButtonUp" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.StylusButtonUp" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3315" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusButtonUpEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="3316" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusButtonUpEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="3317" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusButtonUpEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="3318" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusButtonUpEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3319" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusButtonUpEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3320" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.StylusDown">
          <source>Occurs when the stylus touches the digitizer while the stylus is over this element.</source>
          <target state="translated">Ocorre quando a caneta toca o digitalizador enquanto está sobre este elemento.</target>       </trans-unit>
        <trans-unit id="3321" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusDown">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.StylusDown&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.StylusDown&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="3322" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusDown">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusDown&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusDown&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="3323" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusDown">
          <source>Touch, mouse, and stylus input exist in a particular relationship.</source>
          <target state="translated">Entrada de caneta, mouse e toque existem em uma relação específica.</target>       </trans-unit>
        <trans-unit id="3324" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusDown">
          <source>For more information, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3325" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusDown">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="3326" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusDown">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3327" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusDown">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="3328" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusDown">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="3329" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusDown">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="3330" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusDown">
          <source>The corresponding tunneling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusDown&gt;</ph>.</source>
          <target state="translated">O evento de túnel correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusDown&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3331" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusDown">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnStylusDown%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnStylusDown%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="3332" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.StylusDownEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.StylusDown" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.StylusDown" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3333" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusDownEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="3334" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusDownEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="3335" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusDownEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="3336" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusDownEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3337" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusDownEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3338" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.StylusEnter">
          <source>Occurs when the stylus enters the bounds of this element.</source>
          <target state="translated">Ocorre quando a caneta entra nos limites deste elemento.</target>       </trans-unit>
        <trans-unit id="3339" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusEnter">
          <source><ph id="ph1">&lt;xref:System.Windows.UIElement.StylusEnter&gt;</ph> is a  that uses the direct event handling routing strategy.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.UIElement.StylusEnter&gt;</ph> é um que usa o estratégia de roteamento de manipulação de eventos direto.</target>       </trans-unit>
        <trans-unit id="3340" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusEnter">
          <source>Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</source>
          <target state="translated">Os eventos roteados diretos não são gerados ao longo de uma rota; em vez disso, eles são manipulados no mesmo elemento em que eles são gerados.</target>       </trans-unit>
        <trans-unit id="3341" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusEnter">
          <source>However, they do enable other aspects of routed event behavior, such as event triggers in styles.</source>
          <target state="translated">No entanto, elas permitem que outros aspectos do comportamento de eventos roteados, como disparadores em estilos de eventos.</target>       </trans-unit>
        <trans-unit id="3342" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusEnter">
          <source>Although <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusEnter&gt;</ph> tracks when the stylus enters the bounds of an element, this event more literally reports that the <ph id="ph2">&lt;xref:System.Windows.UIElement.IsStylusOver%2A&gt;</ph> property value has changed from <ph id="ph3">`false`</ph> to <ph id="ph4">`true`</ph> on this element.</source>
          <target state="translated">Embora <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusEnter&gt;</ph> rastreia quando a caneta entra nos limites de um elemento, esse evento mais literalmente informa que o <ph id="ph2">&lt;xref:System.Windows.UIElement.IsStylusOver%2A&gt;</ph> o valor da propriedade foi alterado de <ph id="ph3">`false`</ph> para <ph id="ph4">`true`</ph> neste elemento.</target>       </trans-unit>
        <trans-unit id="3343" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusEnter">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.StylusEnter&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.StylusEnter&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="3344" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusEnter">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusEnter&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusEnter&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="3345" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusEnter">
          <source>Touch, mouse, and stylus input exist in a particular relationship.</source>
          <target state="translated">Entrada de caneta, mouse e toque existem em uma relação específica.</target>       </trans-unit>
        <trans-unit id="3346" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusEnter">
          <source>For more information, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3347" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusEnter">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="3348" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusEnter">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3349" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusEnter">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="3350" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusEnter">
          <source>Direct</source>
          <target state="translated">Direto</target>       </trans-unit>
        <trans-unit id="3351" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusEnter">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="3352" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusEnter">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnStylusEnter%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnStylusEnter%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="3353" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.StylusEnterEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.StylusEnter" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.StylusEnter" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3354" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusEnterEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="3355" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusEnterEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="3356" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusEnterEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="3357" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusEnterEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3358" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusEnterEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3359" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.StylusInAirMove">
          <source>Occurs when the stylus moves over an element without actually touching the digitizer.</source>
          <target state="translated">Ocorre quando a caneta se move sobre um elemento sem tocar de fato o digitalizador.</target>       </trans-unit>
        <trans-unit id="3360" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusInAirMove">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.StylusInAirMove&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.StylusInAirMove&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="3361" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusInAirMove">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusInAirMove&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusInAirMove&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="3362" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusInAirMove">
          <source>Touch, mouse, and stylus input exist in a particular relationship.</source>
          <target state="translated">Entrada de caneta, mouse e toque existem em uma relação específica.</target>       </trans-unit>
        <trans-unit id="3363" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusInAirMove">
          <source>For more information, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3364" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusInAirMove">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="3365" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusInAirMove">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3366" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusInAirMove">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="3367" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusInAirMove">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="3368" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusInAirMove">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="3369" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusInAirMove">
          <source>The corresponding tunneling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusInAirMove&gt;</ph>.</source>
          <target state="translated">O evento de túnel correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusInAirMove&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3370" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusInAirMove">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnStylusInAirMove%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnStylusInAirMove%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="3371" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.StylusInAirMoveEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.StylusInAirMove" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.StylusInAirMove" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3372" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusInAirMoveEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="3373" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusInAirMoveEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="3374" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusInAirMoveEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="3375" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusInAirMoveEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3376" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusInAirMoveEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3377" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.StylusInRange">
          <source>Occurs when the stylus is close enough to the digitizer to be detected, while over this element.</source>
          <target state="translated">Ocorre quando a caneta está sobre este elemento e perto o suficiente do digitalizador para ser detectada.</target>       </trans-unit>
        <trans-unit id="3378" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusInRange">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.StylusInRange&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.StylusInRange&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="3379" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusInRange">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusInRange&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusInRange&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="3380" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusInRange">
          <source>Touch, mouse, and stylus input exist in a particular relationship.</source>
          <target state="translated">Entrada de caneta, mouse e toque existem em uma relação específica.</target>       </trans-unit>
        <trans-unit id="3381" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusInRange">
          <source>For more information, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3382" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusInRange">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="3383" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusInRange">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3384" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusInRange">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="3385" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusInRange">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="3386" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusInRange">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="3387" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusInRange">
          <source>The corresponding tunneling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusInRange&gt;</ph>.</source>
          <target state="translated">O evento de túnel correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusInRange&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3388" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusInRange">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnStylusInRange%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnStylusInRange%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="3389" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.StylusInRangeEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.StylusInRange" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.StylusInRange" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3390" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusInRangeEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="3391" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusInRangeEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="3392" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusInRangeEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="3393" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusInRangeEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3394" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusInRangeEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3395" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.StylusLeave">
          <source>Occurs when the stylus leaves the bounds of the element.</source>
          <target state="translated">Ocorre quando a caneta sai dos limites do elemento.</target>       </trans-unit>
        <trans-unit id="3396" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusLeave">
          <source><ph id="ph1">&lt;xref:System.Windows.UIElement.StylusLeave&gt;</ph> is a  that uses the direct event handling routing strategy.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.UIElement.StylusLeave&gt;</ph> é um que usa o estratégia de roteamento de manipulação de eventos direto.</target>       </trans-unit>
        <trans-unit id="3397" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusLeave">
          <source>Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</source>
          <target state="translated">Os eventos roteados diretos não são gerados ao longo de uma rota; em vez disso, eles são manipulados no mesmo elemento em que eles são gerados.</target>       </trans-unit>
        <trans-unit id="3398" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusLeave">
          <source>However, they do enable other aspects of routed event behavior, such as event triggers in styles.</source>
          <target state="translated">No entanto, elas permitem que outros aspectos do comportamento de eventos roteados, como disparadores em estilos de eventos.</target>       </trans-unit>
        <trans-unit id="3399" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusLeave">
          <source>Although <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusLeave&gt;</ph> tracks when the stylus leaves the bounds of an element, this event more literally reports that the <ph id="ph2">&lt;xref:System.Windows.UIElement.IsStylusOver%2A&gt;</ph> property value has changed from <ph id="ph3">`true`</ph> to <ph id="ph4">`false`</ph> on this element.</source>
          <target state="translated">Embora <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusLeave&gt;</ph> rastreia quando a caneta sai dos limites de um elemento, esse evento mais literalmente informa que o <ph id="ph2">&lt;xref:System.Windows.UIElement.IsStylusOver%2A&gt;</ph> o valor da propriedade foi alterado de <ph id="ph3">`true`</ph> para <ph id="ph4">`false`</ph> neste elemento.</target>       </trans-unit>
        <trans-unit id="3400" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusLeave">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.StylusLeave&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.StylusLeave&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="3401" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusLeave">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusLeave&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusLeave&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="3402" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusLeave">
          <source>Touch, mouse, and stylus input exist in a particular relationship.</source>
          <target state="translated">Entrada de caneta, mouse e toque existem em uma relação específica.</target>       </trans-unit>
        <trans-unit id="3403" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusLeave">
          <source>For more information, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3404" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusLeave">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="3405" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusLeave">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3406" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusLeave">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="3407" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusLeave">
          <source>Direct</source>
          <target state="translated">Direto</target>       </trans-unit>
        <trans-unit id="3408" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusLeave">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="3409" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusLeave">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnStylusLeave%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnStylusLeave%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="3410" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.StylusLeaveEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.StylusLeave" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.StylusLeave" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3411" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusLeaveEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="3412" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusLeaveEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="3413" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusLeaveEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="3414" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusLeaveEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3415" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusLeaveEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3416" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.StylusMove">
          <source>Occurs when the stylus moves over this element.</source>
          <target state="translated">Ocorre quando a caneta se move sobre este elemento.</target>       </trans-unit>
        <trans-unit id="3417" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.StylusMove">
          <source>The stylus must move while on the digitizer to raise this event.</source>
          <target state="translated">A caneta deve mover-se enquanto está no digitalizador para gerar este evento.</target>       </trans-unit>
        <trans-unit id="3418" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.StylusMove">
          <source>Otherwise, <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.StylusInAirMove" /&gt;</ph> is raised instead.</source>
          <target state="translated">Caso contrário, <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.StylusInAirMove" /&gt;</ph> será gerado.</target>       </trans-unit>
        <trans-unit id="3419" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusMove">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.StylusMove&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.StylusMove&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="3420" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusMove">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusMove&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusMove&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="3421" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusMove">
          <source>Touch, mouse, and stylus input exist in a particular relationship.</source>
          <target state="translated">Entrada de caneta, mouse e toque existem em uma relação específica.</target>       </trans-unit>
        <trans-unit id="3422" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusMove">
          <source>For more information, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3423" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusMove">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="3424" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusMove">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3425" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusMove">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="3426" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusMove">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="3427" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusMove">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="3428" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusMove">
          <source>The corresponding tunneling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusMove&gt;</ph>.</source>
          <target state="translated">O evento de túnel correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusMove&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3429" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusMove">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnStylusMove%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnStylusMove%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="3430" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.StylusMoveEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.StylusMove" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.StylusMove" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3431" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusMoveEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="3432" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusMoveEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="3433" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusMoveEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="3434" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusMoveEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3435" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusMoveEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3436" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.StylusOutOfRange">
          <source>Occurs when the stylus is too far from the digitizer to be detected, while over this element.</source>
          <target state="translated">Ocorre quando a caneta está sobre o elemento e longe demais do digitalizador para ser detectada.</target>       </trans-unit>
        <trans-unit id="3437" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusOutOfRange">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.StylusOutOfRange&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.StylusOutOfRange&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="3438" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusOutOfRange">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusOutOfRange&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusOutOfRange&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="3439" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusOutOfRange">
          <source>Touch, mouse, and stylus input exist in a particular relationship.</source>
          <target state="translated">Entrada de caneta, mouse e toque existem em uma relação específica.</target>       </trans-unit>
        <trans-unit id="3440" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusOutOfRange">
          <source>For more information, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3441" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusOutOfRange">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="3442" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusOutOfRange">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3443" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusOutOfRange">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="3444" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusOutOfRange">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="3445" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusOutOfRange">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="3446" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusOutOfRange">
          <source>The corresponding tunneling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusOutOfRange&gt;</ph>.</source>
          <target state="translated">O evento de túnel correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusOutOfRange&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3447" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusOutOfRange">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnStylusOutOfRange%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnStylusOutOfRange%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="3448" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.StylusOutOfRangeEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.StylusOutOfRange" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.StylusOutOfRange" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3449" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusOutOfRangeEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="3450" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusOutOfRangeEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="3451" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusOutOfRangeEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="3452" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusOutOfRangeEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3453" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusOutOfRangeEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3454" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.StylusPlugIns">
          <source>Gets a collection of all stylus plug-in (customization) objects associated with this element.</source>
          <target state="translated">Obtém uma coleção de todos os objetos de plug-in (personalização) de caneta associados a esse elemento.</target>       </trans-unit>
        <trans-unit id="3455" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.StylusPlugIns">
          <source>The collection of stylus plug-ins, as a specialized collection.</source>
          <target state="translated">A coleção de plug-ins de caneta como uma coleção especializada.</target>       </trans-unit>
        <trans-unit id="3456" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.StylusPlugIns">
          <source>An example of a control that populates this collection is <ph id="ph1">&lt;xref:System.Windows.Controls.InkCanvas&gt;</ph>.</source>
          <target state="translated">Um exemplo de um controle que preenche essa coleção é <ph id="ph1">&lt;xref:System.Windows.Controls.InkCanvas&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3457" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.StylusPlugIns">
          <source><ph id="ph1">&lt;xref:System.Windows.Controls.InkCanvas&gt;</ph> adds the <ph id="ph2">&lt;xref:System.Windows.Input.StylusPlugIns.DynamicRenderer&gt;</ph> as a collection item, which enables the <ph id="ph3">&lt;xref:System.Windows.Input.StylusPlugIns.DynamicRenderer&gt;</ph> to interact with stylus input and produce the unique rendering in response to stylus driven events.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.InkCanvas&gt;</ph> Adiciona o <ph id="ph2">&lt;xref:System.Windows.Input.StylusPlugIns.DynamicRenderer&gt;</ph> como um item de coleção, que permite que o <ph id="ph3">&lt;xref:System.Windows.Input.StylusPlugIns.DynamicRenderer&gt;</ph> para interagir com a entrada de caneta e produzir a renderização exclusiva em resposta a caneta controlada por eventos.</target>       </trans-unit>
        <trans-unit id="3458" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.StylusPlugIns">
          <source>For information on creating custom plug-ins that can receive and interpret stylus input, see <bpt id="p1">[</bpt>Intercepting Input from the Stylus<ept id="p1">](~/docs/framework/wpf/advanced/intercepting-input-from-the-stylus.md)</ept>.</source>
          <target state="translated">Para obter informações sobre a criação de plug-ins personalizados que podem receber e interpretar a entrada de caneta, consulte <bpt id="p1">[</bpt>interceptando entrada de caneta<ept id="p1">](~/docs/framework/wpf/advanced/intercepting-input-from-the-stylus.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3459" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.StylusPlugIns">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Windows.Input.StylusPlugIns.DynamicRenderer&gt;</ph> instance and adds it to the <ph id="ph2">&lt;xref:System.Windows.UIElement.StylusPlugIns%2A&gt;</ph> collection for a custom ink handling control.</source>
          <target state="translated">O exemplo a seguir cria um <ph id="ph1">&lt;xref:System.Windows.Input.StylusPlugIns.DynamicRenderer&gt;</ph> instância e adiciona-o para o <ph id="ph2">&lt;xref:System.Windows.UIElement.StylusPlugIns%2A&gt;</ph> coleção para uma controle de manuseio de tinta personalizada.</target>       </trans-unit>
        <trans-unit id="3460" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.StylusSystemGesture">
          <source>Occurs when a user performs one of several stylus gestures.</source>
          <target state="translated">Ocorre quando o usuário executa um dos diversos gestos da caneta.</target>       </trans-unit>
        <trans-unit id="3461" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusSystemGesture">
          <source>For more information about stylus gestures, see <ph id="ph1">&lt;xref:System.Windows.Input.SystemGesture&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre gestos da caneta, consulte <ph id="ph1">&lt;xref:System.Windows.Input.SystemGesture&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3462" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusSystemGesture">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.StylusSystemGesture&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.StylusSystemGesture&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="3463" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusSystemGesture">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusSystemGesture&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusSystemGesture&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="3464" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusSystemGesture">
          <source>Touch, mouse, and stylus input exist in a particular relationship.</source>
          <target state="translated">Entrada de caneta, mouse e toque existem em uma relação específica.</target>       </trans-unit>
        <trans-unit id="3465" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusSystemGesture">
          <source>For more information, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3466" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusSystemGesture">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="3467" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusSystemGesture">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3468" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusSystemGesture">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="3469" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusSystemGesture">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="3470" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusSystemGesture">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="3471" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusSystemGesture">
          <source>The corresponding tunneling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusSystemGesture&gt;</ph>.</source>
          <target state="translated">O evento de túnel correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusSystemGesture&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3472" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusSystemGesture">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnStylusSystemGesture%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnStylusSystemGesture%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="3473" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.StylusSystemGestureEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.StylusSystemGesture" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.StylusSystemGesture" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3474" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusSystemGestureEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="3475" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusSystemGestureEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="3476" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusSystemGestureEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="3477" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusSystemGestureEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3478" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusSystemGestureEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3479" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.StylusUp">
          <source>Occurs when the user raises the stylus off the digitizer while it is over this element.</source>
          <target state="translated">Ocorre quando o usuário retira a caneta do digitalizador enquanto ela está sobre este elemento.</target>       </trans-unit>
        <trans-unit id="3480" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusUp">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.StylusUp&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.StylusUp&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="3481" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusUp">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusUp&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.StylusUp&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="3482" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusUp">
          <source>Touch, mouse, and stylus input exist in a particular relationship.</source>
          <target state="translated">Entrada de caneta, mouse e toque existem em uma relação específica.</target>       </trans-unit>
        <trans-unit id="3483" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusUp">
          <source>For more information, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>visão geral de entrada<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3484" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusUp">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="3485" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusUp">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3486" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusUp">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="3487" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusUp">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="3488" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusUp">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="3489" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusUp">
          <source>The corresponding tunneling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusUp&gt;</ph>.</source>
          <target state="translated">O evento de túnel correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewStylusUp&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3490" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.StylusUp">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnStylusUp%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnStylusUp%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="3491" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.StylusUpEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.StylusUp" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.StylusUp" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3492" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusUpEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="3493" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusUpEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="3494" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusUpEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="3495" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusUpEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3496" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.StylusUpEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3497" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.TextInput">
          <source>Occurs when this element gets text in a device-independent manner.</source>
          <target state="translated">Ocorre quando este elemento obtém texto de forma independente de dispositivo.</target>       </trans-unit>
        <trans-unit id="3498" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TextInput">
          <source>This event might already be marked as handled by the internal implementations of composited controls.</source>
          <target state="translated">Esse evento já pode ser marcado como manipulado pelas implementações internas de controles compostos.</target>       </trans-unit>
        <trans-unit id="3499" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TextInput">
          <source>See Remark below.</source>
          <target state="translated">Consulte a observação abaixo.</target>       </trans-unit>
        <trans-unit id="3500" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TextInput">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.TextInput&gt;</ph> event may already be marked as handled by the internal implementations of composited controls.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.TextInput&gt;</ph> evento já pode ser marcado como tratado pelas implementações internas de controles compostos.</target>       </trans-unit>
        <trans-unit id="3501" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TextInput">
          <source>For example, a <ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> is a composited control where the <ph id="ph2">&lt;xref:System.Windows.UIElement.TextInput&gt;</ph> event is already marked as handled; within its compositing.</source>
          <target state="translated">Por exemplo, um <ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> é um controle composto onde o <ph id="ph2">&lt;xref:System.Windows.UIElement.TextInput&gt;</ph> evento já estiver marcado como tratado; dentro de sua composição.</target>       </trans-unit>
        <trans-unit id="3502" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TextInput">
          <source>Controls do this because the control needs to interpret some types of input, such as arrow keys, as having special meaning to that control.</source>
          <target state="translated">Controles de fazem isso, porque o controle precisa interpretar alguns tipos de entrada, como as teclas de direção, como tendo um significado especial para esse controle.</target>       </trans-unit>
        <trans-unit id="3503" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TextInput">
          <source>If you use <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewTextInput&gt;</ph> as the event where you attach handlers for text input, you may receive better results.</source>
          <target state="translated">Se você usar <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewTextInput&gt;</ph> como o evento em que você anexa manipuladores para entrada de texto, você pode receber resultados melhores.</target>       </trans-unit>
        <trans-unit id="3504" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TextInput">
          <source>This technique circumvents most cases where control composition has already marked this event as handled and prevents your handler from receiving the event along the event route.</source>
          <target state="translated">Essa técnica contorna a maioria dos casos onde a composição de controle já marcado esse evento tratados e impede que o manipulador de receber o evento ao longo da rota de evento.</target>       </trans-unit>
        <trans-unit id="3505" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TextInput">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.TextInput&gt;</ph> event allows a component or application to listen for text input in a device-independent manner.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.UIElement.TextInput&gt;</ph> evento permite que um componente ou aplicativo para escutar a entrada de texto de forma independente de dispositivo.</target>       </trans-unit>
        <trans-unit id="3506" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TextInput">
          <source>The keyboard is the primary means of <ph id="ph1">&lt;xref:System.Windows.UIElement.TextInput&gt;</ph>, but speech, handwriting, and other input devices can also raise <ph id="ph2">&lt;xref:System.Windows.UIElement.TextInput&gt;</ph>.</source>
          <target state="translated">O teclado é o principal meio de <ph id="ph1">&lt;xref:System.Windows.UIElement.TextInput&gt;</ph>, mas fala, manuscrito e outros dispositivos de entrada também podem gerar <ph id="ph2">&lt;xref:System.Windows.UIElement.TextInput&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3507" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TextInput">
          <source>Because of key combinations—either in default keyboards or through input method editors—multiple key events might raise just one text input event.</source>
          <target state="translated">Por causa de combinações de teclas — em teclados padrão ou por meio de editores de método de entrada — vários eventos de chave podem disparar um evento de entrada de texto.</target>       </trans-unit>
        <trans-unit id="3508" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TextInput">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType&gt;</ph> attached event for this class, so that <ph id="ph2">&lt;xref:System.Windows.UIElement.TextInput&gt;</ph> is part of the class members list when <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> is inherited as a base element.</source>
          <target state="translated">Esse evento cria um alias para o <ph id="ph1">&lt;xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType&gt;</ph> anexa para esta classe, para que <ph id="ph2">&lt;xref:System.Windows.UIElement.TextInput&gt;</ph> faz parte da classe a lista de membros quando <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> é herdada como um elemento base.</target>       </trans-unit>
        <trans-unit id="3509" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TextInput">
          <source>Event handlers that are attached to the <ph id="ph1">&lt;xref:System.Windows.UIElement.TextInput&gt;</ph> event are attached to the underlying <ph id="ph2">&lt;xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType&gt;</ph> attached event and receive the same event data instance.</source>
          <target state="translated">Manipuladores de eventos associados para o <ph id="ph1">&lt;xref:System.Windows.UIElement.TextInput&gt;</ph> evento associado subjacente <ph id="ph2">&lt;xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType&gt;</ph> evento anexado e receber a mesma instância de dados de evento.</target>       </trans-unit>
        <trans-unit id="3510" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TextInput">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="3511" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TextInput">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3512" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TextInput">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="3513" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TextInput">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="3514" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TextInput">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="3515" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TextInput">
          <source>The corresponding tunneling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewTextInput&gt;</ph>.</source>
          <target state="translated">O evento de túnel correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewTextInput&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3516" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TextInput">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTextInput%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTextInput%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="3517" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.TextInputEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.TextInput" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.TextInput" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3518" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.TextInputEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Identificadores de eventos roteados são criados quando os eventos roteados são registrados.</target>       </trans-unit>
        <trans-unit id="3519" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.TextInputEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Esses identificadores contém um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e método de utilitário para adicionar proprietários para o evento.</target>       </trans-unit>
        <trans-unit id="3520" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.TextInputEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Você pode usar esses identificadores para adicionar manipuladores de classe.</target>       </trans-unit>
        <trans-unit id="3521" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.TextInputEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como registrar eventos roteados, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3522" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.UIElement.TextInputEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre o uso de identificadores de evento roteado para adicionar manipuladores de classe, consulte <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3523" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.TouchDown">
          <source>Occurs when a finger touches the screen while the finger is over this element.</source>
          <target state="translated">Ocorre quando um dedo toca a tela enquanto está sobre esse elemento.</target>       </trans-unit>
        <trans-unit id="3524" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchDown">
          <source>By default, the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewTouchDown&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.UIElement.TouchDown&gt;</ph> events do not occur until a finger touches the screen and moves.</source>
          <target state="translated">Por padrão, o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewTouchDown&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.UIElement.TouchDown&gt;</ph> eventos não ocorrer até que um dedo toca na tela e move.</target>       </trans-unit>
        <trans-unit id="3525" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchDown">
          <source>Pressing a finger on the screen and holding it without moving it causes the press and hold behavior of a <ph id="ph1">&lt;xref:System.Windows.Input.Stylus&gt;</ph>.</source>
          <target state="translated">Pressionando um dedo na tela, mantendo sem movê-lo faz com que o pressionamento e manter o comportamento de um <ph id="ph1">&lt;xref:System.Windows.Input.Stylus&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3526" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchDown">
          <source>The press and hold behavior is equivalent to a mouse right-click.</source>
          <target state="translated">O comportamento pressione e segure a tecla é equivalente a um clique do mouse.</target>       </trans-unit>
        <trans-unit id="3527" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchDown">
          <source>To cause the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewTouchDown&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.UIElement.TouchDown&gt;</ph> events to occur as soon as a finger touches the screen, set the <ph id="ph3">&lt;xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType&gt;</ph> attached property to <ph id="ph4">`false`</ph> for this element.</source>
          <target state="translated">Para fazer com que o <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewTouchDown&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.UIElement.TouchDown&gt;</ph> eventos ocorrer como um dedo toca a tela, defina o <ph id="ph3">&lt;xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType&gt;</ph> anexado a propriedade <ph id="ph4">`false`</ph> para este elemento.</target>       </trans-unit>
        <trans-unit id="3528" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchDown">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="3529" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchDown">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3530" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchDown">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="3531" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchDown">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="3532" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchDown">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="3533" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchDown">
          <source><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> of type <ph id="ph2">&lt;xref:System.Windows.Input.TouchEventArgs&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> do tipo <ph id="ph2">&lt;xref:System.Windows.Input.TouchEventArgs&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3534" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchDown">
          <source>The corresponding tunneling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewTouchDown&gt;</ph>.</source>
          <target state="translated">O evento de túnel correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewTouchDown&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3535" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchDown">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchDown%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchDown%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="3536" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.TouchDownEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.TouchDown" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.TouchDown" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3537" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.TouchEnter">
          <source>Occurs when a touch moves from outside to inside the bounds of this element.</source>
          <target state="translated">Ocorre quando um toque é movido de fora para dentro dos limites deste elemento.</target>       </trans-unit>
        <trans-unit id="3538" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchEnter">
          <source>This event is always raised, whether or not the touch device is captured to this element.</source>
          <target state="translated">Esse evento é gerado sempre se ou não o dispositivo de toque é capturado para este elemento.</target>       </trans-unit>
        <trans-unit id="3539" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchEnter">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="3540" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchEnter">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3541" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchEnter">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="3542" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchEnter">
          <source>Direct</source>
          <target state="translated">Direto</target>       </trans-unit>
        <trans-unit id="3543" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchEnter">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="3544" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchEnter">
          <source><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> of type <ph id="ph2">&lt;xref:System.Windows.Input.TouchEventArgs&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> do tipo <ph id="ph2">&lt;xref:System.Windows.Input.TouchEventArgs&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3545" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchEnter">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchEnter%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchEnter%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="3546" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.TouchEnterEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.TouchEnter" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.TouchEnter" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3547" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.TouchesCaptured">
          <source>Gets all touch devices that are captured to this element.</source>
          <target state="translated">Obtém todos os dispositivos de toque capturados para esse elemento.</target>       </trans-unit>
        <trans-unit id="3548" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.TouchesCaptured">
          <source>An enumeration of <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchDevice" /&gt;</ph> objects that are captured to this element.</source>
          <target state="translated">Uma enumeração de objetos <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchDevice" /&gt;</ph> capturados para esse elemento.</target>       </trans-unit>
        <trans-unit id="3549" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.TouchesCapturedWithin">
          <source>Gets all touch devices that are captured to this element or any child elements in its visual tree.</source>
          <target state="translated">Obtém todos os dispositivos de toque que são capturados para esse elemento ou os elementos filho na árvore visual.</target>       </trans-unit>
        <trans-unit id="3550" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.TouchesCapturedWithin">
          <source>An enumeration of <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchDevice" /&gt;</ph> objects that are captured to this element or any child elements in its visual tree.</source>
          <target state="translated">Uma enumeração de objetos <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchDevice" /&gt;</ph> que são capturados para esse elemento ou elementos filho na árvore visual.</target>       </trans-unit>
        <trans-unit id="3551" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.TouchesDirectlyOver">
          <source>Gets all touch devices that are over this element.</source>
          <target state="translated">Obtém todos os dispositivos de toque nesse elemento.</target>       </trans-unit>
        <trans-unit id="3552" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.TouchesDirectlyOver">
          <source>An enumeration of <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchDevice" /&gt;</ph> objects that are over this element.</source>
          <target state="translated">Uma enumeração de objetos <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchDevice" /&gt;</ph> nesse elemento.</target>       </trans-unit>
        <trans-unit id="3553" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.TouchesOver">
          <source>Gets all touch devices that are over this element or any child elements in its visual tree.</source>
          <target state="translated">Obtém todos os dispositivos de toque que estão sobre esse elemento ou sobre os elementos filho na árvore visual.</target>       </trans-unit>
        <trans-unit id="3554" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.TouchesOver">
          <source>An enumeration of <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchDevice" /&gt;</ph> objects that are over this element or any child elements in its visual tree.</source>
          <target state="translated">Uma enumeração de objetos <ph id="ph1">&lt;see cref="T:System.Windows.Input.TouchDevice" /&gt;</ph> que estão acima desse elemento ou dos elementos filho na árvore visual.</target>       </trans-unit>
        <trans-unit id="3555" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.TouchLeave">
          <source>Occurs when a touch moves from inside to outside the bounds of this element.</source>
          <target state="translated">Ocorre quando um toque é movido de dentro para fora dos limites deste elemento.</target>       </trans-unit>
        <trans-unit id="3556" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchLeave">
          <source>This event is always raised, whether or not the touch device is captured to this element.</source>
          <target state="translated">Esse evento é gerado sempre se ou não o dispositivo de toque é capturado para este elemento.</target>       </trans-unit>
        <trans-unit id="3557" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchLeave">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="3558" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchLeave">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3559" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchLeave">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="3560" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchLeave">
          <source>Direct</source>
          <target state="translated">Direto</target>       </trans-unit>
        <trans-unit id="3561" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchLeave">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="3562" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchLeave">
          <source><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> of type <ph id="ph2">&lt;xref:System.Windows.Input.TouchEventArgs&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> do tipo <ph id="ph2">&lt;xref:System.Windows.Input.TouchEventArgs&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3563" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchLeave">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchLeave%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchLeave%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="3564" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.TouchLeaveEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.TouchLeave" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.TouchLeave" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3565" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.TouchMove">
          <source>Occurs when a finger moves on the screen while the finger is over this element.</source>
          <target state="translated">Ocorre quando um dedo se move na tela enquanto está sobre esse elemento.</target>       </trans-unit>
        <trans-unit id="3566" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchMove">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="3567" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchMove">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3568" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchMove">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="3569" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchMove">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="3570" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchMove">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="3571" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchMove">
          <source><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> of type <ph id="ph2">&lt;xref:System.Windows.Input.TouchEventArgs&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> do tipo <ph id="ph2">&lt;xref:System.Windows.Input.TouchEventArgs&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3572" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchMove">
          <source>The corresponding tunneling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewTouchMove&gt;</ph>.</source>
          <target state="translated">O evento de túnel correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewTouchMove&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3573" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchMove">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchMove%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchMove%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="3574" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.TouchMoveEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.TouchMove" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.TouchMove" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3575" translate="yes" xml:space="preserve" uid="E:System.Windows.UIElement.TouchUp">
          <source>Occurs when a finger is raised off of the screen while the finger is over this element.</source>
          <target state="translated">Ocorre quando um dedo é gerado fora da tela enquanto o dedo está sobre este elemento.</target>       </trans-unit>
        <trans-unit id="3576" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchUp">
          <source>Routed Event Information</source>
          <target state="translated">Informações de evento encaminhado</target>       </trans-unit>
        <trans-unit id="3577" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchUp">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3578" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchUp">
          <source>Routing strategy</source>
          <target state="translated">Estratégia de roteamento</target>       </trans-unit>
        <trans-unit id="3579" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchUp">
          <source>Bubbling</source>
          <target state="translated">Bolha</target>       </trans-unit>
        <trans-unit id="3580" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchUp">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="3581" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchUp">
          <source><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> of type <ph id="ph2">&lt;xref:System.Windows.Input.TouchEventArgs&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.EventHandler%601&gt;</ph> do tipo <ph id="ph2">&lt;xref:System.Windows.Input.TouchEventArgs&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3582" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchUp">
          <source>The corresponding tunneling event is <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewTouchUp&gt;</ph>.</source>
          <target state="translated">O evento de túnel correspondente é <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewTouchUp&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3583" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.UIElement.TouchUp">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchUp%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Substituir <ph id="ph1">&lt;xref:System.Windows.UIElement.OnTouchUp%2A&gt;</ph> para implementar a manipulação de classe para esse evento em classes derivadas.</target>       </trans-unit>
        <trans-unit id="3584" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.TouchUpEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.TouchUp" /&gt;</ph> routed event.</source>
          <target state="translated">Identifica o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.TouchUp" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3585" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.TranslatePoint(System.Windows.Point,System.Windows.UIElement)">
          <source>The point value, as relative to this element.</source>
          <target state="translated">O valor do ponto, como relativo a esse elemento.</target>       </trans-unit>
        <trans-unit id="3586" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.TranslatePoint(System.Windows.Point,System.Windows.UIElement)">
          <source>The element to translate the given point into.</source>
          <target state="translated">O elemento no qual converter o determinado ponto.</target>       </trans-unit>
        <trans-unit id="3587" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.TranslatePoint(System.Windows.Point,System.Windows.UIElement)">
          <source>Translates a point relative to this element to coordinates that are relative to the specified element.</source>
          <target state="translated">Converte um ponto em relação a esse elemento para coordenadas que são relativas ao elemento especificado.</target>       </trans-unit>
        <trans-unit id="3588" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.TranslatePoint(System.Windows.Point,System.Windows.UIElement)">
          <source>A point value, now relative to the target element rather than this source element.</source>
          <target state="translated">Um valor de ponto, agora relativo ao elemento de destino em vez desse elemento de origem.</target>       </trans-unit>
        <trans-unit id="3589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.TranslatePoint(System.Windows.Point,System.Windows.UIElement)">
          <source>Passing <ph id="ph1">`null`</ph> for <ph id="ph2">`relativeTo`</ph> is permitted, and indicates that coordinates should be relative to the root element in the logical tree that this element belongs to.</source>
          <target state="translated">Passando <ph id="ph1">`null`</ph> para <ph id="ph2">`relativeTo`</ph> é permitida e indica que as coordenadas devem ser em relação ao elemento raiz na árvore lógica que esse elemento pertence.</target>       </trans-unit>
        <trans-unit id="3590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.TranslatePoint(System.Windows.Point,System.Windows.UIElement)">
          <source>This method is used for translating hit test point values.</source>
          <target state="translated">Esse método é usado para converter valores de ponto de teste de ocorrências.</target>       </trans-unit>
        <trans-unit id="3591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.TranslatePoint(System.Windows.Point,System.Windows.UIElement)">
          <source>Calling this method is mainly relevant if you are authoring a control and need to process input at a lower level.</source>
          <target state="translated">Chamar esse método é principalmente relevante se você estiver criando um controle e precisa processar a entrada em um nível inferior.</target>       </trans-unit>
        <trans-unit id="3592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.TranslatePoint(System.Windows.Point,System.Windows.UIElement)">
          <source>If you are using existing controls, you can generally assume that completed controls will report correctly translated hit test results.</source>
          <target state="translated">Se você estiver usando os controles existentes, geralmente você pode presumir que controles concluídos relatará resultados de teste de hit traduzidos corretamente.</target>       </trans-unit>
        <trans-unit id="3593" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.Uid">
          <source>Gets or sets the unique identifier (for localization) for this element.</source>
          <target state="translated">Obtém ou define o identificador exclusivo (para localização) para esse elemento.</target>       </trans-unit>
        <trans-unit id="3594" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.Uid">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="3595" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Uid">
          <source>A string that is the unique identifier for this element.</source>
          <target state="translated">Uma cadeia de caracteres que é o identificador exclusivo deste elemento.</target>       </trans-unit>
        <trans-unit id="3596" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Uid">
          <source>Used by designers to get the <ph id="ph1">`x:Uid`</ph> value (see <bpt id="p1">[</bpt>WPF Globalization and Localization Overview<ept id="p1">](~/docs/framework/wpf/advanced/wpf-globalization-and-localization-overview.md)</ept> for more information).</source>
          <target state="translated">Usada por designers para obter o <ph id="ph1">`x:Uid`</ph> valor (consulte <bpt id="p1">[</bpt>visão de geral de localização e globalização de WPF<ept id="p1">](~/docs/framework/wpf/advanced/wpf-globalization-and-localization-overview.md)</ept> para obter mais informações).</target>       </trans-unit>
        <trans-unit id="3597" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Uid">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="3598" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Uid">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3599" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Uid">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="3600" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Uid">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="3601" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.UidProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.Uid" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.Uid" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3602" translate="yes" xml:space="preserve" uid="M:System.Windows.UIElement.UpdateLayout">
          <source>Ensures that all visual child elements of this element are properly updated for layout.</source>
          <target state="translated">Garante que todos os elementos filho visuais desse elemento tenham o layout atualizado corretamente.</target>       </trans-unit>
        <trans-unit id="3603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.UpdateLayout">
          <source>When you call this method, elements with <ph id="ph1">&lt;xref:System.Windows.UIElement.IsMeasureValid%2A&gt;</ph><ph id="ph2">`false`</ph> or <ph id="ph3">&lt;xref:System.Windows.UIElement.IsArrangeValid%2A&gt;</ph><ph id="ph4">`false`</ph> will call element-specific <ph id="ph5">&lt;xref:System.Windows.UIElement.MeasureCore%2A&gt;</ph> and <ph id="ph6">&lt;xref:System.Windows.UIElement.ArrangeCore%2A&gt;</ph> methods, which forces layout update, and all computed sizes will be validated.</source>
          <target state="translated">Quando você chama esse método, os elementos com <ph id="ph1">&lt;xref:System.Windows.UIElement.IsMeasureValid%2A&gt;</ph> <ph id="ph2">`false`</ph> ou <ph id="ph3">&lt;xref:System.Windows.UIElement.IsArrangeValid%2A&gt;</ph> <ph id="ph4">`false`</ph> chamará o elemento específico <ph id="ph5">&lt;xref:System.Windows.UIElement.MeasureCore%2A&gt;</ph> e <ph id="ph6">&lt;xref:System.Windows.UIElement.ArrangeCore%2A&gt;</ph> atualizar métodos, o que força o layout e todos os tamanhos computados serão validados.</target>       </trans-unit>
        <trans-unit id="3604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.UpdateLayout">
          <source>Calling this method has no effect if layout is unchanged, or if neither arrangement nor measurement state of a layout is invalid.</source>
          <target state="translated">Chamar esse método não tem nenhum efeito se layout é alterado, ou se o estado de organização nem a medida de um layout é inválido.</target>       </trans-unit>
        <trans-unit id="3605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.UpdateLayout">
          <source>However, if layout is invalid in either respect, the <ph id="ph1">&lt;xref:System.Windows.UIElement.UpdateLayout%2A&gt;</ph> call will redo the entire layout.</source>
          <target state="translated">No entanto, se o layout é inválido em qualquer aspecto de <ph id="ph1">&lt;xref:System.Windows.UIElement.UpdateLayout%2A&gt;</ph> chamada irá Refazer todo o layout.</target>       </trans-unit>
        <trans-unit id="3606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.UpdateLayout">
          <source>Therefore, you should avoid calling <ph id="ph1">&lt;xref:System.Windows.UIElement.UpdateLayout%2A&gt;</ph> after each incremental and minor change in the element tree.</source>
          <target state="translated">Portanto, evite chamar <ph id="ph1">&lt;xref:System.Windows.UIElement.UpdateLayout%2A&gt;</ph> após cada alteração incremental e pequena na árvore de elementos.</target>       </trans-unit>
        <trans-unit id="3607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.UpdateLayout">
          <source>The layout system will perform element layout in a deferred manner, using an algorithm that balances performance and currency, and with a weighting strategy to defer changes to roots until all child elements are valid.</source>
          <target state="translated">O sistema de layout executará o layout do elemento de uma maneira adiada, usando um algoritmo que equilibra a desempenho e moeda, e uma estratégia de ponderação para adiar alterações raízes até que todos os elementos filho são válidos.</target>       </trans-unit>
        <trans-unit id="3608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.UIElement.UpdateLayout">
          <source>You should only call <ph id="ph1">&lt;xref:System.Windows.UIElement.UpdateLayout%2A&gt;</ph> if you absolutely need updated sizes and positions, and only after you are certain that all changes to properties that you control and that may affect layout are completed.</source>
          <target state="translated">Você só deve chamar <ph id="ph1">&lt;xref:System.Windows.UIElement.UpdateLayout%2A&gt;</ph> se é absolutamente necessário posições e tamanhos atualizados, e somente depois que você tiver certeza de que todas as alterações de propriedades que você controle e que pode afetar o layout são concluídas.</target>       </trans-unit>
        <trans-unit id="3609" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.Visibility">
          <source>Gets or sets the <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> visibility of this element.</source>
          <target state="translated">Obtém ou define a visibilidade <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> desse elemento.</target>       </trans-unit>
        <trans-unit id="3610" translate="yes" xml:space="preserve" uid="P:System.Windows.UIElement.Visibility">
          <source>This is a dependency property.</source>
          <target state="translated">É uma propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="3611" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Visibility">
          <source>A value of the enumeration.</source>
          <target state="translated">Um valor da enumeração.</target>       </trans-unit>
        <trans-unit id="3612" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Visibility">
          <source>The default value is <ph id="ph1">&lt;see cref="F:System.Windows.Visibility.Visible" /&gt;</ph>.</source>
          <target state="translated">O valor padrão é <ph id="ph1">&lt;see cref="F:System.Windows.Visibility.Visible" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3613" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Visibility">
          <source>Setting this property affects the value of <ph id="ph1">&lt;xref:System.Windows.UIElement.IsVisible%2A&gt;</ph>, which in turn may raise the <ph id="ph2">&lt;xref:System.Windows.UIElement.IsVisibleChanged&gt;</ph> event.</source>
          <target state="translated">A definição dessa propriedade afeta o valor de <ph id="ph1">&lt;xref:System.Windows.UIElement.IsVisible%2A&gt;</ph>, que por sua vez pode gerar o <ph id="ph2">&lt;xref:System.Windows.UIElement.IsVisibleChanged&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="3614" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Visibility">
          <source>However, <ph id="ph1">&lt;xref:System.Windows.UIElement.IsVisible%2A&gt;</ph> has other factors that influence it, for instance the visibility settings of parents that contain it.</source>
          <target state="translated">No entanto, <ph id="ph1">&lt;xref:System.Windows.UIElement.IsVisible%2A&gt;</ph> tem outros fatores que influenciam a ele, por exemplo, as configurações de visibilidade de pais que contêm.</target>       </trans-unit>
        <trans-unit id="3615" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Visibility">
          <source>Elements where <ph id="ph1">&lt;xref:System.Windows.UIElement.Visibility%2A&gt;</ph> is not <ph id="ph2">&lt;xref:System.Windows.Visibility.Visible&gt;</ph> do not participate in input events (or commands), do not influence either the Measure or Arrange passes of layout, are not in a tab sequence, and will not be reported in hit testing.</source>
          <target state="translated">Elementos onde <ph id="ph1">&lt;xref:System.Windows.UIElement.Visibility%2A&gt;</ph> não é <ph id="ph2">&lt;xref:System.Windows.Visibility.Visible&gt;</ph> não participam de eventos de entrada (ou comandos), não influenciam a medida ou organizar passos de layout, não estão em uma sequência de guia e não serão reportadas no teste de clique.</target>       </trans-unit>
        <trans-unit id="3616" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Visibility">
          <source>When inherited by <ph id="ph1">&lt;xref:System.Windows.Window&gt;</ph> or its derived classes, <ph id="ph2">&lt;xref:System.Windows.Window&gt;</ph> redefines the default value of this property to be <ph id="ph3">&lt;xref:System.Windows.Visibility.Collapsed&gt;</ph>.</source>
          <target state="translated">Quando herdado por <ph id="ph1">&lt;xref:System.Windows.Window&gt;</ph> ou suas classes derivadas, <ph id="ph2">&lt;xref:System.Windows.Window&gt;</ph> redefine o valor padrão dessa propriedade para ser <ph id="ph3">&lt;xref:System.Windows.Visibility.Collapsed&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3617" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Visibility">
          <source>This has the effect of not running the Measure pass of layout on an initially created <ph id="ph1">&lt;xref:System.Windows.Window&gt;</ph>, and <ph id="ph2">&lt;xref:System.Windows.UIElement.RenderSize%2A&gt;</ph> returns (0,0).</source>
          <target state="translated">Isso tem o efeito da execução não a passagem da medida de layout em inicialmente criado <ph id="ph1">&lt;xref:System.Windows.Window&gt;</ph>, e <ph id="ph2">&lt;xref:System.Windows.UIElement.RenderSize%2A&gt;</ph> retorna (0,0).</target>       </trans-unit>
        <trans-unit id="3618" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Visibility">
          <source>For details, see <ph id="ph1">&lt;xref:System.Windows.Window&gt;</ph>.</source>
          <target state="translated">Para obter detalhes, consulte <ph id="ph1">&lt;xref:System.Windows.Window&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3619" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Visibility">
          <source><ph id="ph1">&lt;xref:System.Windows.Controls.Primitives.Popup&gt;</ph> also redefines the default value to be <ph id="ph2">&lt;xref:System.Windows.Visibility.Collapsed&gt;</ph>, with similar resulting behavior for <ph id="ph3">&lt;xref:System.Windows.Controls.Primitives.Popup&gt;</ph> and its derived classes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.Primitives.Popup&gt;</ph> também redefine o valor padrão para <ph id="ph2">&lt;xref:System.Windows.Visibility.Collapsed&gt;</ph>, com um comportamento semelhante resultante para <ph id="ph3">&lt;xref:System.Windows.Controls.Primitives.Popup&gt;</ph> e suas classes derivadas.</target>       </trans-unit>
        <trans-unit id="3620" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Visibility">
          <source>Dependency Property Information</source>
          <target state="translated">Informações da propriedade de dependência</target>       </trans-unit>
        <trans-unit id="3621" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Visibility">
          <source>Identifier field</source>
          <target state="translated">Campo de identificador</target>       </trans-unit>
        <trans-unit id="3622" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Visibility">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propriedades de metadados é definido como <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="3623" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Visibility">
          <source>None</source>
          <target state="translated">Nenhum</target>       </trans-unit>
        <trans-unit id="3624" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Visibility">
          <source>The following example implements a handler that references two different named buttons that are intended to be a mutually exclusive pair in the user interface.</source>
          <target state="translated">O exemplo a seguir implementa um manipulador que faz referência a dois botões nomeadas diferentes que devem ser um par mutuamente na interface do usuário.</target>       </trans-unit>
        <trans-unit id="3625" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.UIElement.Visibility">
          <source>Prior to running the actual program logic associated with the button, the button itself is set to be <ph id="ph1">&lt;xref:System.Windows.Visibility.Hidden?displayProperty=nameWithType&gt;</ph>, and the other button in the pair is set to <ph id="ph2">&lt;xref:System.Windows.Visibility.Visible?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Antes de executar a lógica real do programa associada ao botão, o próprio botão está definido para ser <ph id="ph1">&lt;xref:System.Windows.Visibility.Hidden?displayProperty=nameWithType&gt;</ph>, e o outro botão no par é definido como <ph id="ph2">&lt;xref:System.Windows.Visibility.Visible?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3626" translate="yes" xml:space="preserve" uid="F:System.Windows.UIElement.VisibilityProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.Visibility" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica a propriedade de dependência <ph id="ph1">&lt;see cref="P:System.Windows.UIElement.Visibility" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>