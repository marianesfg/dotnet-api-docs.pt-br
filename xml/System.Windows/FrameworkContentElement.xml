<Type Name="FrameworkContentElement" FullName="System.Windows.FrameworkContentElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1c90a9ddef163b0e59dd29a8a1fb7b48cd8dbb6c" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkContentElement extends System.Windows.ContentElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkContentElement&#xA;Inherits ContentElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkContentElement : System::Windows::ContentElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.ContentElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="2f635-101">
        <see cref="T:System.Windows.FrameworkContentElement" /> é a implementação em nível de estrutura do WPF (Windows Presentation Foundation) e a expansão da classe base <see cref="T:System.Windows.ContentElement" />.</span>
      <span class="sxs-lookup">
        <span data-stu-id="2f635-101">
          <see cref="T:System.Windows.FrameworkContentElement" /> is the WPF framework-level implementation and expansion of the <see cref="T:System.Windows.ContentElement" /> base class.</span>
      </span>
      <span data-ttu-id="2f635-102">
        <see cref="T:System.Windows.FrameworkContentElement" /> adiciona suporte para APIs de entrada adicionais (incluindo menus de contexto e dicas de ferramentas), storyboards, contexto de dados para vinculação de dados, suporte a estilos e APIs auxiliares de árvore lógica.</span>
      <span class="sxs-lookup">
        <span data-stu-id="2f635-102">
          <see cref="T:System.Windows.FrameworkContentElement" /> adds support for additional input APIs (including tooltips and context menus), storyboards, data context for data binding, styles support, and logical tree helper APIs.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-103"><xref:System.Windows.FrameworkContentElement> ainda não definir seu próprio comportamento de renderização; Criando um real <xref:System.Windows.FrameworkContentElement> instância de classe no código ou marcação é possível, mas não exibirá nada em uma [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] aplicativo [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="2f635-103"><xref:System.Windows.FrameworkContentElement> does not yet define its own rendering behavior; instantiating an actual <xref:System.Windows.FrameworkContentElement> class instance in code or markup is possible but displays nothing in a [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] application [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="2f635-104">Lógica de processamento deve ser fornecido por classes que usam <xref:System.Windows.FrameworkContentElement> elementos filho como parte de seu modelo de conteúdo, ou em <xref:System.Windows.FrameworkContentElement> classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="2f635-104">Rendering logic must be provided by classes that take <xref:System.Windows.FrameworkContentElement> child elements as part of their content model, or in <xref:System.Windows.FrameworkContentElement> derived classes.</span></span>  
  
 <span data-ttu-id="2f635-105"><xref:System.Windows.FrameworkContentElement> deliberadamente comparável ao muitas das mesmas [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] como <xref:System.Windows.FrameworkElement>.</span><span class="sxs-lookup"><span data-stu-id="2f635-105"><xref:System.Windows.FrameworkContentElement> deliberately parallels many of the same [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] as <xref:System.Windows.FrameworkElement>.</span></span> <span data-ttu-id="2f635-106">Observe que certos [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] encontrado no <xref:System.Windows.FrameworkElement> não terá um <xref:System.Windows.FrameworkContentElement> equivalente.</span><span class="sxs-lookup"><span data-stu-id="2f635-106">Note that certain [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] found on <xref:System.Windows.FrameworkElement> will not have a <xref:System.Windows.FrameworkContentElement> equivalent.</span></span> <span data-ttu-id="2f635-107">Vários do <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] são para a funcionalidade como representação de geometria ou de layout, que não são relevantes para um <xref:System.Windows.FrameworkContentElement>.</span><span class="sxs-lookup"><span data-stu-id="2f635-107">Several of the <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] are for functionality such as geometry representation or layout, which are not relevant for a <xref:System.Windows.FrameworkContentElement>.</span></span>  
  
 <span data-ttu-id="2f635-108">A maioria dos existentes <xref:System.Windows.FrameworkContentElement> serão localizadas em classes derivadas de <xref:System.Windows.Documents> namespace.</span><span class="sxs-lookup"><span data-stu-id="2f635-108">The majority of existing <xref:System.Windows.FrameworkContentElement> derived classes will be found in the <xref:System.Windows.Documents> namespace.</span></span> <span data-ttu-id="2f635-109">Muitas dessas classes derivadas implementam elementos para o modelo de documento de fluxo.</span><span class="sxs-lookup"><span data-stu-id="2f635-109">Many of these derived classes implement elements for the flow document model.</span></span> <span data-ttu-id="2f635-110">Certas classes derivadas como <xref:System.Windows.Documents.Hyperlink> tem algumas funcionalidades de controle, mas são derivados de <xref:System.Windows.FrameworkContentElement> , de modo que os elementos de tipo de controle ainda podem participar no modelo de documento de fluxo.</span><span class="sxs-lookup"><span data-stu-id="2f635-110">Certain derived classes such as <xref:System.Windows.Documents.Hyperlink> have some control-like functionality, but are derived from <xref:System.Windows.FrameworkContentElement> such that the control-like elements can still participate in the flow document model.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.FrameworkElement" />
    <altmember cref="T:System.Windows.ContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2f635-111">Inicializa uma nova instância da classe <see cref="T:System.Windows.FrameworkContentElement" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-111">Initializes a new instance of the <see cref="T:System.Windows.FrameworkContentElement" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">
          <span data-ttu-id="2f635-112">O elemento filho a ser adicionado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-112">The child element to be added.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2f635-113">Adiciona o elemento fornecido como um filho desse elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-113">Adds the provided element as a child of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-114">Esse método pode gerar uma exceção se for chamado em um momento quando a árvore lógica está sendo iterada por outro processo.</span><span class="sxs-lookup"><span data-stu-id="2f635-114">This method can throw an exception if called at a time when the logical tree is being iterated by another process.</span></span>  
  
 <span data-ttu-id="2f635-115">A maioria dos <xref:System.Windows.FrameworkContentElement> classes derivadas expõem coleções dedicadas que são responsáveis por contenção (por exemplo, <xref:System.Windows.Documents.Span.Inlines%2A> no <xref:System.Windows.Documents.Span> classe; <xref:System.Windows.Documents.Section.Blocks%2A> no <xref:System.Windows.Documents.Section> classe).</span><span class="sxs-lookup"><span data-stu-id="2f635-115">Most <xref:System.Windows.FrameworkContentElement> derived classes expose dedicated collections that are responsible for containment (for example, <xref:System.Windows.Documents.Span.Inlines%2A> on the <xref:System.Windows.Documents.Span> class; <xref:System.Windows.Documents.Section.Blocks%2A> on the <xref:System.Windows.Documents.Section> class).</span></span> <span data-ttu-id="2f635-116">Normalmente, você pode evitar qualquer necessidade para manipular a árvore lógica diretamente se você derivar dessas classes em vez disso.</span><span class="sxs-lookup"><span data-stu-id="2f635-116">You can typically avoid any need to manipulate the logical tree directly if you derive from these classes instead.</span></span> <span data-ttu-id="2f635-117">Trabalhar com a árvore lógica para elementos de conteúdo é um cenário avançado que pode exigir um analisador especializado ou um especializado <xref:System.Windows.FrameworkElement> que atua como o elemento de renderização do pai (host de conteúdo).</span><span class="sxs-lookup"><span data-stu-id="2f635-117">Working with the logical tree for content elements is an advanced scenario that may require a specialized parser or a specialized <xref:System.Windows.FrameworkElement> that acts as the parent rendering element (content host).</span></span>  
  
 <span data-ttu-id="2f635-118">Para obter mais informações sobre como usar <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> e <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, consulte [árvores no WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span><span class="sxs-lookup"><span data-stu-id="2f635-118">For more information about how to use <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> and <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, see [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkContentElement.LogicalChildren" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2f635-119">Chamado antes de um elemento ser inicializado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-119">Called before an element is initialized.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="2f635-120">Substitua este método para fornecer um tratamento especial que deve ocorrer antes que o elemento é inicializado durante o processo de carregamento de elemento.</span>
            <span class="sxs-lookup">
              <span data-stu-id="2f635-120">Override this method to provide special handling that should occur before your element is initialized during the element loading process.</span>
            </span>
            <span data-ttu-id="2f635-121">Sua implementação deve chamar a implementação base, porque a implementação de base (padrão) define alguns sinalizadores internos para manter o controle de inicialização.</span>
            <span class="sxs-lookup">
              <span data-stu-id="2f635-121">Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</span>
            </span>
            <span data-ttu-id="2f635-122">A implementação base lançará uma exceção se <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> é chamado mais de uma vez no mesmo elemento antes de alcançar <see cref="M:System.Windows.FrameworkContentElement.EndInit" />.</span>
            <span class="sxs-lookup">
              <span data-stu-id="2f635-122">The base implementation will throw an exception if <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> is called more than one time on the same element prior to reaching <see cref="M:System.Windows.FrameworkContentElement.EndInit" />.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-123">Inicia a sequência de ações que estão contidas no storyboard fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-123">Begins the sequence of actions that are contained in the provided storyboard.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">
          <span data-ttu-id="2f635-124">O storyboard a ser iniciado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-124">The storyboard to begin.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2f635-125">Inicia a sequência de ações que estão contidas no storyboard fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-125">Begins the sequence of actions that are contained in the provided storyboard.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-126">Para que as assinaturas que não usam o `isControllable`, parâmetro, ou quando esse parâmetro é especificado `false`, os relógios de linha do tempo associados a animação são removidos como atingir o período de "Preenchimento".</span><span class="sxs-lookup"><span data-stu-id="2f635-126">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="2f635-127">Portanto, a animação não pode ser reiniciada depois de ser executado uma vez.</span><span class="sxs-lookup"><span data-stu-id="2f635-127">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="2f635-128">Observe que também controlar uma animação exige que o storyboard seja nomeado ou acessível como uma instância no código.</span><span class="sxs-lookup"><span data-stu-id="2f635-128">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">
          <span data-ttu-id="2f635-129">O storyboard a ser iniciado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-129">The storyboard to begin.</span>
          </span>
        </param>
        <param name="handoffBehavior">
          <span data-ttu-id="2f635-130">Um valor de enumeração que descreve o comportamento a ser usado se uma propriedade descrita no storyboard já for animada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-130">A value of the enumeration that describes behavior to use if a property described in the storyboard is already animated.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2f635-131">Inicia a sequência de ações contidas no storyboard fornecido, com opções especificadas para o que acontece se a propriedade já for animada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-131">Begins the sequence of actions that are contained in the provided storyboard, with options specified for what should occur if the property is already animated.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-132">Para que as assinaturas que não usam o `isControllable`, parâmetro, ou quando esse parâmetro é especificado `false`, os relógios de linha do tempo associados a animação são removidos como atingir o período de "Preenchimento".</span><span class="sxs-lookup"><span data-stu-id="2f635-132">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="2f635-133">Portanto, a animação não pode ser reiniciada depois de ser executado uma vez.</span><span class="sxs-lookup"><span data-stu-id="2f635-133">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="2f635-134">Observe que também controlar uma animação exige que o storyboard seja nomeado ou acessível como uma instância no código.</span><span class="sxs-lookup"><span data-stu-id="2f635-134">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
## <a name="using-the-compose-handoffbehavior"></a><span data-ttu-id="2f635-135">Usando o HandoffBehavior de composição</span><span class="sxs-lookup"><span data-stu-id="2f635-135">Using the Compose HandoffBehavior</span></span>  
 <span data-ttu-id="2f635-136">Quando você aplica um <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, ou <xref:System.Windows.Media.Animation.AnimationClock> para uma propriedade usando o <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, qualquer <xref:System.Windows.Media.Animation.Clock> objetos anteriormente associados com aquela propriedade continuam a consumir recursos do sistema; o sistema de temporização não remove os relógios automaticamente.</span><span class="sxs-lookup"><span data-stu-id="2f635-136">When you apply a <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, or <xref:System.Windows.Media.Animation.AnimationClock> to a property by using the <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> objects previously associated with that property continue to consume system resources; the timing system does not remove the clocks automatically.</span></span>  
  
 <span data-ttu-id="2f635-137">Para evitar problemas de desempenho quando você aplicar um grande número de relógios usando <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, você deve remover relógios de composição da propriedade animada após a conclusão.</span><span class="sxs-lookup"><span data-stu-id="2f635-137">To avoid performance issues when you apply a large number of clocks by using <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, you should remove composing clocks from the animated property after they complete.</span></span> <span data-ttu-id="2f635-138">Há várias maneiras de remover um relógio de:</span><span class="sxs-lookup"><span data-stu-id="2f635-138">There are several ways to remove a clock:</span></span>  
  
-   <span data-ttu-id="2f635-139">Para remover todos os relógios de uma propriedade, use o <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> ou <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> método do objeto animado.</span><span class="sxs-lookup"><span data-stu-id="2f635-139">To remove all clocks from a property, use the <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> or <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> method of the animated object.</span></span> <span data-ttu-id="2f635-140">Especifique a propriedade sendo animada como o primeiro parâmetro, e `null` como o segundo.</span><span class="sxs-lookup"><span data-stu-id="2f635-140">Specify the property being animated as the first parameter, and `null` as the second.</span></span> <span data-ttu-id="2f635-141">Isso remove todos os relógios de animação da propriedade.</span><span class="sxs-lookup"><span data-stu-id="2f635-141">This removes all animation clocks from the property.</span></span>  
  
-   <span data-ttu-id="2f635-142">Para remover um determinado <xref:System.Windows.Media.Animation.AnimationClock> de uma lista de relógios, use o <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriedade do <xref:System.Windows.Media.Animation.AnimationClock> para recuperar um <xref:System.Windows.Media.Animation.ClockController>, chame o <xref:System.Windows.Media.Animation.ClockController.Remove%2A> método do <xref:System.Windows.Media.Animation.ClockController>.</span><span class="sxs-lookup"><span data-stu-id="2f635-142">To remove a specific <xref:System.Windows.Media.Animation.AnimationClock> from a list of clocks, use the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of the <xref:System.Windows.Media.Animation.AnimationClock> to retrieve a <xref:System.Windows.Media.Animation.ClockController>, then call the <xref:System.Windows.Media.Animation.ClockController.Remove%2A> method of the <xref:System.Windows.Media.Animation.ClockController>.</span></span> <span data-ttu-id="2f635-143">Isso geralmente é feito o <xref:System.Windows.Media.Animation.Clock.Completed> um relógio de manipulador de eventos.</span><span class="sxs-lookup"><span data-stu-id="2f635-143">This is typically done in the <xref:System.Windows.Media.Animation.Clock.Completed> event handler for a clock.</span></span> <span data-ttu-id="2f635-144">Observe que somente relógios de raiz podem ser controlados por um <xref:System.Windows.Media.Animation.ClockController>; o <xref:System.Windows.Media.Animation.Clock.Controller%2A> retorna a propriedade de um relógio filho `null`.</span><span class="sxs-lookup"><span data-stu-id="2f635-144">Note that only root clocks can be controlled by a <xref:System.Windows.Media.Animation.ClockController>; the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of a child clock returns `null`.</span></span> <span data-ttu-id="2f635-145">Observe também que o <xref:System.Windows.Media.Animation.Clock.Completed> evento não será gerado se a duração efetiva do relógio for indefinida.</span><span class="sxs-lookup"><span data-stu-id="2f635-145">Note also that the <xref:System.Windows.Media.Animation.Clock.Completed> event is not raised if the effective duration of the clock is forever.</span></span>  <span data-ttu-id="2f635-146">Nesse caso, o usuário deve determinar quando chamar <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span><span class="sxs-lookup"><span data-stu-id="2f635-146">In that case, the user must determine when to call <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span></span>  
  
 <span data-ttu-id="2f635-147">Isso é basicamente um problema para animações em objetos que têm um longo tempo de vida.</span><span class="sxs-lookup"><span data-stu-id="2f635-147">This is primarily an issue for animations on objects that have a long lifetime.</span></span>  <span data-ttu-id="2f635-148">Quando um objeto é coletado como lixo, seus relógios também serão desconectados e coletados como lixo.</span><span class="sxs-lookup"><span data-stu-id="2f635-148">When an object is garbage collected, its clocks are also disconnected and garbage collected.</span></span>  
  
 <span data-ttu-id="2f635-149">Para obter mais informações sobre objetos clock, consulte [visão geral do sistema de controle de tempo e animação](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span><span class="sxs-lookup"><span data-stu-id="2f635-149">For more information about clock objects, see [Animation and Timing System Overview](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">
          <span data-ttu-id="2f635-150">O storyboard a ser iniciado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-150">The storyboard to begin.</span>
          </span>
        </param>
        <param name="handoffBehavior">
          <span data-ttu-id="2f635-151">Um valor de enumeração que descreve o comportamento a ser usado se uma propriedade descrita no storyboard já for animada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-151">A value of the enumeration that describes behavior to use if a  property described in the storyboard is already animated.</span>
          </span>
        </param>
        <param name="isControllable">
          <span data-ttu-id="2f635-152">Declara se a animação é controlável (pode estar em pausa) depois que ela é iniciada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-152">Declares whether the animation is controllable (can be paused) after it is started.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2f635-153">Inicia a sequência de ações contidas no storyboard fornecido, com o estado especificado para o controle da animação depois que ela é iniciada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-153">Begins the sequence of actions that are contained in the provided storyboard, with specified state for control of the animation after it is started.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-154">Para que as assinaturas que não usam o `isControllable`, parâmetro, ou quando esse parâmetro é especificado `false`, os relógios de linha do tempo associados a animação são removidos como atingir o período de "Preenchimento".</span><span class="sxs-lookup"><span data-stu-id="2f635-154">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="2f635-155">Portanto, a animação não pode ser reiniciada depois de ser executado uma vez.</span><span class="sxs-lookup"><span data-stu-id="2f635-155">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="2f635-156">Observe que também controlar uma animação exige que o storyboard seja nomeado ou acessível como uma instância no código.</span><span class="sxs-lookup"><span data-stu-id="2f635-156">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
## <a name="using-the-compose-handoffbehavior"></a><span data-ttu-id="2f635-157">Usando o HandoffBehavior de composição</span><span class="sxs-lookup"><span data-stu-id="2f635-157">Using the Compose HandoffBehavior</span></span>  
 <span data-ttu-id="2f635-158">Quando você aplica um <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, ou <xref:System.Windows.Media.Animation.AnimationClock> para uma propriedade usando o <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, qualquer <xref:System.Windows.Media.Animation.Clock> objetos anteriormente associados com aquela propriedade continuam a consumir recursos do sistema; o sistema de tempo não removerá esses relógios automaticamente.</span><span class="sxs-lookup"><span data-stu-id="2f635-158">When you apply a <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, or <xref:System.Windows.Media.Animation.AnimationClock> to a property by using the <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> objects previously associated with that property continue to consume system resources; the timing system does not remove these clocks automatically.</span></span>  
  
 <span data-ttu-id="2f635-159">Para evitar problemas de desempenho quando você aplicar um grande número de relógios usando <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, você deve remover relógios de composição da propriedade animada após a conclusão.</span><span class="sxs-lookup"><span data-stu-id="2f635-159">To avoid performance issues when you apply a large number of clocks by using <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, you should remove composing clocks from the animated property after they complete.</span></span> <span data-ttu-id="2f635-160">Há várias maneiras de remover um relógio de:</span><span class="sxs-lookup"><span data-stu-id="2f635-160">There are several ways to remove a clock:</span></span>  
  
-   <span data-ttu-id="2f635-161">Para remover todos os relógios de uma propriedade, use o <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> ou <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> método do objeto animado.</span><span class="sxs-lookup"><span data-stu-id="2f635-161">To remove all clocks from a property, use the <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> or <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> method of the animated object.</span></span> <span data-ttu-id="2f635-162">Especifique a propriedade sendo animada como o primeiro parâmetro, e `null` como o segundo.</span><span class="sxs-lookup"><span data-stu-id="2f635-162">Specify the property being animated as the first parameter, and `null` as the second.</span></span> <span data-ttu-id="2f635-163">Isso remove todos os relógios de animação da propriedade.</span><span class="sxs-lookup"><span data-stu-id="2f635-163">This removes all animation clocks from the property.</span></span>  
  
-   <span data-ttu-id="2f635-164">Para remover um determinado <xref:System.Windows.Media.Animation.AnimationClock> de uma lista de relógios, use o <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriedade do <xref:System.Windows.Media.Animation.AnimationClock> para recuperar um <xref:System.Windows.Media.Animation.ClockController>, chame o <xref:System.Windows.Media.Animation.ClockController.Remove%2A> método do <xref:System.Windows.Media.Animation.ClockController>.</span><span class="sxs-lookup"><span data-stu-id="2f635-164">To remove a specific <xref:System.Windows.Media.Animation.AnimationClock> from a list of clocks, use the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of the <xref:System.Windows.Media.Animation.AnimationClock> to retrieve a <xref:System.Windows.Media.Animation.ClockController>, then call the <xref:System.Windows.Media.Animation.ClockController.Remove%2A> method of the <xref:System.Windows.Media.Animation.ClockController>.</span></span> <span data-ttu-id="2f635-165">Isso geralmente é feito o <xref:System.Windows.Media.Animation.Clock.Completed> um relógio de manipulador de eventos.</span><span class="sxs-lookup"><span data-stu-id="2f635-165">This is typically done in the <xref:System.Windows.Media.Animation.Clock.Completed> event handler for a clock.</span></span> <span data-ttu-id="2f635-166">Observe que somente relógios de raiz podem ser controlados por um <xref:System.Windows.Media.Animation.ClockController>; o <xref:System.Windows.Media.Animation.Clock.Controller%2A> retorna a propriedade de um relógio filho `null`.</span><span class="sxs-lookup"><span data-stu-id="2f635-166">Note that only root clocks can be controlled by a <xref:System.Windows.Media.Animation.ClockController>; the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of a child clock returns `null`.</span></span> <span data-ttu-id="2f635-167">Observe também que o <xref:System.Windows.Media.Animation.Clock.Completed> evento não será gerado se a duração efetiva do relógio for indefinida.</span><span class="sxs-lookup"><span data-stu-id="2f635-167">Note also that the <xref:System.Windows.Media.Animation.Clock.Completed> event is not raised if the effective duration of the clock is forever.</span></span>  <span data-ttu-id="2f635-168">Nesse caso, o usuário deve determinar quando chamar <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span><span class="sxs-lookup"><span data-stu-id="2f635-168">In that case, the user must determine when to call <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span></span>  
  
 <span data-ttu-id="2f635-169">Isso é basicamente um problema para animações em objetos que têm um longo tempo de vida.</span><span class="sxs-lookup"><span data-stu-id="2f635-169">This is primarily an issue for animations on objects that have a long lifetime.</span></span>  <span data-ttu-id="2f635-170">Quando um objeto é coletado como lixo, seus relógios também serão desconectados e coletados como lixo.</span><span class="sxs-lookup"><span data-stu-id="2f635-170">When an object is garbage collected, its clocks are also disconnected and garbage collected.</span></span>  
  
 <span data-ttu-id="2f635-171">Para obter mais informações sobre objetos clock, consulte [visão geral do sistema de controle de tempo e animação](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span><span class="sxs-lookup"><span data-stu-id="2f635-171">For more information about clock objects, see [Animation and Timing System Overview](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-172">Obtém ou define o <see cref="T:System.Windows.Data.BindingGroup" /> que é usado para o elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-172">Gets or sets the <see cref="T:System.Windows.Data.BindingGroup" /> that is used for the element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2f635-173">O <see cref="T:System.Windows.Data.BindingGroup" /> que é usado para o elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-173">The <see cref="T:System.Windows.Data.BindingGroup" /> that is used for the element.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-174">Um <xref:System.Windows.Data.BindingGroup> pode ser usado para validar os valores de várias propriedades de um objeto.</span><span class="sxs-lookup"><span data-stu-id="2f635-174">A <xref:System.Windows.Data.BindingGroup> can be used to validate the values of multiple properties of an object.</span></span> <span data-ttu-id="2f635-175">Por exemplo, suponha que um aplicativo solicita que o usuário insira um endereço e, em seguida, popula um objeto do tipo `Address`, que tem as propriedades `Street`, `City`, `ZipCode`, e `Country`, com os valores fornecidos pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="2f635-175">For example, suppose that an application prompts the user to enter an address and then populates an object of type `Address`, which has the properties `Street`, `City`, `ZipCode`, and `Country`, with the values that the user provided.</span></span> <span data-ttu-id="2f635-176">O aplicativo tem um painel que contém quatro <xref:System.Windows.Controls.TextBox> controles, cada um deles está associada a uma das propriedades do objeto.</span><span class="sxs-lookup"><span data-stu-id="2f635-176">The application has a panel that contains four <xref:System.Windows.Controls.TextBox> controls, each of which is bound to one of the object’s properties.</span></span> <span data-ttu-id="2f635-177">Você pode usar um <xref:System.Windows.Controls.ValidationRule> em uma <xref:System.Windows.Data.BindingGroup> para validar o `Address` objeto.</span><span class="sxs-lookup"><span data-stu-id="2f635-177">You can use a <xref:System.Windows.Controls.ValidationRule> in a <xref:System.Windows.Data.BindingGroup> to validate the `Address` object.</span></span> <span data-ttu-id="2f635-178">Por exemplo, o <xref:System.Windows.Controls.ValidationRule> pode garantir que o código postal seja válido para o país do endereço.</span><span class="sxs-lookup"><span data-stu-id="2f635-178">For example, the <xref:System.Windows.Controls.ValidationRule> can ensure that the zip code is valid for the country of the address.</span></span>  
  
 <span data-ttu-id="2f635-179">Elementos filho herdam o <xref:System.Windows.Data.BindingGroup> de seus elementos-pai, assim como com qualquer outra propriedade herdável.</span><span class="sxs-lookup"><span data-stu-id="2f635-179">Child elements inherit the <xref:System.Windows.Data.BindingGroup> from their parent elements, just as with any other inheritable property.</span></span>  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2f635-180">Informações da propriedade de dependência</span><span class="sxs-lookup"><span data-stu-id="2f635-180">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2f635-181">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="2f635-181">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|  
|<span data-ttu-id="2f635-182">Definir propriedades de metadados **true**</span><span class="sxs-lookup"><span data-stu-id="2f635-182">Metadata properties set to **true**</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-183">Identifica a propriedade de dependência <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-183">Identifies the <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2f635-184">Tenta trazer esse elemento para a exibição, dentro de qualquer região rolável na qual ele está contido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-184">Attempts to bring this element into view, within any scrollable regions it is contained within.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-185">Ao chamar esse método, você efetivamente chamará <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> em qualquer área rolável pai que contém o elemento (o pai pode ser muito bem um <xref:System.Windows.FrameworkElement>, não um <xref:System.Windows.FrameworkContentElement>).</span><span class="sxs-lookup"><span data-stu-id="2f635-185">By calling this method, you effectively will call <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> on any parent scrollable area that contains the element (the parent may very well be a <xref:System.Windows.FrameworkElement>, not a <xref:System.Windows.FrameworkContentElement>).</span></span> <span data-ttu-id="2f635-186">Se esse elemento não está contido em uma área rolável, ele ainda é gerado, mas não haverá nenhum efeito.</span><span class="sxs-lookup"><span data-stu-id="2f635-186">If this element is not contained in a scrollable area, the event is still raised, but there will be no effect.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-187">Obtém ou define o elemento do menu de contexto que deve aparecer sempre que o menu de contexto for solicitado por meio de [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] nesse elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-187">Gets or sets the context menu element that should appear whenever the context menu is requested via [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] from within this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2f635-188">O menu de contexto que usa esse elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-188">The context menu that this element uses.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2f635-189">Informações da propriedade de dependência</span><span class="sxs-lookup"><span data-stu-id="2f635-189">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2f635-190">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="2f635-190">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|  
|<span data-ttu-id="2f635-191">Propriedades de metadados é definido como `true`</span><span class="sxs-lookup"><span data-stu-id="2f635-191">Metadata properties set to `true`</span></span>|<span data-ttu-id="2f635-192">Nenhum</span><span class="sxs-lookup"><span data-stu-id="2f635-192">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="2f635-193">O exemplo a seguir coloca um <xref:System.Windows.Controls.ContextMenu> em um <xref:System.Windows.Documents.Paragraph>.</span><span class="sxs-lookup"><span data-stu-id="2f635-193">The following example places a <xref:System.Windows.Controls.ContextMenu> on a <xref:System.Windows.Documents.Paragraph>.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#contextmenu)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-194">Ocorre logo antes do fechamento de qualquer menu de contexto no elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-194">Occurs just before any context menu on the element is closed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-195">Para suprimir o fechamento menus de contexto, manipuladores de evento devem marcá-la como manipulado.</span><span class="sxs-lookup"><span data-stu-id="2f635-195">To suppress closing context menus, handlers of the event should mark it as handled.</span></span>  
  
 <span data-ttu-id="2f635-196">Para usar esse evento como um <xref:System.Windows.EventTrigger> em um estilo, você deve referenciar o identificador de evento de serviço subjacente:</span><span class="sxs-lookup"><span data-stu-id="2f635-196">To use this event as an <xref:System.Windows.EventTrigger> in a style, you must reference the underlying service event identifier:</span></span>  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 <span data-ttu-id="2f635-197">(Esse uso é necessário porque a implementação de evento em <xref:System.Windows.FrameworkContentElement> que expõe o evento serviço subjacente não mapear corretamente o <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> identificador para uso em gatilhos).</span><span class="sxs-lookup"><span data-stu-id="2f635-197">(This usage is required because the event implementation on <xref:System.Windows.FrameworkContentElement> that exposes the underlying service event does not correctly map the <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> identifier for use in triggers).</span></span>  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="2f635-198">Informações de evento encaminhado</span><span class="sxs-lookup"><span data-stu-id="2f635-198">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2f635-199">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="2f635-199">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|  
|<span data-ttu-id="2f635-200">Estratégia de roteamento</span><span class="sxs-lookup"><span data-stu-id="2f635-200">Routing strategy</span></span>|<span data-ttu-id="2f635-201">Bolha</span><span class="sxs-lookup"><span data-stu-id="2f635-201">Bubbling</span></span>|  
|<span data-ttu-id="2f635-202">delegado</span><span class="sxs-lookup"><span data-stu-id="2f635-202">Delegate</span></span>|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
   
  
## Examples  
 <span data-ttu-id="2f635-203">O exemplo a seguir implementa um manipulador que altera o cursor sobre uma determinada região `DisplayArea` (não mostrado).</span><span class="sxs-lookup"><span data-stu-id="2f635-203">The following example implements a handler that changes the cursor over a named region `DisplayArea` (not shown).</span></span> <span data-ttu-id="2f635-204">O comentário sugere um <xref:System.Windows.UIElement> uso, mas na verdade, este exemplo será idêntico se `DisplayArea` foram um <xref:System.Windows.FrameworkContentElement>.</span><span class="sxs-lookup"><span data-stu-id="2f635-204">The comment hints at a <xref:System.Windows.UIElement> usage, but in fact this sample would be identical if `DisplayArea` were a <xref:System.Windows.FrameworkContentElement>.</span></span>  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-205">Identifica a [Visão geral de eventos roteados](~/docs/framework/wpf/advanced/routed-events-overview.md) de <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-205">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-206">Objetos de identificador de evento são criados quando os eventos roteados são registrados (consulte <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) e, em seguida, pode ser usado para adicionar manipuladores de classe (consulte <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="2f635-206">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="2f635-207">Objetos de identificador contêm um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e um método de utilitário para adicionar proprietários para o evento.</span><span class="sxs-lookup"><span data-stu-id="2f635-207">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-208">Ocorre quando qualquer menu de contexto no elemento é aberto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-208">Occurs when any context menu on the element is opened.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-209">Para abrir manualmente os menus de contexto, manipuladores de eventos devem marcar o evento relevante como manipulado.</span><span class="sxs-lookup"><span data-stu-id="2f635-209">To manually open context menus, handlers of the events should mark the relevant event as handled.</span></span> <span data-ttu-id="2f635-210">Caso contrário, o valor existente da <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> propriedade será usada para automaticamente abrir um menu de contexto.</span><span class="sxs-lookup"><span data-stu-id="2f635-210">Otherwise, the existing value of the <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> property will be used to automatically open a context menu.</span></span> <span data-ttu-id="2f635-211">Marcar o evento manipulado efetivamente cancelará a ação padrão e pode ser uma oportunidade para redefinir o valor da <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> propriedade e, em seguida, abra o novo <xref:System.Windows.Controls.ContextMenu>.</span><span class="sxs-lookup"><span data-stu-id="2f635-211">Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> property and then open the new <xref:System.Windows.Controls.ContextMenu>.</span></span> <span data-ttu-id="2f635-212">No entanto, há um problema de sincronização que deve estar atento.</span><span class="sxs-lookup"><span data-stu-id="2f635-212">However, there is a timing issue you should be aware of.</span></span> <span data-ttu-id="2f635-213">Para substituir completamente o menu de contexto por meio de um <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> manipulador, no menu de contexto inicial não deve ser nulo / vazio.</span><span class="sxs-lookup"><span data-stu-id="2f635-213">In order to completely replace the context menu through a <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> handler, the initial context menu must not be null / empty.</span></span> <span data-ttu-id="2f635-214">Como alternativa, você precisará manipular o evento e, em seguida, abra manualmente um novo menu de contexto.</span><span class="sxs-lookup"><span data-stu-id="2f635-214">Alternatively, you might need to handle the event and then manually open a new context menu.</span></span> <span data-ttu-id="2f635-215">Para obter detalhes, consulte [como: manipular o evento ContextMenuOpening](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).</span><span class="sxs-lookup"><span data-stu-id="2f635-215">For details, see [How to: Handle the ContextMenuOpening Event](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).</span></span>  
  
 <span data-ttu-id="2f635-216">Para usar esse evento como um <xref:System.Windows.EventTrigger> em um estilo, você deve referenciar o identificador de evento de serviço subjacente:</span><span class="sxs-lookup"><span data-stu-id="2f635-216">To use this event as an <xref:System.Windows.EventTrigger> in a style, you must reference the underlying service event identifier:</span></span>  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 <span data-ttu-id="2f635-217">(Esse uso é necessário porque a implementação de evento em <xref:System.Windows.FrameworkContentElement> que expõe o evento serviço subjacente não mapear corretamente o <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> identificador para uso em gatilhos).</span><span class="sxs-lookup"><span data-stu-id="2f635-217">(This usage is required because the event implementation on <xref:System.Windows.FrameworkContentElement> that exposes the underlying service event does not correctly map the <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> identifier for use in triggers).</span></span>  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="2f635-218">Informações de evento encaminhado</span><span class="sxs-lookup"><span data-stu-id="2f635-218">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2f635-219">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="2f635-219">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|  
|<span data-ttu-id="2f635-220">Estratégia de roteamento</span><span class="sxs-lookup"><span data-stu-id="2f635-220">Routing strategy</span></span>|<span data-ttu-id="2f635-221">Bolha</span><span class="sxs-lookup"><span data-stu-id="2f635-221">Bubbling</span></span>|  
|<span data-ttu-id="2f635-222">delegado</span><span class="sxs-lookup"><span data-stu-id="2f635-222">Delegate</span></span>|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-223">Identifica a [Visão geral de eventos roteados](~/docs/framework/wpf/advanced/routed-events-overview.md) de <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-223">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-224">Objetos de identificador de evento são criados quando os eventos roteados são registrados (consulte <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) e, em seguida, pode ser usado para adicionar manipuladores de classe (consulte <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="2f635-224">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="2f635-225">Objetos de identificador contêm um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e um método de utilitário para adicionar proprietários para o evento.</span><span class="sxs-lookup"><span data-stu-id="2f635-225">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-226">Identifica a propriedade de dependência <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-226">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-227">Obtém ou define o cursor exibido quando o ponteiro do mouse está sobre este elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-227">Gets or sets the cursor that displays when the mouse pointer is over this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2f635-228">O cursor a ser exibido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-228">The cursor to display.</span>
          </span>
          <span data-ttu-id="2f635-229">O valor padrão é definido como <see langword="null" /> por essa propriedade de dependência.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-229">The default value is defined as <see langword="null" /> per this dependency property.</span>
          </span>
          <span data-ttu-id="2f635-230">No entanto, o padrão prático em tempo de execução virá de uma variedade de fatores.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-230">However, the practical default at run time will come from a variety of factors.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-231">Ao definir essa propriedade em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], o [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] processador depende de conversão de tipo para o <xref:System.Windows.Input.Cursor> classe para avaliar a cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="2f635-231">When setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] processor relies on type conversion for the <xref:System.Windows.Input.Cursor> class to evaluate the string.</span></span> <span data-ttu-id="2f635-232">A cadeia de caracteres fornecida deve ser avaliada como um <xref:System.Windows.Input.CursorType> valor.</span><span class="sxs-lookup"><span data-stu-id="2f635-232">The provided string should evaluate to a <xref:System.Windows.Input.CursorType> value.</span></span> <span data-ttu-id="2f635-233">Consulte <xref:System.Windows.Input.Cursor> para obter os detalhes.</span><span class="sxs-lookup"><span data-stu-id="2f635-233">See <xref:System.Windows.Input.Cursor> for details.</span></span>  
  
 <span data-ttu-id="2f635-234">Se o cursor como definido por essa propriedade será ou não será exibida quando o ponteiro do mouse está sobre este elemento também é dependente do valor da <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="2f635-234">Whether the cursor as established by this property will or will not display when the mouse pointer is over this element is also dependent on the value of the <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> property.</span></span> <span data-ttu-id="2f635-235">Além disso, considerações relacionadas, como um ativo arrastar, captura do mouse, modos dentro de controles e assim por diante, de edição de texto também afeta o cursor com prioridade maior do que o valor especificado nesta propriedade.</span><span class="sxs-lookup"><span data-stu-id="2f635-235">Also, event-related considerations such as an active drag, mouse capture, text editing modes within controls, and so on, will also affect the cursor with higher priority than the value you specify in this property.</span></span>  
  
 <span data-ttu-id="2f635-236">Para reverter o comportamento de definir esta propriedade para o padrão eventual, defina-a como `null` novamente.</span><span class="sxs-lookup"><span data-stu-id="2f635-236">To revert the behavior of setting this property to the eventual default, set it to `null` again.</span></span>  
  
 <span data-ttu-id="2f635-237">O `null` padrão realmente significa que a determinação do valor prático de cursor é adiada aqui e deve ser obtida a partir de outro local.</span><span class="sxs-lookup"><span data-stu-id="2f635-237">The `null` default really means that determination of the practical cursor value is deferred here and should be obtained from elsewhere.</span></span> <span data-ttu-id="2f635-238">Se for exibida sem valores programático de qualquer origem, o cursor padrão por um [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] aplicativo será uma seta.</span><span class="sxs-lookup"><span data-stu-id="2f635-238">If presented with no programmatic values from any source, the default cursor over a [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] application will be an arrow.</span></span>  
  
 <span data-ttu-id="2f635-239">Cada movimento do mouse sobre um [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] aplicativo gera um <xref:System.Windows.ContentElement.QueryCursor> eventos.</span><span class="sxs-lookup"><span data-stu-id="2f635-239">Each movement of the mouse over a [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] application raises a <xref:System.Windows.ContentElement.QueryCursor> event.</span></span> <span data-ttu-id="2f635-240">As bolhas de evento e qualquer elemento na rota tem a oportunidade para manipular o evento e definir o valor do cursor via argumentos desse evento.</span><span class="sxs-lookup"><span data-stu-id="2f635-240">The event bubbles, and any element along the route has the opportunity to handle the event and to set the value of the cursor via the arguments of this event.</span></span> <span data-ttu-id="2f635-241">Se isso acontecer, o fato de que o evento é manipulado e tem um valor alterado nos argumentos tem precedência sobre o valor da <xref:System.Windows.FrameworkContentElement.Cursor%2A> propriedade em qualquer nível, a menos que <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> está definido.</span><span class="sxs-lookup"><span data-stu-id="2f635-241">If that happens, the fact that the event is handled and has a changed value in the arguments takes precedence over the value of the <xref:System.Windows.FrameworkContentElement.Cursor%2A> property at any level, unless <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> is set.</span></span>  
  
 <span data-ttu-id="2f635-242">Se não criar um cursor personalizado, normalmente você define essa propriedade para um valor da propriedade estática de <xref:System.Windows.Input.Cursors> classe.</span><span class="sxs-lookup"><span data-stu-id="2f635-242">If not creating a custom cursor, typically you set this property to a static property value of the <xref:System.Windows.Input.Cursors> class.</span></span>  
  
 <span data-ttu-id="2f635-243">Definindo o <xref:System.Windows.Input.Cursor> para um valor personalizado não está habilitado em confiança parcial.</span><span class="sxs-lookup"><span data-stu-id="2f635-243">Setting the <xref:System.Windows.Input.Cursor> to a custom value is not enabled in partial trust.</span></span> <span data-ttu-id="2f635-244">Para obter mais informações sobre cursores personalizados, consulte [visão geral de entrada](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="2f635-244">For more information on custom cursors, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2f635-245">Informações da propriedade de dependência</span><span class="sxs-lookup"><span data-stu-id="2f635-245">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2f635-246">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="2f635-246">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.CursorProperty>|  
|<span data-ttu-id="2f635-247">Propriedades de metadados é definido como `true`</span><span class="sxs-lookup"><span data-stu-id="2f635-247">Metadata properties set to `true`</span></span>|<span data-ttu-id="2f635-248">Nenhum</span><span class="sxs-lookup"><span data-stu-id="2f635-248">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="2f635-249">O exemplo a seguir define o cursor para um valor personalizado.</span><span class="sxs-lookup"><span data-stu-id="2f635-249">The following example sets the cursor to a custom value.</span></span>  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkContentElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-250">Identifica a propriedade de dependência <see cref="P:System.Windows.FrameworkContentElement.Cursor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-250">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-251">Obtém ou define o contexto de dados de um elemento quando ele participa da vinculação de dados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-251">Gets or sets the data context for an element when it participates in data binding.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2f635-252">O objeto a ser usado como contexto de dados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-252">The object to use as data context.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-253">*Contexto de dados* é um conceito que permite aos elementos herdar informações de seus elementos pais sobre a origem de associação que é usada para associação, bem como outras características da associação, como o caminho.</span><span class="sxs-lookup"><span data-stu-id="2f635-253">*Data context* is a concept that allows elements to inherit information from their parent elements about the binding source that is used for binding, as well as other characteristics of the binding such as the path.</span></span>  
  
 <span data-ttu-id="2f635-254">Contexto de dados pode ser definido diretamente para um [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] objeto, com as associações de avaliação de propriedades desse objeto.</span><span class="sxs-lookup"><span data-stu-id="2f635-254">Data context can be set directly to a [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] object, with the bindings evaluating to properties of that object.</span></span> <span data-ttu-id="2f635-255">Como alternativa, você pode definir o contexto de dados para um <xref:System.Windows.Data.DataSourceProvider> objeto.</span><span class="sxs-lookup"><span data-stu-id="2f635-255">Alternatively, you can set the data context to a <xref:System.Windows.Data.DataSourceProvider> object.</span></span>  
  
 <span data-ttu-id="2f635-256">Essa propriedade de dependência herda valores da propriedade.</span><span class="sxs-lookup"><span data-stu-id="2f635-256">This dependency property inherits property values.</span></span> <span data-ttu-id="2f635-257">Se houver elementos filho com nenhum outro valor para <xref:System.Windows.FrameworkContentElement.DataContext%2A> estabelecida por meio de estilos ou valores locais, o sistema de propriedade definirá o valor a ser o <xref:System.Windows.FrameworkContentElement.DataContext%2A> valor do elemento pai mais próximo com esse valor atribuído.</span><span class="sxs-lookup"><span data-stu-id="2f635-257">If there are child elements with no other value for <xref:System.Windows.FrameworkContentElement.DataContext%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkContentElement.DataContext%2A> value of the nearest parent element with this value assigned.</span></span>  
  
 <span data-ttu-id="2f635-258">Como alternativa, você pode usar uma das seguintes propriedades de <xref:System.Windows.Data.Binding> classe para especificar a origem de associação explicitamente: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, ou <xref:System.Windows.Data.Binding.RelativeSource%2A>.</span><span class="sxs-lookup"><span data-stu-id="2f635-258">Alternatively, you can use one of the following properties of the <xref:System.Windows.Data.Binding> class to specify the binding source explicitly: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, or <xref:System.Windows.Data.Binding.RelativeSource%2A>.</span></span> <span data-ttu-id="2f635-259">Para obter mais informações, consulte [como: especificar a origem da associação](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).</span><span class="sxs-lookup"><span data-stu-id="2f635-259">For more information, see [How to: Specify the Binding Source](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).</span></span>  
  
 <span data-ttu-id="2f635-260">Em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.FrameworkContentElement.DataContext%2A> geralmente é definido como como um <xref:System.Windows.Data.Binding> declaração.</span><span class="sxs-lookup"><span data-stu-id="2f635-260">In [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.FrameworkContentElement.DataContext%2A> is most commonly set to as a <xref:System.Windows.Data.Binding> declaration.</span></span> <span data-ttu-id="2f635-261">Você pode usar a sintaxe de elemento de propriedade ou sintaxe de atributo.</span><span class="sxs-lookup"><span data-stu-id="2f635-261">You can use either property element syntax or attribute syntax.</span></span> <span data-ttu-id="2f635-262">Sintaxe de atributo é mostrado no exemplo nesta página.</span><span class="sxs-lookup"><span data-stu-id="2f635-262">Attribute syntax is shown in the example on this page.</span></span> <span data-ttu-id="2f635-263">Você também pode definir <xref:System.Windows.FrameworkContentElement.DataContext%2A> no código.</span><span class="sxs-lookup"><span data-stu-id="2f635-263">You can also set <xref:System.Windows.FrameworkContentElement.DataContext%2A> in code.</span></span>  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="2f635-264">Uso do elemento propriedade XAML</span><span class="sxs-lookup"><span data-stu-id="2f635-264">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="2f635-265">Uso do Atributo XAML</span><span class="sxs-lookup"><span data-stu-id="2f635-265">XAML Attribute Usage</span></span>  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a><span data-ttu-id="2f635-266">Valores XAML</span><span class="sxs-lookup"><span data-stu-id="2f635-266">XAML Values</span></span>  
 <span data-ttu-id="2f635-267">*dataContextObject*</span><span class="sxs-lookup"><span data-stu-id="2f635-267">*dataContextObject*</span></span>  
 <span data-ttu-id="2f635-268">Um objeto diretamente incorporado que serve como o contexto de dados para associações dentro do elemento pai.</span><span class="sxs-lookup"><span data-stu-id="2f635-268">A directly embedded object that serves as data context for any bindings within the parent element.</span></span> <span data-ttu-id="2f635-269">Normalmente, esse objeto é um <xref:System.Windows.Data.Binding> ou outro <xref:System.Windows.Data.BindingBase> subclasse.</span><span class="sxs-lookup"><span data-stu-id="2f635-269">Typically, this object is a <xref:System.Windows.Data.Binding> or another <xref:System.Windows.Data.BindingBase> subclass.</span></span> <span data-ttu-id="2f635-270">Como alternativa, os dados brutos de qualquer [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] destinado para associação pode ser colocada aqui, com as associações reais definidas posteriormente do tipo de objeto.</span><span class="sxs-lookup"><span data-stu-id="2f635-270">Alternatively, raw data of any [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] object type intended for binding may be placed here, with the actual bindings defined later.</span></span>  
  
 <span data-ttu-id="2f635-271">*bindingUsage*</span><span class="sxs-lookup"><span data-stu-id="2f635-271">*bindingUsage*</span></span>  
 <span data-ttu-id="2f635-272">Um uso de associação que é avaliada para um contexto de dados apropriado.</span><span class="sxs-lookup"><span data-stu-id="2f635-272">A binding usage that evaluates to an appropriate data context.</span></span> <span data-ttu-id="2f635-273">Para ver os detalhes, consulte [Extensão de marcação Binding](~/docs/framework/wpf/advanced/binding-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="2f635-273">For details, see [Binding Markup Extension](~/docs/framework/wpf/advanced/binding-markup-extension.md).</span></span>  
  
 <span data-ttu-id="2f635-274">*resourceExtension*</span><span class="sxs-lookup"><span data-stu-id="2f635-274">*resourceExtension*</span></span>  
 <span data-ttu-id="2f635-275">Um dos seguintes: `StaticResource`, ou `DynamicResource`.</span><span class="sxs-lookup"><span data-stu-id="2f635-275">One of the following: `StaticResource`, or `DynamicResource`.</span></span> <span data-ttu-id="2f635-276">Esse uso é usado ao fazer referência a dados brutos definidos como um objeto de recursos.</span><span class="sxs-lookup"><span data-stu-id="2f635-276">This usage is used when referring to raw data defined as an object in resources.</span></span> <span data-ttu-id="2f635-277">Consulte [recursos XAML](~/docs/framework/wpf/advanced/xaml-resources.md).</span><span class="sxs-lookup"><span data-stu-id="2f635-277">See [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
 <span data-ttu-id="2f635-278">*contextResourceKey*</span><span class="sxs-lookup"><span data-stu-id="2f635-278">*contextResourceKey*</span></span>  
 <span data-ttu-id="2f635-279">O identificador de chave para o objeto que está sendo solicitado de dentro um <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="2f635-279">The key identifier for the object being requested from within a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2f635-280">Informações da propriedade de dependência</span><span class="sxs-lookup"><span data-stu-id="2f635-280">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2f635-281">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="2f635-281">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.DataContextProperty>|  
|<span data-ttu-id="2f635-282">Propriedades de metadados é definido como `true`</span><span class="sxs-lookup"><span data-stu-id="2f635-282">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 <span data-ttu-id="2f635-283">O exemplo a seguir define uma associação em um <xref:System.Windows.Documents.Paragraph> elemento, criando um novo objeto de dados personalizados, estabelecer esse objeto como <xref:System.Windows.FrameworkContentElement.DataContext%2A>e definir o caminho de associação a uma propriedade dentro dele.</span><span class="sxs-lookup"><span data-stu-id="2f635-283">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as <xref:System.Windows.FrameworkContentElement.DataContext%2A>, and setting the binding path to a property within it.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-284">Ocorre quando o contexto de dados desse elemento é alterado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-284">Occurs when this element's data context changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-285">Para obter uma explicação de contextos de dados e a associação de dados, consulte [visão geral de associação de dados](~/docs/framework/wpf/data/data-binding-overview.md).</span><span class="sxs-lookup"><span data-stu-id="2f635-285">For an explanation of data contexts and data binding, see [Data Binding Overview](~/docs/framework/wpf/data/data-binding-overview.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="2f635-286">Quando um elemento <xref:System.Windows.FrameworkContentElement.DataContext%2A> alterações, todas as propriedades de associação de dados neste elemento potencialmente são afetadas.</span><span class="sxs-lookup"><span data-stu-id="2f635-286">When an element's <xref:System.Windows.FrameworkContentElement.DataContext%2A> changes, all data-bound properties on this element are potentially affected.</span></span> <span data-ttu-id="2f635-287">Isso se aplica a qualquer elemento que elementos descendentes do elemento atual, que herdam o contexto de dados, e também o elemento atual.</span><span class="sxs-lookup"><span data-stu-id="2f635-287">This applies to any elements that are descendant elements of the current element, which inherit the data context, and also the current element itself.</span></span> <span data-ttu-id="2f635-288">Todas as associações novamente interpretam o novo <xref:System.Windows.FrameworkContentElement.DataContext%2A> para refletir o novo valor em associações.</span><span class="sxs-lookup"><span data-stu-id="2f635-288">All such bindings re-interpret the new <xref:System.Windows.FrameworkContentElement.DataContext%2A> to reflect the new value in bindings.</span></span> <span data-ttu-id="2f635-289">Não há nenhuma garantia feita sobre a ordem dessas alterações em relação ao aumento do <xref:System.Windows.FrameworkContentElement.DataContextChanged> evento.</span><span class="sxs-lookup"><span data-stu-id="2f635-289">There is no guarantee made about the order of these changes relative to the raising of the <xref:System.Windows.FrameworkContentElement.DataContextChanged> event.</span></span>  <span data-ttu-id="2f635-290">As alterações podem ocorrer antes do evento após o evento, ou em qualquer combinação.</span><span class="sxs-lookup"><span data-stu-id="2f635-290">The changes can occur before the event, after the event, or in any mixture.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-291">Identifica a propriedade de dependência <see cref="P:System.Windows.FrameworkContentElement.DataContext" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-291">Identifies the <see cref="P:System.Windows.FrameworkContentElement.DataContext" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-292">Obtém ou define a chave a ser usada para localizar o modelo de estilo para este controle nos temas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-292">Gets or sets the key to use to find the style template for this control in themes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2f635-293">A chave de estilo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-293">The style key.</span>
          </span>
          <span data-ttu-id="2f635-294">Para funcionar corretamente como parte da pesquisa de estilo de tema, esse valor deve ser o <see cref="T:System.Type" /> do elemento sendo o estilo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-294">To work correctly as part of theme style lookup, this value is expected to be the <see cref="T:System.Type" /> of the element being styled.</span>
          </span>
          <span data-ttu-id="2f635-295">
            <see langword="null" /> é um valor aceito para um determinado caso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-295">
              <see langword="null" /> is an accepted value for a certain case.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-296">Normalmente, essa propriedade não é definida por meio de qualquer um de seus setters diretos.</span><span class="sxs-lookup"><span data-stu-id="2f635-296">This property is typically not set through any of its direct setters.</span></span> <span data-ttu-id="2f635-297">Em vez disso, você substituir os metadados específicos do tipo dessa propriedade de dependência toda vez que você criar uma nova subclasse.</span><span class="sxs-lookup"><span data-stu-id="2f635-297">Instead, you override the type-specific metadata of this dependency property every time you create a new subclass.</span></span> <span data-ttu-id="2f635-298">Quando você subclasse, chame o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> método em relação a <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> identificador do construtor estático de subclasse de controle.</span><span class="sxs-lookup"><span data-stu-id="2f635-298">When you subclass, call the <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method against the <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> identifier, within the static constructor of the control subclass.</span></span>  
  
 <span data-ttu-id="2f635-299">Por exemplo, uma classe embutido como <xref:System.Windows.Documents.Bold> realmente tem uma implementação muito pouco além substituindo o <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> metadados em seu construtor estático e expor vários construtores de instância.</span><span class="sxs-lookup"><span data-stu-id="2f635-299">For instance, an inline class such as <xref:System.Windows.Documents.Bold> actually has very little implementation beyond overriding the <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> metadata in its static constructor, and exposing several instance constructors.</span></span> <span data-ttu-id="2f635-300">O fato de que elementos entre o <xref:System.Windows.Documents.Bold> marca ganho uma <xref:System.Windows.Documents.TextElement.FontWeight%2A> propriedade de <xref:System.Windows.FontWeights.Bold%2A> é implementado no estilo de tema que foi referenciado, definindo o valor padrão de <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> para `typeof(Bold)`.</span><span class="sxs-lookup"><span data-stu-id="2f635-300">The fact that elements surrounded by the <xref:System.Windows.Documents.Bold> tag gain a <xref:System.Windows.Documents.TextElement.FontWeight%2A> property of <xref:System.Windows.FontWeights.Bold%2A> is implemented within the theme style that was referenced by setting the default value of <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> to `typeof(Bold)`.</span></span>  
  
 <span data-ttu-id="2f635-301">Se você quiser que o elemento ou o controle não usar estilos de temas, defina o <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> propriedade `true`.</span><span class="sxs-lookup"><span data-stu-id="2f635-301">If you want your element or control to deliberately not use theme styles, set the <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> property to `true`.</span></span>  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2f635-302">Informações da propriedade de dependência</span><span class="sxs-lookup"><span data-stu-id="2f635-302">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2f635-303">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="2f635-303">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|  
|<span data-ttu-id="2f635-304">Propriedades de metadados é definido como `true`</span><span class="sxs-lookup"><span data-stu-id="2f635-304">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-305">Identifica a propriedade de dependência <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-305">Identifies the <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2f635-306">Chamado imediatamente após um elemento ser inicializado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-306">Called immediately after an element is initialized.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-307">Implemente esse método para fornecer um tratamento especial que deve ocorrer quando o elemento é inicializado durante o processo de carregamento de elemento.</span><span class="sxs-lookup"><span data-stu-id="2f635-307">Implement this method to provide special handling that should occur when your element is initialized during the element loading process.</span></span>  
  
 <span data-ttu-id="2f635-308">Sua implementação deve chamar a implementação base, porque a implementação de base (padrão) define alguns sinalizadores internos para manter o controle de inicialização.</span><span class="sxs-lookup"><span data-stu-id="2f635-308">Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</span></span>  
  
 <span data-ttu-id="2f635-309">Se <xref:System.Windows.FrameworkContentElement.BeginInit%2A> foi chamado anteriormente, a base de implementação irá gerar o <xref:System.Windows.FrameworkContentElement.Initialized> evento.</span><span class="sxs-lookup"><span data-stu-id="2f635-309">If <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was previously called, the base implementation will raise the <xref:System.Windows.FrameworkContentElement.Initialized> event.</span></span> <span data-ttu-id="2f635-310">Caso contrário, se <xref:System.Windows.FrameworkContentElement.BeginInit%2A> não foi chamado ou não pôde ser determinado se <xref:System.Windows.FrameworkContentElement.BeginInit%2A> foi chamado, o evento não será gerado.</span><span class="sxs-lookup"><span data-stu-id="2f635-310">Otherwise, if <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was not called or it could not be determined whether <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was called, the event is not raised.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2f635-311">O nome do elemento pelo qual pesquisar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-311">Name of the element to search for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2f635-312">Localiza um elemento que tem o nome do identificador fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-312">Finds an element that has the provided identifier name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2f635-313">O elemento solicitado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-313">The requested element.</span>
          </span>
          <span data-ttu-id="2f635-314">Pode ser <see langword="null" /> se nenhum elemento correspondente foi encontrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-314">May be <see langword="null" /> if no matching element was found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-315">Se este elemento tem elementos filho, esses elementos filho são todos recursivamente pesquisada para o elemento nomeado solicitado.</span><span class="sxs-lookup"><span data-stu-id="2f635-315">If this element has child elements, these child elements are all searched recursively for the requested named element.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f635-316">O exemplo a seguir define uma propriedade em um elemento encontrado por nome em uma referência <xref:System.Windows.Documents.FlowDocument> em uma página.</span><span class="sxs-lookup"><span data-stu-id="2f635-316">The following example sets a property on an element found by name within a referenced <xref:System.Windows.Documents.FlowDocument> on a page.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#FindName](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findname)]
 [!code-vb[ContentElementsSmorgasbord#FindName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findname)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">
          <span data-ttu-id="2f635-317">O identificador de chave do recurso a ser encontrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-317">Key identifier of the resource to be found.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2f635-318">Pesquisa um recurso com a chave especificada e gera uma exceção se o recurso solicitado não é encontrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-318">Searches for a resource with the specified key, and will throw an exception if the requested resource is not found.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2f635-319">O recurso encontrado ou <see langword="null" />, se nenhum recurso correspondente foi encontrado (mas também gera uma exceção se <see langword="null" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-319">The found resource, or <see langword="null" /> if no matching resource was found (but will also throw an exception if <see langword="null" />).</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="2f635-320">Se você chamar esse método para uma chave que não pode ser encontrada, uma exceção será lançada.</span><span class="sxs-lookup"><span data-stu-id="2f635-320">If you call this method for a key that cannot be found, an exception is thrown.</span></span> <span data-ttu-id="2f635-321">Se você não deseja tratar exceções para este caso, em vez disso, você deve chamar <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>.</span><span class="sxs-lookup"><span data-stu-id="2f635-321">If you do not want to handle exceptions for this case, you should instead call <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>.</span></span> <span data-ttu-id="2f635-322"><xref:System.Windows.FrameworkContentElement.TryFindResource%2A> Retorna `null` quando nenhum recurso foi encontrado e não gerará uma exceção.</span><span class="sxs-lookup"><span data-stu-id="2f635-322"><xref:System.Windows.FrameworkContentElement.TryFindResource%2A> returns `null` when no resource is found, and does not throw an exception.</span></span>  
  
 <span data-ttu-id="2f635-323">Se o recurso não foi encontrado no elemento de chamada, a árvore pai é pesquisada usando a árvore lógica, da mesma forma que a árvore será pesquisada se um recurso foi solicitado por chave no tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="2f635-323">If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a resource were requested by key at run-time.</span></span>  
  
 <span data-ttu-id="2f635-324">Normalmente você imediatamente atribui o valor de retorno para o tipo da propriedade que você está tentando definido com o valor retornado do recurso.</span><span class="sxs-lookup"><span data-stu-id="2f635-324">Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f635-325">O exemplo a seguir encontra um recurso, conforme definido na marcação e o aplica a determinadas propriedades de um elemento em resposta a um evento roteado.</span><span class="sxs-lookup"><span data-stu-id="2f635-325">The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#FindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findresource)]
 [!code-vb[ContentElementsSmorgasbord#FindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findresource)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">
          <span data-ttu-id="2f635-326">A chave do recurso solicitado não foi localizada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-326">The requested resource key was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2f635-327">
            <paramref name="resourceKey" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-327">
              <paramref name="resourceKey" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-328">Obtém ou define um objeto que permite a personalização da aparência, efeitos ou outras características de estilo que se aplicam a esse elemento quando ele captura o foco do teclado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-328">Gets or sets an object that enables customization of appearance, effects, or other style characteristics that will apply to this element when it captures keyboard focus.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2f635-329">O estilo desejado a ser aplicado no foco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-329">The desired style to apply on focus.</span>
          </span>
          <span data-ttu-id="2f635-330">O valor padrão como declarado na propriedade de dependência é um <see cref="T:System.Windows.Style" /> estático vazio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-330">The default value as declared in the dependency property is an empty static <see cref="T:System.Windows.Style" />.</span>
          </span>
          <span data-ttu-id="2f635-331">No entanto, o valor efetivo em tempo de execução é normalmente (mas nem sempre) um estilo fornecido pelo suporte de tema para controles.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-331">However, the effective value at run time is often (but not always) a style as supplied by theme support for controls.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-332">Ao definir essa propriedade em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]estilos são quase sempre são definidos como um recurso, em vez de embutidos como um elemento e que o recurso é geralmente referenciado como um <xref:System.Windows.StaticResourceExtension>.</span><span class="sxs-lookup"><span data-stu-id="2f635-332">When setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], styles are almost always defined as a resource, rather than inline as an element, and that resource is usually referenced as a <xref:System.Windows.StaticResourceExtension>.</span></span>  
  
 <span data-ttu-id="2f635-333">Observe que essa propriedade afeta a aparência visual, mas não relata isso nos metadados.</span><span class="sxs-lookup"><span data-stu-id="2f635-333">Note that this property affects visual appearance but does not report so in metadata.</span></span> <span data-ttu-id="2f635-334">Isso ocorre porque a alteração da aparência visual é controlada por evento não pode ser aplicadas em todos os momentos e, portanto, não geralmente Relate quaisquer informações de layout ou de visual nos metadados.</span><span class="sxs-lookup"><span data-stu-id="2f635-334">This is because the visual appearance change is event-driven and may not apply at all times, and thus should not generally report any visual or layout information in metadata.</span></span>  
  
 <span data-ttu-id="2f635-335">Conceitualmente, o comportamento visual de foco aplicado a um controle deve ser coerente para cada elemento.</span><span class="sxs-lookup"><span data-stu-id="2f635-335">Conceptually, the visual behavior of focus applied to a control should be coherent from element to element.</span></span> <span data-ttu-id="2f635-336">É a maneira mais adequada para impor a coerência alterar o estilo visual de foco apenas se você estiver compondo um tema inteiro.</span><span class="sxs-lookup"><span data-stu-id="2f635-336">The most sensible way to enforce coherence is to only change the focus visual style if you are composing an entire theme.</span></span> <span data-ttu-id="2f635-337">A definição dessa propriedade em estilos individuais e não como parte de um tema não é o uso pretendido dessa propriedade, porque isso pode resultar em uma experiência de usuário confuso sobre o foco do teclado.</span><span class="sxs-lookup"><span data-stu-id="2f635-337">Setting this property on individual styles and not as part of a theme is not the intended usage of this property, because it may lead to a confusing user experience regarding keyboard focus.</span></span> <span data-ttu-id="2f635-338">Se você estiver pretendendo comportamento específico do elemento que é deliberadamente não coerente em um tema, uma abordagem muito melhor é usar disparadores em estilos para propriedades de estado de entrada individual, como <xref:System.Windows.UIElement.IsFocused%2A> ou <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>e fazer isso de forma que não interfere em nenhum estilo visual de foco existente visualmente.</span><span class="sxs-lookup"><span data-stu-id="2f635-338">If you are intending element-specific behavior that is deliberately not coherent across a theme, a much better approach is to use triggers in styles for individual input state properties, such as <xref:System.Windows.UIElement.IsFocused%2A> or <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>, and to do so in a way that does not visually interfere with any existing focus visual style.</span></span> <span data-ttu-id="2f635-339">Para obter mais informações sobre a intenção de design do <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> e alternativa se concentrar propriedades, consulte [estilo de foco em controles e FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).</span><span class="sxs-lookup"><span data-stu-id="2f635-339">For more information on the design intention of <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> and alternative focus properties, see [Styling for Focus in Controls, and FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).</span></span>  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="2f635-340">Uso do Atributo XAML</span><span class="sxs-lookup"><span data-stu-id="2f635-340">XAML Attribute Usage</span></span>  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="2f635-341">Uso do elemento propriedade XAML</span><span class="sxs-lookup"><span data-stu-id="2f635-341">XAML Property Element Usage</span></span>  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a><span data-ttu-id="2f635-342">Valores XAML</span><span class="sxs-lookup"><span data-stu-id="2f635-342">XAML Values</span></span>  
 <span data-ttu-id="2f635-343">*resourceExtension*</span><span class="sxs-lookup"><span data-stu-id="2f635-343">*resourceExtension*</span></span>  
 <span data-ttu-id="2f635-344">Um dos seguintes:, ou.</span><span class="sxs-lookup"><span data-stu-id="2f635-344">One of the following: , or .</span></span> <span data-ttu-id="2f635-345">Consulte [recursos XAML](~/docs/framework/wpf/advanced/xaml-resources.md).</span><span class="sxs-lookup"><span data-stu-id="2f635-345">See [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
 <span data-ttu-id="2f635-346">*styleResourceKey*</span><span class="sxs-lookup"><span data-stu-id="2f635-346">*styleResourceKey*</span></span>  
 <span data-ttu-id="2f635-347">A chave que identifica o estilo que está sendo solicitado.</span><span class="sxs-lookup"><span data-stu-id="2f635-347">The key that identifies the style being requested.</span></span> <span data-ttu-id="2f635-348">A chave refere-se a um recurso existente em um <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="2f635-348">The key refers to an existing resource in a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2f635-349">Sintaxe de elemento de propriedade é tecnicamente possível, mas não é recomendado.</span><span class="sxs-lookup"><span data-stu-id="2f635-349">Property element syntax is technically possible, but not recommended.</span></span> <span data-ttu-id="2f635-350">Consulte [modelos e estilos in-line](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span><span class="sxs-lookup"><span data-stu-id="2f635-350">See [Inline Styles and Templates](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span></span>  <span data-ttu-id="2f635-351">Uma referência de associação usando ou <xref:System.Windows.Data.Binding> também é possível, mas não é comum.</span><span class="sxs-lookup"><span data-stu-id="2f635-351">A binding reference using  or <xref:System.Windows.Data.Binding> is also possible, but uncommon.</span></span>  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2f635-352">Informações da propriedade de dependência</span><span class="sxs-lookup"><span data-stu-id="2f635-352">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2f635-353">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="2f635-353">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|  
|<span data-ttu-id="2f635-354">Propriedades de metadados é definido como `true`</span><span class="sxs-lookup"><span data-stu-id="2f635-354">Metadata properties set to `true`</span></span>|<span data-ttu-id="2f635-355">Nenhum</span><span class="sxs-lookup"><span data-stu-id="2f635-355">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-356">Identifica a propriedade de dependência <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-356">Identifies the <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-357">Obtém ou define um valor que indica se este <see cref="T:System.Windows.FrameworkContentElement" /> deve forçar o [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] a renderizar o cursor, conforme declarado pela propriedade <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> desta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-357">Gets or sets a value indicating whether this <see cref="T:System.Windows.FrameworkContentElement" /> should force the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] to render the cursor as declared by this instance's <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2f635-358">
            <see langword="true" /> para forçar a apresentação do cursor enquanto está sobre este elemento para usar essa instância de configuração para o cursor (inclusive em todos os elementos filho); Caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-358">
              <see langword="true" /> to force cursor presentation while over this element to use this instance's setting for the cursor (including on all child elements); otherwise <see langword="false" />.</span>
          </span>
          <span data-ttu-id="2f635-359">O valor padrão é <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-359">The default value is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-360">Definir essa propriedade como `true` substituirão as preferências de cursor estabelecidas por elementos filho.</span><span class="sxs-lookup"><span data-stu-id="2f635-360">Setting this property to `true` will override the cursor preferences established by child elements.</span></span> <span data-ttu-id="2f635-361">Fazer assim em geral aplicativo [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] pode ser confuso para o usuário, especialmente se os elementos filho são tentar especificar cursores.</span><span class="sxs-lookup"><span data-stu-id="2f635-361">Doing so in general application [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] might be confusing for the user, particularly if child elements are attempting to specify cursors.</span></span> <span data-ttu-id="2f635-362">Configuração <xref:System.Windows.FrameworkElement.ForceCursor%2A> é mais adequado em cenários de subclassificação ou composição de controle.</span><span class="sxs-lookup"><span data-stu-id="2f635-362">Setting <xref:System.Windows.FrameworkElement.ForceCursor%2A> is more appropriate in control subclassing or compositing scenarios.</span></span>  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2f635-363">Informações da propriedade de dependência</span><span class="sxs-lookup"><span data-stu-id="2f635-363">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2f635-364">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="2f635-364">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|  
|<span data-ttu-id="2f635-365">Propriedades de metadados é definido como `true`</span><span class="sxs-lookup"><span data-stu-id="2f635-365">Metadata properties set to `true`</span></span>|<span data-ttu-id="2f635-366">Nenhum</span><span class="sxs-lookup"><span data-stu-id="2f635-366">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="2f635-367">O exemplo a seguir força o cursor sobre o elemento.</span><span class="sxs-lookup"><span data-stu-id="2f635-367">The following example forces the cursor while over the element.</span></span>  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-368">Identifica a propriedade de dependência <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-368">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="2f635-369">O <see cref="T:System.Windows.DependencyProperty" /> de destino do qual obter a associação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-369">The target <see cref="T:System.Windows.DependencyProperty" /> from which to get the binding.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2f635-370">Obtém o <see cref="T:System.Windows.Data.BindingExpression" /> da associação da propriedade especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-370">Gets the <see cref="T:System.Windows.Data.BindingExpression" /> for the specified property's binding.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2f635-371">Retorna um <see cref="T:System.Windows.Data.BindingExpression" /> se o destino é associado a dados; caso contrário, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-371">Returns a <see cref="T:System.Windows.Data.BindingExpression" /> if the target is data bound; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="2f635-372">O exemplo a seguir recupera uma associação consultando uma propriedade.</span><span class="sxs-lookup"><span data-stu-id="2f635-372">The following example retrieves a binding by querying a property.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#getbindingexpression)]
 [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#getbindingexpression)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2f635-373">Retorna um pai lógico alternativo para esse elemento se não houver nenhum pai visual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-373">Returns an alternative logical parent for this element if there is no visual parent.</span>
          </span>
          <span data-ttu-id="2f635-374">Nesse caso, um <see cref="T:System.Windows.FrameworkContentElement" /> pai é sempre o mesmo valor que a propriedade <see cref="P:System.Windows.FrameworkContentElement.Parent" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-374">In this case, a <see cref="T:System.Windows.FrameworkContentElement" /> parent is always the same value as the <see cref="P:System.Windows.FrameworkContentElement.Parent" /> property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2f635-375">Retorna algo diferente de <see langword="null" /> sempre que uma implementação de nível de estrutura WPF desse método tem uma conexão pai não visual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-375">Returns something other than <see langword="null" /> whenever a WPF framework-level implementation of this method has a non-visual parent connection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-376">A implementação padrão retorna o pai de visual único esperado.</span><span class="sxs-lookup"><span data-stu-id="2f635-376">The default implementation returns the expected single visual parent.</span></span> <span data-ttu-id="2f635-377">Implementações personalizadas podem retornar relações pai alternativo.</span><span class="sxs-lookup"><span data-stu-id="2f635-377">Custom implementations might return alternate parent relationships.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-378">Ocorre quando este <see cref="T:System.Windows.FrameworkContentElement" /> é inicializado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-378">Occurs when this <see cref="T:System.Windows.FrameworkContentElement" /> is initialized.</span>
          </span>
          <span data-ttu-id="2f635-379">Isso coincide com casos em que o valor da propriedade <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> é alterado de <see langword="false" /> (ou indefinido) para <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-379">This coincides with cases where the value of the <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> property changes from <see langword="false" /> (or undefined) to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-380">Esse evento será gerado sempre que o <xref:System.Windows.FrameworkContentElement.EndInit%2A> ou <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> métodos são chamados.</span><span class="sxs-lookup"><span data-stu-id="2f635-380">This event will be raised whenever the <xref:System.Windows.FrameworkContentElement.EndInit%2A> or <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> methods are called.</span></span> <span data-ttu-id="2f635-381">Chamadas para esses métodos podem ter sido efetuadas com código deliberado ou o [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] processo de carregamento.</span><span class="sxs-lookup"><span data-stu-id="2f635-381">Calls to these methods could have been made by deliberate code, or by the [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] loading process.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-382">Obtém ou define o contexto de entrada usado por este <see cref="T:System.Windows.FrameworkContentElement" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-382">Gets or sets the context for input used by this <see cref="T:System.Windows.FrameworkContentElement" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2f635-383">O escopo de entrada, que modifica como a entrada de métodos alternativos de entrada é interpretada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-383">The input scope, which modifies how input from alternative input methods is interpreted.</span>
          </span>
          <span data-ttu-id="2f635-384">O valor padrão é <see langword="null" /> (que resulta em um tratamento padrão de comandos).</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-384">The default value is <see langword="null" /> (which results in a default handling of commands).</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-385">Essa propriedade de dependência herda valores da propriedade.</span><span class="sxs-lookup"><span data-stu-id="2f635-385">This dependency property inherits property values.</span></span> <span data-ttu-id="2f635-386">Se houver elementos filho com nenhum outro valor para <xref:System.Windows.FrameworkElement.InputScope%2A> estabelecida por meio de estilos ou valores locais, o sistema de propriedade definirá o valor a ser o <xref:System.Windows.FrameworkElement.InputScope%2A> valor do elemento pai mais próximo com esse valor atribuído.</span><span class="sxs-lookup"><span data-stu-id="2f635-386">If there are child elements with no other value for <xref:System.Windows.FrameworkElement.InputScope%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkElement.InputScope%2A> value of the nearest parent element with this value assigned.</span></span>  
  
 <span data-ttu-id="2f635-387">Embora um [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] uso de sintaxe é listado e sintaticamente é permitido, a definição dessa propriedade [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] não é comum.</span><span class="sxs-lookup"><span data-stu-id="2f635-387">Although a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax usage is listed and is syntactically allowed, setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] is not common.</span></span>  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2f635-388">Informações da propriedade de dependência</span><span class="sxs-lookup"><span data-stu-id="2f635-388">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2f635-389">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="2f635-389">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.InputScopeProperty>|  
|<span data-ttu-id="2f635-390">Propriedades de metadados é definido como `true`</span><span class="sxs-lookup"><span data-stu-id="2f635-390">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-391">Identifica a propriedade de dependência <see cref="P:System.Windows.FrameworkContentElement.InputScope" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-391">Identifies the <see cref="P:System.Windows.FrameworkContentElement.InputScope" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-392">Obtém um valor que indica se este elemento foi inicializado, seja ao ser carregado como [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] ou tendo seu método <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> chamado explicitamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-392">Gets a value indicating whether this element has been initialized, either by being loaded as [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], or by explicitly having its <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> method called.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2f635-393">
            <see langword="true" /> Se o elemento é inicializado pelas chamadas de método ou carregamento mencionados acima; Caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-393">
              <see langword="true" /> if the element is initialized per the aforementioned loading or method calls; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-394">Essa propriedade também pode ser `true` se esse elemento foi movido dentro da árvore de elementos, de modo que ele tem um novo elemento pai e, portanto, torna-se recarregar novamente.</span><span class="sxs-lookup"><span data-stu-id="2f635-394">This property may also be `true` if this element has been moved within the element tree such that it has a new parent element, and therefore becomes reloaded again.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-395">Obtém um valor que indica se esse elemento foi carregado para apresentação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-395">Gets a value indicating whether this element has been loaded for presentation.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2f635-396">
            <see langword="true" /> Se o elemento atual está anexado a uma árvore de elementos e processado. <see langword="false" /> se o elemento nunca foi anexado a uma árvore de elementos carregados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-396">
              <see langword="true" /> if the current element is attached to an element tree and has been rendered; <see langword="false" /> if the element has never been attached to a loaded element tree.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-397">Em uma instância recentemente construída, essa propriedade começa `false`e permanece `true` depois que ele é definido como `true`, mesmo se forem removidos subsequentemente por código.</span><span class="sxs-lookup"><span data-stu-id="2f635-397">From a newly constructed instance, this property starts off `false`, and remains `true` once it is set to `true`, even if subsequently removed by  code.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f635-398">O código de exemplo a seguir usa <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> como uma verificação condicional para assegurar que uma função `displayData` (não mostrado) serão ter elementos válidos carregado na página para que funcionem com, como parte de um manipulador de sob demanda.</span><span class="sxs-lookup"><span data-stu-id="2f635-398">The following example code uses <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> as a conditional check to assure that a function `displayData` (not shown) will have valid elements loaded on the page to work against, as part of an on-demand handler.</span></span> <span data-ttu-id="2f635-399">Que a mesma lógica é executada como um manipulador de eventos <xref:System.Windows.FrameworkContentElement.Loaded>.</span><span class="sxs-lookup"><span data-stu-id="2f635-399">That same logic is run as an event handler for <xref:System.Windows.FrameworkContentElement.Loaded>.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#isloaded)]
 [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#isloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkContentElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-400">Obtém ou define informações de localização/globalização do idioma que se aplicam a um elemento individual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-400">Gets or sets localization/globalization language information that applies to an individual element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2f635-401">As informações de cultura para este elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-401">The culture information for this element.</span>
          </span>
          <span data-ttu-id="2f635-402">O valor padrão é um <see cref="T:System.Windows.Markup.XmlLanguage" /> instância com seu <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> valor definido para a cadeia de caracteres "en-US".</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-402">The default value is an <see cref="T:System.Windows.Markup.XmlLanguage" /> instance with its <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> value set to the string "en-US".</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-403">Os formatos de cadeia de caracteres seguem o padrão de RFC 3066.</span><span class="sxs-lookup"><span data-stu-id="2f635-403">The string formats follow the RFC 3066 standard.</span></span> <span data-ttu-id="2f635-404">Por exemplo, EUA Inglês é "en-US".</span><span class="sxs-lookup"><span data-stu-id="2f635-404">For example, U.S. English is "en-US".</span></span> <span data-ttu-id="2f635-405">Consulte <xref:System.Windows.Markup.XmlLanguage> para obter mais informações sobre os valores e o formato.</span><span class="sxs-lookup"><span data-stu-id="2f635-405">See <xref:System.Windows.Markup.XmlLanguage> for more information on the values and format.</span></span>  
  
 <span data-ttu-id="2f635-406">Essa propriedade de dependência herda valores da propriedade.</span><span class="sxs-lookup"><span data-stu-id="2f635-406">This dependency property inherits property values.</span></span> <span data-ttu-id="2f635-407">Se houver elementos filho com nenhum outro valor para <xref:System.Windows.FrameworkElement.Language%2A> estabelecida por meio de estilos ou valores locais, o sistema de propriedade definirá o valor a ser o <xref:System.Windows.FrameworkElement.Language%2A> valor do elemento pai mais próximo com esse valor atribuído.</span><span class="sxs-lookup"><span data-stu-id="2f635-407">If there are child elements with no other value for <xref:System.Windows.FrameworkElement.Language%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkElement.Language%2A> value of the nearest parent element with this value assigned.</span></span>  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2f635-408">Informações da propriedade de dependência</span><span class="sxs-lookup"><span data-stu-id="2f635-408">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2f635-409">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="2f635-409">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.LanguageProperty>|  
|<span data-ttu-id="2f635-410">Propriedades de metadados é definido como `true`</span><span class="sxs-lookup"><span data-stu-id="2f635-410">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-411">Identifica a propriedade de dependência <see cref="P:System.Windows.FrameworkContentElement.Language" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-411">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Language" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-412">Ocorre quando o elemento é apresentado, renderizado e está pronto para interação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-412">Occurs when the element is laid out, rendered, and ready for interaction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-413">Os eventos roteados diretos não seguem uma rota, somente são tratados dentro do mesmo elemento no qual eles são gerados.</span><span class="sxs-lookup"><span data-stu-id="2f635-413">Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</span></span> <span data-ttu-id="2f635-414">Eventos roteados diretos suportam outro comportamento eventos roteados: eles dão suporte a uma coleção de manipuladores acessível e pode ser usados como um <xref:System.Windows.EventTrigger> em um estilo.</span><span class="sxs-lookup"><span data-stu-id="2f635-414">Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <xref:System.Windows.EventTrigger> in a style.</span></span>  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="2f635-415">Informações de evento encaminhado</span><span class="sxs-lookup"><span data-stu-id="2f635-415">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2f635-416">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="2f635-416">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.LoadedEvent>|  
|<span data-ttu-id="2f635-417">Estratégia de roteamento</span><span class="sxs-lookup"><span data-stu-id="2f635-417">Routing strategy</span></span>|<span data-ttu-id="2f635-418">Direto</span><span class="sxs-lookup"><span data-stu-id="2f635-418">Direct</span></span>|  
|<span data-ttu-id="2f635-419">delegado</span><span class="sxs-lookup"><span data-stu-id="2f635-419">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-420">Identifica a [Visão geral de eventos roteados](~/docs/framework/wpf/advanced/routed-events-overview.md) de <see cref="E:System.Windows.FrameworkContentElement.Loaded" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-420">Identifies the <see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-421">Objetos de identificador de evento são criados quando os eventos roteados são registrados (consulte <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) e, em seguida, pode ser usado para adicionar manipuladores de classe (consulte <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="2f635-421">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="2f635-422">Objetos de identificador contêm um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e um método de utilitário para adicionar proprietários para o evento.</span><span class="sxs-lookup"><span data-stu-id="2f635-422">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-423">Obtém um enumerador para os elementos filho lógicos desse elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-423">Gets an enumerator for the logical child elements of this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2f635-424">Um enumerador para elementos filho lógicos desse elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-424">An enumerator for logical child elements of this element.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-425">Para obter mais informações sobre como usar <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> e <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, consulte [árvores no WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span><span class="sxs-lookup"><span data-stu-id="2f635-425">For more information on how to use <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> and <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, see [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">
          <span data-ttu-id="2f635-426">A direção para a qual o foco deve ser movido, como um valor da enumeração.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-426">The direction that focus is to be moved, as a value of the enumeration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2f635-427">Move o foco do teclado deste elemento para outro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-427">Moves the keyboard focus from this element to another element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2f635-428">Retorna <see langword="true" /> se o foco é movido com êxito; <see langword="false" /> se o elemento de destino na direção especificada não existe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-428">Returns <see langword="true" /> if focus is moved successfully; <see langword="false" /> if the target element in direction as specified does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-429">Obtém ou define o nome de identificação do elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-429">Gets or sets the identifying name of the element.</span>
          </span>
          <span data-ttu-id="2f635-430">O nome fornece uma referência de instância para que o code-behind programático, como o código do manipulador de eventos, possa consultar um elemento depois que ele é construído durante a análise de [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-430">The name provides an instance reference so that programmatic code-behind, such as event handler code, can refer to an element once it is constructed during parsing of [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2f635-431">O nome do elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-431">The name of the element.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-432">O uso mais comum dessa propriedade é ao especificar um [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] nome do elemento na marcação.</span><span class="sxs-lookup"><span data-stu-id="2f635-432">The most common usage of this property is when specifying a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] element name in markup.</span></span>  
  
 <span data-ttu-id="2f635-433">Esta propriedade fornece essencialmente uma propriedade de conveniência de nível de framework do WPF para definir o [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [diretiva X:Name](~/docs/framework/xaml-services/x-name-directive.md).</span><span class="sxs-lookup"><span data-stu-id="2f635-433">This property essentially provides a WPF framework-level convenience property to set the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [x:Name Directive](~/docs/framework/xaml-services/x-name-directive.md).</span></span>  
  
 <span data-ttu-id="2f635-434">Obtendo um <xref:System.Windows.FrameworkContentElement.Name%2A> de código não é comum, pois se você já a referência apropriada no código, você pode simplesmente chamar métodos e propriedades no elemento de referem e geralmente não têm necessidade de <xref:System.Windows.FrameworkContentElement.Name%2A>.</span><span class="sxs-lookup"><span data-stu-id="2f635-434">Getting a <xref:System.Windows.FrameworkContentElement.Name%2A> from code is not common, because if you have the appropriate reference in code already, you can just call methods and properties on the element reference and do not generally need the <xref:System.Windows.FrameworkContentElement.Name%2A>.</span></span> <span data-ttu-id="2f635-435">Uma exceção é se a cadeia de caracteres tem algumas sobrecarregados que significa que, por exemplo se é útil exibir esse nome no [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="2f635-435">An exception is if the string has some overloaded meaning, for instance if it is useful to display that name in [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="2f635-436">Definindo um <xref:System.Windows.FrameworkContentElement.Name%2A> do código se original <xref:System.Windows.FrameworkContentElement.Name%2A> foi da marcação também não é recomendada e alterar a propriedade não alterará a referência de objeto.</span><span class="sxs-lookup"><span data-stu-id="2f635-436">Setting a <xref:System.Windows.FrameworkContentElement.Name%2A> from code if the original <xref:System.Windows.FrameworkContentElement.Name%2A> was set from markup is also not recommended, and changing the property will not change the object reference.</span></span> <span data-ttu-id="2f635-437">Essas referências de objeto são criadas apenas quando os namescopes subjacentes são explicitamente criados durante [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] carregar.</span><span class="sxs-lookup"><span data-stu-id="2f635-437">Such object references are created only when the underlying namescopes are explicitly created during [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] loading.</span></span>  
  
 <span data-ttu-id="2f635-438">Você deverá chamar especificamente <xref:System.Windows.FrameworkContentElement.RegisterName%2A> para fazer uma alteração efetiva no <xref:System.Windows.FrameworkContentElement.Name%2A> propriedade de um elemento já carregada.</span><span class="sxs-lookup"><span data-stu-id="2f635-438">You must specifically call <xref:System.Windows.FrameworkContentElement.RegisterName%2A> to make an effective change on the <xref:System.Windows.FrameworkContentElement.Name%2A> property of an already loaded element.</span></span>  
  
 <span data-ttu-id="2f635-439">Importantes de um caso onde a configuração <xref:System.Windows.FrameworkContentElement.Name%2A> do código é importante para os elementos nomeados que storyboards será executado em.</span><span class="sxs-lookup"><span data-stu-id="2f635-439">One notable case where setting <xref:System.Windows.FrameworkContentElement.Name%2A> from  code is important is for naming elements that storyboards will run against.</span></span> <span data-ttu-id="2f635-440">Antes de registrar um nome, também precisará criar uma instância e atribuir um <xref:System.Windows.NameScope> instância.</span><span class="sxs-lookup"><span data-stu-id="2f635-440">Before you can register a name, might also need to instantiate and assign a <xref:System.Windows.NameScope> instance.</span></span> <span data-ttu-id="2f635-441">Consulte a seção de exemplo ou [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span><span class="sxs-lookup"><span data-stu-id="2f635-441">See the Example section, or [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span></span>  
  
 <span data-ttu-id="2f635-442">Configuração <xref:System.Windows.FrameworkContentElement.Name%2A> do código limitou os aplicativos, mas pesquisar por nome de um elemento é mais comum, especialmente se você estiver usando um modelo de navegação em páginas Recarregar no aplicativo e o código de tempo de execução não é necessariamente o code-behind do respectivo página.</span><span class="sxs-lookup"><span data-stu-id="2f635-442">Setting <xref:System.Windows.FrameworkContentElement.Name%2A> from code has limited applications, but looking up an element by name is more common, particularly if you are employing a navigation model where pages reload into the application and the run-time code is not necessarily the code-behind of that respective page.</span></span> <span data-ttu-id="2f635-443">O método de utilitário <xref:System.Windows.FrameworkContentElement.FindName%2A>, que está disponível em qualquer <xref:System.Windows.FrameworkContentElement>, pode encontrar qualquer elemento por <xref:System.Windows.FrameworkContentElement.Name%2A> em recursivamente de árvore lógica desse elemento.</span><span class="sxs-lookup"><span data-stu-id="2f635-443">The utility method <xref:System.Windows.FrameworkContentElement.FindName%2A>, which is available from any <xref:System.Windows.FrameworkContentElement>, can find any element by <xref:System.Windows.FrameworkContentElement.Name%2A> in that element's logical tree recursively.</span></span> <span data-ttu-id="2f635-444">Ou você pode usar o <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> método estático de <xref:System.Windows.LogicalTreeHelper>, que também usa o <xref:System.Windows.FrameworkContentElement.Name%2A> cadeia de caracteres como um argumento.</span><span class="sxs-lookup"><span data-stu-id="2f635-444">Or you can use the <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> static method of <xref:System.Windows.LogicalTreeHelper>, which also takes the <xref:System.Windows.FrameworkContentElement.Name%2A> string as an argument.</span></span>  
  
 <span data-ttu-id="2f635-445">Usados em elementos raiz (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> por exemplo) implementa a interface <xref:System.Windows.Markup.INameScope>.</span><span class="sxs-lookup"><span data-stu-id="2f635-445">Commonly used root elements (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> for example) implement the interface <xref:System.Windows.Markup.INameScope>.</span></span> <span data-ttu-id="2f635-446">Implementações dessa interface devem impor que os nomes sejam ambíguos no seu escopo.</span><span class="sxs-lookup"><span data-stu-id="2f635-446">Implementations of this interface are expected to enforce that names be unambiguous within their scope.</span></span>  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2f635-447">Informações da propriedade de dependência</span><span class="sxs-lookup"><span data-stu-id="2f635-447">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2f635-448">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="2f635-448">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.NameProperty>|  
|<span data-ttu-id="2f635-449">Propriedades de metadados é definido como `true`</span><span class="sxs-lookup"><span data-stu-id="2f635-449">Metadata properties set to `true`</span></span>|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-450">Identifica a propriedade de dependência <see cref="P:System.Windows.FrameworkContentElement.Name" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-450">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Name" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="2f635-451">Fornece dados sobre o evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-451">Provides data about the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2f635-452">Invocado sempre que um evento roteado <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> acessa essa classe em sua rota.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-452">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> routed event reaches this class in its route.</span>
          </span>
          <span data-ttu-id="2f635-453">Implemente esse método para adicionar tratamento de classe a esse evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-453">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-454">Esse método não tem nenhuma implementação padrão.</span><span class="sxs-lookup"><span data-stu-id="2f635-454">This method has no default implementation.</span></span> <span data-ttu-id="2f635-455">Você ainda deve chamar a implementação base no caso de uma classe intermediária na herança implementou esse método.</span><span class="sxs-lookup"><span data-stu-id="2f635-455">You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="2f635-456">O objetivo deste método é semelhante a [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] padrão de evento em \* métodos: ele fornece os meios para manipular o evento correspondente de classes derivadas com um manipulador de classe em vez de um manipulador de instância.</span><span class="sxs-lookup"><span data-stu-id="2f635-456">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="2f635-457">Nesse caso, o evento correspondente é um evento roteado.</span><span class="sxs-lookup"><span data-stu-id="2f635-457">In this case the matching event is a routed event.</span></span> <span data-ttu-id="2f635-458">O padrão de implementação dos métodos On \* é diferente para eventos roteados porque o evento roteado pode ter sido gerado por um elemento filho, não necessariamente o elemento que invocará manipuladores.</span><span class="sxs-lookup"><span data-stu-id="2f635-458">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="2f635-459">Portanto, sua implementação terá que consideram o evento propriedades da fonte dos argumentos (e não deve tentar gerar novamente o evento na maioria dos casos).</span><span class="sxs-lookup"><span data-stu-id="2f635-459">Therefore, your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="2f635-460">As subclasses de <xref:System.Windows.FrameworkContentElement> pode optar por chamar os métodos do manipulador de classe privada quando o evento é recebido na rota.</span><span class="sxs-lookup"><span data-stu-id="2f635-460">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="2f635-461">Um cenário potencial é receber os argumentos do evento e deliberadamente marcar o evento como manipulado para encurtar a rota.</span><span class="sxs-lookup"><span data-stu-id="2f635-461">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="2f635-462">Os dados de evento do evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-462">Event data for the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2f635-463">Invocado sempre que um evento roteado <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> acessa essa classe em sua rota.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-463">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> routed event reaches this class in its route.</span>
          </span>
          <span data-ttu-id="2f635-464">Implemente esse método para adicionar tratamento de classe a esse evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-464">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-465">Esse método não tem nenhuma implementação padrão.</span><span class="sxs-lookup"><span data-stu-id="2f635-465">This method has no default implementation.</span></span> <span data-ttu-id="2f635-466">Você ainda deve chamar base() no caso de uma classe intermediária na herança implementou esse método.</span><span class="sxs-lookup"><span data-stu-id="2f635-466">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="2f635-467">O objetivo deste método é semelhante a [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] padrão de evento em \* métodos: ele fornece os meios para manipular o evento correspondente de classes derivadas com um manipulador de classe em vez de um manipulador de instância.</span><span class="sxs-lookup"><span data-stu-id="2f635-467">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="2f635-468">Nesse caso, o evento correspondente é um evento roteado.</span><span class="sxs-lookup"><span data-stu-id="2f635-468">In this case the matching event is a routed event.</span></span> <span data-ttu-id="2f635-469">O padrão de implementação dos métodos On \* é diferente para eventos roteados porque o evento roteado pode ter sido gerado por um elemento filho, não necessariamente o elemento que invocará manipuladores, para que sua implementação terá que consideram o evento propriedades da fonte dos argumentos (e não deve tentar gerar novamente o evento na maioria dos casos).</span><span class="sxs-lookup"><span data-stu-id="2f635-469">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="2f635-470">As subclasses de <xref:System.Windows.FrameworkContentElement> pode optar por chamar os métodos do manipulador de classe privada quando o evento é recebido na rota.</span><span class="sxs-lookup"><span data-stu-id="2f635-470">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="2f635-471">Um cenário potencial é receber os argumentos do evento e deliberadamente marcar o evento como manipulado para encurtar a rota.</span><span class="sxs-lookup"><span data-stu-id="2f635-471">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="2f635-472">Os dados de evento do evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-472">Event data for the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2f635-473">Manipulador de classe para o evento <see cref="E:System.Windows.ContentElement.GotFocus" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-473">Class handler for the <see cref="E:System.Windows.ContentElement.GotFocus" /> event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-474">Esse manipulador da classe define o comportamento de foco apropriado neste elemento, se o evento foi originado desse elemento.</span><span class="sxs-lookup"><span data-stu-id="2f635-474">This class handler sets appropriate focus behavior on this element if the event originated from this element.</span></span> <span data-ttu-id="2f635-475">Se outro elemento na árvore de origem do evento, o manipulador não fará nada.</span><span class="sxs-lookup"><span data-stu-id="2f635-475">If the event's source was another element in the tree, the handler does nothing.</span></span>  
  
 <span data-ttu-id="2f635-476">Substitua este método para alterar essas padrão voltados para o elemento de comportamento.</span><span class="sxs-lookup"><span data-stu-id="2f635-476">Override this method in order to change these default focusing behavior on your element.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="2f635-477">Os dados de evento do evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-477">Event data for the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2f635-478">Aciona o evento <see cref="E:System.Windows.FrameworkContentElement.Initialized" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-478">Raises the <see cref="E:System.Windows.FrameworkContentElement.Initialized" /> event.</span>
          </span>
          <span data-ttu-id="2f635-479">Este método é invocado sempre que <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> é definido como <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-479">This method is invoked whenever <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> is set to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-480">A implementação padrão desse método virtual gera o evento conforme descrito anteriormente neste tópico.</span><span class="sxs-lookup"><span data-stu-id="2f635-480">The default implementation of this virtual method raises the event as described earlier in this topic.</span></span> <span data-ttu-id="2f635-481">Substituições devem chamar base() para preservar esse comportamento.</span><span class="sxs-lookup"><span data-stu-id="2f635-481">Overrides should call base() to preserve this behavior.</span></span>  
  
 <span data-ttu-id="2f635-482">Observe que o <xref:System.Windows.FrameworkContentElement.IsInitialized%2A> propriedade é somente leitura.</span><span class="sxs-lookup"><span data-stu-id="2f635-482">Note that the <xref:System.Windows.FrameworkContentElement.IsInitialized%2A> property is read-only.</span></span> <span data-ttu-id="2f635-483">Portanto, você não pode configurá-lo para forçar o comportamento de inicialização dessa maneira.</span><span class="sxs-lookup"><span data-stu-id="2f635-483">Therefore, you cannot set it to force initialization behavior that way.</span></span> <span data-ttu-id="2f635-484">Configuração de inicialização se destina a ser feito apenas pelo [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework.</span><span class="sxs-lookup"><span data-stu-id="2f635-484">Initialization setting is intended to be done only by the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="2f635-485">Os dados de evento que descrevem a propriedade alterada, incluindo os valores novos e antigos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-485">The event data that describes the property that changed, including the old and new values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2f635-486">Invocado sempre que o valor efetivo de qualquer propriedade de dependência nesse <see cref="T:System.Windows.FrameworkContentElement" /> for atualizada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-486">Invoked whenever the effective value of any dependency property on this <see cref="T:System.Windows.FrameworkContentElement" /> has been updated.</span>
          </span>
          <span data-ttu-id="2f635-487">A propriedade de dependência específica alterada é relatada no parâmetro de argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-487">The specific dependency property that changed is reported in the arguments parameter.</span>
          </span>
          <span data-ttu-id="2f635-488">Substitui <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-488">Overrides <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-489">Esse método não deve detectar geralmente invalidações ou alterações de propriedade.</span><span class="sxs-lookup"><span data-stu-id="2f635-489">This method is not intended to generally detect property changes or invalidations.</span></span> <span data-ttu-id="2f635-490">Em vez disso destina para modificações do padrão de invalidação geral se for conhecidas certas informações sobre classificações de largura de propriedades.</span><span class="sxs-lookup"><span data-stu-id="2f635-490">It is instead intended for modifications of the general invalidation pattern if certain information is known about wide classifications of properties.</span></span>  
  
 <span data-ttu-id="2f635-491">Esse método é potencialmente chamado várias vezes durante a vida de um objeto.</span><span class="sxs-lookup"><span data-stu-id="2f635-491">This method is potentially invoked many times during the life of an object.</span></span> <span data-ttu-id="2f635-492">Portanto, você pode obter um melhor desempenho se você substituir os metadados de propriedades específicas e, em seguida, anexa <xref:System.Windows.CoerceValueCallback> ou <xref:System.Windows.PropertyChangedCallback> funções de propriedades individuais.</span><span class="sxs-lookup"><span data-stu-id="2f635-492">Therefore, you can achieve better performance if you override the metadata of specific properties and then attach <xref:System.Windows.CoerceValueCallback> or <xref:System.Windows.PropertyChangedCallback> functions for individual properties.</span></span> <span data-ttu-id="2f635-493">No entanto, você usaria esse método se um <xref:System.Windows.FrameworkContentElement> inclui um número significativo de propriedades de dependência inter-relacionados de valor, ou se ele inclui lógica, como o comportamento de renderização que deve ser executado novamente para vários casos de invalidações de propriedade de relacionados.</span><span class="sxs-lookup"><span data-stu-id="2f635-493">However, you would use this method if a <xref:System.Windows.FrameworkContentElement> includes a significant number of value-interrelated dependency properties, or if it includes logic such as rendering behavior that must be rerun for several related cases of property invalidations.</span></span>  
  
 <span data-ttu-id="2f635-494">Observe que há um nome idêntico `OnPropertyChanged` método com uma assinatura diferente (o tipo de parâmetro é <xref:System.ComponentModel.PropertyChangedEventArgs>) que podem aparecer em um número de classes.</span><span class="sxs-lookup"><span data-stu-id="2f635-494">Note that there is an identically named `OnPropertyChanged` method with a different signature (the parameter type is <xref:System.ComponentModel.PropertyChangedEventArgs>) that can appear on a number of classes.</span></span> <span data-ttu-id="2f635-495">Que `OnPropertyChanged` é usado para notificações do objeto de dados e faz parte do contrato de <xref:System.ComponentModel.INotifyPropertyChanged>.</span><span class="sxs-lookup"><span data-stu-id="2f635-495">That `OnPropertyChanged` is used for data object notifications, and is part of the contract for <xref:System.ComponentModel.INotifyPropertyChanged>.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="2f635-496">Sempre chame a implementação base, como a primeira operação em sua implementação.</span>
            <span class="sxs-lookup">
              <span data-stu-id="2f635-496">Always call the base implementation, as the first operation in your implementation.</span>
            </span>
            <span data-ttu-id="2f635-497">Falha ao fazer isso significativamente desabilitará toda a [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema de propriedade, o que faz com que valores incorretos a serem relatados.</span>
            <span class="sxs-lookup">
              <span data-stu-id="2f635-497">Failure to do this will significantly disable the entire [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system, which causes incorrect values to be reported.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">
          <span data-ttu-id="2f635-498">O estilo antigo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-498">The old style.</span>
          </span>
        </param>
        <param name="newStyle">
          <span data-ttu-id="2f635-499">O novo estilo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-499">The new style.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2f635-500">É invocado quando o estilo que está em uso neste elemento é alterado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-500">Invoked when the style that is in use on this element changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-501">Esse método tem uma implementação padrão que define um sinalizador interno observando a condição de estilo alterado.</span><span class="sxs-lookup"><span data-stu-id="2f635-501">This method has a default implementation that sets an internal flag noting the style changed condition.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="2f635-502">Sempre chamar a implementação base, caso contrário, os estilos não podem ser aplicados.</span>
            <span class="sxs-lookup">
              <span data-stu-id="2f635-502">Always call the base implementation, otherwise styles cannot be applied.</span>
            </span>
            <span data-ttu-id="2f635-503">Cenários para substituir esse método podem incluir se sua classe derivada tem um seletor de estilo especializado ou armazena em cache os valores de estilo.</span>
            <span class="sxs-lookup">
              <span data-stu-id="2f635-503">Scenarios for overriding this method might include if your derived class has a specialized style selector, or caches style values.</span>
            </span>
            <span data-ttu-id="2f635-504">Alterações de tema potencialmente irá chamar este método.</span>
            <span class="sxs-lookup">
              <span data-stu-id="2f635-504">Theme changes will potentially invoke this method.</span>
            </span>
          </para>
        </block>
        <altmember cref="P:System.Windows.FrameworkContentElement.Style" />
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="2f635-505">Fornece dados sobre o evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-505">Provides data about the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2f635-506">Invocado sempre que um evento roteado <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> acessa essa classe em sua rota.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-506">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> routed event reaches this class in its route.</span>
          </span>
          <span data-ttu-id="2f635-507">Implemente esse método para adicionar tratamento de classe a esse evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-507">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-508">Esse método não tem nenhuma implementação padrão.</span><span class="sxs-lookup"><span data-stu-id="2f635-508">This method has no default implementation.</span></span> <span data-ttu-id="2f635-509">Você ainda deve chamar base() no caso de uma classe intermediária na herança implementou esse método.</span><span class="sxs-lookup"><span data-stu-id="2f635-509">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="2f635-510">O objetivo deste método é semelhante a [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] padrão de evento em \* métodos: ele fornece os meios para manipular o evento correspondente de classes derivadas com um manipulador de classe em vez de um manipulador de instância.</span><span class="sxs-lookup"><span data-stu-id="2f635-510">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="2f635-511">Nesse caso, o evento correspondente é um evento roteado.</span><span class="sxs-lookup"><span data-stu-id="2f635-511">In this case the matching event is a routed event.</span></span> <span data-ttu-id="2f635-512">O padrão de implementação dos métodos On \* é diferente para eventos roteados porque o evento roteado pode ter sido gerado por um elemento filho, não necessariamente o elemento que invocará manipuladores, para que sua implementação terá que consideram o evento propriedades da fonte dos argumentos (e não deve tentar gerar novamente o evento na maioria dos casos).</span><span class="sxs-lookup"><span data-stu-id="2f635-512">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="2f635-513">As subclasses de <xref:System.Windows.FrameworkContentElement> pode optar por chamar os métodos do manipulador de classe privada quando o evento é recebido na rota.</span><span class="sxs-lookup"><span data-stu-id="2f635-513">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="2f635-514">Um cenário potencial é receber os argumentos do evento e deliberadamente marcar o evento como manipulado para encurtar a rota.</span><span class="sxs-lookup"><span data-stu-id="2f635-514">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="2f635-515">Fornece dados sobre o evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-515">Provides data about the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2f635-516">Invocado sempre que um evento roteado <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> acessa essa classe em sua rota.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-516">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> routed event reaches this class in its route.</span>
          </span>
          <span data-ttu-id="2f635-517">Implemente esse método para adicionar tratamento de classe a esse evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-517">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-518">Esse método não tem nenhuma implementação padrão.</span><span class="sxs-lookup"><span data-stu-id="2f635-518">This method has no default implementation.</span></span> <span data-ttu-id="2f635-519">Você ainda deve chamar base() no caso de uma classe intermediária na herança implementou esse método.</span><span class="sxs-lookup"><span data-stu-id="2f635-519">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="2f635-520">O objetivo deste método é semelhante a [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] padrão de evento em \* métodos: ele fornece os meios para manipular o evento correspondente de classes derivadas com um manipulador de classe em vez de um manipulador de instância.</span><span class="sxs-lookup"><span data-stu-id="2f635-520">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="2f635-521">Nesse caso, o evento correspondente é um evento roteado.</span><span class="sxs-lookup"><span data-stu-id="2f635-521">In this case the matching event is a routed event.</span></span> <span data-ttu-id="2f635-522">O padrão de implementação dos métodos On \* é diferente para eventos roteados porque o evento roteado pode ter sido gerado por um elemento filho, não necessariamente o elemento que invocará manipuladores, portanto, sua implementação precisa consideram o evento propriedades da fonte dos argumentos (e não deve tentar gerar novamente o evento na maioria dos casos).</span><span class="sxs-lookup"><span data-stu-id="2f635-522">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="2f635-523">As subclasses de <xref:System.Windows.FrameworkContentElement> pode optar por chamar os métodos do manipulador de classe privada quando o evento é recebido na rota.</span><span class="sxs-lookup"><span data-stu-id="2f635-523">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="2f635-524">Um cenário potencial é receber os argumentos do evento e deliberadamente marcar o evento como manipulado para encurtar a rota.</span><span class="sxs-lookup"><span data-stu-id="2f635-524">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-525">Obtém ou define um valor que indica se este elemento incorpora propriedades de estilo dos estilos de tema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-525">Gets or sets a value indicating whether this element incorporates style properties from theme styles.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2f635-526">
            <see langword="true" /> se esse elemento não usar as propriedades de estilo do tema. Todas as propriedades que originam o estilo vêm de estilos de aplicativos locais e propriedades de estilo do tema não se aplicam.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-526">
              <see langword="true" /> if this element does not use theme style properties; all style-originating properties come from local application styles, and theme style properties do not apply.</span>
          </span>
          <span data-ttu-id="2f635-527">
            <see langword="false" /> se os estilos de aplicativo se aplicarem primeiro e, então, estilos de tema se aplicarem a propriedades que não foram definidas especificamente em estilos de aplicativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-527">
              <see langword="false" /> if application styles apply first, and then theme styles apply for properties that were not specifically set in application styles.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-528">O uso mais comum dessa propriedade é um uso indireto em setter de um estilo que está fornecendo um estilo com tema.</span><span class="sxs-lookup"><span data-stu-id="2f635-528">The most common usage of this property is an indirect usage within the setter of a style that is supplying a themed style.</span></span>  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2f635-529">Informações da propriedade de dependência</span><span class="sxs-lookup"><span data-stu-id="2f635-529">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2f635-530">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="2f635-530">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|  
|<span data-ttu-id="2f635-531">Propriedades de metadados é definido como `true`</span><span class="sxs-lookup"><span data-stu-id="2f635-531">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-532">Identifica a propriedade de dependência <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-532">Identifies the <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-533">Obtém o pai na árvore lógica para este elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-533">Gets the parent in the logical tree for this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2f635-534">O pai lógico para este elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-534">The logical parent for this element.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-535">Observe que o pai lógico de um elemento potencialmente pode mudar dependendo de sua funcionalidade do aplicativo e manter o valor dessa propriedade não refletirá essa alteração.</span><span class="sxs-lookup"><span data-stu-id="2f635-535">Note that the logical parent of an element can potentially change depending on your application functionality, and keeping the value of this property will not reflect that change.</span></span> <span data-ttu-id="2f635-536">Normalmente, você deve obter o valor imediatamente antes de você precisa dele.</span><span class="sxs-lookup"><span data-stu-id="2f635-536">You typically should get the value immediately before you need it.</span></span>  
  
 <span data-ttu-id="2f635-537">Consulte [árvores no WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) para obter mais informações sobre percorrer árvores de lógicas e os cenários em que essa abordagem para descoberta de elemento é apropriado.</span><span class="sxs-lookup"><span data-stu-id="2f635-537">See [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) for more information about traversing logical trees, and the scenarios where taking this approach towards element discovery is appropriate.</span></span>  
  
 <span data-ttu-id="2f635-538">O sistema de propriedade potencialmente recalculará todos os valores de propriedade de um elemento quando ele é alterado o nível superior, porque algumas propriedades herdam valores por meio da árvore lógica.</span><span class="sxs-lookup"><span data-stu-id="2f635-538">The property system will potentially recalculate all property values of an element when it is reparented, because some properties inherit values through the logical tree.</span></span> <span data-ttu-id="2f635-539">O <xref:System.Windows.FrameworkContentElement.DataContext%2A> que se aplica para associações também podem alterar quando os elementos de seus pais são modificados.</span><span class="sxs-lookup"><span data-stu-id="2f635-539">The <xref:System.Windows.FrameworkContentElement.DataContext%2A> that applies for bindings can also change when elements are reparented.</span></span>  
  
 <span data-ttu-id="2f635-540">Alterando o pai de um elemento é normalmente feito somente por meio de manipulação de coleções, usando dedicado adicionar ou remover métodos, ou por meio de propriedades do conteúdo dos elementos de configuração.</span><span class="sxs-lookup"><span data-stu-id="2f635-540">Changing an element's parent is typically only done through manipulation of collections, by using dedicated add or remove methods, or through setting content properties of elements.</span></span>  
  
 <span data-ttu-id="2f635-541">O cenário mais comum para usar o <xref:System.Windows.FrameworkContentElement.Parent%2A> é de propriedade obter uma referência e, em seguida, obter vários <xref:System.Windows.FrameworkContentElement> valores de propriedade do pai.</span><span class="sxs-lookup"><span data-stu-id="2f635-541">The most typical scenario for using the <xref:System.Windows.FrameworkContentElement.Parent%2A> property is to obtain a reference and then get various <xref:System.Windows.FrameworkContentElement> property values from the parent.</span></span> <span data-ttu-id="2f635-542">Para os modelos, o <xref:System.Windows.FrameworkContentElement.Parent%2A> do modelo eventualmente será `null`.</span><span class="sxs-lookup"><span data-stu-id="2f635-542">For templates, the <xref:System.Windows.FrameworkContentElement.Parent%2A> of the template eventually will be `null`.</span></span> <span data-ttu-id="2f635-543">Para obter após esse ponto e estender a árvore lógica em que o modelo é aplicado na verdade, usar <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>.</span><span class="sxs-lookup"><span data-stu-id="2f635-543">To get past this point and extend into the logical tree where the template is actually applied, use <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f635-544">O exemplo a seguir verifica se o <xref:System.Windows.FrameworkContentElement.Parent%2A> de um <xref:System.Windows.Documents.TextPointer> é de um tipo específico.</span><span class="sxs-lookup"><span data-stu-id="2f635-544">The following example checks to see whether the <xref:System.Windows.FrameworkContentElement.Parent%2A> of a <xref:System.Windows.Documents.TextPointer> is of a particular type.</span></span>  
  
 [!code-csharp[TextPointer_snippets#FCEParent](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#fceparent)]
 [!code-vb[TextPointer_snippets#FCEParent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#fceparent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">
          <span data-ttu-id="2f635-545">A direção para a qual uma alteração de foco potencial deve ser determinada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-545">The direction for which a prospective focus change should be determined.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2f635-546">Determina o próximo elemento que deve receber o foco em relação a esse elemento para uma direção de movimento do foco fornecido, mas não move o foco realmente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-546">Determines the next element that would receive focus relative to this element for a provided focus movement direction, but does not actually move the focus.</span>
          </span>
          <span data-ttu-id="2f635-547">Este método está selado e não pode ser substituído.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-547">This method is sealed and cannot be overridden.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2f635-548">O próximo elemento para o qual o foco se moverá se o foco for realmente percorrido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-548">The next element that focus would move to if focus were actually traversed.</span>
          </span>
          <span data-ttu-id="2f635-549">Poderá retornar <see langword="null" /> se o foco não puder ser movido em relação a esse elemento para a direção fornecida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-549">May return <see langword="null" /> if focus cannot be moved relative to this element for the provided direction.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-550"><xref:System.Windows.FrameworkContentElement.MoveFocus%2A> é o método relacionado que, na verdade, move o foco.</span><span class="sxs-lookup"><span data-stu-id="2f635-550"><xref:System.Windows.FrameworkContentElement.MoveFocus%2A> is the related method that actually does move focus.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <span data-ttu-id="2f635-551">Especifica uma das seguintes instruções no <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" /> ou <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-551">Specified one of the following directions in the <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />.</span>
          </span>
          <span data-ttu-id="2f635-552">Essas instruções não são válidas para <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (mas são válidas para <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-552">These directions are not legal for <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (but they are legal for <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2f635-553">Nome a ser usado para o mapeamento de nome-objeto especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-553">Name to use for the specified name-object mapping.</span>
          </span>
        </param>
        <param name="scopedElement">
          <span data-ttu-id="2f635-554">Objeto para o mapeamento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-554">Object for the mapping.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2f635-555">Fornece um acessador que simplifica o acesso ao método de registro <see cref="T:System.Windows.NameScope" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-555">Provides an accessor that simplifies access to the <see cref="T:System.Windows.NameScope" /> registration method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-556">Esse método é um método conveniente para chamar <xref:System.Windows.NameScope.RegisterName%2A>.</span><span class="sxs-lookup"><span data-stu-id="2f635-556">This method is a convenience method for calling <xref:System.Windows.NameScope.RegisterName%2A>.</span></span> <span data-ttu-id="2f635-557">A implementação verificará sucessivos elementos pais até encontrar o aplicável <xref:System.Windows.NameScope> implementação, que é encontrada por localizar um elemento que implementa <xref:System.Windows.Markup.INameScope>.</span><span class="sxs-lookup"><span data-stu-id="2f635-557">The implementation will check successive parent elements until it finds the applicable <xref:System.Windows.NameScope> implementation, which is found by finding an element that implements <xref:System.Windows.Markup.INameScope>.</span></span> <span data-ttu-id="2f635-558">Para obter mais informações sobre namescopes, consulte [WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).</span><span class="sxs-lookup"><span data-stu-id="2f635-558">For more information about namescopes, see [WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).</span></span>  
  
 <span data-ttu-id="2f635-559">Chamando <xref:System.Windows.FrameworkContentElement.RegisterName%2A> é necessário para conectar corretamente storyboards de animação para aplicativos quando criado em código.</span><span class="sxs-lookup"><span data-stu-id="2f635-559">Calling <xref:System.Windows.FrameworkContentElement.RegisterName%2A> is necessary in order to correctly hook up animation storyboards for applications when created in code.</span></span> <span data-ttu-id="2f635-560">Isso ocorre porque uma chave de storyboard propriedades, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, usa uma pesquisa de nome de tempo de execução em vez de ser capaz de levar a uma referência a um elemento de destino.</span><span class="sxs-lookup"><span data-stu-id="2f635-560">This is because one of the key storyboard properties, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, uses a run-time name lookup instead of being able to take a reference to a target element.</span></span> <span data-ttu-id="2f635-561">Isso é verdadeiro mesmo se esse elemento é acessível por referência do código.</span><span class="sxs-lookup"><span data-stu-id="2f635-561">This is true even if that element is accessible by reference from the code.</span></span> <span data-ttu-id="2f635-562">Para obter mais informações sobre por que você precisa registrar nomes para os destinos de storyboard, consulte [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span><span class="sxs-lookup"><span data-stu-id="2f635-562">For more information on why you need to register names for storyboard targets, see [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span></span> <span data-ttu-id="2f635-563">Animações para elementos de conteúdo são menos comuns que animações em controles, o [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md) concentra-se em cenários de controle.</span><span class="sxs-lookup"><span data-stu-id="2f635-563">Animations for content elements are less common than animations on controls, the [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md) concentrates on control scenarios.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">
          <span data-ttu-id="2f635-564">O elemento a ser removido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-564">The element to remove.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2f635-565">Remove o elemento especificado da árvore lógica para este elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-565">Removes the specified element from the logical tree for this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-566">Isso [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] é principalmente relevante para a classe derivando cenários, quando a adição de suporte para coleções filho.</span><span class="sxs-lookup"><span data-stu-id="2f635-566">This [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] is mainly relevant for class deriving scenarios, when adding support for child collections.</span></span>  
  
 <span data-ttu-id="2f635-567">A maioria dos <xref:System.Windows.FrameworkContentElement> classes derivadas expõem coleções dedicadas que são responsáveis por contenção (por exemplo, <xref:System.Windows.Documents.Span.Inlines%2A> no <xref:System.Windows.Documents.Span> classe; <xref:System.Windows.Documents.Section.Blocks%2A> no <xref:System.Windows.Documents.Section> classe).</span><span class="sxs-lookup"><span data-stu-id="2f635-567">Most <xref:System.Windows.FrameworkContentElement> derived classes expose dedicated collections that are responsible for containment (for example, <xref:System.Windows.Documents.Span.Inlines%2A> on the <xref:System.Windows.Documents.Span> class; <xref:System.Windows.Documents.Section.Blocks%2A> on the <xref:System.Windows.Documents.Section> class).</span></span> <span data-ttu-id="2f635-568">Derivando de classes de tais normalmente pode evitar a necessidade para manipular a árvore lógica diretamente.</span><span class="sxs-lookup"><span data-stu-id="2f635-568">Deriving from such classes typically can avoid any need to manipulate the logical tree directly.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-569">Obtém ou define o dicionário de recursos atual definido localmente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-569">Gets or sets the current locally-defined resource dictionary.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2f635-570">Os recursos atuais definidos localmente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-570">The current locally-defined resources.</span>
          </span>
          <span data-ttu-id="2f635-571">Este é um dicionário de recursos, onde os recursos dentro do dicionário são acessados por chave.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-571">This is a dictionary of resources, where resources within the dictionary are accessed by key.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-572">Dicionários de recursos que podem ser definidos completamente ou parcialmente em [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] normalmente são criadas como um elemento de propriedade e são normalmente no elemento raiz de qualquer página individual ou para o aplicativo.</span><span class="sxs-lookup"><span data-stu-id="2f635-572">Resource dictionaries that can be defined completely or partially in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] are typically created as a property element, and are typically on the root element for any individual page or for the application.</span></span> <span data-ttu-id="2f635-573">Colocar o dicionário de recurso com esse nível torna mais fácil a localização de elementos filho individual na página (ou de qualquer página, no caso de aplicativo).</span><span class="sxs-lookup"><span data-stu-id="2f635-573">Placing the resource dictionary at this level makes it easier to find from individual child elements in the page (or from any page, in the application case).</span></span> <span data-ttu-id="2f635-574">Na maioria dos cenários de aplicativo, é recomendável que os estilos seja definida como elementos de objeto dentro de um dicionário de recursos, ou ser definido como recursos externos para que o recurso de estilo inteiro pode ser independente (essa abordagem ajuda a separar designers responsabilidades de responsabilidades do desenvolvedor, separando arquivos físicos que precisam ser editadas).</span><span class="sxs-lookup"><span data-stu-id="2f635-574">In most application scenarios, we recommend that styles be defined as object elements within a resource dictionary, or be defined as external resources so that the entire style resource can be self-contained (this approach helps separate designer responsibilities from developer responsibilities by separating the physical files that need to be edited).</span></span>  
  
 <span data-ttu-id="2f635-575">Observe que essa propriedade retorna o dicionário de recurso declarado diretamente dentro desse elemento.</span><span class="sxs-lookup"><span data-stu-id="2f635-575">Note that this property returns only the resource dictionary declared directly within that element.</span></span> <span data-ttu-id="2f635-576">Isso é diferente do processo de pesquisa de recurso real, em que um elemento filho pode acessar qualquer um dos recursos definidos em cada elemento pai, pesquisa recursivamente para cima.</span><span class="sxs-lookup"><span data-stu-id="2f635-576">This is different than the actual resource lookup process, where a child element can access any of the resources defined in each parent element, searching recursively upwards.</span></span>  
  
 <span data-ttu-id="2f635-577">Recursos também podem ser referenciados pelo código de dentro da coleção, mas lembre-se de que os recursos criados em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] definitivamente não estará acessível até depois <xref:System.Windows.FrameworkContentElement.Loaded> é gerado pelo elemento que declara o dicionário.</span><span class="sxs-lookup"><span data-stu-id="2f635-577">Resources can also be referenced by code from within the collection, but be aware that resources created in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] will definitely not be accessible until after <xref:System.Windows.FrameworkContentElement.Loaded> is raised by the element that declares the dictionary.</span></span> <span data-ttu-id="2f635-578">Na verdade, os recursos são analisados de forma assíncrona e nem mesmo o <xref:System.Windows.FrameworkContentElement.Loaded> evento é uma garantia de que você pode fazer referência a um [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] definido pelo recurso.</span><span class="sxs-lookup"><span data-stu-id="2f635-578">In fact, resources are parsed asynchronously, and not even the <xref:System.Windows.FrameworkContentElement.Loaded> event is an assurance that you can reference a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] defined resource.</span></span> <span data-ttu-id="2f635-579">Por esse motivo geralmente só deve acessar [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] definido recursos como parte do código de tempo de execução ou por meio de outros [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] técnicas, como estilos ou referências de extensão de recurso para valores de atributo.</span><span class="sxs-lookup"><span data-stu-id="2f635-579">For this reason you should generally only access [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] defined resources as part of run-time code, or through other [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] techniques such as styles or resource extension references for attribute values.</span></span> <span data-ttu-id="2f635-580">Ao acessar recursos através do código, é essencialmente equivalente a uma referência feita no [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="2f635-580">When you access resources through code, it is essentially equivalent to a  reference made from [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 <span data-ttu-id="2f635-581">Subjacente <xref:System.Windows.ResourceDictionary> suporta os métodos necessários para adicionar, remover ou consultar recursos de dentro da coleção por meio de código.</span><span class="sxs-lookup"><span data-stu-id="2f635-581">The underlying <xref:System.Windows.ResourceDictionary> supports the methods required to add, remove, or query resources from within the collection by using code.</span></span> <span data-ttu-id="2f635-582">O <xref:System.Windows.FrameworkContentElement.Resources%2A> propriedade é configurável para dar suporte ao cenário de substituir completamente a coleção de recursos de um elemento para ser um novo ou diferente <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="2f635-582">The <xref:System.Windows.FrameworkContentElement.Resources%2A> property is settable to support the scenario of completely replacing the resources collection of an element to be a new or different <xref:System.Windows.ResourceDictionary>.</span></span>  
  
 <span data-ttu-id="2f635-583">Observe que o [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sintaxe mostrada não incluir um elemento para o <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="2f635-583">Notice that the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax shown does not include an element for the <xref:System.Windows.ResourceDictionary>.</span></span> <span data-ttu-id="2f635-584">Este é um exemplo da sintaxe de coleção implícita; uma marca que representa o elemento de coleção pode ser omitida.</span><span class="sxs-lookup"><span data-stu-id="2f635-584">This is an example of implicit collection syntax; a tag representing the collection element can be omitted.</span></span> <span data-ttu-id="2f635-585">Os elementos que são adicionados como itens na coleção são especificados em vez disso.</span><span class="sxs-lookup"><span data-stu-id="2f635-585">The elements that are added as items to the collection are specified instead.</span></span> <span data-ttu-id="2f635-586">Para obter mais informações sobre coleções implícita e [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], consulte [XAML sintaxe em detalhes](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span><span class="sxs-lookup"><span data-stu-id="2f635-586">For more information about implicit collections and [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], see [XAML Syntax In Detail](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="2f635-587">Um caso em que um <xref:System.Windows.ResourceDictionary> ainda estão especificadas explicitamente como um elemento é se você está implantando um dicionário mesclado, caso em que normalmente não há nenhum elemento filho para que <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="2f635-587">One case where a <xref:System.Windows.ResourceDictionary> is still specified explicitly as an element is if you are introducing a merged dictionary, in which case there are typically no child elements for that <xref:System.Windows.ResourceDictionary>.</span></span> <span data-ttu-id="2f635-588">Para obter detalhes, consulte [dicionários de recursos mesclados](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).</span><span class="sxs-lookup"><span data-stu-id="2f635-588">For details, see [Merged Resource Dictionaries](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).</span></span>  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="2f635-589">Uso do elemento propriedade XAML</span><span class="sxs-lookup"><span data-stu-id="2f635-589">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a><span data-ttu-id="2f635-590">Valores XAML</span><span class="sxs-lookup"><span data-stu-id="2f635-590">XAML Values</span></span>  
 <span data-ttu-id="2f635-591">*oneOrMoreResourceElements*</span><span class="sxs-lookup"><span data-stu-id="2f635-591">*oneOrMoreResourceElements*</span></span>  
 <span data-ttu-id="2f635-592">Um ou mais elementos de objeto, cada uma delas define um recurso.</span><span class="sxs-lookup"><span data-stu-id="2f635-592">One or more object elements, each of which defines a resource.</span></span> <span data-ttu-id="2f635-593">Cada elemento de propriedade de recurso dentro de cada <xref:System.Windows.ResourceDictionary> deve ter um valor exclusivo para o [diretiva X:Key](~/docs/framework/xaml-services/x-key-directive.md), que serve como a chave exclusiva quando os valores são recuperados do <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="2f635-593">Each resource property element within each <xref:System.Windows.ResourceDictionary> must have a unique value for the [x:Key Directive](~/docs/framework/xaml-services/x-key-directive.md), which serves as the unique key when values are retrieved from the <xref:System.Windows.ResourceDictionary>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f635-594">O exemplo a seguir estabelece uma <xref:System.Windows.FrameworkContentElement.Resources%2A> coleção em uma <xref:System.Windows.Documents.FlowDocument> elemento raiz.</span><span class="sxs-lookup"><span data-stu-id="2f635-594">The following example establishes a <xref:System.Windows.FrameworkContentElement.Resources%2A> collection on a <xref:System.Windows.Documents.FlowDocument> root element.</span></span> <span data-ttu-id="2f635-595"><xref:System.Windows.Documents.FlowDocument> é uma opção típica porque é uma das poucas <xref:System.Windows.FrameworkContentElement> classes que fazem sentido como um elemento raiz e os recursos geralmente são armazenados na raiz de página ou em níveis mais altos mesmo como o aplicativo.</span><span class="sxs-lookup"><span data-stu-id="2f635-595"><xref:System.Windows.Documents.FlowDocument> is a typical choice because it is one of the few <xref:System.Windows.FrameworkContentElement> classes that make sense as a root element, and resources are generally stored at the page root or at even higher levels such as in the application.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-596">Anexa uma associação a esse elemento para a propriedade de dependência especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-596">Attaches a binding to this element for the specified dependency property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="2f635-597">Identifica a propriedade associada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-597">Identifies the bound property.</span>
          </span>
        </param>
        <param name="path">
          <span data-ttu-id="2f635-598">O nome da propriedade de origem ou o caminho para a propriedade usada para a associação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-598">The source property name or the path to the property used for the binding.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2f635-599">Anexa uma associação a esse elemento, com base no nome da propriedade de origem fornecida, como uma qualificação de caminho para a fonte de dados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-599">Attaches a binding to this element, based on the provided source property name as a path qualification to the data source.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2f635-600">Registra as condições da associação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-600">Records the conditions of the binding.</span>
          </span>
          <span data-ttu-id="2f635-601">Esse valor retornado pode ser útil para a verificação de erros.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-601">This return value can be useful for error checking.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-602">Esse método é um método conveniente para chamar <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, que passa a instância atual como o <xref:System.Windows.DependencyObject>e cria um novo <xref:System.Windows.Data.Binding> com base em fornecidos `path` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="2f635-602">This method is a convenience method for calling <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, which passes the current instance as the <xref:System.Windows.DependencyObject>, and creates a new <xref:System.Windows.Data.Binding> based on the provided `path` parameter.</span></span> <span data-ttu-id="2f635-603">Esta assinatura é mais conveniente se você estiver estabelecendo uma associação simples padrão.</span><span class="sxs-lookup"><span data-stu-id="2f635-603">This signature is more convenient if you are establishing a simple default binding.</span></span> <span data-ttu-id="2f635-604">Se você precisa especificar as propriedades de associação para condições não padrão ou se desejar usar um <xref:System.Windows.Data.MultiBinding> ou <xref:System.Windows.Data.PriorityBinding>, você deve usar o <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> assinatura.</span><span class="sxs-lookup"><span data-stu-id="2f635-604">If you need to specify any binding properties to non-default conditions, or want to use a <xref:System.Windows.Data.MultiBinding> or <xref:System.Windows.Data.PriorityBinding>,you should use the <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> signature.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f635-605">O exemplo a seguir define uma associação em um <xref:System.Windows.Documents.Paragraph> elemento, criando um novo objeto de dados personalizados, estabelecer esse objeto como <xref:System.Windows.FrameworkContentElement.DataContext%2A>e definir o caminho de associação a uma propriedade dentro dele.</span><span class="sxs-lookup"><span data-stu-id="2f635-605">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as <xref:System.Windows.FrameworkContentElement.DataContext%2A>, and setting the binding path to a property within it.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="2f635-606">Identifica a propriedade associada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-606">Identifies the bound property.</span>
          </span>
        </param>
        <param name="binding">
          <span data-ttu-id="2f635-607">Representa uma associação de dados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-607">Represents a data binding.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2f635-608">Anexa uma associação a esse elemento, com base no objeto de associação fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-608">Attaches a binding to this element, based on the provided binding object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2f635-609">Registra as condições da associação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-609">Records the conditions of the binding.</span>
          </span>
          <span data-ttu-id="2f635-610">Esse valor retornado pode ser útil para a verificação de erros.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-610">This return value can be useful for error checking.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-611">Esse método é um método conveniente para chamar <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, que passa a instância atual como o <xref:System.Windows.DependencyObject>.</span><span class="sxs-lookup"><span data-stu-id="2f635-611">This method is a convenience method for calling <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, which passes the current instance as the <xref:System.Windows.DependencyObject>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f635-612">O exemplo a seguir define uma associação em um <xref:System.Windows.Documents.Paragraph> elemento, criando um novo <xref:System.Windows.Data.Binding> e configurando a origem para um recém-criado `DateTime` objeto.</span><span class="sxs-lookup"><span data-stu-id="2f635-612">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new <xref:System.Windows.Data.Binding> and setting the source to a newly built `DateTime` object.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#setbinding)]
 [!code-vb[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#setbinding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="2f635-613">A propriedade à qual o recurso está associado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-613">The property to which the resource is bound.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="2f635-614">O nome do recurso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-614">The name of the resource.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2f635-615">Pesquisa por um recurso com o nome especificado e define uma referência de recurso a ele para a propriedade especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-615">Searches for a resource with the specified name and sets up a resource reference to it for the specified property.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-616">Uma referência de recurso é semelhante ao uso de um [DynamicResource Markup Extension](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) na marcação.</span><span class="sxs-lookup"><span data-stu-id="2f635-616">A resource reference is similar to the use of a [DynamicResource Markup Extension](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) in markup.</span></span> <span data-ttu-id="2f635-617">A referência de recurso cria uma expressão interna que fornece o valor da propriedade especificada em uma base de tempo de execução adiada.</span><span class="sxs-lookup"><span data-stu-id="2f635-617">The resource reference creates an internal expression that supplies the value of the specified property on a run-time deferred basis.</span></span> <span data-ttu-id="2f635-618">A expressão será avaliada novamente sempre que o dicionário de recurso indica um valor alterado por meio de eventos internos ou sempre que o elemento atual é alterado o nível superior (uma alteração de pai alteraria o caminho de pesquisa de dicionário).</span><span class="sxs-lookup"><span data-stu-id="2f635-618">The expression will be re-evaluated whenever the resource dictionary indicates a changed value through internal events, or whenever the current element is reparented (a parent change would change the dictionary lookup path).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2f635-619">Indica se os processos de serialização devem serializar o conteúdo da propriedade <see cref="P:System.Windows.FrameworkContentElement.Resources" /> em instâncias dessa classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-619">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.FrameworkContentElement.Resources" /> property on instances of this class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2f635-620">
            <see langword="true" /> se o valor da propriedade <see cref="P:System.Windows.FrameworkContentElement.Resources" /> precisar ser serializado; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-620">
              <see langword="true" /> if the <see cref="P:System.Windows.FrameworkContentElement.Resources" /> property value should be serialized; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-621">Isso retornará `true` enquanto houver pelo menos um recurso com chave local <xref:System.Windows.FrameworkContentElement.Resources%2A>.</span><span class="sxs-lookup"><span data-stu-id="2f635-621">This will return `true` so long as there is at least one keyed resource in the local <xref:System.Windows.FrameworkContentElement.Resources%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2f635-622">Indica se os processos de serialização devem serializar o conteúdo da propriedade <see cref="P:System.Windows.FrameworkContentElement.Style" /> em instâncias dessa classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-622">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.FrameworkContentElement.Style" /> property on instances of this class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2f635-623">
            <see langword="true" /> se o valor da propriedade <see cref="P:System.Windows.FrameworkContentElement.Style" /> precisar ser serializado; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-623">
              <see langword="true" /> if the <see cref="P:System.Windows.FrameworkContentElement.Style" /> property value should be serialized; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-624">Isso retornará `true` se o <xref:System.Windows.Style> é definido localmente.</span><span class="sxs-lookup"><span data-stu-id="2f635-624">This will return `true` if the <xref:System.Windows.Style> is locally set.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-625">Ocorre quando qualquer fonte de dados associada que participe de uma associação nesse elemento é alterada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-625">Occurs when any associated data source participating in a binding on this element changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-626">Este superfícies de evento de <xref:System.Windows.Data.Binding.SourceUpdated> evento que é gerado por qualquer <xref:System.Windows.Data.Binding> associado a este elemento.</span><span class="sxs-lookup"><span data-stu-id="2f635-626">This event surfaces the <xref:System.Windows.Data.Binding.SourceUpdated> event that is raised by any <xref:System.Windows.Data.Binding> associated with this element.</span></span>  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="2f635-627">Uso do Atributo XAML</span><span class="sxs-lookup"><span data-stu-id="2f635-627">XAML Attribute Usage</span></span>  
  
```  
<object SourceUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-628">Obtém ou define o estilo a ser usado por esse elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-628">Gets or sets the style to be used by this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2f635-629">O estilo não padrão aplicado a esse elemento, se houver.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-629">The applied, nondefault style for the element, if present.</span>
          </span>
          <span data-ttu-id="2f635-630">Caso contrário, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-630">Otherwise, <see langword="null" />.</span>
          </span>
          <span data-ttu-id="2f635-631">O padrão para um <see cref="T:System.Windows.FrameworkContentElement" /> construído por padrão é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-631">The default for a default-constructed <see cref="T:System.Windows.FrameworkContentElement" /> is <see langword="null" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-632">O estilo atual geralmente é fornecido por um estilo de padrão de temas ou de estilos geral aplicados a objetos desse tipo por recursos no nível do aplicativo ou página (um estilo implícito).</span><span class="sxs-lookup"><span data-stu-id="2f635-632">The current style is often provided by a default style from theming, or from styles generally applied to objects of that type by resources at page or application level (an implicit style).</span></span> <span data-ttu-id="2f635-633">Essa propriedade não padrão não definido ou retorno estilos (tema), mas ela retorna o estilo implícita ou um estilo explícito.</span><span class="sxs-lookup"><span data-stu-id="2f635-633">This property does not set or return default (theme) styles, but it does return the implicit style or an explicit style.</span></span> <span data-ttu-id="2f635-634">No caso de estilos implícitos ou explícitos, não importa se o estilo for acessado como um recurso ou definido localmente.</span><span class="sxs-lookup"><span data-stu-id="2f635-634">In the case of implicit or explicit styles, it does not matter whether the style is accessed as a resource or defined locally.</span></span>  
  
 <span data-ttu-id="2f635-635">Definir os estilos tem algumas restrições.</span><span class="sxs-lookup"><span data-stu-id="2f635-635">Setting the styles has some restrictions.</span></span> <span data-ttu-id="2f635-636">Você pode redefinir todo o <xref:System.Windows.FrameworkContentElement.Style%2A> propriedade para um novo <xref:System.Windows.Style> a qualquer momento, forçando uma recomposition de layout.</span><span class="sxs-lookup"><span data-stu-id="2f635-636">You can reset the entire <xref:System.Windows.FrameworkContentElement.Style%2A> property to a new <xref:System.Windows.Style> at any time, which will force a layout recomposition.</span></span> <span data-ttu-id="2f635-637">No entanto, assim que esse estilo é colocado em uso por um elemento carregado, o <xref:System.Windows.Style> devem ser consideradas lacrado.</span><span class="sxs-lookup"><span data-stu-id="2f635-637">However, as soon as that style is placed in use by a loaded element, the <xref:System.Windows.Style> should be considered sealed.</span></span> <span data-ttu-id="2f635-638">Tentativa de alterar qualquer propriedade individual de um estilo em uso (como qualquer coisa dentro da coleção de <xref:System.Windows.Style.Setters%2A>) faz com que uma exceção seja lançada.</span><span class="sxs-lookup"><span data-stu-id="2f635-638">Attempting to make a change to any individual property of an in-use style (such as anything within the collection of <xref:System.Windows.Style.Setters%2A>) causes an exception to be thrown.</span></span> <span data-ttu-id="2f635-639">Um estilo que é definido na marcação é considerado para estar em uso assim que ele é carregado de um dicionário de recurso (para recursos), ou a página que está contida na for carregada (para estilos embutidos).</span><span class="sxs-lookup"><span data-stu-id="2f635-639">A style that is defined in markup is considered to be in use as soon as it is loaded from a resource dictionary (for resources), or the page it is contained within is loaded (for inline styles).</span></span>  
  
 <span data-ttu-id="2f635-640"><xref:System.Windows.FrameworkContentElement.Style%2A> é uma propriedade de dependência com precedência especial.</span><span class="sxs-lookup"><span data-stu-id="2f635-640"><xref:System.Windows.FrameworkContentElement.Style%2A> is a dependency property with special precedence.</span></span> <span data-ttu-id="2f635-641">Definido localmente estilo geralmente opera na precedência mais alta no sistema de propriedade.</span><span class="sxs-lookup"><span data-stu-id="2f635-641">The locally set style generally operates at the highest precedence in the property system.</span></span> <span data-ttu-id="2f635-642">Se o <xref:System.Windows.FrameworkContentElement.Style%2A> é nulo neste momento, durante o carregamento, o sistema de propriedade verifica estilos implícitos como recursos definidos que especificam o tipo.</span><span class="sxs-lookup"><span data-stu-id="2f635-642">If the <xref:System.Windows.FrameworkContentElement.Style%2A> is null at this point, during loading the property system checks for implicit styles as defined resources that specify that type.</span></span> <span data-ttu-id="2f635-643">Se o estilo for nulo ainda após essa etapa, o estilo vem do estilo padrão (tema), mas o estilo padrão não é retornado no <xref:System.Windows.FrameworkContentElement.Style%2A> o valor da propriedade.</span><span class="sxs-lookup"><span data-stu-id="2f635-643">If the style is still null after this step, then the style comes from the default (theme) style, but the default style is not returned in the <xref:System.Windows.FrameworkContentElement.Style%2A> property value.</span></span> <span data-ttu-id="2f635-644">Consulte [precedência de valor de propriedade de dependência](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span><span class="sxs-lookup"><span data-stu-id="2f635-644">See [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span></span>  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="2f635-645">Uso do Atributo XAML</span><span class="sxs-lookup"><span data-stu-id="2f635-645">XAML Attribute Usage</span></span>  
  
```  
<object Style="{resourceExtension StyleResourceKey}"/>  
```  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a><span data-ttu-id="2f635-646">Valores XAML</span><span class="sxs-lookup"><span data-stu-id="2f635-646">XAML Values</span></span>  
 <span data-ttu-id="2f635-647">*resourceExtension*</span><span class="sxs-lookup"><span data-stu-id="2f635-647">*resourceExtension*</span></span>  
 <span data-ttu-id="2f635-648">Um dos seguintes:, ou.</span><span class="sxs-lookup"><span data-stu-id="2f635-648">One of the following: , or .</span></span> <span data-ttu-id="2f635-649">Consulte [recursos XAML](~/docs/framework/wpf/advanced/xaml-resources.md).</span><span class="sxs-lookup"><span data-stu-id="2f635-649">See [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
 <span data-ttu-id="2f635-650">*styleResourceKey*</span><span class="sxs-lookup"><span data-stu-id="2f635-650">*styleResourceKey*</span></span>  
 <span data-ttu-id="2f635-651">A chave que identifica o estilo que está sendo solicitado.</span><span class="sxs-lookup"><span data-stu-id="2f635-651">The key that identifies the style being requested.</span></span> <span data-ttu-id="2f635-652">A chave refere-se a um recurso existente em um <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="2f635-652">The key refers to an existing resource in a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2f635-653">Sintaxe de elemento de propriedade é tecnicamente possível, mas não é recomendado.</span><span class="sxs-lookup"><span data-stu-id="2f635-653">Property element syntax is technically possible, but not recommended.</span></span> <span data-ttu-id="2f635-654">Consulte [modelos e estilos in-line](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span><span class="sxs-lookup"><span data-stu-id="2f635-654">See [Inline Styles and Templates](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span></span>  <span data-ttu-id="2f635-655">Uma referência de associação usando ou <xref:System.Windows.Data.Binding> também é possível, mas não é comum.</span><span class="sxs-lookup"><span data-stu-id="2f635-655">A binding reference using  or <xref:System.Windows.Data.Binding> is also possible, but uncommon.</span></span>  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2f635-656">Informações da propriedade de dependência</span><span class="sxs-lookup"><span data-stu-id="2f635-656">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2f635-657">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="2f635-657">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.StyleProperty>|  
|<span data-ttu-id="2f635-658">Propriedades de metadados é definido como `true`</span><span class="sxs-lookup"><span data-stu-id="2f635-658">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 <span data-ttu-id="2f635-659">O exemplo a seguir estabelece uma <xref:System.Windows.FrameworkContentElement.Resources%2A> coleção em uma <xref:System.Windows.Documents.FlowDocument> elemento raiz e, em seguida, faça referência a ele, como um recurso como um estilo específico para um <xref:System.Windows.Documents.Paragraph>.</span><span class="sxs-lookup"><span data-stu-id="2f635-659">The following example establishes a <xref:System.Windows.FrameworkContentElement.Resources%2A> collection on a <xref:System.Windows.Documents.FlowDocument> root element and then references it as a resource as a specific style for a <xref:System.Windows.Documents.Paragraph>.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-660">Identifica a propriedade de dependência <see cref="P:System.Windows.FrameworkContentElement.Style" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-660">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Style" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">
          <span data-ttu-id="2f635-661">O nome da propriedade de ambiente solicitada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-661">The name of the requested ambient property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2f635-662">Para obter uma descrição desse membro, consulte o método <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-662">For a description of this member, see the <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2f635-663">
            <see langword="true" /> se <paramref name="propertyName" /> estiver disponível; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-663">
              <see langword="true" /> if <paramref name="propertyName" /> is available; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-664">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="2f635-664">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="2f635-665">Ele só pode ser usado quando a instância de <xref:System.Windows.FrameworkContentElement> é convertida em uma interface de <xref:System.Windows.Markup.IQueryAmbient>.</span><span class="sxs-lookup"><span data-stu-id="2f635-665">It can be used only when the <xref:System.Windows.FrameworkContentElement> instance is cast to an <xref:System.Windows.Markup.IQueryAmbient> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-666">Obtém ou define um valor arbitrário de objeto que pode ser usado para armazenar informações personalizadas sobre este elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-666">Gets or sets an arbitrary object value that can be used to store custom information about this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2f635-667">O valor desejado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-667">The intended value.</span>
          </span>
          <span data-ttu-id="2f635-668">Esta propriedade não tem valor padrão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-668">This property has no default value.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-669">Essa propriedade é análoga a propriedades da marca em outros [!INCLUDE[TLA#tla_ms](~/includes/tlasharptla-ms-md.md)] modelos de programação como [!INCLUDE[TLA#tla_vba](~/includes/tlasharptla-vba-md.md)] ou [!INCLUDE[TLA#tla_winforms](~/includes/tlasharptla-winforms-md.md)].</span><span class="sxs-lookup"><span data-stu-id="2f635-669">This property is analogous to Tag properties in other [!INCLUDE[TLA#tla_ms](~/includes/tlasharptla-ms-md.md)] programming models, such as [!INCLUDE[TLA#tla_vba](~/includes/tlasharptla-vba-md.md)] or [!INCLUDE[TLA#tla_winforms](~/includes/tlasharptla-winforms-md.md)].</span></span> <span data-ttu-id="2f635-670">Destina-se a fornecer um local já existente para armazenar algumas informações básicas personalizadas sobre qualquer elemento sem fazer com que os desenvolvedores de aplicativos para subclasse.</span><span class="sxs-lookup"><span data-stu-id="2f635-670">It is intended to provide a pre-existing place to store some basic custom information about any element without forcing application developers to subclass.</span></span>  
  
<a name="xamlValues_Tag"></a>   
## <a name="xaml-values"></a><span data-ttu-id="2f635-671">Valores XAML</span><span class="sxs-lookup"><span data-stu-id="2f635-671">XAML Values</span></span>  
 <span data-ttu-id="2f635-672">Como essa propriedade usa um objeto, você precisa usar o uso do elemento de propriedade para definir o <xref:System.Windows.FrameworkContentElement.Tag%2A> propriedade [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] para algo diferente de um objeto com um conversor de tipo conhecido e internos, como uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="2f635-672">Because this property takes an object, you would need to use the property element usage in order to set the <xref:System.Windows.FrameworkContentElement.Tag%2A> property in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] to anything other than an object with a known and built-in type converter, such as a string.</span></span> <span data-ttu-id="2f635-673">Objetos usados dessa maneira normalmente não estão dentro do padrão [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] namespaces e, portanto, podem exigir o mapeamento de namespace para o namespace externo para ser apresentado como [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] elementos.</span><span class="sxs-lookup"><span data-stu-id="2f635-673">Objects used in this way are typically not within the standard [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] namespaces and therefore may require namespace mapping to the external namespace in order to be introduced as [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] elements.</span></span>  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2f635-674">Informações da propriedade de dependência</span><span class="sxs-lookup"><span data-stu-id="2f635-674">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2f635-675">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="2f635-675">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.TagProperty>|  
|<span data-ttu-id="2f635-676">Propriedades de metadados é definido como `true`</span><span class="sxs-lookup"><span data-stu-id="2f635-676">Metadata properties set to `true`</span></span>|<span data-ttu-id="2f635-677">Nenhum</span><span class="sxs-lookup"><span data-stu-id="2f635-677">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-678">Identifica a propriedade de dependência <see cref="P:System.Windows.FrameworkContentElement.Tag" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-678">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Tag" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-679">Ocorre quando qualquer propriedade de destino associada que participa de uma associação nesse elemento é alterada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-679">Occurs when any associated target property participating in a binding on this element changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-680">Este superfícies de evento de <xref:System.Windows.Data.Binding.TargetUpdated> evento que é gerado por qualquer <xref:System.Windows.Data.Binding> associado a este elemento.</span><span class="sxs-lookup"><span data-stu-id="2f635-680">This event surfaces the <xref:System.Windows.Data.Binding.TargetUpdated> event that is raised by any <xref:System.Windows.Data.Binding> associated with this element.</span></span> <span data-ttu-id="2f635-681">Isso geralmente significa que a associação em questão é uma associação bidirecional, e a propriedade de dependência associado confirmará uma invalidação do valor da propriedade anterior por qualquer validação ou esquema de cache que oferece suporte à propriedade.</span><span class="sxs-lookup"><span data-stu-id="2f635-681">This usually means that the binding in question is a two-way binding, and that the bound  dependency property affirms an invalidation of the previous property value per any validation or caching scheme that the property supports.</span></span>  
  
 <span data-ttu-id="2f635-682">Os argumentos de evento deste evento informará a você que associado a propriedade foi alterada.</span><span class="sxs-lookup"><span data-stu-id="2f635-682">The event arguments of this event will inform you which bound property was changed.</span></span>  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="2f635-683">Uso do Atributo XAML</span><span class="sxs-lookup"><span data-stu-id="2f635-683">XAML Attribute Usage</span></span>  
  
```  
<object TargetUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-684">Obtém uma referência ao pai do modelo desse elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-684">Gets a reference to the template parent of this element.</span>
          </span>
          <span data-ttu-id="2f635-685">Essa propriedade não é relevante se o elemento não foi criado por meio de um modelo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-685">This property is not relevant if the element was not created through a template.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2f635-686">O elemento cujo <see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> causou esse elemento a ser criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-686">The element whose <see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> caused this element to be created.</span>
          </span>
          <span data-ttu-id="2f635-687">Esse valor é frequentemente <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-687">This value is frequently <see langword="null" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-688">Modelos são objetos compartilhados na verdade, onde o conteúdo do modelo é criado apenas uma vez.</span><span class="sxs-lookup"><span data-stu-id="2f635-688">Templates are actually shared objects, where the contents of the template are created only once.</span></span> <span data-ttu-id="2f635-689">Portanto, se você obtiver uma referência de objeto para um elemento que veio de um modelo, você pode achar que a árvore lógica aparente não acessar a raiz da página.</span><span class="sxs-lookup"><span data-stu-id="2f635-689">Therefore, if you obtain an object reference to an element that came from a template, you may find that the apparent logical tree does not reach to the page root.</span></span> <span data-ttu-id="2f635-690">Para conectar-se uma referência de modelo de árvore lógica da página, você deve obter o <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> valor e continuar a navegar árvore elemento conforme desejado.</span><span class="sxs-lookup"><span data-stu-id="2f635-690">In order to connect such a template reference to the page's logical tree, you should get the <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> value and continue to navigate that element tree as desired.</span></span>  
  
 <span data-ttu-id="2f635-691"><xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> será frequentemente `null` para objetos comuns, porque se você tiver obtido uma referência de objeto de uma página em seu aplicativo por meio de típico, esse elemento provavelmente não foi criado de um modelo.</span><span class="sxs-lookup"><span data-stu-id="2f635-691"><xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> will frequently be `null` for common objects, because if you have obtained an object reference from out of a page in your application through typical means, that element probably was not created from a template.</span></span> <span data-ttu-id="2f635-692">Casos onde <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> pode não ser `null` inclui operações como eventos de testes, tratamento de certos eventos de entrada de baixo nível, ou trabalhar com enumeradores, que podem ter retornado elementos que veio de modelos.</span><span class="sxs-lookup"><span data-stu-id="2f635-692">Cases where <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> might not be `null` would include operations such as hit-testing, event handling for certain low-level input events, or working with enumerators, which may have returned elements that came from templates.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-693">Obtém ou define o objeto de dica de ferramenta exibido para este elemento na [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-693">Gets or sets the tool-tip object that is displayed for this element in the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2f635-694">O objeto de dica de ferramenta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-694">The tooltip object.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-695">Se o valor dessa propriedade é do tipo <xref:System.Windows.Controls.ToolTip>, em seguida, que é a dica de ferramenta que será usada no [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="2f635-695">If the value of this property is of type <xref:System.Windows.Controls.ToolTip>, then that is the tool-tip that will be used in the [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span>  <span data-ttu-id="2f635-696">Se o valor for de qualquer outro tipo, esse valor será usado como o *conteúdo* para um <xref:System.Windows.Controls.ToolTip> fornecido (construído) pelo sistema.</span><span class="sxs-lookup"><span data-stu-id="2f635-696">If the value is of any other type, then that value will be used as the *content* for a <xref:System.Windows.Controls.ToolTip> provided (constructed) by the system.</span></span> <span data-ttu-id="2f635-697">Para obter mais informações, consulte <xref:System.Windows.Controls.ToolTipService>.</span><span class="sxs-lookup"><span data-stu-id="2f635-697">For more information see <xref:System.Windows.Controls.ToolTipService>.</span></span> <span data-ttu-id="2f635-698">A classe de serviço fornece as propriedades anexadas que podem ser usadas para personalizar uma dica de ferramenta.</span><span class="sxs-lookup"><span data-stu-id="2f635-698">The service class provides attached properties that can be used to further customize a tool-tip.</span></span>  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="2f635-699">Uso do Atributo XAML</span><span class="sxs-lookup"><span data-stu-id="2f635-699">XAML Attribute Usage</span></span>  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="2f635-700">Uso do elemento propriedade XAML</span><span class="sxs-lookup"><span data-stu-id="2f635-700">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a><span data-ttu-id="2f635-701">Valores XAML</span><span class="sxs-lookup"><span data-stu-id="2f635-701">XAML Values</span></span>  
 <span data-ttu-id="2f635-702">*toolTipContent*</span><span class="sxs-lookup"><span data-stu-id="2f635-702">*toolTipContent*</span></span>  
 <span data-ttu-id="2f635-703">Uma cadeia de caracteres que se torna o texto exibido para o <xref:System.Windows.FrameworkContentElement.ToolTip%2A>.</span><span class="sxs-lookup"><span data-stu-id="2f635-703">A string that becomes the display text for the <xref:System.Windows.FrameworkContentElement.ToolTip%2A>.</span></span>  
  
 <span data-ttu-id="2f635-704">*toolTipObjectContent*</span><span class="sxs-lookup"><span data-stu-id="2f635-704">*toolTipObjectContent*</span></span>  
 <span data-ttu-id="2f635-705">Um objeto, fornecido na forma de elemento de objeto, que deve ser usada como o conteúdo para o <xref:System.Windows.FrameworkContentElement> .</span><span class="sxs-lookup"><span data-stu-id="2f635-705">Some object, provided in object element form, that should be used as the content for the <xref:System.Windows.FrameworkContentElement> .</span></span> <span data-ttu-id="2f635-706">Geralmente isso seria uma <xref:System.Windows.FrameworkElement> ou algum outro elemento que cria a composição de layout para o <xref:System.Windows.FrameworkContentElement.ToolTip%2A>, eventualmente com o conteúdo de texto dentro da composição.</span><span class="sxs-lookup"><span data-stu-id="2f635-706">Typically this would be a <xref:System.Windows.FrameworkElement> or some other element that creates layout compositing for the <xref:System.Windows.FrameworkContentElement.ToolTip%2A>, eventually containing text content within the compositing.</span></span> <span data-ttu-id="2f635-707">Nesse exemplo, o <xref:System.Windows.Controls.ToolTip> elemento é criado implicitamente de analisada [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]e o *toolTipObjectContent* o conteúdo está definido como seu <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="2f635-707">In this usage, the <xref:System.Windows.Controls.ToolTip> element is created implicitly from the parsed [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], and the *toolTipObjectContent* content is set as its <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="2f635-708"><`ToolTip` .../></span><span class="sxs-lookup"><span data-stu-id="2f635-708"><`ToolTip` .../></span></span>  
 <span data-ttu-id="2f635-709">Consulte <xref:System.Windows.Controls.ToolTip>.</span><span class="sxs-lookup"><span data-stu-id="2f635-709">See <xref:System.Windows.Controls.ToolTip>.</span></span>  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="2f635-710">Informações da propriedade de dependência</span><span class="sxs-lookup"><span data-stu-id="2f635-710">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2f635-711">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="2f635-711">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipProperty>|  
|<span data-ttu-id="2f635-712">Propriedades de metadados é definido como `true`</span><span class="sxs-lookup"><span data-stu-id="2f635-712">Metadata properties set to `true`</span></span>|<span data-ttu-id="2f635-713">Nenhum</span><span class="sxs-lookup"><span data-stu-id="2f635-713">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="2f635-714">O exemplo a seguir define o valor de <xref:System.Windows.FrameworkElement.ToolTip%2A> propriedade diretamente para uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="2f635-714">The following example sets the value of the <xref:System.Windows.FrameworkElement.ToolTip%2A> property directly to a string.</span></span>  
  
 [!code-csharp[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/csharp/VS_Snippets_Wpf/TableSnippets2/CSharp/Window1.xaml.cs#_table_rowgroups_maniprows)]
 [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TableSnippets2/visualbasic/window1.xaml.vb#_table_rowgroups_maniprows)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-715">Ocorre logo antes de qualquer dica de ferramenta no elemento seja fechada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-715">Occurs just before any tooltip on the element is closed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-716">Para suprimir a dica de ferramenta de fechamento, manipuladores de evento devem marcá-la como manipulado.</span><span class="sxs-lookup"><span data-stu-id="2f635-716">To suppress closing the tooltip, handlers of the event should mark it as handled.</span></span>  
  
 <span data-ttu-id="2f635-717">Esse evento não pode ser um <xref:System.Windows.EventTrigger> em um estilo.</span><span class="sxs-lookup"><span data-stu-id="2f635-717">This event cannot be an <xref:System.Windows.EventTrigger> in a style.</span></span> <span data-ttu-id="2f635-718">Isso ocorre porque o campo de identificador desse evento reutiliza uma implementação de um serviço que não expor os métodos de adicionar ou remover o evento.</span><span class="sxs-lookup"><span data-stu-id="2f635-718">This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</span></span>  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="2f635-719">Informações de evento encaminhado</span><span class="sxs-lookup"><span data-stu-id="2f635-719">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2f635-720">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="2f635-720">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|  
|<span data-ttu-id="2f635-721">Estratégia de roteamento</span><span class="sxs-lookup"><span data-stu-id="2f635-721">Routing strategy</span></span>|<span data-ttu-id="2f635-722">Direto</span><span class="sxs-lookup"><span data-stu-id="2f635-722">Direct</span></span>|  
|<span data-ttu-id="2f635-723">delegado</span><span class="sxs-lookup"><span data-stu-id="2f635-723">Delegate</span></span>|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-724">Identifica a [Visão geral de eventos roteados](~/docs/framework/wpf/advanced/routed-events-overview.md) de <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-724">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-725">Objetos de identificador de evento são criados quando os eventos roteados são registrados (consulte <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) e, em seguida, pode ser usado para adicionar manipuladores de classe (consulte <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="2f635-725">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="2f635-726">Objetos de identificador contêm um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e um método de utilitário para adicionar proprietários para o evento.</span><span class="sxs-lookup"><span data-stu-id="2f635-726">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-727">Ocorre quando qualquer dica de ferramenta no elemento é aberta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-727">Occurs when any tooltip on the element is opened.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-728">Para abrir manualmente as dicas de ferramenta, manipuladores de eventos devem marcar o evento relevante como manipulado.</span><span class="sxs-lookup"><span data-stu-id="2f635-728">To manually open tooltips, handlers of the events should mark the relevant event as handled.</span></span> <span data-ttu-id="2f635-729">Caso contrário, o valor de <xref:System.Windows.FrameworkContentElement.ToolTip%2A> propriedade será usada para automaticamente abrir um menu de contexto.</span><span class="sxs-lookup"><span data-stu-id="2f635-729">Otherwise, the value of the <xref:System.Windows.FrameworkContentElement.ToolTip%2A> property will be used to automatically open a context menu.</span></span> <span data-ttu-id="2f635-730">Marcar o evento manipulado efetivamente cancelará a ação padrão e pode ser uma oportunidade para redefinir o valor da <xref:System.Windows.FrameworkContentElement.ToolTip%2A> propriedade e, em seguida, abra o novo <xref:System.Windows.Controls.ContextMenu>.</span><span class="sxs-lookup"><span data-stu-id="2f635-730">Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <xref:System.Windows.FrameworkContentElement.ToolTip%2A> property and then open the new <xref:System.Windows.Controls.ContextMenu>.</span></span> <span data-ttu-id="2f635-731">Observe que esse evento não será gerado se <xref:System.Windows.FrameworkContentElement.ToolTip%2A> é uma referência nula ou de outra forma não definida.</span><span class="sxs-lookup"><span data-stu-id="2f635-731">Note that this event will not be raised if <xref:System.Windows.FrameworkContentElement.ToolTip%2A> is a null reference or otherwise unset.</span></span>  
  
 <span data-ttu-id="2f635-732">Esse evento não pode ser um <xref:System.Windows.EventTrigger> em um estilo.</span><span class="sxs-lookup"><span data-stu-id="2f635-732">This event cannot be an <xref:System.Windows.EventTrigger> in a style.</span></span> <span data-ttu-id="2f635-733">Isso ocorre porque o campo de identificador desse evento reutiliza uma implementação de um serviço que não expor os métodos de adicionar ou remover o evento.</span><span class="sxs-lookup"><span data-stu-id="2f635-733">This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</span></span>  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="2f635-734">Informações de evento encaminhado</span><span class="sxs-lookup"><span data-stu-id="2f635-734">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2f635-735">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="2f635-735">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|  
|<span data-ttu-id="2f635-736">Estratégia de roteamento</span><span class="sxs-lookup"><span data-stu-id="2f635-736">Routing strategy</span></span>|<span data-ttu-id="2f635-737">Direto</span><span class="sxs-lookup"><span data-stu-id="2f635-737">Direct</span></span>|  
|<span data-ttu-id="2f635-738">delegado</span><span class="sxs-lookup"><span data-stu-id="2f635-738">Delegate</span></span>|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-739">Identifica a [Visão geral de eventos roteados](~/docs/framework/wpf/advanced/routed-events-overview.md) de <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-739">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-740">Objetos de identificador de evento são criados quando os eventos roteados são registrados (consulte <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) e, em seguida, pode ser usado para adicionar manipuladores de classe (consulte <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="2f635-740">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="2f635-741">Objetos de identificador contêm um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e um método de utilitário para adicionar proprietários para o evento.</span><span class="sxs-lookup"><span data-stu-id="2f635-741">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-742">Identifica a propriedade de dependência <see cref="P:System.Windows.FrameworkContentElement.ToolTip" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-742">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ToolTip" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">
          <span data-ttu-id="2f635-743">O identificador de chave do recurso a ser encontrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-743">Key identifier of the resource to be found.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2f635-744">Pesquisa um recurso com a chave especificada e retorna esse recurso, se encontrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-744">Searches for a resource with the specified key, and returns that resource if found.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2f635-745">O recurso localizado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-745">The found resource.</span>
          </span>
          <span data-ttu-id="2f635-746">Se nenhum recurso for localizado, <see langword="null" /> será retornado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-746">If no resource was found, <see langword="null" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-747">Se o recurso não foi encontrado no elemento de chamada, a árvore pai é pesquisada usando a árvore lógica, da mesma forma que a árvore será pesquisada se uma referência de recurso dinâmico foi solicitada por chave no tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="2f635-747">If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a dynamic resource reference were requested by key at run-time.</span></span>  
  
 <span data-ttu-id="2f635-748">Normalmente você imediatamente atribui o valor de retorno para o tipo da propriedade que você está tentando definido com o valor retornado do recurso.</span><span class="sxs-lookup"><span data-stu-id="2f635-748">Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</span></span>  
  
 <span data-ttu-id="2f635-749">O <xref:System.Windows.FrameworkContentElement.FindResource%2A> método tem um comportamento semelhante, exceto que ela irá gerar uma exceção no caso de não encontrar um recurso com a chave fornecida.</span><span class="sxs-lookup"><span data-stu-id="2f635-749">The <xref:System.Windows.FrameworkContentElement.FindResource%2A> method has similar behavior, except that it will throw an exception in the case of not finding a resource with the provided key.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f635-750">O exemplo a seguir encontra um recurso, conforme definido na marcação e o aplica a determinadas propriedades de um elemento em resposta a um evento roteado.</span><span class="sxs-lookup"><span data-stu-id="2f635-750">The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#tryfindresource)]
 [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#tryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-751">Ocorre quando o elemento é removido de uma árvore de elementos carregados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-751">Occurs when the element is removed from an element tree of loaded elements.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-752">Os eventos roteados diretos não seguem uma rota, somente são tratados dentro do mesmo elemento no qual eles são gerados.</span><span class="sxs-lookup"><span data-stu-id="2f635-752">Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</span></span> <span data-ttu-id="2f635-753">Eventos roteados diretos suportam outro comportamento eventos roteados: eles dão suporte a uma coleção de manipuladores acessível e pode ser usados como um <xref:System.Windows.EventTrigger> em um estilo.</span><span class="sxs-lookup"><span data-stu-id="2f635-753">Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <xref:System.Windows.EventTrigger> in a style.</span></span>  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="2f635-754">Informações de evento encaminhado</span><span class="sxs-lookup"><span data-stu-id="2f635-754">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2f635-755">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="2f635-755">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.UnloadedEvent>|  
|<span data-ttu-id="2f635-756">Estratégia de roteamento</span><span class="sxs-lookup"><span data-stu-id="2f635-756">Routing strategy</span></span>|<span data-ttu-id="2f635-757">Direto</span><span class="sxs-lookup"><span data-stu-id="2f635-757">Direct</span></span>|  
|<span data-ttu-id="2f635-758">delegado</span><span class="sxs-lookup"><span data-stu-id="2f635-758">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2f635-759">Identifica a [Visão geral de eventos roteados](~/docs/framework/wpf/advanced/routed-events-overview.md) de <see cref="E:System.Windows.FrameworkContentElement.Unloaded" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-759">Identifies the <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-760">Objetos de identificador de evento são criados quando os eventos roteados são registrados (consulte <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) e, em seguida, pode ser usado para adicionar manipuladores de classe (consulte <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="2f635-760">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="2f635-761">Objetos de identificador contêm um nome de identificação, tipo de proprietário, tipo de manipulador, estratégia de roteamento e um método de utilitário para adicionar proprietários para o evento.</span><span class="sxs-lookup"><span data-stu-id="2f635-761">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2f635-762">Nome do par de nome-objeto a ser removido do escopo atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-762">Name of the name-object pair to remove from the current scope.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2f635-763">Simplifica o acesso ao método de cancelamento de registro <see cref="T:System.Windows.NameScope" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-763">Simplifies access to the <see cref="T:System.Windows.NameScope" /> de-registration method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f635-764">Você só precisa cancelar o registro nomes se você pretende registrar novamente o outro elemento com o mesmo nome.</span><span class="sxs-lookup"><span data-stu-id="2f635-764">You only need to un-register names if you intend to re-register another element with that same name.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2f635-765">Reaplica o estilo padrão para o <see cref="T:System.Windows.FrameworkContentElement" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2f635-765">Reapplies the default style to the current <see cref="T:System.Windows.FrameworkContentElement" />.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>