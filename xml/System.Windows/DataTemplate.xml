<Type Name="DataTemplate" FullName="System.Windows.DataTemplate">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e1be32bee3ca5612f323121520537a6e04cc0a03" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56373372" /></Metadata><TypeSignature Language="C#" Value="public class DataTemplate : System.Windows.FrameworkTemplate" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DataTemplate extends System.Windows.FrameworkTemplate" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DataTemplate" />
  <TypeSignature Language="VB.NET" Value="Public Class DataTemplate&#xA;Inherits FrameworkTemplate" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataTemplate : System::Windows::FrameworkTemplate" />
  <TypeSignature Language="F#" Value="type DataTemplate = class&#xA;    inherit FrameworkTemplate" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkTemplate</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.DictionaryKeyProperty("DataTemplateKey")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Descreve a estrutura visual de um objeto de dados.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você usa um <xref:System.Windows.DataTemplate> para especificar a visualização dos seus objetos de dados. <xref:System.Windows.DataTemplate> objetos são particularmente úteis quando você está associando um <xref:System.Windows.Controls.ItemsControl> como um <xref:System.Windows.Controls.ListBox> para uma coleção inteira. Sem instruções específicas, uma <xref:System.Windows.Controls.ListBox> exibe a representação de cadeia de caracteres dos objetos em uma coleção. Nesse caso, você pode usar um <xref:System.Windows.DataTemplate> para definir a aparência de seus objetos de dados. O conteúdo de seu <xref:System.Windows.DataTemplate> torna-se a estrutura visual de seus objetos de dados.  
  
 Para uma discussão detalhada, consulte [visão geral de modelagem de dados](~/docs/framework/wpf/data/data-templating-overview.md).  
  
   
  
## Examples  
 O exemplo a seguir mostra como criar um <xref:System.Windows.DataTemplate> embutido. O <xref:System.Windows.DataTemplate> Especifica que cada item de dados aparece como três <xref:System.Windows.Controls.TextBlock> elementos dentro de um <xref:System.Windows.Controls.StackPanel>. Neste exemplo, o objeto de dados é uma classe chamada `Task`. Observe que cada <xref:System.Windows.Controls.TextBlock> elemento neste modelo está associado a uma propriedade do `Task` classe.  
  
 [!code-xaml[DataTemplatingIntro_snip#Inline](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#inline)]  
  
 É mais comum para definir um <xref:System.Windows.DataTemplate> na seção de recursos para que possa ser um objeto reutilizável, como no exemplo a seguir:  
  
 [!code-xaml[DataTemplatingIntro_snip#R1](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#r1)]  
[!code-xaml[DataTemplatingIntro_snip#AsResource](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#asresource)]  
[!code-xaml[DataTemplatingIntro_snip#R2](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#r2)]  
  
 Agora, é possível usar o `myTaskTemplate` como recurso, como no exemplo a seguir:  
  
 [!code-xaml[DataTemplatingIntro_snip#MyTaskTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#mytasktemplate)]  
  
 Para ver a amostra completa, consulte [Amostra da introdução à modelagem de dados](https://github.com/Microsoft/WPF-Samples/tree/master/Data%20Binding/DataTemplatingIntro).  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Data.Binding" />
    <altmember cref="T:System.Windows.Controls.DataTemplateSelector" />
    <altmember cref="T:System.Windows.HierarchicalDataTemplate" />
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=163703">Demonstração de associação de dados</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.DataTemplate" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DataTemplate.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTemplate();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.DataTemplate" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTemplate (object dataType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object dataType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DataTemplate.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataType As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTemplate(System::Object ^ dataType);" />
      <MemberSignature Language="F#" Value="new System.Windows.DataTemplate : obj -&gt; System.Windows.DataTemplate" Usage="new System.Windows.DataTemplate dataType" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataType" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dataType">Se o modelo destina-se a dados de objeto, este é o nome do Tipo do objeto de dados.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.DataTemplate" /> com a propriedade <see cref="P:System.Windows.DataTemplate.DataType" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para se referir ao nome do tipo da classe, use o [extensão de marcação X:Type](~/docs/framework/xaml-services/x-type-markup-extension.md). Se o modelo é destinado para [!INCLUDE[TLA#tla_xml](~/includes/tlasharptla-xml-md.md)] dados, isso é a cadeia de caracteres que representa o nome da marca dos dados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataTemplateKey">
      <MemberSignature Language="C#" Value="public object DataTemplateKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataTemplateKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DataTemplate.DataTemplateKey" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataTemplateKey As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataTemplateKey { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataTemplateKey : obj" Usage="System.Windows.DataTemplate.DataTemplateKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a chave padrão do <see cref="T:System.Windows.DataTemplate" />.</summary>
        <value>A chave padrão do <see cref="T:System.Windows.DataTemplate" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você não definir a [X:Key](~/docs/framework/xaml-services/x-key-directive.md) em um <xref:System.Windows.DataTemplate> que está em um <xref:System.Windows.ResourceDictionary>, o <xref:System.Windows.DataTemplate.DataTemplateKey%2A> é usado como a chave.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataType">
      <MemberSignature Language="C#" Value="public object DataType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DataTemplate.DataType" />
      <MemberSignature Language="VB.NET" Value="Public Property DataType As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataType { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataType : obj with get, set" Usage="System.Windows.DataTemplate.DataType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tipo para o qual esse <see cref="T:System.Windows.DataTemplate" /> foi projetado.</summary>
        <value>O valor padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade é muito semelhante do <xref:System.Windows.Style.TargetType%2A> propriedade do <xref:System.Windows.Style> classe. Quando você define essa propriedade como o tipo de dados sem especificar um `x:Key`, o <xref:System.Windows.DataTemplate> é aplicado automaticamente a objetos desse tipo de dados. Observe que, quando você faz isso a `x:Key` é definido implicitamente. Portanto, se você atribuir a esse <xref:System.Windows.DataTemplate> uma `x:Key` valor, você está substituindo implícito `x:Key` e o <xref:System.Windows.DataTemplate> não será aplicado automaticamente.  
  
 Observe também que, se você estiver associando um <xref:System.Windows.Controls.ContentControl> a uma coleção de `Task` objetos, o <xref:System.Windows.Controls.ContentControl> não usa o <xref:System.Windows.DataTemplate> automaticamente. Isso ocorre porque a associação em um <xref:System.Windows.Controls.ContentControl> precisa de mais informações para distinguir se você deseja associar a uma coleção inteira ou os objetos individuais. Se sua <xref:System.Windows.Controls.ContentControl> está acompanhando a seleção de um <xref:System.Windows.Controls.ItemsControl> tipo, você pode definir o <xref:System.Windows.Data.Binding.Path%2A> propriedade do <xref:System.Windows.Controls.ContentControl> associando a "`/`" para indicar que você está interessado no item atual. Para obter um exemplo, consulte [ Associar a uma coleção e exibir informações com base na seleção](~/docs/framework/wpf/data/how-to-bind-to-a-collection-and-display-information-based-on-selection.md). Caso contrário, você precisará especificar o <xref:System.Windows.DataTemplate> explicitamente, definindo o <xref:System.Windows.Controls.ContentControl.ContentTemplate%2A> propriedade.  
  
 O <xref:System.Windows.DataTemplate.DataType%2A> propriedade é particularmente útil quando você tem um <xref:System.Windows.Data.CompositeCollection> de diferentes tipos de objetos de dados.  
  
 Se essa propriedade for destinado a um elemento XML que não está no namespace padrão, você deve preceder o nome do elemento com o namespace ou um designador de namespace. Para XML exposta por meio de LINQ para XML, o namespace aparece entre chaves, precedidas por uma sequência de escape de chave:  
  
```xaml  
<DataTemplate DataType="{}{http://myNamespace}Details">  
```  
  
 Para XML exposto por meio de XPath, o nome do elemento é precedido por um designador de namespace estabelecido por uma instância do <xref:System.Windows.Data.XmlNamespaceMapping>:  
  
```xaml  
<DataTemplate DataType="mn:Details">  
```  
  
<a name="xamlAttributeUsage_DataType"></a>   
## <a name="xaml-attribute-usage"></a>Uso do Atributo XAML  
  
```  
<object DataType="typeName"/>  
```  
  
<a name="xamlValues_DataType"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *typeName*  
 Se o modelo destina-se a dados de objeto, essa propriedade contém o nome do tipo do objeto de dados (como uma cadeia de caracteres). Para se referir ao nome do tipo da classe, use o [extensão de marcação X:Type](~/docs/framework/xaml-services/x-type-markup-extension.md). Se o modelo é destinado para [!INCLUDE[TLA#tla_xml](~/includes/tlasharptla-xml-md.md)] dados, essa propriedade contém o nome do elemento XML. Consulte os comentários de documentação para obter detalhes sobre como especificar um namespace não padrão para o elemento XML.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160009">Introdução à amostra de modelagem de dados</related>
      </Docs>
    </Member>
    <Member MemberName="Triggers">
      <MemberSignature Language="C#" Value="public System.Windows.TriggerCollection Triggers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TriggerCollection Triggers" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DataTemplate.Triggers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Triggers As TriggerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TriggerCollection ^ Triggers { System::Windows::TriggerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Triggers : System.Windows.TriggerCollection" Usage="System.Windows.DataTemplate.Triggers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Markup.DependsOn("VisualTree")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Windows.Markup.DependsOn("Template")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.TriggerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma coleção de gatilhos que aplicam valores de propriedade ou executam ações com base em uma ou mais condições.</summary>
        <value>Uma coleção de objetos de gatilho. O valor padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você estiver criando gatilhos dentro de um modelo de dados, os setters de gatilhos devem ser definindo propriedades que estão dentro do escopo do modelo de dados. Caso contrário, ele pode ser mais adequado ao criar gatilhos usando um estilo que tem como alvo o tipo que contém os dados. Por exemplo, se você estiver associando um <xref:System.Windows.Controls.ListBox> controle, os contêineres são <xref:System.Windows.Controls.ListBoxItem> objetos. Se você estiver usando gatilhos para definir as propriedades que não estão dentro do escopo do <xref:System.Windows.DataTemplate>, ele poderá ser mais adequado ao criar um <xref:System.Windows.Controls.ListBoxItem> de estilo e criar gatilhos dentro desse estilo. Para obter mais informações, consulte o que pertence a um DataTemplate? no [visão geral de modelagem de dados](~/docs/framework/wpf/data/data-templating-overview.md).  
  
> [!NOTE]
>  Essa propriedade só pode ser definida [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] por meio da sintaxe de coleção mostrado ou acessando o objeto da coleção e usando seus vários métodos como Add. A propriedade para acessar o objeto de coleção é somente leitura, a coleção em si é leitura / gravação.  
  
<a name="xamlPropertyElementUsage_Triggers"></a>   
## <a name="xaml-property-element-usage"></a>Uso do elemento propriedade XAML  
  
```  
<object>  
  <object.Triggers>  
    OneOrMoreTriggers  
  </object.Triggers>  
</object>  
```  
  
<a name="xamlValues_Triggers"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *OneOrMoreTriggers*  
 Zero ou mais <xref:System.Windows.TriggerBase> objetos.  
  
   
  
## Examples  
 O seguinte <xref:System.Windows.DataTemplate> demonstra o uso do <xref:System.Windows.DataTemplate.Triggers%2A> propriedade.  
  
 [!code-xaml[DataBindingLab#AuctionItemDataTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/DataBindingLab/CSharp/DataBindingLabApp.xaml#auctionitemdatatemplate)]  
  
 Para o exemplo completo, consulte [Data Binding Demo](https://go.microsoft.com/fwlink/?LinkID=163703).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DataTrigger" />
        <altmember cref="T:System.Windows.MultiDataTrigger" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160009">Introdução à amostra de modelagem de dados</related>
      </Docs>
    </Member>
    <Member MemberName="ValidateTemplatedParent">
      <MemberSignature Language="C#" Value="protected override void ValidateTemplatedParent (System.Windows.FrameworkElement templatedParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ValidateTemplatedParent(class System.Windows.FrameworkElement templatedParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DataTemplate.ValidateTemplatedParent(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ValidateTemplatedParent (templatedParent As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ValidateTemplatedParent(System::Windows::FrameworkElement ^ templatedParent);" />
      <MemberSignature Language="F#" Value="override this.ValidateTemplatedParent : System.Windows.FrameworkElement -&gt; unit" Usage="dataTemplate.ValidateTemplatedParent templatedParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="templatedParent" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="templatedParent">O elemento ao qual este modelo é aplicado.</param>
        <summary>Verifica o pai modelo em relação a um conjunto de regras.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método usa as seguintes regras:  
  
-   O `templatedParent` deve ser não null <xref:System.Windows.FrameworkElement>.  
  
-   O <xref:System.Windows.DataTemplate> deve ser aplicado a um <xref:System.Windows.Controls.ContentPresenter>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>