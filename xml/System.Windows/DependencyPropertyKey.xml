<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="DependencyPropertyKey.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac59a12e407bc5345e416145c390f8fcd6f8262c445.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9a12e407bc5345e416145c390f8fcd6f8262c445</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyPropertyKey">
          <source>Provides a dependency property identifier for limited write access to a read-only dependency property.</source>
          <target state="translated">Fornece um identificador de propriedade de dependência para acesso de gravação limitado a uma propriedade de dependência somente leitura.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> instances are obtained as the return value of a dependency property registration call using the methods <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> instâncias são obtidas como o valor de retorno de uma chamada de registro de propriedade de dependência usando os métodos <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>The types that register a dependency property can use the <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> in calls to <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph> that adjust the property's value as part of class logic.</source>
          <target state="translated">Os tipos que registrar uma propriedade de dependência podem usar o <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> em chamadas para <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> e <ph id="ph3">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph> que ajustar o valor da propriedade como parte da lógica de classe.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>If permitted by the access level of the key, related classes can use the key and the dependency property also.</source>
          <target state="translated">Se permitido pelo nível de acesso da chave, classes relacionadas também podem usar a chave e a propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>For instance, you can declare the key as internal, and other types within the same assembly can also set that dependency property.</source>
          <target state="translated">Por exemplo, você pode declarar a chave como internos e outros tipos de dentro do mesmo assembly também podem definir a propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> returned by read-only dependency property registration should not be made public, because exposing the key makes the property settable, thus defeating the point of registering it as a read-only dependency property.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> retornado pela dependência de somente leitura registro da propriedade não deve ser feito público, como expor a chave torna a propriedade configurável, invalidando, assim, o ponto de registro-la como uma propriedade de dependência somente leitura.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>Also, exposing the key causes a mismatch between the available dependency property behaviors and its <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> property wrapper implementations, which is bad class design.</source>
          <target state="translated">Além disso, expondo a chave causa uma incompatibilidade entre a dependência disponível comportamentos de propriedade e seu <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> implementações de wrapper de propriedade, que é o design de classe inválido.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>Instead of exposing the key itself, you should instead expose the <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> value of the <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> as a <ph id="ph3">`public static readonly`</ph><ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph> on your class.</source>
          <target state="translated">Em vez de expor a chave em si, em vez disso, você deve expor o <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> valor o <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> como um <ph id="ph3">`public static readonly`</ph> <ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph> em sua classe.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>This enables the property to return a valid dependency property identifier for certain property system operations such as enumerating locally set values.</source>
          <target state="translated">Isso permite que a propriedade retornar um identificador de propriedade de dependência válido para determinadas operações de sistema de propriedades como a numeração de valores definidos localmente.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>However, the identifier thus obtained does not have the full capabilities of a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> for many property system operations.</source>
          <target state="translated">No entanto, o identificador obtido, portanto, não tem recursos completos de um <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> para várias operações de sistema de propriedade.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>The following example registers a read-only dependency property, and also uses the key for two purposes in other class members: implementing the get "wrapper", and as the identifier for a protected determination operation that sets the value based on calculations of other property values.</source>
          <target state="translated">O exemplo a seguir registra uma propriedade de dependência somente leitura e também usa a chave para dois propósitos em outros membros de classe: Implementando get "wrapper" e como o identificador para uma operação de determinação protegido que define o valor com base nos cálculos outros valores de propriedade.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>Gets the dependency property identifier associated with this specialized read-only dependency property identifier.</source>
          <target state="translated">Obtém o identificador de propriedade de dependência associado a este identificador de propriedade de dependência somente leitura especializado.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>The relevant dependency property identifier.</source>
          <target state="translated">O identificador de propriedade de dependência relevantes.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> value enables a read-only property's identifier to participate in common property system operations using some of the same interfaces as used for read-write dependency properties.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> valor permite que o identificador de uma propriedade somente leitura do participar de operações do sistema de propriedades usando algumas das mesmas interfaces usadas para propriedades de dependência de leitura / gravação em comum.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>In order to implement the get property accessor for a read-only dependency property, you should create and expose a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier on your class.</source>
          <target state="translated">Para implementar o acessador de propriedade get para uma propriedade de dependência somente leitura, você deve criar e expor um <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identificador em sua classe.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>This serves two purposes:</source>
          <target state="translated">Isso serve para duas finalidades:</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>Your own class needs the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier in order to implement the get accessor for the property wrapper.</source>
          <target state="translated">Suas necessidades de classe a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identificador para implementar o acessador get para o wrapper de propriedade.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>You use the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> as a parameter for the <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> call that implements the get accessor.</source>
          <target state="translated">Você usa o <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> como um parâmetro para o <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> chamada que implementa o acessador get.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifiers expose your dependency property to the property system such that other methods that rely on metadata can access it in a standard form.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identificadores de expõem sua propriedade de dependência para o sistema de propriedade, de modo que outros métodos que se baseiam nos metadados podem acessá-lo em um formato padrão.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>For instance, if you called <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;</ph> on some <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> and obtained an enumeration of locally set properties (values and identifiers) the identifier returned for a read-only dependency property would be your <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> value rather than the key.</source>
          <target state="translated">Por exemplo, se você chamou <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;</ph> em alguns <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> e obter uma enumeração de localmente conjunto de propriedades (valores e identificadores) o identificador retornado para uma propriedade de dependência somente leitura seria o <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> valor em vez da chave.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>Not exposing a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier does not increase the security of your read-only dependency property in any way, it just makes operations that involve your property more awkward both for subsequent derived classes and class instances.</source>
          <target state="translated">Não expor um <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identificador não aumenta a segurança de sua propriedade de dependência somente leitura de qualquer forma, isso facilita as operações que envolvem a mais complicado para classes derivadas subsequentes e instâncias de classe de propriedade.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>To expose the  <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier on your class, you call <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> directly on your key.</source>
          <target state="translated">Para expor o <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identificador em sua classe, chame <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> diretamente em sua chave.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>Use this value to create a <ph id="ph1">`public static readonly`</ph><ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier on the class, which parallels the <ph id="ph3">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>.</source>
          <target state="translated">Use esse valor para criar um <ph id="ph1">`public static readonly`</ph> <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identificador na classe, comparável ao <ph id="ph3">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>The following example calls <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> to expose the <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier (<ph id="ph3">`AquariumGraphicProperty`</ph>) for the <ph id="ph4">`AquariumGraphic`</ph> read-only dependency property on a class.</source>
          <target state="translated">A exemplo a seguir chama <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> para expor o <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identificador (<ph id="ph3">`AquariumGraphicProperty`</ph>) para o <ph id="ph4">`AquariumGraphic`</ph> propriedade de dependência somente leitura em uma classe.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>The example also shows the <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> creation (as an internal member) and the get accessor for <ph id="ph2">`AquariumGraphic`</ph>.</source>
          <target state="translated">O exemplo também mostra o <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> criação (como um membro interno) e o acessador get para <ph id="ph2">`AquariumGraphic`</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>The type on which this dependency property exists and metadata should be overridden.</source>
          <target state="translated">O tipo no qual essa propriedade de dependência existe e os metadados devem ser substituídos.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Metadata supplied for this type.</source>
          <target state="translated">Metadados fornecidos para esse tipo.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Overrides the metadata of a read-only dependency property that is represented by this dependency property identifier.</source>
          <target state="translated">Substitui os metadados de uma propriedade de dependência somente leitura que é representada por esse identificador de propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Overriding metadata on a read-only dependency property is done for similar reasons as overriding metadata on a read-write dependency property, and is restricted to access at the key level because behaviors specified in the metadata can change the set behavior (the default value, for instance).</source>
          <target state="translated">Substituir os metadados em uma propriedade de dependência somente leitura é feita por motivos semelhantes como substituir os metadados em uma propriedade de dependência de leitura / gravação e é restrito a acesso no nível de chave porque comportamentos especificados nos metadados podem alterar o comportamento do conjunto (o valor padrão, por exemplo).</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>As with read-write dependency properties, overriding metadata on a read-only dependency property should only be done prior to that property being placed in use by the property system (this equates to the time that specific instances of objects that register the property are instantiated).</source>
          <target state="translated">Como com as propriedades de dependência de leitura / gravação, substituir os metadados em uma propriedade de dependência somente leitura só deve ser feito antes da propriedade que está sendo colocada em uso pelo sistema de propriedade (Isso é igual ao tempo que são criadas instâncias de instâncias específicas de objetos que registra a propriedade).</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Calls to <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;</ph> should only be performed within the static constructors of the type that provides itself as the <ph id="ph2">`forType`</ph> parameter of this method, or equivalent initialization for that class.</source>
          <target state="translated">Chamadas para <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;</ph> só deve ser executada dentro de construtores estáticos do tipo que fornece a próprio como o <ph id="ph2">`forType`</ph> parâmetro deste método ou inicialização equivalente para essa classe.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>This method effectively forwards to the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> method, passing the <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> instance as the key parameter.</source>
          <target state="translated">Esse método efetivamente encaminha para o <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> método, passando o <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> instância como o parâmetro de chave.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>The following example overrides metadata for an existing read-only dependency property that a class inherits.</source>
          <target state="translated">O exemplo a seguir substitui os metadados para uma propriedade de dependência somente leitura existente que herda de uma classe.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>In this case, the scenario goal was to add a coerce value callback that the base property metadata did not have.</source>
          <target state="translated">Nesse caso, a meta de cenário foi adicionar um retorno de chamada do valor de forçados não tinha os metadados da propriedade base.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>You could also override metadata for any of the other reasons that overriding metadata is typically appropriate (changing default value, adding <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> values, etc.)</source>
          <target state="translated">Você também pode substituir os metadados em qualquer um dos outros motivos que substituir os metadados é normalmente apropriados (alterando o valor padrão, adicionando <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> valores, etc.)</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Attempted metadata override on a read-write dependency property (cannot be done using this signature).</source>
          <target state="translated">Ocorreu uma tentativa de substituir os metadados em uma propriedade de dependência de leitura/gravação (não pode ser feita usando essa assinatura).</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Metadata was already established for the property as it exists on the provided type.</source>
          <target state="translated">Os metadados já foram estabelecidos para a propriedade como ela existe no tipo fornecido.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>