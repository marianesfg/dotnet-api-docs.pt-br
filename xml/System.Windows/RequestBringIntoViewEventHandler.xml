<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="RequestBringIntoViewEventHandler.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5cda95cbf8cf82761ed796773cf82db1b1779f599.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cda95cbf8cf82761ed796773cf82db1b1779f599</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>The object where the event handler is attached.</source>
          <target state="translated">O objeto em que o manipulador de eventos está anexado.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>The event data.</source>
          <target state="translated">Os dados do evento.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>Represents the method that will handle the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /&gt;</ph> routed event.</source>
          <target state="translated">Representa o método que manipulará o evento roteado <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>Handling this event is typically only done within elements that support a scrollable region, or otherwise deliberately set their rendering size smaller than the combined desired size of their child element content, and is only done by deliberately handling the event once it has routed upwards in the element tree and has reached the first parent that offers scrolling region support.</source>
          <target state="translated">O evento normalmente é feito somente em elementos que oferecem suporte a uma região de rolagem, ou caso contrário deliberadamente definir seu tamanho de renderização menor do que o tamanho desejado combinado de seu conteúdo de elemento filho e é feito apenas por deliberadamente manipular o evento depois que ele encaminhado para cima na árvore de elementos e atingiu o primeiro parente que oferece suporte de região de rolagem.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>An existing implementation that handles scrolling regions in a manner that is typically desirable for user controls is <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>.</source>
          <target state="translated">Uma implementação que manipula as áreas de rolagem de uma maneira que é normalmente recomendado para controles de usuário é <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>If you derive from <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>, you can register a class handler for <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType&gt;</ph> and supplement the base class handling of the event.</source>
          <target state="translated">Se você derivar de <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>, você pode registrar um manipulador de classe para <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType&gt;</ph> e completar o tratamento de classe base do evento.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>You should also consider using or class-handling the class-defined <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer.ScrollChanged&gt;</ph> event instead of <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Você também deve considerar o uso ou a classe definida de tratamento de classe <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer.ScrollChanged&gt;</ph> eventos em vez de <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>Alternatively, if you create an entirely custom class that does not derive from <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>, you can still add class handling by calling <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A?displayProperty=nameWithType&gt;</ph> in your class instantiation.</source>
          <target state="translated">Como alternativa, se você criar uma classe totalmente personalizada que não derivam de <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>, você ainda poderá adicionar classe tratamento chamando <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A?displayProperty=nameWithType&gt;</ph> em sua instanciação de classe.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>For details on class handling, see <bpt id="p1">[</bpt>Marking Routed Events as Handled, and Class Handling<ept id="p1">](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)</ept>.</source>
          <target state="translated">Para obter detalhes sobre a manipulação de classe, consulte <bpt id="p1">[</bpt>marcar eventos roteados como Handled e tratamento de classe<ept id="p1">](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)</ept>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>Content elements can cause the event to be raised by their content hosts (through calling <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BringIntoView%2A&gt;</ph> and raising <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType&gt;</ph> from the content host).</source>
          <target state="translated">Elementos de conteúdo podem fazer com que o evento a ser gerado por seus hosts de conteúdo (chamando <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BringIntoView%2A&gt;</ph> e gerando <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType&gt;</ph> do host de conteúdo).</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>Similarly, you can request logical tree elements to be brought into view with the helper method <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.BringIntoView%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Da mesma forma, você pode solicitar os elementos de árvore lógica para ser colocado em modo de exibição com o método auxiliar <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.BringIntoView%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>A <ph id="ph1">&lt;xref:System.Windows.Controls.ListBox&gt;</ph> implements a related but different method <ph id="ph2">&lt;xref:System.Windows.Controls.ListBox.ScrollIntoView%2A&gt;</ph>.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Windows.Controls.ListBox&gt;</ph> implementa um método relacionado, mas diferente <ph id="ph2">&lt;xref:System.Windows.Controls.ListBox.ScrollIntoView%2A&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>