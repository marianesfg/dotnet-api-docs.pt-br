<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="CoerceValueCallback.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5edddfb39d197bb5c7d9ebb6e4c366a99eae21935.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">edddfb39d197bb5c7d9ebb6e4c366a99eae21935</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.CoerceValueCallback">
          <source>The object that the property exists on.</source>
          <target state="translated">O objeto na qual a propriedade existe.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Windows.CoerceValueCallback">
          <source>When the callback is invoked, the property system will pass this value.</source>
          <target state="translated">Quando o retorno de chamada for invocado, o sistema de propriedade passará esse valor.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" uid="T:System.Windows.CoerceValueCallback">
          <source>The new value of the property, prior to any coercion attempt.</source>
          <target state="translated">O novo valor da propriedade, antes de qualquer tentativa de coerção.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" uid="T:System.Windows.CoerceValueCallback">
          <source>Provides a template for a method that is called whenever a dependency property value is being re-evaluated, or coercion is specifically requested.</source>
          <target state="translated">Fornece um modelo para um método que é chamado sempre que um valor da propriedade de dependência está sendo reavaliado ou a coerção é especificamente solicitada.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" uid="T:System.Windows.CoerceValueCallback">
          <source>The coerced value (with appropriate type).</source>
          <target state="translated">O valor imposto (com o tipo apropriado).</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Callbacks based on <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> can be assigned to a dependency property through several different techniques.</source>
          <target state="translated">Retornos de chamada com base em <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> pode ser atribuído a uma propriedade de dependência por meio de várias técnicas diferentes.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Each of these techniques requires that you first create a new property metadata object (<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>, or a derived class such as <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>).</source>
          <target state="translated">Cada uma dessas técnicas requer que você primeiro crie um novo objeto de metadados de propriedade (<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>, ou uma classe derivada como <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Create the metadata object using a constructor signature that takes the <ph id="ph1">`coerceValueCallback`</ph> parameter, and assign that parameter to your callback handler.</source>
          <target state="translated">Criar o objeto de metadados usando uma assinatura de construtor que recebe o <ph id="ph1">`coerceValueCallback`</ph> parâmetro e atribuir esse parâmetro para o manipulador de retorno de chamada.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Or construct the metadata by any signature and set the <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> property prior to putting the metadata in use.</source>
          <target state="translated">Ou criar os metadados por qualquer assinatura e o conjunto de <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> propriedade antes de colocar os metadados em uso.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>When you have this metadata, you can:</source>
          <target state="translated">Quando você tiver esses metadados, você pode:</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Define a new dependency property on a new class, using either signature of  <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, giving the metadata as the <ph id="ph2">`typeMetadata`</ph> value.</source>
          <target state="translated">Definir uma nova propriedade de dependência em uma nova classe, usando qualquer uma das assinaturas de <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, fornecendo os metadados, como o <ph id="ph2">`typeMetadata`</ph> valor.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Override the metadata (call <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>) for an existing dependency property, when you derive from the class that owns the dependency property.</source>
          <target state="translated">Substituir os metadados (chamar <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>) para uma propriedade de dependência existente, quando você derivar da classe que possui a propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Add an existing dependency property to a new <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> class, using new metadata, by calling <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>.</source>
          <target state="translated">Adicionar uma propriedade de dependência existente para um novo <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> de classe, usando os novos metadados, chamando <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Implementations of this callback should check the value in <ph id="ph1">`baseValue`</ph> and determine based on either the value or the type whether this is a value that needs to be further coerced.</source>
          <target state="translated">Implementações desse retorno de chamada devem verificar o valor <ph id="ph1">`baseValue`</ph> e determinar com base no valor ou o tipo, se este é um valor que precisa ser forçado adicional.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>The <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> for a dependency property is invoked any time that the property system or any other caller calls <ph id="ph2">&lt;xref:System.Windows.DependencyObject.CoerceValue%2A&gt;</ph> on a <ph id="ph3">&lt;xref:System.Windows.DependencyObject&gt;</ph> instance, specifying that property's identifier as the <ph id="ph4">`dp`</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> de uma dependência de propriedade é invocada sempre que o sistema de propriedade ou qualquer outro chamador chama <ph id="ph2">&lt;xref:System.Windows.DependencyObject.CoerceValue%2A&gt;</ph> em uma <ph id="ph3">&lt;xref:System.Windows.DependencyObject&gt;</ph> instância, especificando o identificador da propriedade como o <ph id="ph4">`dp`</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Changes to the property value may have come from any possible participant in the property system.</source>
          <target state="translated">As alterações para o valor da propriedade podem ter vindo de qualquer participante possíveis no sistema de propriedade.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>This includes styles, generic invalidation, triggers, property value inheritance, and local value setting.</source>
          <target state="translated">Isso inclui estilos, invalidação genérica, gatilhos, herança de valor de propriedade e configuração do valor local.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Generally you should avoid specifying more than one <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> for any given dependency property (overriding or adding with new metadata for a dependency property that already had a <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph>).</source>
          <target state="translated">Geralmente você deve evitar a especificação de mais de um <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> para qualquer dado propriedade de dependência (substituindo ou adição de novos metadados para uma propriedade de dependência que já tinha um <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Only one of the callbacks will be able to act. The acting callback will be the one that was applied to the most derived class in the inheritance as compared to the <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> caller.</source>
          <target state="translated">Somente um dos retornos de chamada poderá agir. O retorno de chamada de ação será aquele que foi aplicado à classe mais derivado na herança, em comparação com o <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> chamador.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Other callbacks as assigned to metadata for the dependency property as it existed higher in the owner hierarchy are replaced when the metadata is overridden.</source>
          <target state="translated">Outras chamadas de retorno conforme são atribuídos a metadados para a propriedade de dependência que existia superior na hierarquia de proprietário são substituídas quando os metadados é substituído.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>The following example includes an implementation of this callback to coerce the stored value of a dependency property based on other inputs, such as another property's value.</source>
          <target state="translated">O exemplo a seguir inclui uma implementação desse retorno de chamada para forçar o valor armazenado da propriedade de dependência com base em outras entradas, como o valor da propriedade da outra.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>In this case, the callback checks to see whether the <ph id="ph1">`ShirtType`</ph> property corresponds to a type of shirt that has buttons; if so it establishes a starting default color for the <ph id="ph2">`ButtonColor`</ph>, if the shirt type has no buttons, it coerces the <ph id="ph3">`ButtonColor`</ph> value back to a starting value, which causes the <ph id="ph4">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph> (not shown) to remove that dropdown from the effective choices.</source>
          <target state="translated">Nesse caso, o retorno de chamada verifica se o <ph id="ph1">`ShirtType`</ph> propriedade corresponde a um tipo de camisa com botões; nesse caso, ele estabelece uma cor inicial do padrão para o <ph id="ph2">`ButtonColor`</ph>, se o tipo de camisa botões não força o <ph id="ph3">`ButtonColor`</ph> valor como um valor inicial, que faz com que o <ph id="ph4">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph> (não mostrado) para remover essa lista suspensa com as opções de efetivas.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>