<Type Name="CodeAccessPermission" FullName="System.Security.CodeAccessPermission">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b497a3cd20cb1d0ae8172ce6caf259ae001ddee0" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30500850" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class CodeAccessPermission : System.Security.IPermission, System.Security.IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit CodeAccessPermission extends System.Object implements class System.Security.IPermission, class System.Security.ISecurityEncodable, class System.Security.IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.CodeAccessPermission" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CodeAccessPermission&#xA;Implements IPermission, IStackWalk" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeAccessPermission abstract : System::Security::IPermission, System::Security::IStackWalk" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Security.IPermission</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IStackWalk</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="87865-101">Define a estrutura subjacente de todas as permissões de acesso do código.</span>
      <span class="sxs-lookup">
        <span data-stu-id="87865-101">Defines the underlying structure of all code access permissions.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="87865-102">Permissões de acesso de código usam um exame da pilha para garantir que todos os chamadores do código receberam uma permissão.</span><span class="sxs-lookup"><span data-stu-id="87865-102">Code access permissions use a stack walk to ensure that all callers of the code have been granted a permission.</span></span> <span data-ttu-id="87865-103">Se for um objeto de permissão `null`, ela será manipulada o mesmo que um objeto de permissão com o estado <xref:System.Security.Permissions.PermissionState.None?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="87865-103">If a permission object is `null`, it is handled the same as a permission object with the state <xref:System.Security.Permissions.PermissionState.None?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="87865-104">A pilha de chamadas é representada geralmente como crescimento para baixo, para que os métodos superiores na pilha de chamadas chamam métodos inferior na pilha de chamadas.</span><span class="sxs-lookup"><span data-stu-id="87865-104">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 <span data-ttu-id="87865-105">Herdeiros do <xref:System.Security.CodeAccessPermission> classe deve ser concedida confiança total para funcionar corretamente, estendendo a infraestrutura de segurança de permissões.</span><span class="sxs-lookup"><span data-stu-id="87865-105">Inheritors of the <xref:System.Security.CodeAccessPermission> class must be granted full trust to function correctly as permissions extending the security infrastructure.</span></span> <span data-ttu-id="87865-106">Para determinar que os herdeiros são totalmente confiáveis, <xref:System.Security.CodeAccessPermission> problemas um <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> para <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence>  =  `true` e <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy>  =  `true`.</span><span class="sxs-lookup"><span data-stu-id="87865-106">To determine that the inheritors are fully trusted, <xref:System.Security.CodeAccessPermission> issues an <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> for <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence> = `true` and <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy> = `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="87865-107">O exemplo de código a seguir mostra uma permissão que deriva de <xref:System.Security.CodeAccessPermission> classe.</span><span class="sxs-lookup"><span data-stu-id="87865-107">The following code example shows a permission derived from the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#1)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#1)]
 [!code-vb[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
      <span data-ttu-id="87865-108">a capacidade de herdeiros para fornecer evidências e exibir e modificar a política.</span>
      <span class="sxs-lookup">
        <span data-stu-id="87865-108">for the ability of inheritors to provide evidence and view and modify policy.</span>
      </span>
      <span data-ttu-id="87865-109">Enumerações associadas: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />, <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</span>
      <span class="sxs-lookup">
        <span data-stu-id="87865-109">Associated enumerations: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />, <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</span>
      </span>
    </permission>
    <block subset="none" type="overrides">
      <para>
        <span data-ttu-id="87865-110">Ao herdar de <see cref="T:System.Security.CodeAccessPermission" />, você também deve implementar o <see cref="T:System.Security.Permissions.IUnrestrictedPermission" /> interface.</span>
        <span class="sxs-lookup">
          <span data-stu-id="87865-110">When you inherit from <see cref="T:System.Security.CodeAccessPermission" />, you must also implement the <see cref="T:System.Security.Permissions.IUnrestrictedPermission" /> interface.</span>
        </span>
        <span data-ttu-id="87865-111">O seguinte <see cref="T:System.Security.CodeAccessPermission" /> membros devem ser substituídos: <see cref="M:System.Security.CodeAccessPermission.Copy" />, <see cref="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.ToXml" />, <see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />, e <see cref="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />.</span>
        <span class="sxs-lookup">
          <span data-stu-id="87865-111">The following <see cref="T:System.Security.CodeAccessPermission" /> members must be overridden: <see cref="M:System.Security.CodeAccessPermission.Copy" />, <see cref="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.ToXml" />, <see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />, and <see cref="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />.</span>
        </span>
        <span data-ttu-id="87865-112">Você também deve definir um construtor que aceita um <see cref="T:System.Security.Permissions.PermissionState" /> como seu único parâmetro.</span>
        <span class="sxs-lookup">
          <span data-stu-id="87865-112">You must also define a constructor that takes a <see cref="T:System.Security.Permissions.PermissionState" /> as its only parameter.</span>
        </span>
        <span data-ttu-id="87865-113">Você deve aplicar o <see cref="T:System.SerializableAttribute" /> atributo a uma classe que herda de <see cref="T:System.Security.CodeAccessPermission" />.</span>
        <span class="sxs-lookup">
          <span data-stu-id="87865-113">You must apply the <see cref="T:System.SerializableAttribute" /> attribute to a class that inherits from <see cref="T:System.Security.CodeAccessPermission" />.</span>
        </span>
      </para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeAccessPermission ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CodeAccessPermission();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="87865-114">Inicializa uma nova instância da classe <see cref="T:System.Security.CodeAccessPermission" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-114">Initializes a new instance of the <see cref="T:System.Security.CodeAccessPermission" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="87865-115">Este construtor é chamado para inicializar o estado no tipo sempre que uma instância da classe derivada é criada.</span><span class="sxs-lookup"><span data-stu-id="87865-115">This constructor is called to initialize state in the type whenever an instance of the derived class is created.</span></span> <span data-ttu-id="87865-116">Embora você pode chamar explicitamente esse construtor na declaração de construtor do construtor de classe derivada, isso geralmente não é necessário; a maioria dos compiladores gerará automaticamente a chamada para você.</span><span class="sxs-lookup"><span data-stu-id="87865-116">Although you can explicitly call this constructor in the constructor declaration of the derived class constructor, this is not usually necessary; most compilers will automatically generate the call for you.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Assert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Assert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Assert();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Assert</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="87865-117">Declara que o código de chamada pode acessar o recurso protegido por uma demanda de permissão através do código que chama este método, mesmo que os chamadores na pilha não tenham recebido permissão para acessar o recurso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-117">Declares that the calling code can access the resource protected by a permission demand through the code that calls this method, even if callers higher in the stack have not been granted permission to access the resource.</span>
          </span>
          <span data-ttu-id="87865-118">Usar <see cref="M:System.Security.CodeAccessPermission.Assert" /> pode criar problemas de segurança.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-118">Using <see cref="M:System.Security.CodeAccessPermission.Assert" /> can create security issues.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="87865-119">A pilha de chamadas é representada geralmente como crescimento para baixo, para que os métodos superiores na pilha de chamadas chamam métodos inferior na pilha de chamadas.</span><span class="sxs-lookup"><span data-stu-id="87865-119">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span> <span data-ttu-id="87865-120">Chamando <xref:System.Security.CodeAccessPermission.Assert%2A> impede que um exame da pilha de origem inferior na pilha de chamadas de continuar a pilha de chamadas além do código que chama esse método.</span><span class="sxs-lookup"><span data-stu-id="87865-120">Calling <xref:System.Security.CodeAccessPermission.Assert%2A> prevents a stack walk originating lower in the call stack from proceeding up the call stack beyond the code that calls this method.</span></span> <span data-ttu-id="87865-121">Portanto, mesmo que os chamadores superior na pilha de chamadas não tem as permissões necessárias para acessar um recurso, eles ainda podem acessá-lo por meio do código que chama esse método em que a permissão necessária.</span><span class="sxs-lookup"><span data-stu-id="87865-121">Therefore, even if callers higher on the call stack do not have the requisite permissions to access a resource, they can still access it through the code that calls this method on the necessary permission.</span></span> <span data-ttu-id="87865-122">Uma asserção é eficaz somente se o código que chama <xref:System.Security.CodeAccessPermission.Assert%2A> passa na verificação de segurança para a permissão que está declarando.</span><span class="sxs-lookup"><span data-stu-id="87865-122">An assertion is effective only if the code that calls <xref:System.Security.CodeAccessPermission.Assert%2A> passes the security check for the permission that it is asserting.</span></span>  
  
 <span data-ttu-id="87865-123">A chamada para <xref:System.Security.CodeAccessPermission.Assert%2A> é eficiente, até que o código de chamada retorna ao chamador.</span><span class="sxs-lookup"><span data-stu-id="87865-123">The call to <xref:System.Security.CodeAccessPermission.Assert%2A> is effective until the calling code returns to its caller.</span></span> <span data-ttu-id="87865-124">Apenas um <xref:System.Security.CodeAccessPermission.Assert%2A> podem estar ativas em um quadro.</span><span class="sxs-lookup"><span data-stu-id="87865-124">Only one <xref:System.Security.CodeAccessPermission.Assert%2A> can be active on a frame.</span></span> <span data-ttu-id="87865-125">Uma tentativa de chamar <xref:System.Security.CodeAccessPermission.Assert%2A> quando um ativo <xref:System.Security.CodeAccessPermission.Assert%2A> existe nos resultados do quadro um <xref:System.Security.SecurityException>.</span><span class="sxs-lookup"><span data-stu-id="87865-125">An attempt to call <xref:System.Security.CodeAccessPermission.Assert%2A> when an active <xref:System.Security.CodeAccessPermission.Assert%2A> exists on the frame results in a <xref:System.Security.SecurityException>.</span></span> <span data-ttu-id="87865-126">Chamar <xref:System.Security.CodeAccessPermission.RevertAssert%2A> ou <xref:System.Security.CodeAccessPermission.RevertAll%2A> para remover um ativo <xref:System.Security.CodeAccessPermission.Assert%2A>.</span><span class="sxs-lookup"><span data-stu-id="87865-126">Call <xref:System.Security.CodeAccessPermission.RevertAssert%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active <xref:System.Security.CodeAccessPermission.Assert%2A>.</span></span>  
  
 <span data-ttu-id="87865-127"><xref:System.Security.CodeAccessPermission.Assert%2A> é ignorado para uma permissão concedida não porque uma solicitação de permissão não terá êxito.</span><span class="sxs-lookup"><span data-stu-id="87865-127"><xref:System.Security.CodeAccessPermission.Assert%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="87865-128">No entanto, se inferior na pilha de chamadas de código chama <xref:System.Security.CodeAccessPermission.Demand%2A> para essa permissão, um <xref:System.Security.SecurityException> é gerada quando a movimentação da pilha atinge o código que tentou chamar <xref:System.Security.CodeAccessPermission.Assert%2A>.</span><span class="sxs-lookup"><span data-stu-id="87865-128">However, if code lower on the call stack calls <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.CodeAccessPermission.Assert%2A>.</span></span> <span data-ttu-id="87865-129">Isso ocorre porque o código que chamou <xref:System.Security.CodeAccessPermission.Assert%2A> não recebeu a permissão, mesmo que ele tentou <xref:System.Security.CodeAccessPermission.Assert%2A> -lo.</span><span class="sxs-lookup"><span data-stu-id="87865-129">This happens because the code that called <xref:System.Security.CodeAccessPermission.Assert%2A> has not been granted the permission, even though it tried to <xref:System.Security.CodeAccessPermission.Assert%2A> it.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="87865-130">Como chamar <xref:System.Security.CodeAccessPermission.Assert%2A> remove o requisito de que todos os código da cadeia de chamada deve ter permissão para acessar o recurso especificado, ele poderá abrir problemas de segurança se usado incorretamente ou inadequadamente.</span><span class="sxs-lookup"><span data-stu-id="87865-130">Because calling <xref:System.Security.CodeAccessPermission.Assert%2A> removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security issues if used incorrectly or inappropriately.</span></span> <span data-ttu-id="87865-131">Portanto, ele deve ser usado com cuidado.</span><span class="sxs-lookup"><span data-stu-id="87865-131">Therefore, it should be used with great caution.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="87865-132">O código de chamada não tem <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-132">The calling code does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</span>
          </span>
          <span data-ttu-id="87865-133">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-133">-or-</span>
          </span>
          <span data-ttu-id="87865-134">Já existe um <see cref="M:System.Security.CodeAccessPermission.Assert" /> ativo para o quadro atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-134">There is already an active <see cref="M:System.Security.CodeAccessPermission.Assert" /> for the current frame.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="87865-135">a capacidade de chamar <see cref="M:System.Security.CodeAccessPermission.Assert" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-135">for the ability to call <see cref="M:System.Security.CodeAccessPermission.Assert" />.</span>
          </span>
          <span data-ttu-id="87865-136">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-136">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /></span>
          </span>
        </permission>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="87865-137">Você não pode substituir esse método.</span>
            <span class="sxs-lookup">
              <span data-stu-id="87865-137">You cannot override this method.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public abstract System.Security.IPermission Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Copy" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Copy () As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::IPermission ^ Copy();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Copy</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="87865-138">Quando implementada por uma classe derivada, cria e retorna uma cópia idêntica do objeto de permissão atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-138">When implemented by a derived class, creates and returns an identical copy of the current permission object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="87865-139">Uma cópia do objeto de permissão atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-139">A copy of the current permission object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="87865-140">Uma cópia de um objeto de permissão representa o mesmo acesso a recursos como o objeto de permissão original.</span><span class="sxs-lookup"><span data-stu-id="87865-140">A copy of a permission object represents the same access to resources as the original permission object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="87865-141">O exemplo de código a seguir mostra uma substituição do <xref:System.Security.CodeAccessPermission.Copy%2A> método.</span><span class="sxs-lookup"><span data-stu-id="87865-141">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.Copy%2A> method.</span></span> <span data-ttu-id="87865-142">Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.Security.CodeAccessPermission> classe.</span><span class="sxs-lookup"><span data-stu-id="87865-142">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#2)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#2)]
 [!code-vb[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="87865-143">Você deve substituir esse método em uma classe derivada.</span>
            <span class="sxs-lookup">
              <span data-stu-id="87865-143">You must override this method in a derived class.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Demand();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Demand</InterfaceMember>
        <InterfaceMember>M:System.Security.IStackWalk.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="87865-144">Força um <see cref="T:System.Security.SecurityException" /> no tempo de execução se todos os chamadores no topo da pilha de chamadas não receberam as permissões especificadas pela instância atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-144">Forces a <see cref="T:System.Security.SecurityException" /> at run time if all callers higher in the call stack have not been granted the permission specified by the current instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="87865-145">Normalmente, esse método é usado pelas bibliotecas seguras para garantir que os chamadores tem permissão para acessar um recurso.</span><span class="sxs-lookup"><span data-stu-id="87865-145">This method is typically used by secure libraries to ensure that callers have permission to access a resource.</span></span> <span data-ttu-id="87865-146">Por exemplo, uma classe de arquivo em uma biblioteca de classe seguro chama <xref:System.Security.CodeAccessPermission.Demand%2A> para necessários <xref:System.Security.Permissions.FileIOPermission> antes de executar uma operação de arquivo solicitada pelo chamador.</span><span class="sxs-lookup"><span data-stu-id="87865-146">For example, a file class in a secure class library calls <xref:System.Security.CodeAccessPermission.Demand%2A> for the necessary <xref:System.Security.Permissions.FileIOPermission> before performing a file operation requested by the caller.</span></span>  
  
 <span data-ttu-id="87865-147">As permissões do código que chama esse método não são examinadas; a seleção começa o chamador imediato do código e continua na pilha.</span><span class="sxs-lookup"><span data-stu-id="87865-147">The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack.</span></span> <span data-ttu-id="87865-148">A pilha de chamadas é representada geralmente como crescimento para baixo, para que os métodos superiores na pilha de chamadas chamam métodos inferior na pilha de chamadas.</span><span class="sxs-lookup"><span data-stu-id="87865-148">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span> <span data-ttu-id="87865-149"><xref:System.Security.CodeAccessPermission.Demand%2A> é realizada somente se nenhuma <xref:System.Security.SecurityException> é gerado.</span><span class="sxs-lookup"><span data-stu-id="87865-149"><xref:System.Security.CodeAccessPermission.Demand%2A> succeeds only if no <xref:System.Security.SecurityException> is raised.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="87865-150">Um chamador superior na pilha de chamadas não tem a permissão especificada na instância atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-150">A caller higher in the call stack does not have the permission specified by the current instance.</span>
          </span>
          <span data-ttu-id="87865-151">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-151">-or-</span>
          </span>
          <span data-ttu-id="87865-152">Um chamador superior na pilha de chamadas chamou <see cref="M:System.Security.CodeAccessPermission.Deny" /> no objeto de permissão atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-152">A caller higher in the call stack has called <see cref="M:System.Security.CodeAccessPermission.Deny" /> on the current permission object.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="87865-153">Você não pode substituir esse método.</span>
            <span class="sxs-lookup">
              <span data-stu-id="87865-153">You cannot override this method.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Deny" />
      <MemberSignature Language="VB.NET" Value="Public Sub Deny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Deny();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Deny</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="87865-154">Impede que os chamadores no nível superior da pilha de chamadas usem o código que chama esse método para acessar o recurso especificado pela instância atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-154">Prevents callers higher in the call stack from using the code that calls this method to access the resource specified by the current instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="87865-155">O <xref:System.Security.CodeAccessPermission.Deny%2A> método deve ser usado apenas para proteger os recursos do access acidental por código totalmente confiável.</span><span class="sxs-lookup"><span data-stu-id="87865-155">The <xref:System.Security.CodeAccessPermission.Deny%2A> method should be used only to protect resources from accidental access by fully trusted code.</span></span> <span data-ttu-id="87865-156">Ele não deve ser usado para proteger recursos contra uso inadequado intencional por código não confiável.</span><span class="sxs-lookup"><span data-stu-id="87865-156">It should not be used to protect resources from intentional misuse by untrusted code.</span></span> <span data-ttu-id="87865-157">Por exemplo, se método `A` problemas um <xref:System.Security.CodeAccessPermission.Deny%2A> para uma permissão e, em seguida, o método de chamadas `B`, método `B` evidentemente pode substituir o <xref:System.Security.CodeAccessPermission.Deny%2A> emitindo um <xref:System.Security.CodeAccessPermission.Assert%2A>.</span><span class="sxs-lookup"><span data-stu-id="87865-157">For example, if method `A` issues a <xref:System.Security.CodeAccessPermission.Deny%2A> for a permission and then calls method `B`, method `B` can overtly override the <xref:System.Security.CodeAccessPermission.Deny%2A> by issuing an <xref:System.Security.CodeAccessPermission.Assert%2A>.</span></span> <span data-ttu-id="87865-158">O método chamado é sempre superior na pilha.</span><span class="sxs-lookup"><span data-stu-id="87865-158">The called method is always higher in the stack.</span></span> <span data-ttu-id="87865-159">Portanto, se método `B` tenta acessar um recurso protegido, o sistema de segurança começa a verificação de permissões com ele como método `B` é o chamador imediato e aborda abaixo da pilha para confirmar se há nenhum <xref:System.Security.CodeAccessPermission.Deny%2A> ou <xref:System.Security.CodeAccessPermission.PermitOnly%2A> inferior na pilha.</span><span class="sxs-lookup"><span data-stu-id="87865-159">Therefore, if method `B` tries to access a protected resource, the security system begins checking for permissions with it because method `B` is the immediate caller, and then walks down the stack to confirm that there is no <xref:System.Security.CodeAccessPermission.Deny%2A> or <xref:System.Security.CodeAccessPermission.PermitOnly%2A> lower in the stack.</span></span> <span data-ttu-id="87865-160">Método `B`, que está tentando acessar o recurso, pode parar a movimentação da pilha imediatamente usando o <xref:System.Security.CodeAccessPermission.Assert%2A> método.</span><span class="sxs-lookup"><span data-stu-id="87865-160">Method `B`, which is trying to access the resource, can stop the stack walk immediately by using the <xref:System.Security.CodeAccessPermission.Assert%2A> method.</span></span> <span data-ttu-id="87865-161">Nesse caso, o <xref:System.Security.CodeAccessPermission.Deny%2A> colocado na pilha pelo método `A` (o método de chamada) nunca é descoberto.</span><span class="sxs-lookup"><span data-stu-id="87865-161">In that case, the <xref:System.Security.CodeAccessPermission.Deny%2A> placed on the stack by method `A` (the calling method) is never discovered.</span></span>  
  
 <span data-ttu-id="87865-162">Esse método impede que os chamadores mais acima na pilha de chamadas acessando o recurso protegido por meio do código que chama esse método, mesmo que os chamadores tiverem permissão para acessá-lo.</span><span class="sxs-lookup"><span data-stu-id="87865-162">This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it.</span></span> <span data-ttu-id="87865-163">A pilha de chamadas é representada geralmente como crescimento para baixo, para que os métodos superiores na pilha de chamadas chamam métodos inferior na pilha de chamadas.</span><span class="sxs-lookup"><span data-stu-id="87865-163">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 <span data-ttu-id="87865-164"><xref:System.Security.CodeAccessPermission.Deny%2A> pode limitar a responsabilidade do programador ou ajudar a evitar problemas de segurança acidental, pois ajuda a impedir que o método que chama <xref:System.Security.CodeAccessPermission.Deny%2A> seja usado para acessar o recurso protegido pela permissão negada.</span><span class="sxs-lookup"><span data-stu-id="87865-164"><xref:System.Security.CodeAccessPermission.Deny%2A> can limit the liability of the programmer or help prevent accidental security issues because it helps prevent the method that calls <xref:System.Security.CodeAccessPermission.Deny%2A> from being used to access the resource protected by the denied permission.</span></span> <span data-ttu-id="87865-165">Se chama um método <xref:System.Security.CodeAccessPermission.Deny%2A> em uma permissão e se um <xref:System.Security.CodeAccessPermission.Demand%2A> para essa permissão é invocado por um chamador inferior na pilha de chamadas, essa verificação de segurança falharão quando atingir o <xref:System.Security.CodeAccessPermission.Deny%2A>.</span><span class="sxs-lookup"><span data-stu-id="87865-165">If a method calls <xref:System.Security.CodeAccessPermission.Deny%2A> on a permission, and if a <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the <xref:System.Security.CodeAccessPermission.Deny%2A>.</span></span>  
  
 <span data-ttu-id="87865-166">A chamada para <xref:System.Security.CodeAccessPermission.Deny%2A> é eficiente, até que o código de chamada retorna ao chamador.</span><span class="sxs-lookup"><span data-stu-id="87865-166">The call to <xref:System.Security.CodeAccessPermission.Deny%2A> is effective until the calling code returns to its caller.</span></span> <span data-ttu-id="87865-167">Apenas um <xref:System.Security.CodeAccessPermission.Deny%2A> podem estar ativas em um quadro.</span><span class="sxs-lookup"><span data-stu-id="87865-167">Only one <xref:System.Security.CodeAccessPermission.Deny%2A> can be active on a frame.</span></span> <span data-ttu-id="87865-168">Uma tentativa de chamar <xref:System.Security.CodeAccessPermission.Deny%2A> quando um ativo <xref:System.Security.CodeAccessPermission.Deny%2A> existe nos resultados do quadro um <xref:System.Security.SecurityException>.</span><span class="sxs-lookup"><span data-stu-id="87865-168">An attempt to call <xref:System.Security.CodeAccessPermission.Deny%2A> when an active <xref:System.Security.CodeAccessPermission.Deny%2A> exists on the frame results in a <xref:System.Security.SecurityException>.</span></span> <span data-ttu-id="87865-169">Chamar <xref:System.Security.CodeAccessPermission.RevertDeny%2A> ou <xref:System.Security.CodeAccessPermission.RevertAll%2A> para remover um ativo <xref:System.Security.CodeAccessPermission.Deny%2A>.</span><span class="sxs-lookup"><span data-stu-id="87865-169">Call <xref:System.Security.CodeAccessPermission.RevertDeny%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active <xref:System.Security.CodeAccessPermission.Deny%2A>.</span></span> <span data-ttu-id="87865-170"><xref:System.Security.CodeAccessPermission.Deny%2A> é ignorado para uma permissão concedida não porque uma solicitação de permissão não terá êxito.</span><span class="sxs-lookup"><span data-stu-id="87865-170"><xref:System.Security.CodeAccessPermission.Deny%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="87865-171">Já existe um <see cref="M:System.Security.CodeAccessPermission.Deny" /> ativo para o quadro atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-171">There is already an active <see cref="M:System.Security.CodeAccessPermission.Deny" /> for the current frame.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="87865-172">Você não pode substituir esse método.</span>
            <span class="sxs-lookup">
              <span data-stu-id="87865-172">You cannot override this method.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="87865-173">O objeto <see cref="T:System.Security.CodeAccessPermission" /> a ser comparado com o <see cref="T:System.Security.CodeAccessPermission" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-173">The <see cref="T:System.Security.CodeAccessPermission" /> object to compare with the current <see cref="T:System.Security.CodeAccessPermission" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="87865-174">Determina se o objeto <see cref="T:System.Security.CodeAccessPermission" /> especificado é igual ao <see cref="T:System.Security.CodeAccessPermission" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-174">Determines whether the specified <see cref="T:System.Security.CodeAccessPermission" /> object is equal to the current <see cref="T:System.Security.CodeAccessPermission" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="87865-175">
            <see langword="true" /> se o objeto <see cref="T:System.Security.CodeAccessPermission" /> especificado for igual ao <see cref="T:System.Security.CodeAccessPermission" /> atual, caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-175">
              <see langword="true" /> if the specified <see cref="T:System.Security.CodeAccessPermission" /> object is equal to the current <see cref="T:System.Security.CodeAccessPermission" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="87865-176">Para obter mais informações, consulte <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="87865-176">For more information, see <xref:System.Object.Equals%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromXml">
      <MemberSignature Language="C#" Value="public abstract void FromXml (System.Security.SecurityElement elem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FromXml(class System.Security.SecurityElement elem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub FromXml (elem As SecurityElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void FromXml(System::Security::SecurityElement ^ elem);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.ISecurityEncodable.FromXml(System.Security.SecurityElement)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elem" Type="System.Security.SecurityElement" />
      </Parameters>
      <Docs>
        <param name="elem">
          <span data-ttu-id="87865-177">A codificação XML a ser usada para reconstruir o objeto de segurança.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-177">The XML encoding to use to reconstruct the security object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="87865-178">Quando substituído em uma classe derivada, reconstrói um objeto de segurança com um estado especificado de uma codificação XML.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-178">When overridden in a derived class, reconstructs a security object with a specified state from an XML encoding.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="87865-179">Código personalizado que estende os objetos de segurança necessário para implementar o <xref:System.Security.CodeAccessPermission.ToXml%2A> e <xref:System.Security.CodeAccessPermission.FromXml%2A> métodos para tornar os objetos de segurança-pode ser codificada.</span><span class="sxs-lookup"><span data-stu-id="87865-179">Custom code that extends security objects needs to implement the <xref:System.Security.CodeAccessPermission.ToXml%2A> and <xref:System.Security.CodeAccessPermission.FromXml%2A> methods to make the objects security-encodable.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="87865-180">O exemplo de código a seguir mostra uma substituição do <xref:System.Security.CodeAccessPermission.FromXml%2A> método.</span><span class="sxs-lookup"><span data-stu-id="87865-180">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.FromXml%2A> method.</span></span> <span data-ttu-id="87865-181">Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.Security.CodeAccessPermission> classe.</span><span class="sxs-lookup"><span data-stu-id="87865-181">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#10)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#10)]
 [!code-vb[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="87865-182">O parâmetro <paramref name="elem" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-182">The <paramref name="elem" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="87865-183">O parâmetro <paramref name="elem" /> não contém a codificação XML para uma instância do mesmo tipo que a instância atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-183">The <paramref name="elem" /> parameter does not contain the XML encoding for an instance of the same type as the current instance.</span>
          </span>
          <span data-ttu-id="87865-184">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-184">-or-</span>
          </span>
          <span data-ttu-id="87865-185">Não há suporte para o número de versão do parâmetro <paramref name="elem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-185">The version number of the <paramref name="elem" /> parameter is not supported.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="87865-186">Você deve substituir esse método em uma classe derivada.</span>
            <span class="sxs-lookup">
              <span data-stu-id="87865-186">You must override this method in a derived class.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="87865-187">Obtém um código hash para o objeto <see cref="T:System.Security.CodeAccessPermission" /> atual, adequado para algoritmos de hash e estruturas de dados, tais como uma tabela de hash.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-187">Gets a hash code for the <see cref="T:System.Security.CodeAccessPermission" /> object that is suitable for use in hashing algorithms and data structures such as a hash table.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="87865-188">Um código hash para o objeto <see cref="T:System.Security.CodeAccessPermission" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-188">A hash code for the current <see cref="T:System.Security.CodeAccessPermission" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="87865-189">O código hash para duas instâncias da mesma permissão pode ser diferente, portanto, um código de hash não deve ser usado para comparar dois <xref:System.Security.CodeAccessPermission> objetos.</span><span class="sxs-lookup"><span data-stu-id="87865-189">The hash code for two instances of the same permission might be different, hence a hash code should not be used to compare two <xref:System.Security.CodeAccessPermission> objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public abstract System.Security.IPermission Intersect (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Intersect(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Intersect (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::IPermission ^ Intersect(System::Security::IPermission ^ target);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Intersect(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="87865-190">Uma permissão para ter interseção com a permissão atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-190">A permission to intersect with the current permission.</span>
          </span>
          <span data-ttu-id="87865-191">Ele deve ser do mesmo tipo da permissão atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-191">It must be of the same type as the current permission.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="87865-192">Quando implementada por uma classe derivada, cria e retorna uma permissão que é a interseção de permissão atual e da permissão especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-192">When implemented by a derived class, creates and returns a permission that is the intersection of the current permission and the specified permission.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="87865-193">Uma nova permissão que representa a interseção da permissão atual e da permissão especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-193">A new permission that represents the intersection of the current permission and the specified permission.</span>
          </span>
          <span data-ttu-id="87865-194">Essa nova permissão é <see langword="null" /> se a interseção estiver vazia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-194">This new permission is <see langword="null" /> if the intersection is empty.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="87865-195">A interseção de duas permissões é uma permissão que descreve o conjunto de operações que ambas descrevem em comum.</span><span class="sxs-lookup"><span data-stu-id="87865-195">The intersection of two permissions is a permission that describes the set of operations they both describe in common.</span></span> <span data-ttu-id="87865-196">Somente uma demanda que passa as permissões originais passará a interseção.</span><span class="sxs-lookup"><span data-stu-id="87865-196">Only a demand that passes both original permissions will pass the intersection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="87865-197">O exemplo de código a seguir mostra uma substituição do <xref:System.Security.CodeAccessPermission.Intersect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="87865-197">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.Intersect%2A> method.</span></span> <span data-ttu-id="87865-198">Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.Security.CodeAccessPermission> classe.</span><span class="sxs-lookup"><span data-stu-id="87865-198">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#5)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#5)]
 [!code-vb[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="87865-199">O parâmetro <paramref name="target" /> não é <see langword="null" /> e não é uma instância da mesma classe que a permissão atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-199">The <paramref name="target" /> parameter is not <see langword="null" /> and is not an instance of the same class as the current permission.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="87865-200">Você deve substituir esse método em uma classe derivada.</span>
            <span class="sxs-lookup">
              <span data-stu-id="87865-200">You must override this method in a derived class.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public abstract bool IsSubsetOf (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function IsSubsetOf (target As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool IsSubsetOf(System::Security::IPermission ^ target);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="87865-201">Uma permissão que deve ser testada quanto à relação de subconjunto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-201">A permission that is to be tested for the subset relationship.</span>
          </span>
          <span data-ttu-id="87865-202">Essa permissão deve ser do mesmo tipo da permissão atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-202">This permission must be of the same type as the current permission.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="87865-203">Quando implementado em uma classe derivada, determina se a permissão atual é um subconjunto da permissão especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-203">When implemented by a derived class, determines whether the current permission is a subset of the specified permission.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="87865-204">
            <see langword="true" /> se a permissão atual for um subconjunto da permissão especificada; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-204">
              <see langword="true" /> if the current permission is a subset of the specified permission; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="87865-205">A permissão atual é um subconjunto de permissão especificada se a permissão atual especifica um conjunto de operações é totalmente contido pelo conjunto de permissões especificado.</span><span class="sxs-lookup"><span data-stu-id="87865-205">The current permission is a subset of the specified permission if the current permission specifies a set of operations that is wholly contained by the specified permission.</span></span> <span data-ttu-id="87865-206">Por exemplo, uma permissão que representa acesso à C:\example.txt é um subconjunto de uma permissão que representa acesso na unidade c:\\.</span><span class="sxs-lookup"><span data-stu-id="87865-206">For example, a permission that represents access to C:\example.txt is a subset of a permission that represents access to C:\\.</span></span> <span data-ttu-id="87865-207">Se esse método retornar `true`, a permissão atual não representa nenhum mais acesso ao recurso protegido que a permissão especificada.</span><span class="sxs-lookup"><span data-stu-id="87865-207">If this method returns `true`, the current permission represents no more access to the protected resource than does the specified permission.</span></span>  
  
 <span data-ttu-id="87865-208">As instruções a seguir são necessárias para ser `true` para todas as substituições do <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> método.</span><span class="sxs-lookup"><span data-stu-id="87865-208">The following statements are required to be `true` for all overrides of the <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> method.</span></span> <span data-ttu-id="87865-209">*X*, *Y*, e *Z* representar objetos de permissão de acesso de código personalizado que não são referências nulas, *U* representa uma permissão de acesso do código irrestrito, e *N* representa uma permissão vazia com um <xref:System.Security.Permissions.PermissionState> de <xref:System.Security.Permissions.PermissionState.None>.</span><span class="sxs-lookup"><span data-stu-id="87865-209">*X*, *Y*, and *Z* represent custom code access permission objects that are not null references, *U* represents an unrestricted code access permission, and *N* represents an empty permission with a <xref:System.Security.Permissions.PermissionState> of <xref:System.Security.Permissions.PermissionState.None>.</span></span>  
  
-   <span data-ttu-id="87865-210">*X*. IsSubsetOf (*X*) retorna `true`.</span><span class="sxs-lookup"><span data-stu-id="87865-210">*X*.IsSubsetOf(*X*) returns `true`.</span></span>  
  
-   <span data-ttu-id="87865-211">*X*. IsSubsetOf (*Y*) retorna o mesmo valor como *Y*. IsSubsetOf (*X*) somente se *X* e *Y* representar o mesmo conjunto de permissões.</span><span class="sxs-lookup"><span data-stu-id="87865-211">*X*.IsSubsetOf(*Y*) returns the same value as *Y*.IsSubsetOf(*X*) if and only if *X* and *Y* represent the same set of permissions.</span></span>  
  
-   <span data-ttu-id="87865-212">If *X*. IsSubsetOf(*Y*) and *Y*. IsSubsetOf(*Z*) both return `true`, *X*. IsSubsetOf (*Z*) retorna `true`.</span><span class="sxs-lookup"><span data-stu-id="87865-212">If *X*.IsSubsetOf(*Y*) and *Y*.IsSubsetOf(*Z*) both return `true`, *X*.IsSubsetOf(*Z*) returns `true`.</span></span>  
  
-   <span data-ttu-id="87865-213">*X*. IsSubsetOf (*U*) retorna `true`.</span><span class="sxs-lookup"><span data-stu-id="87865-213">*X*.IsSubsetOf(*U*) returns `true`.</span></span>  
  
-   <span data-ttu-id="87865-214">*X*.IsSubsetOf(*N*) returns `false`.</span><span class="sxs-lookup"><span data-stu-id="87865-214">*X*.IsSubsetOf(*N*) returns `false`.</span></span>  
  
-   <span data-ttu-id="87865-215">*N*. IsSubsetOf (*X*) retorna `true`.</span><span class="sxs-lookup"><span data-stu-id="87865-215">*N*.IsSubsetOf(*X*) returns `true`.</span></span>  
  
 <span data-ttu-id="87865-216">Se *X* e *Y* representar objetos de permissão de acesso de código personalizado que são referências nulas, *X*. IsSubsetOf (*Y*) retorna `true`.</span><span class="sxs-lookup"><span data-stu-id="87865-216">If *X* and *Y* represent custom code access permission objects that are null references, *X*.IsSubsetOf(*Y*) returns `true`.</span></span> <span data-ttu-id="87865-217">Se *Z* também será null, operação de definição do composto *X*. Union(*Y*). IsSubsetOf (*Z*) também retorna `true` porque a união de duas permissões nulo é uma permissão de nulo.</span><span class="sxs-lookup"><span data-stu-id="87865-217">If *Z* is also null, the compound set operation *X*.Union(*Y*).IsSubsetOf(*Z*) also returns `true` because the union of two null permissions is a null permission.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="87865-218">O exemplo de código a seguir mostra uma substituição do <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> método.</span><span class="sxs-lookup"><span data-stu-id="87865-218">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> method.</span></span> <span data-ttu-id="87865-219">Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.Security.CodeAccessPermission> classe.</span><span class="sxs-lookup"><span data-stu-id="87865-219">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#4)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#4)]
 [!code-vb[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="87865-220">O parâmetro <paramref name="target" /> não é <see langword="null" /> e não é do mesmo tipo que a permissão atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-220">The <paramref name="target" /> parameter is not <see langword="null" /> and is not of the same type as the current permission.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="87865-221">Você deve substituir esse método em uma classe derivada.</span>
            <span class="sxs-lookup">
              <span data-stu-id="87865-221">You must override this method in a derived class.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub PermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void PermitOnly();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.PermitOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="87865-222">Impede que os chamadores no topo da pilha de chamadas usem o código que chama esse método para acessar todos os recursos, com exceção do recurso especificado pela instância atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-222">Prevents callers higher in the call stack from using the code that calls this method to access all resources except for the resource specified by the current instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="87865-223">O <xref:System.Security.CodeAccessPermission.PermitOnly%2A> método deve ser usado apenas para proteger os recursos do access acidental por código totalmente confiável.</span><span class="sxs-lookup"><span data-stu-id="87865-223">The <xref:System.Security.CodeAccessPermission.PermitOnly%2A> method should be used only to protect resources from accidental access by fully trusted code.</span></span> <span data-ttu-id="87865-224">Ele não deve ser usado para proteger recursos contra uso inadequado intencional por código não confiável.</span><span class="sxs-lookup"><span data-stu-id="87865-224">It should not be used to protect resources from intentional misuse by untrusted code.</span></span> <span data-ttu-id="87865-225">Por exemplo, se método `A` problemas um <xref:System.Security.CodeAccessPermission.PermitOnly%2A> para uma permissão e, em seguida, o método de chamadas `B`, método `B` evidentemente pode substituir o <xref:System.Security.CodeAccessPermission.PermitOnly%2A> emitindo um <xref:System.Security.CodeAccessPermission.Assert%2A>.</span><span class="sxs-lookup"><span data-stu-id="87865-225">For example, if method `A` issues a <xref:System.Security.CodeAccessPermission.PermitOnly%2A> for a permission and then calls method `B`, method `B` can overtly override the <xref:System.Security.CodeAccessPermission.PermitOnly%2A> by issuing an <xref:System.Security.CodeAccessPermission.Assert%2A>.</span></span> <span data-ttu-id="87865-226">O método chamado é sempre superior na pilha.</span><span class="sxs-lookup"><span data-stu-id="87865-226">The called method is always higher in the stack.</span></span> <span data-ttu-id="87865-227">Portanto, se método `B` tenta acessar um recurso protegido, o sistema de segurança começa a verificação de permissões com ele como método `B` é o chamador imediato e aborda abaixo da pilha para confirmar se há nenhum <xref:System.Security.CodeAccessPermission.Deny%2A> ou <xref:System.Security.CodeAccessPermission.PermitOnly%2A> inferior na pilha.</span><span class="sxs-lookup"><span data-stu-id="87865-227">Therefore, if method `B` tries to access a protected resource, the security system begins checking for permissions with it because method `B` is the immediate caller, and then walks down the stack to confirm that there is no <xref:System.Security.CodeAccessPermission.Deny%2A> or <xref:System.Security.CodeAccessPermission.PermitOnly%2A> lower in the stack.</span></span> <span data-ttu-id="87865-228">Método `B`, que está tentando acessar o recurso, pode parar a movimentação da pilha imediatamente usando o <xref:System.Security.CodeAccessPermission.Assert%2A> método.</span><span class="sxs-lookup"><span data-stu-id="87865-228">Method `B`, which is trying to access the resource, can stop the stack walk immediately by using the <xref:System.Security.CodeAccessPermission.Assert%2A> method.</span></span> <span data-ttu-id="87865-229">Nesse caso, o <xref:System.Security.CodeAccessPermission.PermitOnly%2A> colocado na pilha pelo método `A` (o método de chamada) nunca é descoberto.</span><span class="sxs-lookup"><span data-stu-id="87865-229">In that case, the <xref:System.Security.CodeAccessPermission.PermitOnly%2A> placed on the stack by method `A` (the calling method) is never discovered.</span></span>  
  
 <span data-ttu-id="87865-230"><xref:System.Security.CodeAccessPermission.PermitOnly%2A> é semelhante ao <xref:System.Security.CodeAccessPermission.Deny%2A>, ambos causam movimentações de pilha falhe quando eles conseguirão caso contrário.</span><span class="sxs-lookup"><span data-stu-id="87865-230"><xref:System.Security.CodeAccessPermission.PermitOnly%2A> is similar to <xref:System.Security.CodeAccessPermission.Deny%2A>, in that both cause stack walks to fail when they would otherwise succeed.</span></span> <span data-ttu-id="87865-231">A diferença é que <xref:System.Security.CodeAccessPermission.Deny%2A> Especifica as permissões que fará com que a movimentação da pilha falhe, mas <xref:System.Security.CodeAccessPermission.PermitOnly%2A> Especifica as permissões somente que fazem com que a movimentação da pilha falha.</span><span class="sxs-lookup"><span data-stu-id="87865-231">The difference is that <xref:System.Security.CodeAccessPermission.Deny%2A> specifies permissions that will cause the stack walk to fail, but <xref:System.Security.CodeAccessPermission.PermitOnly%2A> specifies the only permissions that do not cause the stack walk to fail.</span></span>  
  
 <span data-ttu-id="87865-232">Chame este método para garantir que seu código pode ser usado para acessar somente os recursos especificados.</span><span class="sxs-lookup"><span data-stu-id="87865-232">Call this method to ensure that your code can be used to access only the specified resources.</span></span> <span data-ttu-id="87865-233">A chamada para <xref:System.Security.CodeAccessPermission.PermitOnly%2A> é eficiente, até que o código de chamada retorna ao chamador.</span><span class="sxs-lookup"><span data-stu-id="87865-233">The call to <xref:System.Security.CodeAccessPermission.PermitOnly%2A> is effective until the calling code returns to its caller.</span></span> <span data-ttu-id="87865-234">Apenas um <xref:System.Security.CodeAccessPermission.PermitOnly%2A> podem estar ativas em um quadro.</span><span class="sxs-lookup"><span data-stu-id="87865-234">Only one <xref:System.Security.CodeAccessPermission.PermitOnly%2A> can be active on a frame.</span></span> <span data-ttu-id="87865-235">Uma tentativa de chamar <xref:System.Security.CodeAccessPermission.PermitOnly%2A> quando um ativo <xref:System.Security.CodeAccessPermission.PermitOnly%2A> existe nos resultados do quadro um <xref:System.Security.SecurityException>.</span><span class="sxs-lookup"><span data-stu-id="87865-235">An attempt to call <xref:System.Security.CodeAccessPermission.PermitOnly%2A> when an active <xref:System.Security.CodeAccessPermission.PermitOnly%2A> exists on the frame results in a <xref:System.Security.SecurityException>.</span></span> <span data-ttu-id="87865-236">Chamar <xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A> ou <xref:System.Security.CodeAccessPermission.RevertAll%2A> para remover um ativo <xref:System.Security.CodeAccessPermission.PermitOnly%2A>.</span><span class="sxs-lookup"><span data-stu-id="87865-236">Call <xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active <xref:System.Security.CodeAccessPermission.PermitOnly%2A>.</span></span>  
  
 <span data-ttu-id="87865-237"><xref:System.Security.CodeAccessPermission.PermitOnly%2A> é ignorado para uma permissão concedida não porque uma solicitação de permissão não terá êxito.</span><span class="sxs-lookup"><span data-stu-id="87865-237"><xref:System.Security.CodeAccessPermission.PermitOnly%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="87865-238">No entanto, se o código inferior na chamada de pilha mais tarde chamadas <xref:System.Security.CodeAccessPermission.Demand%2A> para essa permissão, um <xref:System.Security.SecurityException> é gerada quando a movimentação da pilha atinge o código que tentou chamar <xref:System.Security.CodeAccessPermission.PermitOnly%2A>.</span><span class="sxs-lookup"><span data-stu-id="87865-238">However, if code lower on the call stack later calls <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.CodeAccessPermission.PermitOnly%2A>.</span></span> <span data-ttu-id="87865-239">Isso ocorre porque o código chamado <xref:System.Security.CodeAccessPermission.PermitOnly%2A> não recebeu a permissão, mesmo que ela chamou <xref:System.Security.CodeAccessPermission.PermitOnly%2A> para essa permissão.</span><span class="sxs-lookup"><span data-stu-id="87865-239">This is because the code that called <xref:System.Security.CodeAccessPermission.PermitOnly%2A> has not been granted the permission, even though it called <xref:System.Security.CodeAccessPermission.PermitOnly%2A> for that permission.</span></span> <span data-ttu-id="87865-240">A pilha de chamadas é representada geralmente como crescimento para baixo, para que os métodos superiores na pilha de chamadas chamam métodos inferior na pilha de chamadas.</span><span class="sxs-lookup"><span data-stu-id="87865-240">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="87865-241">Já existe um <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> ativo para o quadro atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-241">There is already an active <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="87865-242">Você não pode substituir esse método.</span>
            <span class="sxs-lookup">
              <span data-stu-id="87865-242">You cannot override this method.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="RevertAll">
      <MemberSignature Language="C#" Value="public static void RevertAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertAll" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertAll ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertAll();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="87865-243">Faz com que todas as substituições anteriores para o quadro atual sejam removidas e não estejam mais em vigor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-243">Causes all previous overrides for the current frame to be removed and no longer in effect.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="87865-244">Se não houver nenhum substituições (<xref:System.Security.CodeAccessPermission.Assert%2A>, <xref:System.Security.CodeAccessPermission.Deny%2A>, ou <xref:System.Security.CodeAccessPermission.PermitOnly%2A>) para o quadro atual, um <xref:System.ExecutionEngineException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="87865-244">If there are no overrides (<xref:System.Security.CodeAccessPermission.Assert%2A>, <xref:System.Security.CodeAccessPermission.Deny%2A>, or <xref:System.Security.CodeAccessPermission.PermitOnly%2A>) for the current frame, an <xref:System.ExecutionEngineException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="87865-245">Não há nenhum <see cref="M:System.Security.CodeAccessPermission.Assert" />, <see cref="M:System.Security.CodeAccessPermission.Deny" /> ou <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> anterior para o quadro atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-245">There is no previous <see cref="M:System.Security.CodeAccessPermission.Assert" />, <see cref="M:System.Security.CodeAccessPermission.Deny" />, or <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RevertAssert">
      <MemberSignature Language="C#" Value="public static void RevertAssert ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertAssert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertAssert" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertAssert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertAssert();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="87865-246">Faz com que um <see cref="M:System.Security.CodeAccessPermission.Assert" /> anterior do quadro atual seja removido e não entre mais em vigor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-246">Causes any previous <see cref="M:System.Security.CodeAccessPermission.Assert" /> for the current frame to be removed and no longer in effect.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="87865-247">Se não houver nenhum <xref:System.Security.CodeAccessPermission.Assert%2A> para o quadro atual, um <xref:System.ExecutionEngineException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="87865-247">If there is no <xref:System.Security.CodeAccessPermission.Assert%2A> for the current frame, an <xref:System.ExecutionEngineException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="87865-248">Não há nenhum <see cref="M:System.Security.CodeAccessPermission.Assert" /> anterior para o quadro atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-248">There is no previous <see cref="M:System.Security.CodeAccessPermission.Assert" /> for the current frame.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RevertDeny">
      <MemberSignature Language="C#" Value="public static void RevertDeny ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertDeny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertDeny" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertDeny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertDeny();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="87865-249">Faz com que um <see cref="M:System.Security.CodeAccessPermission.Deny" /> anterior do quadro atual seja removido e não entre mais em vigor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-249">Causes any previous <see cref="M:System.Security.CodeAccessPermission.Deny" /> for the current frame to be removed and no longer in effect.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="87865-250">Se não houver nenhum <xref:System.Security.CodeAccessPermission.Deny%2A> para o quadro atual, um <xref:System.ExecutionEngineException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="87865-250">If there is no <xref:System.Security.CodeAccessPermission.Deny%2A> for the current frame, an <xref:System.ExecutionEngineException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="87865-251">Não há nenhum <see cref="M:System.Security.CodeAccessPermission.Deny" /> anterior para o quadro atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-251">There is no previous <see cref="M:System.Security.CodeAccessPermission.Deny" /> for the current frame.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RevertPermitOnly">
      <MemberSignature Language="C#" Value="public static void RevertPermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertPermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertPermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertPermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertPermitOnly();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="87865-252">Faz com que um <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> anterior do quadro atual seja removido e não entre mais em vigor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-252">Causes any previous <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame to be removed and no longer in effect.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="87865-253">Se não houver nenhum <xref:System.Security.CodeAccessPermission.PermitOnly%2A> para o quadro atual, um <xref:System.ExecutionEngineException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="87865-253">If there is no <xref:System.Security.CodeAccessPermission.PermitOnly%2A> for the current frame, an <xref:System.ExecutionEngineException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="87865-254">Não há nenhum <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> anterior para o quadro atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-254">There is no previous <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IPermission.Demand">
      <MemberSignature Language="C#" Value="void IPermission.Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IPermission.Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IPermission#Demand" />
      <MemberSignature Language="VB.NET" Value="Sub Demand () Implements IPermission.Demand" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IPermission.Demand() = System::Security::IPermission::Demand;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Assert">
      <MemberSignature Language="C#" Value="void IStackWalk.Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Assert" />
      <MemberSignature Language="VB.NET" Value="Sub Assert () Implements IStackWalk.Assert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Assert() = System::Security::IStackWalk::Assert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Assert</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Demand">
      <MemberSignature Language="C#" Value="void IStackWalk.Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Demand" />
      <MemberSignature Language="VB.NET" Value="Sub Demand () Implements IStackWalk.Demand" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Demand() = System::Security::IStackWalk::Demand;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Deny">
      <MemberSignature Language="C#" Value="void IStackWalk.Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Deny" />
      <MemberSignature Language="VB.NET" Value="Sub Deny () Implements IStackWalk.Deny" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Deny() = System::Security::IStackWalk::Deny;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Deny</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.PermitOnly">
      <MemberSignature Language="C#" Value="void IStackWalk.PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Sub PermitOnly () Implements IStackWalk.PermitOnly" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.PermitOnly() = System::Security::IStackWalk::PermitOnly;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.PermitOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="87865-255">Cria e retorna uma representação de cadeia de caracteres do objeto de permissão atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-255">Creates and returns a string representation of the current permission object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="87865-256">Uma representação de cadeia de caracteres do objeto de permissão atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-256">A string representation of the current permission object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="87865-257">Esse método é útil para depuração quando você precisa de permissão são exibidas como uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="87865-257">This method is useful in debugging when you need to display the permission as a string.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public abstract System.Security.SecurityElement ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.SecurityElement ToXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.ToXml" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ToXml () As SecurityElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::SecurityElement ^ ToXml();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.ISecurityEncodable.ToXml</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="87865-258">Quando substituído em uma classe derivada, cria uma codificação XML do objeto de segurança e seu estado atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-258">When overridden in a derived class, creates an XML encoding of the security object and its current state.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="87865-259">Uma codificação XML do objeto de segurança, incluindo quaisquer informações de estado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-259">An XML encoding of the security object, including any state information.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="87865-260">Código personalizado que estende os objetos de segurança necessário para implementar o <xref:System.Security.CodeAccessPermission.ToXml%2A> e <xref:System.Security.CodeAccessPermission.FromXml%2A> métodos para tornar os objetos de segurança-pode ser codificada.</span><span class="sxs-lookup"><span data-stu-id="87865-260">Custom code that extends security objects needs to implement the <xref:System.Security.CodeAccessPermission.ToXml%2A> and <xref:System.Security.CodeAccessPermission.FromXml%2A> methods to make the objects security-encodable.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="87865-261">O exemplo de código a seguir mostra uma substituição do <xref:System.Security.CodeAccessPermission.ToXml%2A> método.</span><span class="sxs-lookup"><span data-stu-id="87865-261">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.ToXml%2A> method.</span></span> <span data-ttu-id="87865-262">Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.Security.CodeAccessPermission> classe.</span><span class="sxs-lookup"><span data-stu-id="87865-262">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#11)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#11)]
 [!code-vb[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#11)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="87865-263">Você deve substituir esse método em uma classe derivada.</span>
            <span class="sxs-lookup">
              <span data-stu-id="87865-263">You must override this method in a derived class.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public virtual System.Security.IPermission Union (System.Security.IPermission other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Union(class System.Security.IPermission other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Union (other As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::IPermission ^ Union(System::Security::IPermission ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Union(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="87865-264">Uma permissão a ser combinada com a permissão atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-264">A permission to combine with the current permission.</span>
          </span>
          <span data-ttu-id="87865-265">Ele deve ser do mesmo tipo da permissão atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-265">It must be of the same type as the current permission.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="87865-266">Quando substituído em uma classe derivada, cria uma permissão que é a união entre a permissão atual e a permissão especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-266">When overridden in a derived class, creates a permission that is the union of the current permission and the specified permission.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="87865-267">Uma nova permissão que representa a união da permissão atual e da permissão especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-267">A new permission that represents the union of the current permission and the specified permission.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="87865-268">O resultado de uma chamada para <xref:System.Security.CodeAccessPermission.Union%2A> é uma permissão que representa todas as operações representadas pela permissão atual e a permissão especificada.</span><span class="sxs-lookup"><span data-stu-id="87865-268">The result of a call to <xref:System.Security.CodeAccessPermission.Union%2A> is a permission that represents all the operations represented by both the current permission and the specified permission.</span></span> <span data-ttu-id="87865-269">Qualquer solicitação que passa a ter a permissão passa seu union.</span><span class="sxs-lookup"><span data-stu-id="87865-269">Any demand that passes either permission passes their union.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="87865-270">O exemplo de código a seguir mostra uma substituição do <xref:System.Security.CodeAccessPermission.Union%2A> método.</span><span class="sxs-lookup"><span data-stu-id="87865-270">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.Union%2A> method.</span></span> <span data-ttu-id="87865-271">Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.Security.CodeAccessPermission> classe.</span><span class="sxs-lookup"><span data-stu-id="87865-271">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#12)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#12)]
 [!code-vb[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="87865-272">O parâmetro <paramref name="other" /> não é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-272">The <paramref name="other" /> parameter is not <see langword="null" />.</span>
          </span>
          <span data-ttu-id="87865-273">Esse método é compatível com este nível apenas quando passar <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="87865-273">This method is only supported at this level when passed <see langword="null" />.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="87865-274">Você deve substituir esse método em uma classe derivada.</span>
            <span class="sxs-lookup">
              <span data-stu-id="87865-274">You must override this method in a derived class.</span>
            </span>
            <span data-ttu-id="87865-275">Você deve retornar uma cópia da permissão se o valor de <paramref name="other" /> parâmetro é <see langword="null" />.</span>
            <span class="sxs-lookup">
              <span data-stu-id="87865-275">You should return a copy of the permission if the value of the <paramref name="other" /> parameter is <see langword="null" />.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>