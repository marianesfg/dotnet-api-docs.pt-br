<Type Name="SecurityManager" FullName="System.Security.SecurityManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="51b52be500a5be1b9b263e9528638a7f09b2cb2a" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30500680" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class SecurityManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed SecurityManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Security.SecurityManager" />
  <TypeSignature Language="VB.NET" Value="Public Class SecurityManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityManager abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece o ponto de acesso principal para as classes que interagem com o sistema de segurança. Essa classe não pode ser herdada.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A segurança fornece métodos para acessar e manipular a configuração de política de segurança. Não é possível criar instâncias de <xref:System.Security.SecurityManager>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CheckExecutionRights">
      <MemberSignature Language="C#" Value="public static bool CheckExecutionRights { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CheckExecutionRights" />
      <MemberSignature Language="DocId" Value="P:System.Security.SecurityManager.CheckExecutionRights" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CheckExecutionRights As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CheckExecutionRights { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o código deve ter <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> para ser executado.</summary>
        <value>
          <see langword="true" /> Se o código deve ter <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> para ser executada; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se essa propriedade for `false`, até mesmo o código sem <xref:System.Security.Permissions.SecurityPermissionFlag.Execution> podem executar. Verificando a execução é caro e pode eliminar as vantagens da resolução lento de política. Esta propriedade é fornecida para desabilitar a execução de verificação quando necessário.  
  
 Alterar essa propriedade não é mantido até <xref:System.Security.SecurityManager.SavePolicy%2A> é chamado. Novos processos não serão afetados pela alteração até que ele é mantido no registro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O código que chama esse método não tem <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">a capacidade de modificar a política. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThreadRequiresSecurityContextCapture">
      <MemberSignature Language="C#" Value="public static bool CurrentThreadRequiresSecurityContextCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CurrentThreadRequiresSecurityContextCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CurrentThreadRequiresSecurityContextCapture () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CurrentThreadRequiresSecurityContextCapture();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina se o thread atual requer uma captura de contexto de segurança se o estado de segurança precisar ser recriado em um momento posterior.</summary>
        <returns>
          <see langword="false" /> se a pilha não contiver nenhum domínio de aplicativo parcialmente confiável, nenhum assembly parcialmente confiável e nenhum modificador <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> ou <see cref="M:System.Security.CodeAccessPermission.Deny" /> ativo no momento; <see langword="true" /> se o Common Language Runtime não puder garantir que a pilha não contém nenhum desses itens.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar o <xref:System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture%2A> método antes de você armazenar dados confidenciais são obtidos após demandas de segurança com êxito.  
  
 Se o <xref:System.Security.CodeAccessPermission.Assert%2A> método foi chamado superior na pilha, os dados não devem ser armazenada em cache sem capturar o contexto de segurança correspondente. Caso contrário, confidenciais dados obtidos em uma <xref:System.Security.CodeAccessPermission.Assert%2A> pode se tornar disponível para o código que é não estar em execução com que <xref:System.Security.CodeAccessPermission.Assert%2A> em vigor.  
  
> [!IMPORTANT]
>  O valor de retorno é confiável apenas quando ele é `false`, que significa que o thread é garantido que não exigem uma captura de contexto de segurança. O método pode retornar true quando uma captura de contexto de segurança não é necessária, para evitar vulnerabilidades de segurança.  
  
 <xref:System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture%2A> é crítico de segurança porque seu uso principal é evitar o contexto de segurança desnecessários captura, que indica que o código de usá-lo é sensível à segurança e deve ser auditado.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetStandardSandbox">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet GetStandardSandbox (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet GetStandardSandbox(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.GetStandardSandbox(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ GetStandardSandbox(System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">A evidência de host a ser correspondida a um conjunto de permissões.</param>
        <summary>Obtém um conjunto de permissões que é seguro conceder a um aplicativo que tem a evidência fornecida.</summary>
        <returns>Um conjunto de permissões que pode ser usado como um conjunto de concessões para o aplicativo que tem a evidência fornecida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  No [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o host provas em `evidence` deve conter <xref:System.Security.Policy.Zone?displayProperty=nameWithType> evidência.  
>   
>  A tabela a seguir mostra os conjuntos de permissões que são retornados para cada zona.  
  
|Zona|Conjunto de permissões|  
|----------|--------------------|  
|<xref:System.Security.SecurityZone.MyComputer>|`FullTrust`|  
|<xref:System.Security.SecurityZone.Intranet>|`LocalIntranet`|  
|<xref:System.Security.SecurityZone.Trusted>|`Internet`|  
|<xref:System.Security.SecurityZone.Internet>|`Internet`|  
|<xref:System.Security.SecurityZone.Untrusted>|Nenhum|  
|<xref:System.Security.SecurityZone.NoZone>|Nenhum|  
  
 Como outros evidência <xref:System.Security.Policy.Url> ou <xref:System.Security.Policy.Site>, pode ser considerada.  
  
 O conjunto de permissões retornado pode ser usado por uma área restrita para executar o aplicativo. Observe que esse método não especificar a política, mas ajuda a um host para determinar se o conjunto de permissões solicitado por um aplicativo é razoável. Esse método pode ser usado para mapear uma zona para uma área restrita.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o <xref:System.Security.SecurityManager.GetStandardSandbox%2A> método para obter a permissão definida para um aplicativo de área restrita. Para obter mais informações sobre como executar um aplicativo em uma área restrita, consulte [como: executar código parcialmente confiável em uma área restrita](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).  
  
 [!code-csharp[sandboxingApis#1](~/samples/snippets/csharp/VS_Snippets_CLR/SandboxingAPIs/CS/program.cs#1)]
 [!code-vb[sandboxingApis#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SandboxingAPIs/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="evidence" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetZoneAndOrigin">
      <MemberSignature Language="C#" Value="public static void GetZoneAndOrigin (out System.Collections.ArrayList zone, out System.Collections.ArrayList origin);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetZoneAndOrigin([out] class System.Collections.ArrayList&amp; zone, [out] class System.Collections.ArrayList&amp; origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.GetZoneAndOrigin(System.Collections.ArrayList@,System.Collections.ArrayList@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetZoneAndOrigin (ByRef zone As ArrayList, ByRef origin As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetZoneAndOrigin([Runtime::InteropServices::Out] System::Collections::ArrayList ^ % zone, [Runtime::InteropServices::Out] System::Collections::ArrayList ^ % origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="zone" Type="System.Collections.ArrayList&amp;" RefType="out" />
        <Parameter Name="origin" Type="System.Collections.ArrayList&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="zone">Um parâmetro de saída que contém um <see cref="T:System.Collections.ArrayList" /> de objetos <see cref="P:System.Security.Permissions.ZoneIdentityPermissionAttribute.Zone" /> concedidos.</param>
        <param name="origin">Um parâmetro de saída que contém um <see cref="T:System.Collections.ArrayList" /> de objetos <see cref="T:System.Security.Permissions.UrlIdentityPermission" /> concedidos.</param>
        <summary>Obtém a identidade de zona concedida e os conjuntos de permissões de identidade URL para o assembly atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A alternativa recomendada para este método é usar a evidência de URL e a zona para o assembly em execução para chamar <xref:System.Security.SecurityManager.ResolvePolicy%2A> para cada tipo de evidência. Os conjuntos de permissões retornados do <xref:System.Security.SecurityManager.ResolvePolicy%2A> chamadas de identificam as permissões concedidas ao assembly em execução com base em sua região e a URL de origem.  
  
> [!NOTE]
>  Este membro faz uma demanda de link para a chave pública ECMA, não é uma chave de criptografia válida, mas uma chave de pseudo. Dentro do .NET Framework a demanda de link para a chave de pseudo ECMA é convertida automaticamente em uma demanda de link para a chave pública da Microsoft. A exceção de segurança baseia-se a chave pública do Microsoft, não a chave de pseudo ECMA.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">A solicitação para <see cref="T:System.Security.Permissions.StrongNameIdentityPermission" /> falhou.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsGranted">
      <MemberSignature Language="C#" Value="public static bool IsGranted (System.Security.IPermission perm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsGranted(class System.Security.IPermission perm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.IsGranted(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsGranted (perm As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsGranted(System::Security::IPermission ^ perm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="perm" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="perm">A permissão a ser testada na concessão do chamador.</param>
        <summary>Determina se uma permissão é concedida ao chamador.</summary>
        <returns>
          <see langword="true" /> se as permissões concedidas ao chamador incluírem a permissão <paramref name="perm" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Concessão de permissões é determinado pela política e é diferente de uma demanda sujeito substituições, como uma declaração. Além disso, <xref:System.Security.SecurityManager.IsGranted%2A> apenas testa a concessão do assembly de código chamada, independente de outros chamadores na pilha.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPolicyLevelFromFile">
      <MemberSignature Language="C#" Value="public static System.Security.Policy.PolicyLevel LoadPolicyLevelFromFile (string path, System.Security.PolicyLevelType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Policy.PolicyLevel LoadPolicyLevelFromFile(string path, valuetype System.Security.PolicyLevelType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadPolicyLevelFromFile (path As String, type As PolicyLevelType) As PolicyLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Policy::PolicyLevel ^ LoadPolicyLevelFromFile(System::String ^ path, System::Security::PolicyLevelType type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.PolicyLevel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="type" Type="System.Security.PolicyLevelType" />
      </Parameters>
      <Docs>
        <param name="path">O caminho de arquivo físico para um arquivo que contém as informações da política de segurança.</param>
        <param name="type">Um dos valores de enumeração que especificam o tipo de nível de política a ser carregado.</param>
        <summary>Carrega um <see cref="T:System.Security.Policy.PolicyLevel" /> do arquivo especificado.</summary>
        <returns>O nível de política carregado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O arquivo indicado pelo parâmetro <paramref name="path" /> não existe.</exception>
        <exception cref="T:System.Security.SecurityException">O código que chama esse método não tem <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.  
  
 - ou -  
  
 O código que chama esse método não tem <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.  
  
 - ou -  
  
 O código que chama esse método não tem <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.  
  
 - ou -  
  
 O código que chama esse método não tem <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</exception>
        <exception cref="T:System.NotSupportedException">Esse método usa a política de CAS (segurança de acesso do código), que está obsoleta no [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. Para habilitar a política de CAS para compatibilidade com versões anteriores do .NET Framework, use o [elemento &lt;legacyCasPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">a capacidade de exibir e modificar a política. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler e gravar arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadPolicyLevelFromString">
      <MemberSignature Language="C#" Value="public static System.Security.Policy.PolicyLevel LoadPolicyLevelFromString (string str, System.Security.PolicyLevelType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Policy.PolicyLevel LoadPolicyLevelFromString(string str, valuetype System.Security.PolicyLevelType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.LoadPolicyLevelFromString(System.String,System.Security.PolicyLevelType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadPolicyLevelFromString (str As String, type As PolicyLevelType) As PolicyLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Policy::PolicyLevel ^ LoadPolicyLevelFromString(System::String ^ str, System::Security::PolicyLevelType type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.PolicyLevel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="type" Type="System.Security.PolicyLevelType" />
      </Parameters>
      <Docs>
        <param name="str">A representação XML de um nível de política de segurança no mesmo formato em que aparece em um arquivo de configuração.</param>
        <param name="type">Um dos valores de enumeração que especificam o tipo de nível de política a ser carregado.</param>
        <summary>Carrega um <see cref="T:System.Security.Policy.PolicyLevel" /> da cadeia de caracteres especificada.</summary>
        <returns>O nível de política carregado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="str" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="str" /> não é válido.</exception>
        <exception cref="T:System.Security.SecurityException">O código que chama esse método não tem <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">a capacidade de exibir e modificar a política. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <Member MemberName="PolicyHierarchy">
      <MemberSignature Language="C#" Value="public static System.Collections.IEnumerator PolicyHierarchy ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IEnumerator PolicyHierarchy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.PolicyHierarchy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PolicyHierarchy () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IEnumerator ^ PolicyHierarchy();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fornece um enumerador para acessar a hierarquia de política de segurança por níveis, como a política de computador e a política de usuário.</summary>
        <returns>Um enumerador para objetos <see cref="T:System.Security.Policy.PolicyLevel" /> que compõem a hierarquia de política de segurança.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O enumerador retornado fornece sucessivas <xref:System.Security.Policy.PolicyLevel> objetos que representam a política em do respectivos (computador, usuário, enterprise, domínio de aplicativo) nível da hierarquia. Esses objetos são os objetos de política dinâmica; alterando esses objetos pode ter resultados imprevisíveis.  
  
 Hierarquia de política mínimo consiste em um nível de máquina, um nível de empresa e um nível de usuário. No entanto, a hierarquia pode incluir níveis adicionais.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Esse método usa a política de CAS (segurança de acesso do código), que está obsoleta no [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. Para habilitar a política de CAS para compatibilidade com versões anteriores do .NET Framework, use o [elemento &lt;legacyCasPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
        <exception cref="T:System.Security.SecurityException">O código que chama esse método não tem <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">a capacidade de exibir e modificar a política. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolvePolicy">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina quais permissões conceder ao código.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolvePolicy">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet ResolvePolicy(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ ResolvePolicy(System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">O conjunto de evidências usado para avaliar a política.</param>
        <summary>Determina quais permissões conceder ao código com base na evidência especificada.</summary>
        <returns>O conjunto de permissões que podem ser concedidas pelo sistema de segurança.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método chama o mecanismo de políticas de segurança, fornecendo prova de identidade do código de chamada. O resultado é determinado pela política de segurança.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Esse método usa a política de CAS (segurança de acesso do código), que está obsoleta no [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. Para habilitar a política de CAS para compatibilidade com versões anteriores do .NET Framework, use o [elemento &lt;legacyCasPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolvePolicy">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence[] evidences);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet ResolvePolicy(class System.Security.Policy.Evidence[] evidences) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ResolvePolicy (evidences As Evidence()) As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ ResolvePolicy(cli::array &lt;System::Security::Policy::Evidence ^&gt; ^ evidences);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidences" Type="System.Security.Policy.Evidence[]" />
      </Parameters>
      <Docs>
        <param name="evidences">Uma matriz de objetos de evidência usados para avaliar a política.</param>
        <summary>Determina quais permissões conceder ao código com base na evidência especificada.</summary>
        <returns>O conjunto de permissões apropriado para todas as evidências fornecidas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método chama o mecanismo de políticas de segurança, fornecendo uma matriz de <xref:System.Security.Policy.Evidence> objetos. O conjunto de permissões retornado representa somente as permissões que se aplicam a cada evidência na matriz. Essas permissões são equivalentes a ou um subconjunto das permissões de política seria tiver concedido a cada evidência individual. Esse método se comporta como se você estivesse executando uma interseção nos resultados da resolução de diretiva em cada uma da <xref:System.Security.Policy.Evidence> objetos na matriz.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Esse método usa a política de CAS (segurança de acesso do código), que está obsoleta no [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. Para habilitar a política de CAS para compatibilidade com versões anteriores do .NET Framework, use o [elemento &lt;legacyCasPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolvePolicy">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence, System.Security.PermissionSet reqdPset, System.Security.PermissionSet optPset, System.Security.PermissionSet denyPset, out System.Security.PermissionSet denied);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet ResolvePolicy(class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet reqdPset, class System.Security.PermissionSet optPset, class System.Security.PermissionSet denyPset, [out] class System.Security.PermissionSet&amp; denied) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ ResolvePolicy(System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ reqdPset, System::Security::PermissionSet ^ optPset, System::Security::PermissionSet ^ denyPset, [Runtime::InteropServices::Out] System::Security::PermissionSet ^ % denied);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="reqdPset" Type="System.Security.PermissionSet" />
        <Parameter Name="optPset" Type="System.Security.PermissionSet" />
        <Parameter Name="denyPset" Type="System.Security.PermissionSet" />
        <Parameter Name="denied" Type="System.Security.PermissionSet&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="evidence">O conjunto de evidências usado para avaliar a política.</param>
        <param name="reqdPset">As permissões necessárias para a execução do código.</param>
        <param name="optPset">As permissões opcionais que serão usadas, se concedidas, mas que não são obrigatórias para a execução do código.</param>
        <param name="denyPset">As permissões negadas que nunca devem ser concedidas ao código, mesmo que a política permita.</param>
        <param name="denied">Um parâmetro de saída que contém o conjunto de permissões não concedidas.</param>
        <summary>Determina quais permissões conceder ao código com base na evidência e nas solicitações especificadas.</summary>
        <returns>O conjunto de permissões que seriam concedidas pelo sistema de segurança.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método chama o mecanismo de políticas de segurança, fornecendo prova de identidade do código de chamada e o conjunto de permissões de código de solicitações. O resultado é determinado pela política de segurança. Esse método retorna o conjunto de permissões que seriam concedidas pelo sistema de segurança e retorna o conjunto de permissões que seriam negadas como um parâmetro de saída. As permissões concedidas efetivas são aqueles no conjunto de concedido que não estão no conjunto negado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Esse método usa a política de CAS (segurança de acesso do código), que está obsoleta no [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. Para habilitar a política de CAS para compatibilidade com versões anteriores do .NET Framework, use o [elemento &lt;legacyCasPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
        <exception cref="T:System.Security.Policy.PolicyException">A política falha em conceder as permissões mínimas necessárias especificadas pelo parâmetro <paramref name="reqdPset" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolvePolicyGroups">
      <MemberSignature Language="C#" Value="public static System.Collections.IEnumerator ResolvePolicyGroups (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IEnumerator ResolvePolicyGroups(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolvePolicyGroups(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IEnumerator ^ ResolvePolicyGroups(System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">O conjunto de evidências em relação ao qual a política é avaliada.</param>
        <summary>Obtém uma coleção de grupos de código correspondentes à evidência especificada.</summary>
        <returns>Uma enumeração do conjunto de grupos de código correspondente à evidência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é útil para analisar como uma configuração de política especificada funciona com tipos específicos de evidência.  
  
 Grupos de código serão retornados de todos os níveis da hierarquia de política de correspondência de aplicável a `evidence` parâmetro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Esse método usa a política de CAS (segurança de acesso do código), que está obsoleta no [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. Para habilitar a política de CAS para compatibilidade com versões anteriores do .NET Framework, use o [elemento &lt;legacyCasPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveSystemPolicy">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet ResolveSystemPolicy (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet ResolveSystemPolicy(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolveSystemPolicy(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ ResolveSystemPolicy(System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">O conjunto de evidências usado para avaliar a política.</param>
        <summary>Determina quais permissões conceder ao código com base na evidência especificada, exceto pela política para o nível <see cref="T:System.AppDomain" />.</summary>
        <returns>O conjunto de permissões que podem ser concedidas pelo sistema de segurança.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método chama o mecanismo de políticas de segurança e fornece evidências de identidade do código de chamada. O resultado é determinado pela política de segurança de sistema exclusivo qualquer <xref:System.AppDomain> política.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Esse método usa a política de CAS (segurança de acesso do código), que está obsoleta no [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. Para habilitar a política de CAS para compatibilidade com versões anteriores do .NET Framework, use o [elemento &lt;legacyCasPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="SavePolicy">
      <MemberSignature Language="C#" Value="public static void SavePolicy ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SavePolicy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.SavePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SavePolicy ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SavePolicy();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Salva o estado da política de segurança modificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método economiza a política como expostos por <xref:System.Security.SecurityManager.PolicyHierarchy%2A>, <xref:System.Security.Policy.PolicyLevel>, e outras classes que representam a configuração da política de segurança. A menos que esse método é chamado, as alterações feitas nos objetos de política não serão salvas e não afetará as execuções subsequentes do aplicativo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Esse método usa a política de CAS (segurança de acesso do código), que está obsoleta no [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. Para habilitar a política de CAS para compatibilidade com versões anteriores do .NET Framework, use o [elemento &lt;legacyCasPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
        <exception cref="T:System.Security.SecurityException">O código que chama esse método não tem <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">a capacidade de modificar a política. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SavePolicyLevel">
      <MemberSignature Language="C#" Value="public static void SavePolicyLevel (System.Security.Policy.PolicyLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SavePolicyLevel(class System.Security.Policy.PolicyLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.SavePolicyLevel(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SavePolicyLevel (level As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SavePolicyLevel(System::Security::Policy::PolicyLevel ^ level);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="level">O objeto de nível da política a ser salvo.</param>
        <summary>Salva um nível de política de segurança modificada carregado com <see cref="M:System.Security.SecurityManager.LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Security.Policy.PolicyLevel> será salvo no mesmo local do qual ele carregado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O código que chama esse método não tem <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <exception cref="T:System.NotSupportedException">Esse método usa a política de CAS (segurança de acesso do código), que está obsoleta no [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. Para habilitar a política de CAS para compatibilidade com versões anteriores do .NET Framework, use o [elemento &lt;legacyCasPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">a capacidade de modificar a política. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityEnabled">
      <MemberSignature Language="C#" Value="public static bool SecurityEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SecurityEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Security.SecurityManager.SecurityEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SecurityEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SecurityEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The security manager cannot be turned off on MS runtime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a segurança está habilitada.</summary>
        <value>
          <see langword="true" /> Se a segurança está habilitada; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade é usada pelo [Caspol.exe (ferramenta de política de segurança de acesso do código)](~/docs/framework/tools/caspol-exe-code-access-security-policy-tool.md)  
  
 `-security` (`-s`) a opção para desativar a segurança baseada em código.  
  
 <xref:System.Security.SecurityManager.SecurityEnabled%2A> Fornece uma maneira para que os administradores desabilitar a segurança de acesso ao código. Quando a segurança de acesso ao código é desabilitada, todas as demandas de acesso ao código são bem-sucedidas. Na verdade, isso concede todo o código `FullTrust`. Desativando a segurança de acesso de código ignora o sistema de segurança para que o código pode executar um pouco melhor do que a concessão de política de segurança equivalentes `FullTrust` para todo o código. Essa propriedade não desativar a segurança baseada em função; Portanto, <xref:System.Security.Permissions.PrincipalPermission> demandas não são afetadas.  
  
> [!CAUTION]
>  A desabilitação da segurança de acesso ao código deixa o sistema vulnerável a ataques pelo código mal-intencionado, como vírus e worms. Desativando a segurança de acesso do código não automaticamente bloqueia a execução de qualquer forma de código gerenciado. TI faz com que apenas código sendo executado sem restrição, o sistema de segurança de acesso do código gerenciado e só deve ser feito com cuidado o mais exigentes. Desativar a segurança para obter desempenho extra só deve ser feito quando outras medidas de segurança foram tomadas para ajudar a proteger a segurança do sistema. Entre os exemplos de outras precauções de segurança estão a desconexão de redes públicas, protegendo fisicamente computadores e assim por diante.  
  
 Alterar essa propriedade não é persistente no registro até <xref:System.Security.SecurityManager.SavePolicy%2A> é chamado. Novos processos não serão afetados pela alteração até que ele é mantido no registro. Alterar o valor dessa propriedade em um processo em execução não necessariamente alterar o estado da maneira esperada. Para garantir que as alterações entraram em vigor, você deve chamar <xref:System.Security.SecurityManager.SavePolicy%2A> e iniciar um novo processo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O código que chama esse método não tem <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">a capacidade de modificar a política. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>