<Type Name="ServiceAuthorizationManager" FullName="System.ServiceModel.ServiceAuthorizationManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="507ef7fb282a367be5aaaddbe4806c43a6bf0204" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34316041" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ServiceAuthorizationManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ServiceAuthorizationManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.ServiceAuthorizationManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ServiceAuthorizationManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceAuthorizationManager" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornece verificação de acesso de autorização para operações de serviço.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa classe é responsável por avaliar todas as políticas (regras que definem o que um usuário pode fazer), comparando as políticas a serem feitas por uma configuração de cliente, resultante de declarações <xref:System.IdentityModel.Policy.AuthorizationContext> para o <xref:System.ServiceModel.ServiceSecurityContext>e fornecer a decisão de autorização para permitir ou negar o acesso de uma operação de serviço fornecido para um chamador.  
  
 O <xref:System.ServiceModel.ServiceAuthorizationManager.CheckAccessCore%2A> método é chamado pela infraestrutura do Windows Communication Foundation (WCF) sempre é feita uma tentativa de acessar um recurso. O método retorna `true` ou `false` para permitir ou negar o acesso, respectivamente.  
  
 O <xref:System.ServiceModel.ServiceAuthorizationManager> faz parte do WCF*modelo de identidade* infraestrutura. O modelo de identidade permite criar diretivas de autorização personalizada e esquemas de autorização personalizada. Para obter mais informações sobre como funciona o modelo de identidade, consulte [Gerenciando reivindicações e autorização com o modelo de identidade](~/docs/framework/wcf/feature-details/managing-claims-and-authorization-with-the-identity-model.md).  
  
## <a name="custom-authorization"></a>Autorização personalizada  
 Essa classe não executa qualquer autorização e permite que os usuários acessem todas as operações de serviço. Para fornecer autorização mais restritiva, você deve criar uma autorização personalizada manager que verifica as políticas personalizadas. Para fazer isso, herdar desta classe e substituir o <xref:System.ServiceModel.ServiceAuthorizationManager.CheckAccessCore%2A> método. Especifique a instância da classe derivada por meio de <xref:System.ServiceModel.Dispatcher.DispatchRuntime.ServiceAuthorizationManager%2A> propriedade.  
  
 Em <xref:System.ServiceModel.ServiceAuthorizationManager.CheckAccessCore%2A>, o aplicativo pode usar o <xref:System.ServiceModel.OperationContext> objeto para acessar a identidade do chamador (<xref:System.ServiceModel.OperationContext.ServiceSecurityContext%2A>).  
  
 Obtendo o <xref:System.ServiceModel.OperationContext.IncomingMessageHeaders%2A> propriedade, que retorna um <xref:System.ServiceModel.Channels.MessageHeaders> do objeto, o aplicativo pode acessar o serviço (<xref:System.ServiceModel.Channels.MessageHeaders.To%2A>) e a operação (<xref:System.ServiceModel.Channels.MessageHeaders.Action%2A>).  
  
 Obtendo o <xref:System.ServiceModel.OperationContext.RequestContext%2A> propriedade, que retorna um <xref:System.ServiceModel.Channels.RequestContext> do objeto, o aplicativo pode acessar a mensagem de solicitação inteira (<xref:System.ServiceModel.Channels.RequestContext.RequestMessage%2A>) e executar a decisão de autorização adequadamente.  
  
 Para obter um exemplo, consulte [como: criar um Gerenciador de autorização personalizada para um serviço](~/docs/framework/wcf/extending/how-to-create-a-custom-authorization-manager-for-a-service.md).  
  
 Para criar diretivas de autorização personalizada, implementar a <xref:System.IdentityModel.Policy.IAuthorizationPolicy> classe.  Para obter um exemplo, consulte [como: criar uma política de autorização personalizada](~/docs/framework/wcf/extending/how-to-create-a-custom-authorization-policy.md).  
  
 Para criar uma declaração personalizada, use o <xref:System.IdentityModel.Claims.Claim> classe.  Para obter um exemplo, consulte [como: criar uma declaração personalizada](~/docs/framework/wcf/extending/how-to-create-a-custom-claim.md). Para comparar declarações personalizadas, você deve comparar declarações, conforme mostrado no [como: comparar declarações](~/docs/framework/wcf/extending/how-to-compare-claims.md).  
  
 Para obter mais informações, consulte [autorização personalizada](~/docs/framework/wcf/extending/custom-authorization.md).  
  
 Você pode definir o tipo de um Gerenciador de autorização personalizada usando o [ &lt;serviceAuthorization&gt; ](~/docs/framework/configure-apps/file-schema/wcf/serviceauthorization-element.md) em um arquivo de configuração do aplicativo cliente.  
  
   
  
## Examples  
 O exemplo a seguir mostra uma classe chamada `MyServiceAuthorizationManager` que herde o <xref:System.ServiceModel.ServiceAuthorizationManager> e substitui o <xref:System.ServiceModel.ServiceAuthorizationManager.CheckAccessCore%2A> método.  
  
 [!code-csharp[c_CustomAuthMgr#2](~/samples/snippets/csharp/VS_Snippets_CFX/c_customauthmgr/cs/c_customauthmgr.cs#2)]
 [!code-vb[c_CustomAuthMgr#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/c_customauthmgr/vb/c_customauthmgr.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IdentityModel.Claims.ClaimSet" />
    <altmember cref="T:System.IdentityModel.Claims.Claim" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceAuthorizationManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceAuthorizationManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceAuthorizationManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.ServiceModel.ServiceAuthorizationManager" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CheckAccess">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verifica a autorização para o contexto de operação fornecido e a mensagem opcional.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CheckAccess">
      <MemberSignature Language="C#" Value="public virtual bool CheckAccess (System.ServiceModel.OperationContext operationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CheckAccess(class System.ServiceModel.OperationContext operationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceAuthorizationManager.CheckAccess(System.ServiceModel.OperationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CheckAccess(System::ServiceModel::OperationContext ^ operationContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="operationContext" Type="System.ServiceModel.OperationContext" />
      </Parameters>
      <Docs>
        <param name="operationContext">O <see cref="T:System.ServiceModel.OperationContext" />.</param>
        <summary>Verifica a autorização para o contexto de operação fornecido.</summary>
        <returns>
          <see langword="true" /> se o acesso for concedido; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em geral, os aplicativos devem substituir <xref:System.ServiceModel.ServiceAuthorizationManager.CheckAccessCore%2A> em vez desse método.  
  
 Substituir <xref:System.ServiceModel.ServiceAuthorizationManager.CheckAccess%2A> se o aplicativo associa ou apresenta um conjunto diferente de políticas para resultante <xref:System.ServiceModel.ServiceSecurityContext> ou forneça um modelo de avaliação (cadeia) de diretiva diferente.  
  
 Esse método é responsável por chamar <xref:System.ServiceModel.ServiceAuthorizationManager.CheckAccessCore%2A>.  
  
   
  
## Examples  
 O código a seguir mostra como substituir este método para aplicar os requisitos de controle de acesso personalizado.  
  
 [!code-csharp[c_Federation#1](~/samples/snippets/csharp/VS_Snippets_CFX/c_federation/cs/source.cs#1)]
 [!code-vb[c_Federation#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/c_federation/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckAccess">
      <MemberSignature Language="C#" Value="public virtual bool CheckAccess (System.ServiceModel.OperationContext operationContext, ref System.ServiceModel.Channels.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CheckAccess(class System.ServiceModel.OperationContext operationContext, class System.ServiceModel.Channels.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceAuthorizationManager.CheckAccess(System.ServiceModel.OperationContext,System.ServiceModel.Channels.Message@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CheckAccess(System::ServiceModel::OperationContext ^ operationContext, System::ServiceModel::Channels::Message ^ % message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="operationContext" Type="System.ServiceModel.OperationContext" />
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="operationContext">O <see cref="T:System.ServiceModel.OperationContext" />.</param>
        <param name="message">O <see cref="T:System.ServiceModel.Channels.Message" /> a ser examinado para se determinar a autorização.</param>
        <summary>Verifica a autorização para o contexto de operação fornecido quando o acesso a uma mensagem é necessário.</summary>
        <returns>
          <see langword="true" /> se o acesso for concedido; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em geral, os aplicativos devem substituir <xref:System.ServiceModel.ServiceAuthorizationManager.CheckAccessCore%2A> em vez desse método, que só deve ser usado se a decisão de autorização depende do corpo da mensagem. Devido a problemas de desempenho, se possível você deve recriar seu aplicativo para que a decisão de autorização não requer acesso ao corpo da mensagem.  
  
 Substitua este método se o aplicativo associa ou apresenta um conjunto diferente de políticas para resultante <xref:System.ServiceModel.ServiceSecurityContext> e <xref:System.ServiceModel.Channels.Message> ou forneça um modelo de avaliação (cadeia) de diretiva diferente.  
  
 Esse método é responsável por chamar <xref:System.ServiceModel.ServiceAuthorizationManager.CheckAccessCore%2A>.  
  
   
  
## Examples  
 O código a seguir mostra como substituir este método para aplicar os requisitos de controle de acesso personalizado que requerem acesso ao corpo da mensagem.  
  
 [!code-csharp[c_Federation#6](~/samples/snippets/csharp/VS_Snippets_CFX/c_federation/cs/source.cs#6)]
 [!code-vb[c_Federation#6](~/samples/snippets/visualbasic/VS_Snippets_CFX/c_federation/vb/source.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckAccessCore">
      <MemberSignature Language="C#" Value="protected virtual bool CheckAccessCore (System.ServiceModel.OperationContext operationContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool CheckAccessCore(class System.ServiceModel.OperationContext operationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceAuthorizationManager.CheckAccessCore(System.ServiceModel.OperationContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool CheckAccessCore(System::ServiceModel::OperationContext ^ operationContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="operationContext" Type="System.ServiceModel.OperationContext" />
      </Parameters>
      <Docs>
        <param name="operationContext">O <see cref="T:System.ServiceModel.OperationContext" /> para a solicitação de autorização atual.</param>
        <summary>Verifica a autorização para um determinado contexto de operação com base na avaliação de política padrão.</summary>
        <returns>
          <see langword="true" /> se o acesso for concedido; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.OperationContext.ServiceSecurityContext%2A> geralmente é o resultado da avaliação da política padrão.  
  
 Substitua este método para fornecer as decisões de autorização personalizadas.  
  
 Esse método pode ser usado para fazer a autorização decisões com base em conjuntos de declarações que são inferidos com base nos tokens de entrada ou pode ser adicionado por meio de políticas de autorização externa. Ele também pode tomar decisões de autorização com base nas propriedades da mensagem de entrada: por exemplo, o cabeçalho de ação.  
  
 Nesse método, o aplicativo pode usar o `operationContext` parâmetro para acessar a identidade do chamador (<xref:System.ServiceModel.OperationContext.ServiceSecurityContext%2A>). Retornando o <xref:System.ServiceModel.Channels.RequestContext> de objeto o <xref:System.ServiceModel.OperationContext.RequestContext%2A> propriedade, o aplicativo pode acessar a mensagem de solicitação inteira (<xref:System.ServiceModel.Channels.RequestContext.RequestMessage%2A>). Retornando o <xref:System.ServiceModel.Channels.MessageHeaders> de objeto o <xref:System.ServiceModel.OperationContext.IncomingMessageHeaders%2A> propriedade, o aplicativo pode acessar a URL do serviço (<xref:System.ServiceModel.Channels.MessageHeaders.To%2A>) e a operação (<xref:System.ServiceModel.Channels.MessageHeaders.Action%2A>). Com essas informações, o aplicativo pode executar a decisão de autorização adequadamente.  
  
 As declarações feitas por um usuário são encontradas no <xref:System.IdentityModel.Claims.ClaimSet> retornado pelo <xref:System.IdentityModel.Policy.AuthorizationContext.ClaimSets%2A> propriedade o `AuthorizationContext`. Atual `AuthorizationContext` é retornado pelo <xref:System.ServiceModel.OperationContext.ServiceSecurityContext%2A> propriedade o <xref:System.ServiceModel.OperationContext> classe.  
  
   
  
## Examples  
 O exemplo a seguir mostra uma substituição do <xref:System.ServiceModel.ServiceAuthorizationManager.CheckAccessCore%2A> método.  
  
 [!code-csharp[c_CustomAuthMgr#6](~/samples/snippets/csharp/VS_Snippets_CFX/c_customauthmgr/cs/c_customauthmgr.cs#6)]
 [!code-vb[c_CustomAuthMgr#6](~/samples/snippets/visualbasic/VS_Snippets_CFX/c_customauthmgr/vb/c_customauthmgr.vb#6)]  
  
 Outro exemplo, consulte [como: criar um Gerenciador de autorização personalizada para um serviço](~/docs/framework/wcf/extending/how-to-create-a-custom-authorization-manager-for-a-service.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAuthorizationPolicies">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.Policy.IAuthorizationPolicy&gt; GetAuthorizationPolicies (System.ServiceModel.OperationContext operationContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.Policy.IAuthorizationPolicy&gt; GetAuthorizationPolicies(class System.ServiceModel.OperationContext operationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceAuthorizationManager.GetAuthorizationPolicies(System.ServiceModel.OperationContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::Policy::IAuthorizationPolicy ^&gt; ^ GetAuthorizationPolicies(System::ServiceModel::OperationContext ^ operationContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.Policy.IAuthorizationPolicy&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="operationContext" Type="System.ServiceModel.OperationContext" />
      </Parameters>
      <Docs>
        <param name="operationContext">O <see cref="T:System.ServiceModel.OperationContext" /> da solicitação de autorização atual.</param>
        <summary>Obtém o conjunto de políticas que participam de avaliação de políticas.</summary>
        <returns>Um <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> do tipo <see cref="T:System.IdentityModel.Policy.IAuthorizationPolicy" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação do Windows Communication Foundation (WCF) fornece um conjunto padrão de diretivas de autorização. Esses incluem o token primário que contém as credenciais do solicitante e suporte todos os tokens, tokens de transporte e políticas externas se especificado.  
  
 Você pode substituir essa implementação e fornecer um conjunto diferente de políticas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>