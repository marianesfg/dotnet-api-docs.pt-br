<Type Name="ServiceBehaviorAttribute" FullName="System.ServiceModel.ServiceBehaviorAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="50331392363256e74f896d27155738cc69fd5c32" /><Meta Name="ms.sourcegitcommit" Value="9e3550fb2088d4faf2043f0acb29da4555519937" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="12/12/2018" /><Meta Name="ms.locfileid" Value="53294792" /></Metadata><TypeSignature Language="C#" Value="public sealed class ServiceBehaviorAttribute : Attribute, System.ServiceModel.Description.IServiceBehavior" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ServiceBehaviorAttribute extends System.Attribute implements class System.ServiceModel.Description.IServiceBehavior" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.ServiceBehaviorAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ServiceBehaviorAttribute&#xA;Inherits Attribute&#xA;Implements IServiceBehavior" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBehaviorAttribute sealed : Attribute, System::ServiceModel::Description::IServiceBehavior" />
  <TypeSignature Language="F#" Value="type ServiceBehaviorAttribute = class&#xA;    inherit Attribute&#xA;    interface IServiceBehavior" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Description.IServiceBehavior</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Especifica o comportamento de execução interna de uma implementação de contrato de serviço.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplicar o <xref:System.ServiceModel.ServiceBehaviorAttribute> de atributo para uma implementação de serviço para especificar o comportamento de execução de todo o serviço. (Para especificar o comportamento de execução no nível do método, use o <xref:System.ServiceModel.OperationBehaviorAttribute> atributo.) Esse atributo pode ser aplicado somente a implementações de serviço. Para obter exemplos de funcionamento, consulte o [serviço: Exemplos de comportamentos](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms751453(v=vs.90)).  
  
 <xref:System.ServiceModel.ServiceBehaviorAttribute> propriedades são um recurso modelo Windows Communication Foundation (WCF) programação que permite que os recursos comuns que os desenvolvedores caso contrário, precisam implementar. Para obter mais informações sobre esses e outros comportamentos, consulte [especificando comportamento de tempo de execução do serviço](~/docs/framework/wcf/specifying-service-run-time-behavior.md). Para obter mais informações sobre as propriedades de tempo de execução subjacente que alguns do seguinte conjunto de propriedades, consulte [estendendo ServiceHost e a camada de modelo de serviço](~/docs/framework/wcf/extending/extending-servicehost-and-the-service-model-layer.md).  
  
-   O <xref:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode%2A> propriedade especifica o tipo de filtro que o sistema do dispatcher usa para localizar o ponto de extremidade que manipula as solicitações.  
  
-   O <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> propriedade fecha automaticamente a sessão quando o canal seja fechado e o serviço terminou de processar qualquer mensagem restante.  
  
-   O <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> propriedade controla o modelo de threading interno, habilitando o suporte para serviços reentrantes ou multithread.  
  
-   O <xref:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName%2A> propriedade é usada para declarar um nome para uso em de `name` atributo do `<service>` elemento em um arquivo de configuração.  
  
-   O <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> propriedade permite que o tempo de execução ignorar as informações de serialização extra que não é necessário para processar a mensagem.  
  
-   O <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> propriedade especifica se as exceções sem tratamento em um serviço são retornadas como falhas de SOAP. Isso é apenas para fins de depuração.  
  
-   O <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> propriedade especifica se e quando os serviços e seus objetos de serviço devem ser reciclado durante uma troca com um cliente.  
  
-   O <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> propriedade para limitar o número de itens em um gráfico de objeto que são serializados.  
  
-   O <xref:System.ServiceModel.ServiceBehaviorAttribute.Name%2A> e <xref:System.ServiceModel.ServiceBehaviorAttribute.Namespace%2A> propriedades controlam o nome e namespace para a expressão de WSDL do elemento de serviço.  
  
-   O <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> propriedade especifica se o objeto de serviço é reciclado quando uma transação é concluída.  
  
-   O <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose%2A> propriedade especifica se as transações pendentes são concluídas quando a sessão é fechada.  
  
-   O <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel%2A> propriedade especifica o nível de isolamento da transação que tem suporte no contrato.  
  
-   O <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout%2A> propriedade especifica o período de tempo dentro do qual uma transação deve ser concluída ou anulada por ele.  
  
-   O <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A> propriedade indica se é necessário sincronizar chamadas de método de entrada com o thread da interface do usuário automaticamente.  
  
-   O <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A> propriedade informa o sistema se ele deve confirmar que os cabeçalhos SOAP marcado como `MustUnderstand` , na verdade, foram compreendidos.  
  
 O <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> propriedade também pode ser definida usando um arquivo de configuração do aplicativo. Para obter detalhes, consulte <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o <xref:System.ServiceModel.ServiceBehaviorAttribute> propriedades. O `BehaviorService` classe usa o <xref:System.ServiceModel.ServiceBehaviorAttribute> atributo para indicar que:  
  
-   O objeto de serviço é reciclado quando a transação seja concluída.  
  
-   Há um objeto de serviço para cada sessão.  
  
-   O serviço é single-threaded e não oferece suporte a chamadas reentrantes.  
  
 Além disso, no nível da operação, o <xref:System.ServiceModel.OperationBehaviorAttribute> valores indicam que o `TxWork` método automaticamente inscreve-se em transações fluídas ou cria uma nova transação para fazer o trabalho e que a transação é confirmada automaticamente se uma exceção não tratada exceção não ocorrerá.  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 A associação subjacente deve dar suporte a transações fluídas para o exemplo de código a seguir para serem executados corretamente. Para dar suporte a transações fluídas usando o <xref:System.ServiceModel.WSHttpBinding>, por exemplo, defina a <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> propriedade para `true` no código ou em um arquivo de configuração do aplicativo. O exemplo de código a seguir mostra o arquivo de configuração para o exemplo anterior.  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceModel.OperationBehaviorAttribute" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms751453(v=vs.90)">Serviço: Exemplo de comportamento</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBehaviorAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBehaviorAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.ServiceModel.ServiceBehaviorAttribute" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os valores padrão para o <xref:System.ServiceModel.ServiceBehaviorAttribute> são:  
  
-   O <xref:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode%2A> é definido como <xref:System.ServiceModel.AddressFilterMode.Exact>.  
  
-   A propriedade <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> é `true`.  
  
-   O <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> é definido como <xref:System.ServiceModel.ConcurrencyMode.Single>.  
  
-   O <xref:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName%2A> propriedade é o nome qualificado de namespace do tipo sem as informações de assembly.  
  
-   A propriedade <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> é `false`.  
  
-   O <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> estiver definida como 64 KB.  
  
-   O <xref:System.ServiceModel.ServiceBehaviorAttribute.Name%2A> propriedade é o nome do tipo de serviço, sem informações de namespace e assembly.  
  
-   O <xref:System.ServiceModel.ServiceBehaviorAttribute.Namespace%2A> propriedade é "http://tempuri.org".  
  
-   A propriedade <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> é `true`.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> é `false`.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A> é `true`.  
  
-   A propriedade <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose%2A> é `false`.  
  
-   A propriedade <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel%2A> é <xref:System.Transactions.IsolationLevel.Unspecified>.  
  
-   A propriedade <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout%2A> é definida como <xref:System.TimeSpan.Zero>.  
  
-   A propriedade <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A> é `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddressFilterMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.AddressFilterMode AddressFilterMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.AddressFilterMode AddressFilterMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AddressFilterMode As AddressFilterMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::AddressFilterMode AddressFilterMode { System::ServiceModel::AddressFilterMode get(); void set(System::ServiceModel::AddressFilterMode value); };" />
      <MemberSignature Language="F#" Value="member this.AddressFilterMode : System.ServiceModel.AddressFilterMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.AddressFilterMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o <see cref="T:System.ServiceModel.AddressFilterMode" /> usado pelo dispatcher para encaminhar mensagens de entrada ao ponto de extremidade correto.</summary>
        <value>O <see cref="T:System.ServiceModel.AddressFilterMode" /> objeto que é usado pelo dispatcher para rotear mensagens de entrada para o ponto de extremidade correto.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor não é um dos valores <see cref="T:System.ServiceModel.AddressFilterMode" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AutomaticSessionShutdown">
      <MemberSignature Language="C#" Value="public bool AutomaticSessionShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutomaticSessionShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticSessionShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutomaticSessionShutdown { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticSessionShutdown : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica se uma sessão será fechada automaticamente quando um cliente fechar uma sessão de saída.</summary>
        <value><see langword="true" /> Se os serviços de fechar automaticamente uma sessão quando o cliente fecha uma sessão de saída; Caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão quando um cliente fecha uma sessão de saída e o serviço terminou de processar qualquer mensagem restante o servidor fecha a sessão. Definindo <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> para `false` impede que o servidor fechar automaticamente a sessão e habilita o controle personalizado de tempos de vida de sessão.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConcurrencyMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ConcurrencyMode ConcurrencyMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.ConcurrencyMode ConcurrencyMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ConcurrencyMode As ConcurrencyMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::ConcurrencyMode ConcurrencyMode { System::ServiceModel::ConcurrencyMode get(); void set(System::ServiceModel::ConcurrencyMode value); };" />
      <MemberSignature Language="F#" Value="member this.ConcurrencyMode : System.ServiceModel.ConcurrencyMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ConcurrencyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define se um serviço dá suporte a um thread, vários threads ou chamadas reentrantes.</summary>
        <value>Um dos valores <see cref="T:System.ServiceModel.ConcurrencyMode" />; o padrão é <see cref="F:System.ServiceModel.ConcurrencyMode.Single" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade indica se uma instância de um serviço pode manipular um thread ou vários threads executadas simultaneamente e, se single-threaded, se reentrância tem suporte.  
  
> [!NOTE]
>  O <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> propriedade interage com algumas outras configurações. Por exemplo, se o <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> valor é definido como <xref:System.ServiceModel.InstanceContextMode.Single> o resultado é que seu serviço só pode processar uma mensagem por vez, a menos que você definir também a <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> valor <xref:System.ServiceModel.ConcurrencyMode.Multiple>. Essa propriedade também gera um comportamento em combinação com o <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> propriedade. Para obter detalhes, consulte [sessões, criação de instâncias e simultaneidade](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
 Definindo <xref:System.ServiceModel.ConcurrencyMode> para <xref:System.ServiceModel.ConcurrencyMode.Single> instrui o sistema para restringir as instâncias do serviço para um thread de execução por vez, que libera você de lidar com problemas de threading. Um valor de <xref:System.ServiceModel.ConcurrencyMode.Multiple> significa que objetos de serviço pode ser executada por vários threads a qualquer momento. Nesse caso, você deve assegurar acesso thread-safe.  
  
 <xref:System.ServiceModel.ConcurrencyMode.Reentrant> também restringe o acesso a um único thread por vez; durante a operação de processamento, nenhuma outra mensagem pode inserir a operação. Se durante a operação de sair de uma chamada para outro serviço, a mensagem atual perde o bloqueio de operação, que é gratuito para processar outras mensagens. Ao chamar o serviço retorna, o bloqueio for restabelecido e a mensagem original pode continuar a processar a sua conclusão ou até ocorre outra chamada fora de operação.  
  
> [!IMPORTANT]
>  Embora <xref:System.ServiceModel.ConcurrencyMode.Single> restringe as instâncias do serviço para um thread de execução por vez, você também deve definir <xref:System.ServiceModel.Description.ServiceThrottlingBehavior.MaxConcurrentCalls%2A> como 1 para não assegurar nenhuma mensagem fora de ordem.  
>   
>  Além disso, é sua responsabilidade manter o estado de seu objeto consistente antes dos textos explicativos e você deve confirmar que os dados de local da operação são válidos após os textos explicativos. Observe que a instância do serviço é desbloqueada somente chamando outro serviço em um canal do WCF. Nesse caso, o serviço chamado pode reinserir o primeiro serviço por meio de um retorno de chamada. Se o primeiro serviço não for reentrante, a sequência de chamadas resultará em um deadlock. Para obter detalhes, consulte <xref:System.ServiceModel.ConcurrencyMode>.  
  
 Durante a qualquer chamada de saída de uma operação de processamento, dados locais a operação não podem ser modificados. (Dados de estado local são garantidos para ser válida quando a mensagem original retoma o processamento). Como resultado, antes chamada de saída, você deve garantir que os dados de local não é válidos para as outras chamadas de entrada e revalide dados não-local após o retorno de chamada de saída.  
  
 O pseudocódigo a seguir ilustra o padrão necessário para suporte reentrante bem-sucedida.  
  
```csharp  
public void MyMethod()  
{  
  this.SomeNonLocalDataState;  
  // Here you need to clean nonlocal state for other users  
  OutboundProxy proxy = new OutboundProxy();  
  int returnValue = proxy.CallOutOfOperation();  
  // Ensure that this.SomeNonLocalDataState is valid for continued use.  
  this.ModifyNonLocalState;  
  return returnValue;  
}  
  
```  
  
 Usando o padrão de chamada assíncrona de início/fim para uma saída chamado quando o <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> é <xref:System.ServiceModel.ConcurrencyMode.Reentrant> aciona uma exceção. Chamadas de saída assíncronas exigem uma operação na qual <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> é <xref:System.ServiceModel.ConcurrencyMode.Multiple>, nesse caso, você deve lidar com problemas de sincronização.  
  
 Em geral, se uma mensagem chega para uma instância que viola seu modo de simultaneidade, a mensagem aguarda até que a instância está disponível ou o tempo limite.  
  
 Além disso, se o <xref:System.ServiceModel.ConcurrencyMode> é definido como <xref:System.ServiceModel.ConcurrencyMode.Single> e uma chamada reentrante é bloqueada enquanto espera para a instância a ser liberado, o sistema detecta o deadlock e gera uma exceção.  
  
> [!NOTE]
>  Um <xref:System.InvalidOperationException> será lançada em tempo de execução se <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> é `true` quando o <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> estiver definida como <xref:System.ServiceModel.ConcurrencyMode.Single>.  
  
 Observe que você deve definir explicitamente <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> à `false` se não houver uma operação com <xref:System.ServiceModel.OperationBehaviorAttribute.TransactionScopeRequired%2A?displayProperty=nameWithType> definido como true e defina <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> para <xref:System.ServiceModel.ConcurrencyMode.Reentrant>. Caso contrário, uma exceção de validação é gerada porque o valor padrão de <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> é `true`.  
  
 Há uma interação entre o <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> e outras propriedades que podem alterar o comportamento de tempo de execução. Para obter uma descrição completa dessas interações, consulte [sessões, criação de instâncias e simultaneidade](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra a diferença entre usar <xref:System.ServiceModel.ConcurrencyMode.Single>, <xref:System.ServiceModel.ConcurrencyMode.Reentrant>, e <xref:System.ServiceModel.ConcurrencyMode.Multiple>. Este exemplo não for compilado sem uma implementação real por trás dele, mas demonstram o tipo de threading garantias que torna o Windows Communication Foundation (WCF) e o que isso significa para seu código de operação.  
  
 [!code-csharp[C_BestPractices-Concurrency#1](~/samples/snippets/csharp/VS_Snippets_CFX/c_bestpractices-concurrency/cs/reentrantandmultiple.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor não é um dos valores <see cref="T:System.ServiceModel.ConcurrencyMode" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationName">
      <MemberSignature Language="C#" Value="public string ConfigurationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationName : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor usado para localizar o elemento de serviço em um arquivo de configuração de aplicativo.</summary>
        <value>O valor a ser localizado no arquivo de configuração. O valor padrão é o nome de tipo totalmente qualificado sem informações de assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse valor para especificar um serviço específico no arquivo de configuração.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor é uma cadeia de caracteres vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureOrderedDispatch">
      <MemberSignature Language="C#" Value="public bool EnsureOrderedDispatch { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnsureOrderedDispatch" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.EnsureOrderedDispatch" />
      <MemberSignature Language="VB.NET" Value="Public Property EnsureOrderedDispatch As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnsureOrderedDispatch { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnsureOrderedDispatch : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.EnsureOrderedDispatch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o envio ordenado pelo serviço é garantido.</summary>
        <value><see langword="true" /> Se o envio ordenado pelo serviço é garantido; Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWellKnownSingleton">
      <MemberSignature Language="C#" Value="public object GetWellKnownSingleton ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetWellKnownSingleton() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.GetWellKnownSingleton" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWellKnownSingleton () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetWellKnownSingleton();" />
      <MemberSignature Language="F#" Value="member this.GetWellKnownSingleton : unit -&gt; obj" Usage="serviceBehaviorAttribute.GetWellKnownSingleton " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera um objeto que implementa o serviço e que é usado como a instância singleton do serviço ou <see langword="null" />, se não houver nenhuma instância singleton.</summary>
        <returns>Uma implementação do serviço. O valor padrão é <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um não -`null` valor fornece a instância de serviço para o qual todas as mensagens endereçadas para o serviço serão distribuídas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreExtensionDataObject">
      <MemberSignature Language="C#" Value="public bool IgnoreExtensionDataObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreExtensionDataObject" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreExtensionDataObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreExtensionDataObject { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreExtensionDataObject : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que especifica se dados de serialização desconhecidos serão enviados na conexão.</summary>
        <value><see langword="true" /> se os dados de serialização desconhecidos nunca forem enviados; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um tipo implementa o <xref:System.Runtime.Serialization.IExtensibleDataObject> interface, ele armazena quaisquer dados extra não sabe sobre o que é transmitida ao desserializar em tipo. Por exemplo, se um tipo `Person` tem membros `FirstName` e `LastName`, e um elemento chamado `PhoneNumber` é fornecido, ele é armazenado. Ao serializar posteriormente o tipo `PhoneNumber` será emitida novamente. O problema é que o esquema para `Person` exportados pelo serviço só tem `FirstName` e `LastName`, portanto, o Windows Communication Foundation (WCF) gera uma instância de esquema inválido! Se a conformidade de esquema estrita for importante, você pode definir <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> para `true` para desativar esse comportamento emitindo novamente.  
  
 Independentemente disso <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> definindo, WCF sempre processa dados conhecidos (tanto internos quanto externos) e não lança exceções quando entram os dados extras. Você também pode definir essa propriedade usando o [ &lt;dataContractSerializer&gt; ](~/docs/framework/configure-apps/file-schema/wcf/datacontractserializer-element.md) elemento em um arquivo de configuração do aplicativo.  
  
   
  
## Examples  
 O exemplo a seguir mostra o uso de <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> e uma implementação de <xref:System.Runtime.Serialization.IExtensibleDataObject>. Neste exemplo, com <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> definido como `false`, os dados extras que o cliente sabe sobre são recuperado para o cliente.  
  
 [!code-csharp[DCAContainerNoValidation#1](~/samples/snippets/csharp/VS_Snippets_CFX/dcacontainernovalidation/cs/services.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeExceptionDetailInFaults">
      <MemberSignature Language="C#" Value="public bool IncludeExceptionDetailInFaults { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeExceptionDetailInFaults" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeExceptionDetailInFaults As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeExceptionDetailInFaults { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeExceptionDetailInFaults : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que especifica que as exceções de execução gerais sem tratamento devem ser convertidas em um <see cref="T:System.ServiceModel.FaultException`1" /> do tipo <see cref="T:System.ServiceModel.ExceptionDetail" /> e enviadas como uma mensagem de falha. Defina-o como <see langword="true" /> somente durante o desenvolvimento para solucionar problemas de um serviço.</summary>
        <value><see langword="true" /> se as exceções sem tratamento precisarem ser retornadas como falhas de SOAP; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definir <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> para `true` para habilitar as informações de exceção fluir para os clientes para fins de depuração. Esta propriedade requer uma associação que dá suporte a resposta de solicitação ou mensagens duplex.  
  
 Em todos os aplicativos gerenciados, os erros de processamento são representados por <xref:System.Exception> objetos. Aplicativos baseados em SOAP, como aplicativos do WCF, os métodos que implementam as operações de serviço se comunicam usando mensagens de falha SOAP de informações de erro. Como os aplicativos do WCF são executadas em ambos os tipos de sistemas de erro, qualquer informação de exceção gerenciada que precisa ser enviada para o cliente deve ser convertida de exceções em falhas de SOAP. Para obter mais informações, consulte [especificação e tratamento de falhas em contratos e serviços](~/docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md).  
  
 Durante o desenvolvimento, convém seu serviço para também enviar outras exceções de volta ao cliente para ajudar na depuração. Esse é um recurso somente para desenvolvimento e não deve ser empregada em serviços implantados.  
  
 Para facilitar o desenvolvimento de depuração, defina as <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> para `true` em código ou usando um arquivo de configuração do aplicativo.  
  
 Quando habilitado, o serviço retorna automaticamente as informações de exceção mais seguras para o chamador. Essas falhas aparecem para o cliente como <xref:System.ServiceModel.FaultException%601> objetos do tipo <xref:System.ServiceModel.ExceptionDetail>.  
  
> [!IMPORTANT]
>  Definindo <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> para `true` exceções do método de serviço possibilita que os clientes para obter informações sobre internos; ele só é recomendado como uma forma de depuração temporariamente um aplicativo de serviço. Além disso, o WSDL para um método que retorna sem tratamento gerenciadas exceções dessa maneira não contém o contrato para o <xref:System.ServiceModel.FaultException%601> do tipo <xref:System.ServiceModel.ExceptionDetail>. Os clientes devem esperar que a possibilidade de uma falha SOAP desconhecida para obter as informações de depuração corretamente.  
  
 Definir essa propriedade como `true` também pode ser feito usando um arquivo de configuração de aplicativo e o [ &lt;serviceDebug&gt; ](~/docs/framework/configure-apps/file-schema/wcf/servicedebug.md) elemento, como mostra o exemplo de código abaixo.  
  
 [!code-xml[OperationBehaviorAttribute1#10](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#10)]   
   
  
## Examples  
 O exemplo de código a seguir demonstra o <xref:System.ServiceModel.ServiceBehaviorAttribute> propriedades. O `BehaviorService` classe usa o <xref:System.ServiceModel.ServiceBehaviorAttribute> atributo para indicar que:  
  
-   Métodos de implementação são invocados no thread da interface do usuário.  
  
-   Há um objeto de serviço para cada sessão.  
  
-   O serviço é single-threaded e não oferece suporte a chamadas reentrantes.  
  
 Além disso, no nível da operação, o <xref:System.ServiceModel.OperationBehaviorAttribute> valores indicam que o `TxWork` método automaticamente inscreve-se em transações fluídas ou cria uma nova transação para fazer o trabalho e que a transação é confirmada automaticamente se uma exceção não tratada exceção não ocorrerá.  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 A associação subjacente deve dar suporte a transações fluídas para o exemplo de código a seguir para serem executados corretamente. Para dar suporte a transações fluídas usando o <xref:System.ServiceModel.WSHttpBinding>, por exemplo, defina a <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> propriedade para `true` no código ou em um arquivo de configuração do aplicativo. O exemplo de código a seguir mostra o arquivo de configuração para o exemplo anterior.  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceContextMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.InstanceContextMode InstanceContextMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.InstanceContextMode InstanceContextMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceContextMode As InstanceContextMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::InstanceContextMode InstanceContextMode { System::ServiceModel::InstanceContextMode get(); void set(System::ServiceModel::InstanceContextMode value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceContextMode : System.ServiceModel.InstanceContextMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.InstanceContextMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor que indica quando novos objetos de serviço são criados.</summary>
        <value>Um dos valores <see cref="T:System.ServiceModel.InstanceContextMode" />; o valor padrão é <see cref="F:System.ServiceModel.InstanceContextMode.PerSession" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.ServiceModel.InstanceContextMode> propriedade para especificar quando novos objetos de serviço são criados. Porque o objeto de serviço não está conectado diretamente ao canal de comunicação, o tempo de vida dos objetos de serviço é independente do tempo de vida do canal entre um cliente e o aplicativo de serviço. O valor padrão, <xref:System.ServiceModel.InstanceContextMode.PerSession>, instrui o aplicativo de serviço para criar um novo objeto de serviço quando uma nova sessão de comunicação é estabelecida entre um cliente e o aplicativo de serviço. As chamadas subsequentes na mesma sessão são manipuladas pelo mesmo objeto.  
  
 <xref:System.ServiceModel.InstanceContextMode.PerSession> indica que cada objeto de serviço lida com solicitações de canal de um cliente.  
  
> [!NOTE]
>  O <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> propriedade interage com algumas outras configurações. Por exemplo, se o <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> valor é definido como <xref:System.ServiceModel.InstanceContextMode.Single> o resultado é que seu serviço só pode processar uma mensagem por vez, a menos que você definir também a <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> valor <xref:System.ServiceModel.ConcurrencyMode.Multiple>. Essa propriedade também gera um comportamento em combinação com o <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> propriedade. Para obter detalhes, consulte [sessões, criação de instâncias e simultaneidade](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
 Para o comportamento de tempo de vida singleton (por exemplo, se o aplicativo host chama o <xref:System.ServiceModel.ServiceHost.%23ctor%2A> construtor e passa um objeto a ser usado como o serviço), a classe de serviço deve ser definida <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> para `Single`, ou uma exceção é lançada em tempo de execução.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o <xref:System.ServiceModel.ServiceBehaviorAttribute> propriedades. O `BehaviorService` classe usa o <xref:System.ServiceModel.ServiceBehaviorAttribute> atributo para indicar que:  
  
-   Métodos de implementação são invocados no thread da interface do usuário.  
  
-   Há um objeto de serviço para cada sessão.  
  
-   O serviço é single-threaded e não oferece suporte a chamadas reentrantes.  
  
 Além disso, no nível da operação, o <xref:System.ServiceModel.OperationBehaviorAttribute> valores indicam que o `TxWork` método automaticamente inscreve-se em transações fluídas ou cria uma nova transação para fazer o trabalho e que a transação é confirmada automaticamente se uma exceção não tratada exceção não ocorrerá.  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 A associação subjacente deve dar suporte a transações fluídas para o exemplo de código a seguir para serem executados corretamente. Para dar suporte a transações fluídas usando o <xref:System.ServiceModel.WSHttpBinding>, por exemplo, defina a <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> propriedade para `true` no código ou em um arquivo de configuração do aplicativo. O exemplo de código a seguir mostra o arquivo de configuração para o exemplo anterior.  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor não é um dos valores <see cref="T:System.ServiceModel.InstanceContextMode" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxItemsInObjectGraph">
      <MemberSignature Language="C#" Value="public int MaxItemsInObjectGraph { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxItemsInObjectGraph" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxItemsInObjectGraph As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxItemsInObjectGraph { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxItemsInObjectGraph : int with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(2147483647)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(65536)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o número máximo de itens permitidos em um objeto serializado.</summary>
        <value>O número máximo de itens permitidos em um objeto. O padrão é de 65536 bytes (64 KB).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> propriedade definir um limite no número de itens em um gráfico de objeto que são serializados. Você também pode definir essa propriedade usando o [ &lt;dataContractSerializer&gt; ](~/docs/framework/configure-apps/file-schema/wcf/datacontractserializer-element.md) elemento em um arquivo de configuração do aplicativo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor do atributo de nome no elemento de serviço em linguagem WSDL.</summary>
        <value>O valor do atributo name no <see langword="&lt;wsdl:service&gt;" /> elemento quando exportados.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor do namespace de destino para o serviço em linguagem WSDL.</summary>
        <value>O valor da <see langword="targetNamespace" /> de atributo para o <see langword="&lt;wsdl:definitions&gt;" /> elemento que contém o <see langword="&lt;wsdl:service&gt;" /> elemento.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseServiceInstanceOnTransactionComplete">
      <MemberSignature Language="C#" Value="public bool ReleaseServiceInstanceOnTransactionComplete { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="VB.NET" Value="Public Property ReleaseServiceInstanceOnTransactionComplete As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReleaseServiceInstanceOnTransactionComplete { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReleaseServiceInstanceOnTransactionComplete : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que especifica se o objeto de serviço será liberado quando a transação atual for concluída.</summary>
        <value><see langword="true" /> se o objeto de serviço deve ser liberado; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Observe que você deve definir explicitamente <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> à `false` se não houver uma operação com <xref:System.ServiceModel.OperationBehaviorAttribute.TransactionScopeRequired%2A?displayProperty=nameWithType> definido como true e defina <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> para <xref:System.ServiceModel.ConcurrencyMode.Reentrant>. Caso contrário, uma exceção de validação é gerada porque o valor padrão de <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> é `true`.  
  
 Além disso, é importante observar que, se o serviço é criado, passando um objeto de serviço para o <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Object%2CSystem.Uri%5B%5D%29?displayProperty=nameWithType> construtor, o valor dessa propriedade é tratado como se fosse `false`.  
  
   
  
## Examples  
 O exemplo de código a seguir define o isolamento da transação nível para <xref:System.Transactions.IsolationLevel.ReadCommitted>, desabilita o suporte para transações simultâneas, exige uma transação fluída de chamada da operação e confirma a transação no serviço automaticamente, se não sem tratamento ocorrerá uma exceção.  
  
 [!code-csharp[SBA.Transactions#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/services.cs#2)]
 [!code-vb[SBA.Transactions#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactions/vb/services.vb#2)]  
  
 A associação subjacente deve dar suporte a transações fluídas para o exemplo de código a seguir para serem executados corretamente. Para dar suporte a transações fluídas usando o <xref:System.ServiceModel.WSHttpBinding>, por exemplo, defina a <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> propriedade para `true` no código ou em um arquivo de configuração do aplicativo. O exemplo de código a seguir mostra um arquivo de configuração para o exemplo anterior.  
  
 [!code-xml[SBA.Transactions#1](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetWellKnownSingleton">
      <MemberSignature Language="C#" Value="public void SetWellKnownSingleton (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetWellKnownSingleton(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.SetWellKnownSingleton(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetWellKnownSingleton (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetWellKnownSingleton(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetWellKnownSingleton : obj -&gt; unit" Usage="serviceBehaviorAttribute.SetWellKnownSingleton value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">A instância singleton do serviço.</param>
        <summary>Especifica um objeto que implementa o serviço e que é usado como a instância singleton do serviço.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Isso fornece a instância de serviço para o qual todas as mensagens endereçadas para o serviço serão distribuídas.  
  
 Se <xref:System.ServiceModel.ServiceBehaviorAttribute.SetWellKnownSingleton%2A> é definido como um não -`null` valor, em seguida, a <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> deve ser definida como <xref:System.ServiceModel.InstanceContextMode.Single> ou um <xref:System.InvalidOperationException> é gerada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor definido é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeConfigurationName">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeConfigurationName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeConfigurationName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeConfigurationName () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeConfigurationName();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeConfigurationName : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeConfigurationName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor que indica se a propriedade <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" /> foi alterada do valor padrão e deve ser serializada.</summary>
        <returns><see langword="true" /> se o valor da propriedade <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" /> precisar ser serializado; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeReleaseServiceInstanceOnTransactionComplete">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeReleaseServiceInstanceOnTransactionComplete () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeReleaseServiceInstanceOnTransactionComplete : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeReleaseServiceInstanceOnTransactionComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor que indica se a propriedade <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" /> foi alterada do valor padrão e deve ser serializada.</summary>
        <returns><see langword="true" /> se o valor da propriedade <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" /> precisar ser serializado; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionAutoCompleteOnSessionClose">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionAutoCompleteOnSessionClose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionAutoCompleteOnSessionClose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionAutoCompleteOnSessionClose () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionAutoCompleteOnSessionClose();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionAutoCompleteOnSessionClose : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionAutoCompleteOnSessionClose " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor que indica se a propriedade <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" /> foi alterada do valor padrão e deve ser serializada.</summary>
        <returns><see langword="true" /> se o valor da propriedade <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" /> precisar ser serializado; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionIsolationLevel">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionIsolationLevel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionIsolationLevel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionIsolationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionIsolationLevel () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionIsolationLevel();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionIsolationLevel : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionIsolationLevel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor que indica se a propriedade <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" /> foi alterada do valor padrão e deve ser serializada.</summary>
        <returns><see langword="true" /> se o valor da propriedade <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" /> precisar ser serializado; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionTimeout">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionTimeout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionTimeout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionTimeout () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionTimeout();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionTimeout : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionTimeout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor que indica se a propriedade <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" /> foi alterada do valor padrão e deve ser serializada.</summary>
        <returns><see langword="true" /> se o valor da propriedade <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" /> precisar ser serializado; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.AddBindingParameters">
      <MemberSignature Language="C#" Value="void IServiceBehavior.AddBindingParameters (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase, System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Description.ServiceEndpoint&gt; endpoints, System.ServiceModel.Channels.BindingParameterCollection parameters);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase, class System.Collections.ObjectModel.Collection`1&lt;class System.ServiceModel.Description.ServiceEndpoint&gt; endpoints, class System.ServiceModel.Channels.BindingParameterCollection parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#AddBindingParameters(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase,System.Collections.ObjectModel.Collection{System.ServiceModel.Description.ServiceEndpoint},System.ServiceModel.Channels.BindingParameterCollection)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase, System::Collections::ObjectModel::Collection&lt;System::ServiceModel::Description::ServiceEndpoint ^&gt; ^ endpoints, System::ServiceModel::Channels::BindingParameterCollection ^ parameters) = System::ServiceModel::Description::IServiceBehavior::AddBindingParameters;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase,System.Collections.ObjectModel.Collection{System.ServiceModel.Description.ServiceEndpoint},System.ServiceModel.Channels.BindingParameterCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
        <Parameter Name="endpoints" Type="System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Description.ServiceEndpoint&gt;" />
        <Parameter Name="parameters" Type="System.ServiceModel.Channels.BindingParameterCollection" />
      </Parameters>
      <Docs>
        <param name="description">A descrição do serviço.</param>
        <param name="serviceHostBase">O host de serviço.</param>
        <param name="endpoints">Os pontos de extremidade de serviço.</param>
        <param name="parameters">Os objetos de dados exigidos por associações para dar suporte ao comportamento.</param>
        <summary>Passa os objetos de dados personalizados para as associações compatíveis com propriedades de comportamento.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior">
      <MemberSignature Language="C#" Value="void IServiceBehavior.ApplyDispatchBehavior (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#ApplyDispatchBehavior(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase) = System::ServiceModel::Description::IServiceBehavior::ApplyDispatchBehavior;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
      </Parameters>
      <Docs>
        <param name="description">A descrição do serviço.</param>
        <param name="serviceHostBase">O host de serviço.</param>
        <summary>Personaliza o tempo de execução do serviço para ser compatível com as propriedades de comportamento.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.Validate">
      <MemberSignature Language="C#" Value="void IServiceBehavior.Validate (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.Validate(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#Validate(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.Validate(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase) = System::ServiceModel::Description::IServiceBehavior::Validate;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.Validate(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
      </Parameters>
      <Docs>
        <param name="description">A descrição do serviço.</param>
        <param name="serviceHostBase">O host de serviço.</param>
        <summary>Confirma que a descrição do serviço e o host de serviço são capazes de aceitar o comportamento.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionAutoCompleteOnSessionClose">
      <MemberSignature Language="C#" Value="public bool TransactionAutoCompleteOnSessionClose { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionAutoCompleteOnSessionClose As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TransactionAutoCompleteOnSessionClose { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionAutoCompleteOnSessionClose : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que especifica se as transações pendentes são concluídas quando a sessão atual é fechada sem erro.</summary>
        <value><see langword="true" /> Se as transações pendentes devem ser concluídas quando a sessão atual é fechada sem erro; Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionIsolationLevel">
      <MemberSignature Language="C#" Value="public System.Transactions.IsolationLevel TransactionIsolationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Transactions.IsolationLevel TransactionIsolationLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionIsolationLevel As IsolationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Transactions::IsolationLevel TransactionIsolationLevel { System::Transactions::IsolationLevel get(); void set(System::Transactions::IsolationLevel value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionIsolationLevel : System.Transactions.IsolationLevel with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Transactions.IsolationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica o nível de isolamento da transação para novas transações criadas dentro do serviço e fluxo de transações de entrada de um cliente.</summary>
        <value>Um valor <see cref="T:System.Transactions.IsolationLevel" /> que especifica o nível de isolamento da transação. O padrão é <see cref="F:System.Transactions.IsolationLevel.Unspecified" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O nível de isolamento em que as execuções de transação determina como os dados são tratados quando forem feitas alterações em outras transações e o quanto sua transação deve manter bloqueios para proteger contra essas alterações. Por exemplo, o valor padrão, <xref:System.Transactions.IsolationLevel.Unspecified>, especifica que nenhuma atualização ou inserção pode ocorrer até que a transação seja concluída.  
  
 Essa propriedade também pode ser usada para restringir o isolamento de fluxo de nível de transações de entrada de um cliente.  
  
   
  
## Examples  
 O exemplo de código a seguir define o isolamento da transação nível para <xref:System.Transactions.IsolationLevel.ReadCommitted>, não oferece suporte a transações simultâneas, exige uma transação fluída da chamada de método e confirma a transação automaticamente se nenhuma exceção sem tratamento ocorrer.  
  
 [!code-csharp[SBA.Transactions#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/services.cs#2)]
 [!code-vb[SBA.Transactions#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactions/vb/services.vb#2)]  
  
 A associação subjacente deve dar suporte a transações fluídas para o exemplo de código a seguir para serem executados corretamente. Para dar suporte a transações fluídas usando o <xref:System.ServiceModel.WSHttpBinding>, por exemplo, defina a <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> propriedade para `true` no código ou em um arquivo de configuração do aplicativo. O exemplo de código a seguir mostra um arquivo de configuração para o exemplo anterior.  
  
 [!code-xml[SBA.Transactions#1](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor não é um dos valores <see cref="T:System.Transactions.IsolationLevel" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransactionTimeout">
      <MemberSignature Language="C#" Value="public string TransactionTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionTimeout As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionTimeout { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionTimeout : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o período dentro do qual uma transação deve ser concluída.</summary>
        <value>Um objeto <see cref="T:System.TimeSpan" /> que representa o tempo no qual as transações devem ser concluídas ou ser canceladas automaticamente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse valor define o <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.TransactionTimeout%2A?displayProperty=nameWithType> propriedade. Você também pode definir essa propriedade usando o [ &lt;serviceTimeouts&gt; ](~/docs/framework/configure-apps/file-schema/wcf/servicetimeouts.md) elemento em um arquivo de configuração do aplicativo.  
  
   
  
## Examples  
 O arquivo de configuração a seguir especifica um período de tempo limite de transação de três minutos.  
  
 [!code-csharp[SBA.TransactionTimeout#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactiontimeout/cs/services.cs#2)]
 [!code-vb[SBA.TransactionTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactiontimeout/vb/services.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.TimeSpan.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseSynchronizationContext">
      <MemberSignature Language="C#" Value="public bool UseSynchronizationContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseSynchronizationContext" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Property UseSynchronizationContext As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseSynchronizationContext { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseSynchronizationContext : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que especifica se o contexto de sincronização atual deve ser usado para escolher o thread de execução.</summary>
        <value><see langword="true" /> se todas as chamadas para o serviço deverem ser executadas no thread especificado pelo <see cref="T:System.Threading.SynchronizationContext" />; caso contrário, <see langword="false" />. O valor padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa propriedade para fornecer a afinidade de thread de interface do usuário que alguns aplicativos exigem. Por exemplo, um aplicativo do Windows Forms pode ser registrado como um objeto de serviço singleton. Nesse caso, todas as chamadas para o serviço devem executar no thread de formulários do Windows. Caso padrão, no qual <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A> é definido como `true`, sincroniza todas as chamadas para o serviço para ser executado no thread capturada a partir de <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMustUnderstand">
      <MemberSignature Language="C#" Value="public bool ValidateMustUnderstand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidateMustUnderstand" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidateMustUnderstand As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidateMustUnderstand { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidateMustUnderstand : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que especifica se o sistema ou o aplicativo reforça o processamento de cabeçalho SOAP <see langword="MustUnderstand" />.</summary>
        <value><see langword="true" /> Se o sistema executar o cabeçalho SOAP <see langword="MustUnderstand" /> processamento; caso contrário, <see langword="false" />, que indica que o aplicativo executa esse processamento. O valor padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A> propriedade para desativar a validação de imposto de cabeçalhos de mensagens que chegam. No modo de execução normal, os cabeçalhos de mensagem são comparados com o <xref:System.ServiceModel.Channels.MessageHeaders.UnderstoodHeaders%2A> propriedade para confirmar que os cabeçalhos que chegam são manipulados explicitamente pelo serviço. Defina isso como `false` para desabilitar essa verificação. Quando definido como `false`, o aplicativo deve verificar se há cabeçalhos marcados com MustUnderstand = "true" e retornará uma falha se um ou mais deles não foram compreendido. Isso é útil quando o aplicativo deve aceitar quaisquer mensagens SOAP de entrada (por exemplo, quando usando digitado ou mensagens sem tipo) e executar o processamento do cabeçalho personalizado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>