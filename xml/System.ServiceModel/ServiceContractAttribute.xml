<Type Name="ServiceContractAttribute" FullName="System.ServiceModel.ServiceContractAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="aa5c44abf8964e705f5a899718153f6034bdc3df" /><Meta Name="ms.sourcegitcommit" Value="d40b35262cbc997b79bf76da3a39ccf59b738efc" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="12/05/2018" /><Meta Name="ms.locfileid" Value="52909745" /></Metadata><TypeSignature Language="C#" Value="public sealed class ServiceContractAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ServiceContractAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.ServiceContractAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ServiceContractAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceContractAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type ServiceContractAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Interface, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;dotnet-plat-ext-2.2">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Interface, AllowMultiple=false, Inherited=false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Indica que uma interface ou classe define um contrato de serviço em um aplicativo WCF (Windows Communication Foundation).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.ServiceModel.ServiceContractAttribute> atributo em uma interface (ou classe) para definir um contrato de serviço. Em seguida, use o <xref:System.ServiceModel.OperationContractAttribute> atributo em um ou mais dos métodos de classe (ou interface) para definir as operações de serviço do contrato. Quando o contrato de serviço é implementado e combinado com um [ligações](~/docs/framework/wcf/bindings.md) e um <xref:System.ServiceModel.EndpointAddress> do objeto, o contrato de serviço é exposto para uso por clientes. Para uma visão geral do processo usando exemplos simples, consulte [Tutorial de Introdução](~/docs/framework/wcf/getting-started-tutorial.md). Para obter mais informações sobre como criar contratos de serviço, consulte [projetar e implementar serviços](~/docs/framework/wcf/designing-and-implementing-services.md).  
  
 Informações expressadas por um <xref:System.ServiceModel.ServiceContractAttribute> e sua interface está livremente relacionada para a descrição de linguagem WSDL (Web Services) `<portType>` elemento. Um contrato de serviço é usado no lado do serviço para especificar qual ponto de extremidade do serviço expõe para chamadores. Ele também é usado no lado do cliente para especificar o contrato do ponto de extremidade com o qual o cliente se comunica e, no caso de contratos duplex, para especificar o contrato de retorno de chamada (usando o <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> propriedade) que o cliente deve implementar para Participe de uma conversa duplex.  
  
> [!NOTE]
>  Uma interface ou classe é decorada com <xref:System.ServiceModel.ServiceContractAttribute> também deve ter pelo menos um método marcado com o <xref:System.ServiceModel.OperationContractAttribute> atributo para expor qualquer funcionalidade. Consulte a seção de exemplos para obter um exemplo de código do uso mais simples dos dois atributos para definir e implementar um serviço.  
  
 Use o <xref:System.ServiceModel.ServiceContractAttribute> propriedades para modificar o contrato de serviço.  
  
-   O <xref:System.ServiceModel.ServiceContractAttribute.ConfigurationName%2A> propriedade especifica o nome do elemento de serviço no arquivo de configuração para usar.  
  
-   O <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> e <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> propriedades controlam o nome e namespace do contrato no WSDL `<portType>` elemento.  
  
-   O <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> propriedade especifica se o contrato exige uma ligação que dá suporte a sessões.  
  
-   O <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> propriedade especifica o contrato de retorno em uma conversa de duas vias (duplex).  
  
-   O <xref:System.ServiceModel.ServiceContractAttribute.HasProtectionLevel%2A> e <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> propriedades indicam se o contrato de suporte de todas as mensagens têm um explícito <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> valor, e nesse caso, o que esse nível é.  
  
 Os serviços implementar contratos de serviço, que representam a troca de dados que dá suporte a um tipo de serviço. Uma classe de serviço pode implementar um contrato de serviço (Implementando uma interface marcada com <xref:System.ServiceModel.ServiceContractAttribute> que tem métodos marcados com <xref:System.ServiceModel.OperationContractAttribute>) ou ele pode ser marcado com o <xref:System.ServiceModel.ServiceContractAttribute> e aplique o <xref:System.ServiceModel.OperationContractAttribute> para seus próprios métodos de atributo. (Se uma classe implementa uma interface marcada com <xref:System.ServiceModel.ServiceContractAttribute>, ele não pode ser próprio marcado com <xref:System.ServiceModel.ServiceContractAttribute>.) Métodos em tipos de serviço que são marcados com o <xref:System.ServiceModel.OperationContractAttribute> são tratados como parte de um contrato de serviço padrão especificado pelo tipo de serviço em si. Para obter detalhes sobre as operações de serviço, consulte <xref:System.ServiceModel.OperationContractAttribute>.  
  
 Por padrão, o <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> e <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> propriedades são o nome do tipo de contrato e `http://tempuri.org`, respectivamente, e <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> é <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>. Recomenda-se que contratos de serviço definida explicitamente seus nomes, namespaces e níveis de proteção usando essas propriedades. Ao fazer isso atinge dois objetivos. Primeiro, ele cria um contrato que não está conectado diretamente às informações de tipo gerenciado, permitindo que você refatorar seu código gerenciado e namespaces sem quebrar o contrato conforme ele é expresso em WSDL. Em segundo lugar, explicitamente, exigir um certo nível de proteção no próprio contrato permite que o tempo de execução validar se a configuração de associação dá suporte a esse nível de segurança, impedindo que a configuração insuficiente exponha informações confidenciais. Para obter mais informações sobre níveis de proteção, consulte [Noções básicas sobre nível de proteção](~/docs/framework/wcf/understanding-protection-level.md).  
  
 Para expor um serviço para uso por aplicativos cliente, crie um aplicativo de host para registrar seu ponto de extremidade de serviço com o Windows Communication Foundation (WCF). Você pode hospedar serviços WCF usando os serviços de ativação do Windows (WAS), em aplicativos de console, aplicativos de serviço do Windows, aplicativos ASP.NET, aplicativos do Windows Forms ou qualquer outro tipo de domínio do aplicativo.  
  
 O WAS de hospedagem é muito semelhante à criação de um aplicativo ASP.NET. Para obter detalhes, consulte [como: Hospedar um serviço WCF no IIS](~/docs/framework/wcf/feature-details/how-to-host-a-wcf-service-in-iis.md).  
  
 Os clientes também usam a interface de contrato de serviço (a interface marcada com <xref:System.ServiceModel.ServiceContractAttribute>) para criar um canal para o serviço ou eles usam os objetos de cliente (que combine as informações de tipo da interface do contrato de serviço com o <xref:System.ServiceModel.ClientBase%601> classe) para se comunicar com seu serviço. Para obter detalhes sobre os canais de cliente aos serviços, consulte a <xref:System.ServiceModel.ChannelFactory%601> classe e [visão geral do cliente WCF](~/docs/framework/wcf/wcf-client-overview.md).  
  
 Usando um <xref:System.ServiceModel.ServiceContractAttribute> classe ou interface para herdar de outro <xref:System.ServiceModel.ServiceContractAttribute> classe ou interface estende o contrato do pai. Por exemplo, se um `IChildContract` interface é marcado com <xref:System.ServiceModel.ServiceContractAttribute> e herdada de outra interface de contrato de serviço `IParentContract`, o `IChildContract` contrato de serviço contém os métodos de ambos `IParentContract` e `IChildContract`. Estender contratos (seja em classes ou interfaces) é muito semelhante à extensão de interfaces e classes gerenciadas.  
  
 A abordagem mais flexível para criação de serviços é definir interfaces de contrato de serviço pela primeira vez e, em seguida, faça a sua classe de serviço implementa essa interface. (Isso também é a maneira mais simples para criar seus serviços se você deve implementar contratos de serviço que foram definidos por outras pessoas.) Criação de serviços marcando uma classe com <xref:System.ServiceModel.ServiceContractAttribute> e seus métodos com <xref:System.ServiceModel.OperationContractAttribute> funciona quando o serviço expõe somente um contrato (mas esse contrato pode ser exposto por mais de um ponto de extremidade).  
  
 Use o <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> propriedade para indicar o outro contrato de serviço que, quando associado junto com o contrato de serviço original, defina uma troca de mensagens que pode fluir em duas maneiras de forma independente. Para obter detalhes, consulte <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como aplicar a <xref:System.ServiceModel.ServiceContractAttribute> a uma interface para definir um contrato de serviço com o método de um serviço, indicada pela <xref:System.ServiceModel.OperationContractAttribute>. Nesse caso, é o nível de proteção necessário de associações para todas as mensagens <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>.  
  
 O exemplo de código, em seguida, implementa esse contrato no `SampleService` classe.  
  
 [!code-csharp[ServiceContractAttribute#1](~/samples/snippets/csharp/VS_Snippets_CFX/servicecontractattribute/cs/services.cs#1)]
 [!code-vb[ServiceContractAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/servicecontractattribute/vb/services.vb#1)]  
  
 O exemplo de código a seguir mostra um arquivo de configuração simples para o serviço anterior que cria um ponto de extremidade.  
  
 [!code-xml[ServiceContractAttribute#2](~/samples/snippets/csharp/VS_Snippets_CFX/servicecontractattribute/cs/hostapplication.exe.config#2)]   
  
 O exemplo de código a seguir mostra um cliente simples que invoca anterior `SampleService`.  
  
 [!code-csharp[ServiceContractAttribute#3](~/samples/snippets/csharp/VS_Snippets_CFX/servicecontractattribute/cs/client.cs#3)]
 [!code-vb[ServiceContractAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/servicecontractattribute/vb/client.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceModel.OperationContractAttribute" />
    <related type="Article" href="https://msdn.microsoft.com/library/036fae20-7c55-4002-b71d-ac4466e167a3">Definindo contratos de serviço</related>
    <related type="Article" href="https://msdn.microsoft.com/library/192be927-6be2-4fda-98f0-e513c4881acc">Um serviço de hospedagem</related>
    <related type="Article" href="https://msdn.microsoft.com/library/7cf21bfe-23bd-46aa-8033-609f851dbf76">Visão geral de criação de serviço</related>
    <related type="Article" href="https://msdn.microsoft.com/library/28dfff47-d95b-4cc2-9d5c-b3b9ba71fd50">Criando um cliente</related>
    <related type="Article" href="https://msdn.microsoft.com/library/d780af9f-73c5-42db-9e52-077a5e4de7fe">Visão geral de criação de proxy</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceContractAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceContractAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceContractAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.ServiceModel.ServiceContractAttribute" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O construtor cria uma instância do atributo com nenhum requisito de sessão, nenhum contrato de retorno de chamada e o nome padrão e o namespace.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallbackContract">
      <MemberSignature Language="C#" Value="public Type CallbackContract { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type CallbackContract" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.CallbackContract" />
      <MemberSignature Language="VB.NET" Value="Public Property CallbackContract As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ CallbackContract { Type ^ get(); void set(Type ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CallbackContract : Type with get, set" Usage="System.ServiceModel.ServiceContractAttribute.CallbackContract" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tipo de contrato de retorno de chamada quando o contrato é do tipo duplex.</summary>
        <value>Um <see cref="T:System.Type" /> que indica o contrato de retorno de chamada. O padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Especifique uma interface no <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> propriedade que representa o necessária oposta contrato em uma troca de mensagens bidirecional (ou duplex). Isso permite que aplicativos cliente escutar chamadas de operações de entrada que o aplicativo de serviço do lado do servidor pode enviar independentemente de atividade do cliente. Contratos de retorno de chamada que têm operações unidirecionais representam as chamadas do serviço que o cliente pode processar.  
  
> [!NOTE]
>  O <xref:System.ServiceModel.ServiceContractAttribute> atributo é ignorado em contratos de retorno de chamada. Para configurar o comportamento de tempo de execução de objetos de retorno de chamada, use o <xref:System.ServiceModel.CallbackBehaviorAttribute?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra um serviço que especifica um contrato de retorno de chamada, que indica que um serviço do tipo `IDuplexHello` deve ter um destinatário que implementa um serviço do tipo `IHelloCallbackContract`. Além disso, `IHelloCallbackContract` implementa um método de retorno de chamada unidirecional, habilitar o serviço chamar o cliente sem aguardar uma resposta dar suporte a um cliente distribuído e controlada por evento.  
  
 [!code-csharp[SCA.CallbackContract#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.callbackcontract/cs/services.cs#1)]
 [!code-vb[SCA.CallbackContract#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.callbackcontract/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationName">
      <MemberSignature Language="C#" Value="public string ConfigurationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.ConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationName : string with get, set" Usage="System.ServiceModel.ServiceContractAttribute.ConfigurationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nome usado para localizar o serviço em um arquivo de configuração do aplicativo.</summary>
        <value>O nome usado para localizar o elemento de serviço em um arquivo de configuração de aplicativo. O padrão é o nome da classe de implementação de serviço.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para definir o valor pelo qual o sistema de configuração localiza um valor de contrato no arquivo de configuração, consulte <xref:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor é uma cadeia de caracteres vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasProtectionLevel">
      <MemberSignature Language="C#" Value="public bool HasProtectionLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.HasProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasProtectionLevel As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasProtectionLevel { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasProtectionLevel : bool" Usage="System.ServiceModel.ServiceContractAttribute.HasProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o membro tem um nível de proteção atribuído.</summary>
        <value><see langword="true" /> Se o <see cref="P:System.ServiceModel.ServiceContractAttribute.ProtectionLevel" /> není <see cref="F:System.Net.Security.ProtectionLevel.None" />; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ServiceModel.ServiceContractAttribute.HasProtectionLevel%2A> propriedade indica se uma proteção de nível valor diferente de `false` tiver sido definido para o contrato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.ServiceModel.ServiceContractAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nome do elemento <see langword="&lt;portType&gt;" /> na linguagem WSDL.</summary>
        <value>O valor padrão é o nome da classe ou da interface à qual o <see cref="T:System.ServiceModel.ServiceContractAttribute" /> é aplicado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> e o <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> propriedades para controlar o nome e namespace do `<portType>` elemento no WSDL.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar o <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> e <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> propriedades do <xref:System.ServiceModel.ServiceContractAttribute> para definir os valores correspondentes no WSDL.  
  
 [!code-csharp[SCA.Names#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/services.cs#1)]
 [!code-vb[SCA.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/services.vb#1)]  
  
 O exemplo de código a seguir mostra um cliente do Windows Communication Foundation (WCF) para o serviço anterior que WSDL importados usando o [ferramenta de utilitário de metadados ServiceModel (Svcutil.exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md). Esse cliente usa um `HelloWorldProxy` cliente em vez de uma `SampleServiceProxy` cliente (como é o caso com o exemplo na seção exemplo <xref:System.ServiceModel.ServiceContractAttribute>).  
  
 [!code-csharp[SCA.Names#3](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/client.cs#3)]
 [!code-vb[SCA.Names#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/client.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor é uma cadeia de caracteres vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.ServiceModel.ServiceContractAttribute.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o namespace do elemento <see langword="&lt;portType&gt;" /> na linguagem WSDL.</summary>
        <value>O namespace WSDL do <see langword="&lt;portType&gt;" /> elemento. O valor padrão é "http://tempuri.org".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir mostra como usar o <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> e <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> propriedades do <xref:System.ServiceModel.ServiceContractAttribute> para definir os valores correspondentes no WSDL.  
  
 [!code-csharp[SCA.Names#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/services.cs#1)]
 [!code-vb[SCA.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/services.vb#1)]  
  
 O exemplo de código a seguir mostra um cliente do Windows Communication Foundation (WCF) para o serviço anterior que WSDL importados usando o [ferramenta de utilitário de metadados ServiceModel (Svcutil.exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md). Esse cliente usa um `HelloWorldClient` cliente em vez de uma `SampleServiceClient` cliente (como é o caso com o exemplo na seção exemplo <xref:System.ServiceModel.ServiceContractAttribute>).  
  
 [!code-csharp[SCA.Names#3](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/client.cs#3)]
 [!code-vb[SCA.Names#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/client.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectionLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.ProtectionLevel ProtectionLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.ProtectionLevel ProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.ProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtectionLevel As ProtectionLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::ProtectionLevel ProtectionLevel { System::Net::Security::ProtectionLevel get(); void set(System::Net::Security::ProtectionLevel value); };" />
      <MemberSignature Language="F#" Value="member this.ProtectionLevel : System.Net.Security.ProtectionLevel with get, set" Usage="System.ServiceModel.ServiceContractAttribute.ProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Security.ProtectionLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica se a associação para o contrato deve oferecer suporte ao valor da propriedade <see cref="P:System.ServiceModel.ServiceContractAttribute.ProtectionLevel" />.</summary>
        <value>Um dos valores de <see cref="T:System.Net.Security.ProtectionLevel" />. O padrão é <see cref="F:System.Net.Security.ProtectionLevel.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> propriedade para especificar o grau ao qual a associação de contrato requer criptografia, assinaturas digitais ou ambos para pontos de extremidade que expõem o contrato. O valor definido aqui é o valor padrão para todas as mensagens de operação, incluindo falhas.  
  
 É importante lembrar que o comportamento de proteção em tempo de execução é a combinação dos valores de nível de proteção definidas nas propriedades a seguir. Essas propriedades têm uma estrutura hierárquica. Definir o valor mais externo estabelece a configuração padrão para todos os escopos mais estreitas, a menos que um valor diferente para um escopo mais restrito é explicitamente definido. Nesse caso, o valor externo permanece como padrão para todos os mais estreitos escopos com a exceção de que especificamente definido.  
  
 Por exemplo, se <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType> é definido como <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> e não há outros escopos mais estreitos têm configurações de nível de proteção, todas as mensagens em um contrato de operação são criptografadas e assinadas. Se, no entanto, uma dessas operações tem o <xref:System.ServiceModel.OperationContractAttribute> definido como <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType>, em seguida, as mensagens para essa operação são assinadas, mas todas as outras mensagens no contrato são criptografadas e assinadas.  
  
 Para obter detalhes sobre os níveis de proteção e suas suposições e escopos, consulte [Noções básicas sobre nível de proteção](~/docs/framework/wcf/understanding-protection-level.md).  
  
 Os escopos em que esses valores são definidos são:  
  
 <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.MessageContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 O <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> propriedade <xref:System.ServiceModel.MessageHeaderAttribute?displayProperty=nameWithType>.  
  
 O <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> propriedade <xref:System.ServiceModel.MessageBodyMemberAttribute?displayProperty=nameWithType>.  
  
 Quando não há nenhum nível de proteção especificado explicitamente no contrato e a associação subjacente dá suporte à segurança (quer seja no nível de transporte ou de mensagens), o nível de proteção eficaz para o contrato de inteiro é <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>. Se a associação não dá suporte a segurança (como <xref:System.ServiceModel.BasicHttpBinding>), a efetiva <xref:System.Net.Security.ProtectionLevel?displayProperty=nameWithType> é <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType> para o contrato de inteiro. O resultado é esse acordo com a associação de ponto de extremidade, os clientes podem exigir proteção de segurança em nível de mensagem ou de transporte diferentes, mesmo quando o contrato especifica <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor não é um dos valores <see cref="T:System.Net.Security.ProtectionLevel" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SessionMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.SessionMode SessionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.SessionMode SessionMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.SessionMode" />
      <MemberSignature Language="VB.NET" Value="Public Property SessionMode As SessionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::SessionMode SessionMode { System::ServiceModel::SessionMode get(); void set(System::ServiceModel::SessionMode value); };" />
      <MemberSignature Language="F#" Value="member this.SessionMode : System.ServiceModel.SessionMode with get, set" Usage="System.ServiceModel.ServiceContractAttribute.SessionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.SessionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define se as sessões são permitidas, não são permitidas ou são necessárias.</summary>
        <value>Um <see cref="T:System.ServiceModel.SessionMode" /> que indica se as sessões são permitidas, não são permitidas ou são necessárias.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> propriedade para exigir que as associações que dá suporte a sessões entre pontos de extremidade. Uma sessão é uma maneira de correlacionar um conjunto de mensagens trocadas entre duas ou mais pontos de extremidade. Se o serviço dá suporte a sessões de canal, você pode usar o <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> propriedade para especificar a relação entre instâncias de sua implementação do contrato de serviço e a sessão de canal. Se uma associação não oferece suporte a sessões, uma exceção é lançada.  
  
 Por exemplo, se o <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> estiver definida como <xref:System.ServiceModel.SessionMode.Required?displayProperty=nameWithType> e o <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> estiver definida como <xref:System.ServiceModel.InstanceContextMode.PerSession>, os clientes podem usar a mesma conexão para fazer chamadas repetidas para o mesmo objeto de serviço.  
  
 Para obter mais informações sobre as sessões e instâncias de serviço, consulte [usando sessões](~/docs/framework/wcf/using-sessions.md) e [sessões, criação de instâncias e simultaneidade](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
> [!NOTE]
>  Um canal que dá suporte a sessões oferece suporte a associação de padrão de uma instância de serviço com uma determinada sessão. No entanto, as implementações de sessão diferente dão suporte a diferentes recursos, além do controle de instanciação baseadas em sessão. O WCF fornece quatro tipos de sessões que você pode usar para fornecer comportamento de sessão do aplicativo. cada tipo de sessão fornece comportamento adicional específico para o tipo de sessão é.  
  
1.  O <xref:System.ServiceModel.Channels.SecurityBindingElement?displayProperty=nameWithType> dá suporte a sessões de segurança, em que ambas as extremidades de comunicação concordamos um processo de assinatura digital e/ou criptografia; todas as mensagens são correlacionadas com essa conversa segura específica. Para obter mais informações, consulte [protegendo serviços](~/docs/framework/wcf/securing-services.md). Por exemplo, o <xref:System.ServiceModel.WSHttpBinding?displayProperty=nameWithType>, que contém o suporte para ambas as sessões de segurança e sessões confiáveis, por padrão, usa somente uma sessão segura que criptografa e assina digitalmente as mensagens.  
  
2.  O <xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> dá suporte a sessões expostas pelas conexões TCP/IP para garantir que todas as mensagens são correlacionadas pela sessão de conexão no nível de soquete.  
  
3.  O <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType>, que implementa a especificação de WS-ReliableMessaging, fornece suporte para sessões confiáveis em que as mensagens são entregues em ordem e exatamente uma vez, habilitando a confiança, mesmo quando as mensagens passam em vários nós durante a conversa. Para obter mais informações, consulte [sessões confiáveis](~/docs/framework/wcf/feature-details/reliable-sessions.md).  
  
4.  O <xref:System.ServiceModel.NetMsmqBinding?displayProperty=nameWithType> fornece sessões de datagrama do MSMQ. Para obter mais informações, consulte [filas no WCF](~/docs/framework/wcf/feature-details/queues-in-wcf.md).  
  
 Lembre-se de que a configuração de <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> propriedade não especifica o tipo de sessão, o contrato requer, somente que ele requer um.  
  
   
  
## Examples  
 O contrato de serviço a seguir requer que associações configuradas usam sessões ao interagir com `SampleDuplexHello` implementações de serviço.  
  
 [!code-csharp[SCA.Session#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.session/cs/services.cs#1)]
 [!code-vb[SCA.Session#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.session/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor não é um dos valores <see cref="T:System.ServiceModel.SessionMode" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>