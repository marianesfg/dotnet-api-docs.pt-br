<Type Name="ControlAdapter" FullName="System.Web.UI.Adapters.ControlAdapter">
  <Metadata><Meta Name="ms.openlocfilehash" Value="323b2b9e01a99fd820207f307825f68b6ebb75ac" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53462120" /></Metadata><TypeSignature Language="C#" Value="public abstract class ControlAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ControlAdapter extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Adapters.ControlAdapter" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ControlAdapter" />
  <TypeSignature Language="C++ CLI" Value="public ref class ControlAdapter abstract" />
  <TypeSignature Language="F#" Value="type ControlAdapter = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Personaliza a renderização do controle derivado ao qual o adaptador está anexado, para modificar o comportamento ou marcação padrão para navegadores específicos e é a classe base que todos os adaptadores de controle herdam.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Adaptadores de controle são componentes que substituem determinados <xref:System.Web.UI.Control> métodos e eventos do ciclo de vida de execução para permitir que o navegador ou manipulação de marcação específicas de classe. O .NET Framework mapeia um adaptador de controle derivada única para um <xref:System.Web.UI.Control> objeto para cada solicitação de cliente.  
  
 Um adaptador modifica um controle para um navegador específico ou a classe de navegadores ou atua como um filtro arbitrário em algum recurso. Normalmente, o adaptador é definido pela linguagem de marcação que o navegador (por exemplo, XHTML ou HTML 3.2). Grande parte da capacidade de adaptação no comportamento de renderização pode ser encapsulado nas classes especializadas que derivam de <xref:System.Web.UI.HtmlTextWriter> classe. Portanto, é provável que um único adaptador pode ser usado para um número de comportamentos de classe do navegador ou essa inclusão de capacidade de adaptação no <xref:System.Web.UI.HtmlTextWriter> classes poderiam tornar o uso de um adaptador de controle desnecessários.  
  
 Um adaptador para uma classe de controle se aplica a todos os controles que herdam dessa classe, a menos que mais especializadas adaptadores estão presentes. Por exemplo, um adaptador para o <xref:System.Web.UI.WebControls.BaseValidator> classe pode ser usada para todos os `Validator` objetos.  
  
 Adaptadores normalmente não herdam diretamente o <xref:System.Web.UI.Adapters.ControlAdapter> classe, mas um do adaptador de destino específico classes que fornecem funcionalidade adicional específica para o navegador de tipo e de destino do controle de base ou a renderização específica é necessária.  
  
 Controles em si não exigem, necessariamente, um adaptador. Se os controles são estendidos por meio da composição, geralmente, os adaptadores de controle filho são suficientes.  
  
 Cada controle tem mapeamentos explícitos para adaptadores através dos arquivos de definição. browser. Assim, qualquer acesso à <xref:System.Web.UI.Control.Adapter%2A?displayProperty=nameWithType> propriedade usa o <xref:System.Web.HttpBrowserCapabilities> extraído dos arquivos de definição do navegador para executar a pesquisa para o mapeamento do adaptador para o controle do objeto.  
  
 Durante o processamento, o .NET Framework intercepta as chamadas para os métodos substituíveis de um controle que pode ser um destino específico. Se um adaptador de controle está anexado, o .NET Framework chama os métodos de adaptador associado.  
  
 O adaptador executa a renderização para o controle por meio de <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> método. Se for substituído, <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> potencialmente não devem chamar a implementação da classe base como que realiza uma chamada de volta no <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> método. Isso pode causar a renderização ocorra duas vezes, uma vez pelo adaptador e uma vez pelo controle.  
  
 O <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> basear chamadas de método a <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> método do controle. Portanto, se você substituir <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>, você não deve chamar a implementação da classe base, a menos que a renderização é implementar além é fornecida pelo <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> do controle.  
  
 Você deve garantir que o .NET Framework realiza a interceptação para adaptadores de controles filho. Você pode fazer isso chamando o <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> base de método, que chama o <xref:System.Web.UI.Control.RenderChildren%2A?displayProperty=nameWithType> método do controle, de seu <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> substituir.  
  
 O <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> e <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> métodos são chamados pelo controle imediatamente antes e depois (respectivamente) o controle chama o <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> método. Se o pré e pós-processamento são específicos do navegador apenas tarefas de processamento necessárias, usando <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> e <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> podem torná-lo desnecessários substituir <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>. O comportamento padrão do <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> e <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> métodos é chamar os métodos correspondentes a <xref:System.Web.UI.HtmlTextWriter>.  
  
 Para manter suas próprias informações de estado, um adaptador de controle pode substituir a <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, e <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> métodos. <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, e <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> são chamados quando os estados de controle e exibição privados são salvos e carregados, respectivamente.  
  
 O <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>, e <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> chamada de métodos de base novamente na correspondentes <xref:System.Web.UI.Control> métodos de classe. Portanto, qualquer um desses <xref:System.Web.UI.Adapters.ControlAdapter> métodos que são substituídos devem chamar seus métodos base; caso contrário, o evento associado a <xref:System.Web.UI.Control> método de classe não será gerado.  
  
 Controles e adaptadores, opcionalmente, implementam a <xref:System.Web.UI.IPostBackDataHandler> e <xref:System.Web.UI.IPostBackEventHandler> interfaces. O .NET Framework determina se um adaptador existe e se o adaptador implementa essas interfaces. Se isso acontecer, o adaptador deve substituir a <xref:System.Web.UI.IPostBackDataHandler.LoadPostData%2A>, <xref:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent%2A>, e <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> métodos, conforme necessário. Se os dados de postback não são reconhecidos no adaptador, ela deve chamar novamente no controle para processá-lo. Manipuladores de eventos subsequentes também devem retornar a chamada no controle.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Quando você herda de <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> classe, um controle que requeira uma funcionalidade geral do adaptador deve ter um adaptador correspondente denominado no padrão da classe base <paramref name="ControlType" /> <see langword="Adapter" /> (por exemplo, <see langword="TextBoxAdapter" />). O adaptador deve no mínimo retornar uma instância fortemente tipada de controle por meio de seu <see cref="P:System.Web.UI.Adapters.ControlAdapter.Control" /> propriedade.  
  
1.  Adaptadores de controle para uma linguagem de marcação e de tipo determinado de controle deve ser nomeada no padrão <paramref name="MarkupControlType" /> <see langword="Adapter" /> (por exemplo, <see langword="XhtmlTextBoxAdapter" />). Adaptadores para um controle devem ser implementados em uma <see langword="Adapters" /> subnamespace.  
  
Adaptadores de controle devem herdar da classe base apropriada e siga o mesmo modelo de herança que o controle. Por exemplo, um adaptador para um controle herdando a <see cref="T:System.Web.UI.Control" /> classe base deve herdar de qualquer um os <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> classe ou o relevantes <paramref name="ControlType" /> <see langword="Adapter" /> classe.  
  
Todos os adaptadores especializados devem ser definidos para o controle especializado em todos os nós de dispositivo em arquivos de configuração de. browser.  
  
Um controle implementado adequadamente não deve presumir que um adaptador está conectado ou que o adaptador anexado implementa uma interface específica. Em vez disso, ele deve verificar essas antes de chamar.  
  
É possível simular a substituição de métodos de evento protegido no controle, como o <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> método da <see cref="T:System.Web.UI.WebControls.LinkButton" />. Primeiro, crie uma classe de adaptador com um <c>OnClick</c> método. Em seguida, crie um novo controle derivado de <see cref="T:System.Web.UI.WebControls.LinkButton" /> e substitua o <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> método. A substituída <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> chamadas de método de <c>OnClick</c> método do adaptador. O objeto do adaptador está disponível por meio de protegidas <see cref="P:System.Web.UI.Control.Adapter" /> propriedade do <see cref="T:System.Web.UI.Control" /> classe. O <see cref="P:System.Web.UI.Control.Adapter" /> é de propriedade do controle <see langword="null" /> quando não há nenhum adaptador associado, portanto, qualquer código deve verificar se há essa condição antes de chamar métodos do adaptador.</para></block>
    <altmember cref="T:System.Web.UI.Control" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ControlAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ControlAdapter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Web.UI.Adapters.ControlAdapter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework constrói internamente este adaptador quando ele cria correspondente <xref:System.Web.UI.Control> objeto.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="BeginRender">
      <MemberSignature Language="C#" Value="protected internal virtual void BeginRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void BeginRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub BeginRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void BeginRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.BeginRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">O <see cref="T:System.Web.UI.HtmlTextWriter" /> que contém os métodos para renderizar a saída específica do destino.</param>
        <summary>Chamado antes da renderização de um controle. Em uma classe de adaptador derivada, gera marcas de abertura que são necessárias para um destino específico, mas não para navegadores HTML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> método é chamado imediatamente antes o <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> método e é usado para executar o pré-processamento antes do processamento do controle de destino específico.  
  
 Use o <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> método em combinação com o <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> método para garantir que a abertura e fechamento de consistência de marca.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ao herdar dos <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> classe, o <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> chamadas de método de base a <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> método. Assim, substituições do <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> método deve chamar o <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> base método somente se o seu processamento é além, em vez de em vez do <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> método.</para></block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="protected System.Web.HttpBrowserCapabilities Browser { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Browser As HttpBrowserCapabilities" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::HttpBrowserCapabilities ^ Browser { System::Web::HttpBrowserCapabilities ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Browser : System.Web.HttpBrowserCapabilities" Usage="System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma referência aos recursos do navegador do cliente que está fazendo a solicitação HTTP atual.</summary>
        <value>Um <see cref="T:System.Web.HttpBrowserCapabilities" /> especificando os recursos de navegador e a marcação do cliente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Web.UI.Adapters.ControlAdapter> objeto determina os recursos do navegador do cliente da <xref:System.Web.HttpBrowserCapabilities> objeto que é retornado pelo <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> propriedade. Isso permite que o <xref:System.Web.UI.Adapters.ControlAdapter> objeto para renderizar a marcação específica do navegador ou modificar o comportamento do <xref:System.Web.UI.Control>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar o <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> propriedade para acessar os detalhes do navegador solicitante. Neste exemplo, o código verifica para determinar se o navegador é compatível com JavaScript e, em seguida, permite que o desenvolvedor renderizar a saída personalizada nesse caso.  
  
 [!code-cpp[ControlAdapter_Browser#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_Browser/CPP/controladapter_browser.cpp#1)]
 [!code-csharp[ControlAdapter_Browser#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_Browser/CS/controladapter_browser.cs#1)]
 [!code-vb[ControlAdapter_Browser#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_Browser/VB/controladapter_browser.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="Control">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Control Control { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Control" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Control As Control" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Control ^ Control { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Control : System.Web.UI.Control" Usage="System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma referência ao controle ao qual esse adaptador de controle está anexado.</summary>
        <value>O <see cref="T:System.Web.UI.Control" /> ao qual este <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> está anexado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um adaptador de controle derivada está anexado a um controle, o .NET Framework chama determinados membros de adaptador, em vez dos membros de controle.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como derivar um controle personalizado a <xref:System.Web.UI.Control> de classe e, em seguida, criar um adaptador correspondente que herda o <xref:System.Web.UI.Adapters.ControlAdapter> classe. O adaptador substitui o <xref:System.Web.UI.Adapters.ControlAdapter.Control%2A> propriedade e retorna uma referência fortemente tipada ao controle.  
  
 [!code-cpp[ControlAdapter.Control#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter.Control/CPP/controladapter.control.cpp#1)]
 [!code-csharp[ControlAdapter.Control#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter.Control/CS/controladapter.control.cs#1)]
 [!code-vb[ControlAdapter.Control#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter.Control/VB/controladapter.control.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando você herda o <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> classe, no mínimo, você deve implementar um <see langword="Control" /> propriedade para retornar uma instância fortemente tipada do controle, conforme mostrado na seção exemplo.</para></block>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected internal virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CreateChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CreateChildControls();" />
      <MemberSignature Language="F#" Value="abstract member CreateChildControls : unit -&gt; unit&#xA;override this.CreateChildControls : unit -&gt; unit" Usage="controlAdapter.CreateChildControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria os controles filho de destino específico de um controle de composição.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se não houver um adaptador de controle derivada anexado a um <xref:System.Web.UI.Control> objeto e o <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> método for substituído, a substituição é chamada em vez do <xref:System.Web.UI.Control.CreateChildControls%2A?displayProperty=nameWithType> método. Portanto, <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> pode ser usado para criar um conjunto de controles filho de destino específico.  
  
 Para obter mais informações sobre como combinar controles para criar um novo controle, consulte [controles de composição](https://msdn.microsoft.com/library/fb174677-d845-467c-8bf3-cc096b2490b0).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Se você criar uma classe herdada e substituir o <see cref="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" /> método, faça não chamar o método base, a menos que você deseja adicionar controles aos criado pelo método base. Caso contrário, você pode criar dois conjuntos de filho controles.</para></block>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="EndRender">
      <MemberSignature Language="C#" Value="protected internal virtual void EndRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void EndRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub EndRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void EndRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member EndRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.EndRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.EndRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">O <see cref="T:System.Web.UI.HtmlTextWriter" /> que contém os métodos para renderizar a saída específica do destino.</param>
        <summary>Chamado depois da renderização de um controle. Em uma classe de adaptador derivada, gera marcas de fechamento que são necessárias para um destino específico, mas não para navegadores HTML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> método é chamado logo após o <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> método e é usado para executar o pós-processamento de destino específico após a renderização do controle.  
  
 Use o <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> método em combinação com o <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> método para garantir que a abertura e fechamento de consistência de marca.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ao herdar dos <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> classe, o <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> chamadas de método de base a <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> método. Assim, substituições do <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> método deve chamar o <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> base método somente se o seu processamento é além, em vez de em vez do <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> método.</para></block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.EndRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterControlState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterControlState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterControlState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterControlState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterControlState : obj -&gt; unit&#xA;override this.LoadAdapterControlState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterControlState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Um <see cref="T:System.Object" /> que contém informações sobre o estado do controle do adaptador como um <see cref="T:System.Web.UI.StateBag" />.</param>
        <summary>Carrega informações sobre o estado do controle do adaptador que foram salvas pelo <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" /> durante a solicitação anterior à página em que o controle associado a esse adaptador de controle está.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estado de controle é as informações de estado essencial necessárias até mesmo quando o estado de exibição está desabilitado. Quando um adaptador precisa manter suas próprias informações de estado de controle, ele pode substituir a <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> e <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> métodos.  
  
 Um adaptador, talvez seja necessário manter informações de estado do controle quando há recursos que precisam ter estado mantido entre as solicitações, independentemente do estado do controle associado. Por exemplo, um controle composto consiste em uma exibição textual grande e um grupo de <xref:System.Web.UI.WebControls.RadioButton> controles podem processar como uma única exibição nos navegadores de computador desktop. Em outros navegadores, ele pode dividir sua renderização - uma exibição para a exibição textual e outro para o grupo de botões de opção. O adaptador precisa manter suas próprias informações de destino específico sobre o modo de exibição ativo no momento.  
  
 O <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> método é chamado imediatamente após o <xref:System.Web.UI.Control.LoadControlState%2A?displayProperty=nameWithType> método, no `LoadState` estágio do ciclo de vida. O estado de controle do adaptador é separada e, além do estado do controle do controle.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterViewState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterViewState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterViewState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterViewState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterViewState : obj -&gt; unit&#xA;override this.LoadAdapterViewState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterViewState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Um <see cref="T:System.Object" /> que contém informações sobre o estado de exibição do adaptador como um <see cref="T:System.Web.UI.StateBag" />.</param>
        <summary>Carrega informações sobre o estado de exibição do adaptador que foram salvas pelo <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" /> durante uma solicitação anterior à página em que o controle associado a esse adaptador de controle está.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um adaptador precisa manter suas próprias informações de estado de exibição, pode substituir a <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> e <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> métodos.  
  
 Precisa de um adaptador manter informações de estado de exibição quando não há dados que devem ser mantidos em todas as solicitações, independentemente do estado de exibição do controle associado. Por exemplo, um controle de grade em navegadores de desktop pode processar como uma única exibição de linhas e colunas de valores. Em outros navegadores, ele pode dividir sua renderização em várias exibições separadas, como uma lista de linhas e detalhes de uma única linha. O adaptador precisa manter os dados para os modos de exibição que não estão atualmente ativos no estado de exibição.  
  
 O <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> método é chamado imediatamente antes do <xref:System.Web.UI.Control.LoadViewState%2A?displayProperty=nameWithType> método no `LoadState` estágio do ciclo de vida. O estado de exibição do adaptador é separado e, além do estado de exibição do controle.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInit : EventArgs -&gt; unit&#xA;override this.OnInit : EventArgs -&gt; unit" Usage="controlAdapter.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Substitui o método <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> do controle associado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se não houver um adaptador conectado a um <xref:System.Web.UI.Control> objeto e o <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> método for substituído, o método de substituição é chamado em vez do <xref:System.Web.UI.Control.OnInit%2A?displayProperty=nameWithType> método.  
  
 Substituir <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> para executar o processamento de destino específico no `Initialize` estágio do ciclo de vida do controle. Normalmente, são funções que são executadas quando um controle é criado.  
  
   
  
## Examples  
 O exemplo de código a seguir é derivado de um adaptador de controle personalizado do <xref:System.Web.UI.Adapters.ControlAdapter> classe. Ele então substitui o <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> método para definir uma propriedade no controle associado e chamar o método base para concluir a inicialização do controle.  
  
 [!code-cpp[ControlAdapter_OnInit#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_OnInit/CPP/controladapter_oninit.cpp#1)]
 [!code-csharp[ControlAdapter_OnInit#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_OnInit/CS/controladapter_oninit.cs#1)]
 [!code-vb[ControlAdapter_OnInit#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_OnInit/VB/controladapter_oninit.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ao herdar dos <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> classe e as substituições de adaptador a <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" /> método, o adaptador deve chamar o método de classe base correspondente, que por sua vez chama o <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> método. Se o <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> método não for chamado, o <see cref="E:System.Web.UI.Control.Init" /> evento não será gerado.</para></block>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <altmember cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoad : EventArgs -&gt; unit&#xA;override this.OnLoad : EventArgs -&gt; unit" Usage="controlAdapter.OnLoad e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Substitui o método <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> do controle associado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se não houver um adaptador conectado a um <xref:System.Web.UI.Control> objeto e o <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> método for substituído, o método de substituição é chamado em vez do <xref:System.Web.UI.Control.OnLoad%2A?displayProperty=nameWithType> método.  
  
 Substituir a <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> método para executar o processamento de destino específico no `Load` estágio do ciclo de vida do controle. Normalmente, são funções que devem ser executadas para cada solicitação de cliente.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ao herdar dos <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> classe e as substituições de adaptador a <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" /> método, o adaptador deve chamar o método de classe base correspondente, que por sua vez chama o <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> método. Se <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> não for chamado, o <see cref="E:System.Web.UI.Control.Load" /> evento não será gerado.</para></block>
        <altmember cref="E:System.Web.UI.Control.Load" />
        <altmember cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreRender : EventArgs -&gt; unit&#xA;override this.OnPreRender : EventArgs -&gt; unit" Usage="controlAdapter.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Substitui o método <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> do controle associado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se não houver um adaptador conectado a um <xref:System.Web.UI.Control> objeto e o <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> método for substituído, o método de substituição é chamado em vez do <xref:System.Web.UI.Control.OnPreRender%2A?displayProperty=nameWithType> método.  
  
 Substituir a <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> método para executar o processamento de destino específico no `PreRender` estágio do ciclo de vida do controle. Normalmente, são funções que precedem imediatamente o processamento da saída do controle.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ao herdar dos <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> classe e as substituições de adaptador a <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" /> método, o adaptador deve chamar o método de classe base correspondente, que por sua vez chama o <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> método. Se o <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> método não for chamado, o <see cref="E:System.Web.UI.Control.PreRender" /> evento não será gerado.</para></block>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <altmember cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnload : EventArgs -&gt; unit&#xA;override this.OnUnload : EventArgs -&gt; unit" Usage="controlAdapter.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Substitui o método <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> do controle associado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se não houver um adaptador conectado a um <xref:System.Web.UI.Control> objeto e o <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> método for substituído, o método de substituição é chamado em vez do <xref:System.Web.UI.Control.OnUnload%2A?displayProperty=nameWithType> método.  
  
 Substituir a <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> método para fazer o processamento de destino específico `Unload` estágio do ciclo de vida do controle. Normalmente, são funções de limpeza que precedem o descarte do controle.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ao herdar dos <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> classe e as substituições de adaptador a <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" /> método, o adaptador deve chamar o método de classe base correspondente, que por sua vez chama o <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> método. Se <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> não for chamado, o <see cref="E:System.Web.UI.Control.Unload" /> evento não será gerado.</para></block>
        <altmember cref="E:System.Web.UI.Control.Unload" />
        <altmember cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Page Page { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Page As Page" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Page ^ Page { System::Web::UI::Page ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Page : System.Web.UI.Page" Usage="System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma referência à página em que o controle associado a esse adaptador está.</summary>
        <value>Um <see cref="T:System.Web.UI.Page" /> que fornece acesso à instância de página em que o controle associado está localizado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Adapters.ControlAdapter.Page%2A> propriedade fornece acesso para o <xref:System.Web.UI.Page?displayProperty=nameWithType> objeto em que o controle está localizado.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property PageAdapter As PageAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Adapters::PageAdapter ^ PageAdapter { System::Web::UI::Adapters::PageAdapter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageAdapter : System.Web.UI.Adapters.PageAdapter" Usage="System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma referência ao adaptador de página da página em que o controle associado está.</summary>
        <value>Um <see cref="T:System.Web.UI.Adapters.PageAdapter" /> para a página em que o controle associado ao atual <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> está localizada.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> propriedade fornece acesso aos <xref:System.Web.UI.Adapters.PageAdapter?displayProperty=nameWithType> de objeto para o <xref:System.Web.UI.Page> objeto onde o <xref:System.Web.UI.Control> objeto associado atual <xref:System.Web.UI.Adapters.ControlAdapter> objeto está situado.  
  
 O <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> propriedade pode ser usada para acessar outros itens no nível do adaptador de página, como funções comuns de destino específico que pode aplicar a vários tipos de controle na página.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Adapters.PageAdapter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Render : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">O <see cref="T:System.Web.UI.HtmlTextWriter" /> a ser usado para renderizar a saída de destino específico.</param>
        <summary>Gera a marcação específica do destino para o controle ao qual o adaptador de controle está anexado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Substituir o <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> método para gerar a marcação específica do destino para enviar ao navegador do cliente. O <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> método é chamado em vez do <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> método se uma <xref:System.Web.UI.Adapters.ControlAdapter> objeto é anexado a um <xref:System.Web.UI.Control> objeto.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ao herdar dos <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> classe, o <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> chamadas de método de base a <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> método. Assim, substituições do <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> método deve chamar o <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> base método somente se o seu processamento é além, em vez de em vez do <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> método.  
  
Para um controle composto, o desenvolvedor do adaptador deve garantir que os controles filho são renderizados. Se o <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> método faz com que o filho controla a serem processados, mas não gera marcação, ele pode ser apropriado para o <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> método para chamar o método base. Se a renderização de destino específico de controles filho for necessária, o adaptador deve implementar o <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> método e chamar o <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> método da <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> método.</para></block>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RenderChildren (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RenderChildren(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.RenderChildren writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">O <see cref="T:System.Web.UI.HtmlTextWriter" /> a ser usado para renderizar a saída de destino específico.</param>
        <summary>Gera a marcação específica para o destino dos controles filho em um controle de composição ao qual o adaptador de controle está anexado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Substituir o <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> método quando for necessário gerar marcação específica do destino para o conjunto de controles filho de um controle composto, além disso, a marcação para os controles filhos individuais.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando você herda o <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> classe, para um controle composto, o desenvolvedor do adaptador deve garantir que os controles filho são renderizados. Se o adaptador substitui o <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> método, ele deverá chamar o <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> método da substituição do <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> método.  
  
Se o <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> método faz com que o filho controla a serem processados, mas em si não gera a marcação, ele pode ser apropriado para o <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> método para chamar o método de base, que chama o <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> método, em vez de implementar uma substituição para o o <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> método.</para></block>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterControlState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterControlState : unit -&gt; obj&#xA;override this.SaveAdapterControlState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Salva informações de estado do controle do adaptador de controle.</summary>
        <returns>Um <see cref="T:System.Object" /> que contém informações sobre o estado do controle do adaptador como um <see cref="T:System.Web.UI.StateBag" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estado de controle é as informações de estado essencial necessárias até mesmo quando o estado de exibição está desabilitado. Quando um adaptador precisa manter suas próprias informações de estado de controle, ele pode substituir a <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> e <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> métodos.  
  
 Um adaptador, talvez seja necessário manter informações de estado do controle quando há recursos que precisam ter estado mantido entre as solicitações, independentemente do estado do controle associado. Por exemplo, um controle composto consiste em uma exibição textual grande e um grupo de <xref:System.Web.UI.WebControls.RadioButton> controles podem processar como uma única exibição nos navegadores de computador desktop. Em outros navegadores, ele pode dividir sua renderização - uma exibição para a exibição textual e outro para o grupo de botões de opção. O adaptador precisa manter suas próprias informações de destino específico sobre o modo de exibição ativo no momento.  
  
 O <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> método é chamado imediatamente após o <xref:System.Web.UI.Control.SaveControlState%2A?displayProperty=nameWithType> método o `SaveState` estágio do ciclo de vida. O estado de controle do adaptador é separada e, além do estado do controle do controle.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterViewState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterViewState : unit -&gt; obj&#xA;override this.SaveAdapterViewState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Salva informações de estado de exibição do adaptador de controle.</summary>
        <returns>Um <see cref="T:System.Object" /> que contém informações sobre o estado de exibição do adaptador como um <see cref="T:System.Web.UI.StateBag" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um adaptador precisa manter suas próprias informações de estado de exibição, pode substituir a <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> e <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> métodos.  
  
 Precisa de um adaptador manter informações de estado de exibição quando não há dados que devem ser mantidos em todas as solicitações, independentemente do estado de exibição associada do controle. Por exemplo, um controle de grade em navegadores de desktop pode processar como uma única exibição de linhas e colunas de valores. Em outros navegadores, ele pode dividir sua renderização em várias exibições separadas, como uma lista de linhas e detalhes de uma única linha. O adaptador precisa manter os dados para os modos de exibição que não estão atualmente ativos no estado de exibição.  
  
 O <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> método é chamado imediatamente antes do <xref:System.Web.UI.Control.SaveViewState%2A?displayProperty=nameWithType> método no `SaveState` estágio do ciclo de vida. O estado de exibição do adaptador é separado e, além do estado de exibição do controle.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
  </Members>
</Type>