<Type Name="HttpContext" FullName="System.Web.HttpContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4caa3c6c6c3478e5604dd9219b10cf050497eea3" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52236290" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpContext : IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpContext extends System.Object implements class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpContext&#xA;Implements IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpContext sealed : IServiceProvider" />
  <TypeSignature Language="F#" Value="type HttpContext = class&#xA;    interface IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Encapsula todas as informações específicas de HTTP sobre uma solicitação HTTP individual.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As classes que herdam de <xref:System.Web.IHttpModule> e <xref:System.Web.IHttpHandler> interfaces são fornecidas a uma referência a um <xref:System.Web.HttpContext> objeto para a solicitação HTTP atual. O objeto fornece acesso para o intrínseco <xref:System.Web.HttpContext.Request%2A>, <xref:System.Web.HttpContext.Response%2A>, e <xref:System.Web.HttpContext.Server%2A> propriedades para a solicitação.  
  
> [!IMPORTANT] 
> Este objeto está pronto para coleta de lixo quando o <xref:System.Web.HttpRequest> é concluída. Seu uso após a conclusão da solicitação pode resultar em comportamento indefinido, tal como um <xref:System.NullReferenceException>.
>
> Este objeto só está disponível no thread controlado pelo ASP.NET. Uso de threads em segundo plano pode resultar em comportamento indefinido.

## Examples  
 O exemplo a seguir demonstra como acessar e exibir as propriedades do <xref:System.Web.HttpContext> objeto. O contexto da solicitação HTTP atual é acessado usando o <xref:System.Web.UI.Page.Context%2A> propriedade do <xref:System.Web.UI.Page> objeto.  
  
 [!code-aspx-csharp[System.Web.HttpContext#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext/cs/httpcontextcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpContext#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext/vb/httpcontextvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.IHttpModule" />
    <altmember cref="T:System.Web.IHttpHandler" />
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=196730">Uma questão de contexto</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Web.HttpContext" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpWorkerRequest wr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpWorkerRequest wr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpWorkerRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (wr As HttpWorkerRequest)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpWorkerRequest ^ wr);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpWorkerRequest -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext wr" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="wr" Type="System.Web.HttpWorkerRequest" />
      </Parameters>
      <Docs>
        <param name="wr">O objeto <see cref="T:System.Web.HttpWorkerRequest" /> para a solicitação HTTP atual.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Web.HttpContext" /> que usa o objeto de solicitação de trabalho especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpRequest request, System.Web.HttpResponse response);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpRequest request, class System.Web.HttpResponse response) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpRequest,System.Web.HttpResponse)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (request As HttpRequest, response As HttpResponse)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpRequest ^ request, System::Web::HttpResponse ^ response);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpRequest * System.Web.HttpResponse -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext (request, response)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="request" Type="System.Web.HttpRequest" />
        <Parameter Name="response" Type="System.Web.HttpResponse" />
      </Parameters>
      <Docs>
        <param name="request">O objeto <see cref="T:System.Web.HttpRequest" /> para a solicitação HTTP atual.</param>
        <param name="response">O objeto <see cref="T:System.Web.HttpResponse" /> para a solicitação HTTP atual.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Web.HttpContext" /> usando a solicitação e os objetos de resposta especificados.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcceptWebSocketRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aceita uma solicitação <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; -&gt; unit" Usage="httpContext.AcceptWebSocketRequest userFunc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="userFunc">A função de usuário.</param>
        <summary>Aceita uma solicitação <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> usando a função de usuário especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar esse método é equivalente a chamar o <xref:System.Web.HttpContext.AcceptWebSocketRequest%2A> sobrecarga de método e passar `null` para o `options` parâmetro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="userFunc" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">A solicitação não é uma solicitação <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc, System.Web.WebSockets.AspNetWebSocketOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc, class System.Web.WebSockets.AspNetWebSocketOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task), options As AspNetWebSocketOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc, System::Web::WebSockets::AspNetWebSocketOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; * System.Web.WebSockets.AspNetWebSocketOptions -&gt; unit" Usage="httpContext.AcceptWebSocketRequest (userFunc, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" />
        <Parameter Name="options" Type="System.Web.WebSockets.AspNetWebSocketOptions" />
      </Parameters>
      <Docs>
        <param name="userFunc">A função de usuário.</param>
        <param name="options">O objeto de opções.</param>
        <summary>Aceita uma solicitação <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> usando a função de usuário e o objeto de opções especificados.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="userFunc" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">A solicitação não é uma solicitação <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddError">
      <MemberSignature Language="C#" Value="public void AddError (Exception errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddError(class System.Exception errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddError(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddError (errorInfo As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddError(Exception ^ errorInfo);" />
      <MemberSignature Language="F#" Value="member this.AddError : Exception -&gt; unit" Usage="httpContext.AddError errorInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorInfo" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="errorInfo">O <see cref="T:System.Exception" /> a ser adicionado à coleção de exceções.</param>
        <summary>Adiciona uma exceção à coleção de exceções da solicitação HTTP atual.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnRequestCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnRequestCompleted (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnRequestCompleted(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddOnRequestCompleted(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnRequestCompleted (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnRequestCompleted(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnRequestCompleted : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpContext.AddOnRequestCompleted callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">O objeto de contexto HTTP.</param>
        <summary>Aciona um evento virtual que ocorre quando a parte HTTP da solicitação está terminando.</summary>
        <returns>O token de assinatura.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento ocorre antes do <xref:System.Web.WebSockets.AspNetWebSocket> começa a conexão.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="callback" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllErrors">
      <MemberSignature Language="C#" Value="public Exception[] AllErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception[] AllErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllErrors As Exception()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Exception ^&gt; ^ AllErrors { cli::array &lt;Exception ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllErrors : Exception[]" Usage="System.Web.HttpContext.AllErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma matriz de erros acumulados durante o processamento de uma solicitação HTTP.</summary>
        <value>Uma matriz de objetos <see cref="T:System.Exception" /> para a solicitação HTTP atual.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAsyncDuringSyncStages">
      <MemberSignature Language="C#" Value="public bool AllowAsyncDuringSyncStages { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAsyncDuringSyncStages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowAsyncDuringSyncStages As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowAsyncDuringSyncStages { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAsyncDuringSyncStages : bool with get, set" Usage="System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se as operações assíncronas são permitidas durante partes do processamento da solicitação ASP.NET quando elas não são esperadas.</summary>
        <value>
          <see langword="false" /> Se o ASP.NET irá acionar uma exceção quando a API assíncrona é usada em um tempo quando não é esperado; Caso contrário, <see langword="true" />. O valor padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se esse sinalizador não é definido como `true`, ASP.NET irá acionar uma exceção quando ele detecta o aplicativo usando a API assíncrona de maneira indevida. Isso pode ocorrer se você tentar chamar um método assíncrono durante uma parte da solicitação de pipeline de processamento em que operações assíncronas não são esperadas, ou se há trabalho assíncrono ainda pendente quando um módulo assíncrono ou manipulador sinaliza a conclusão. Esse comportamento destina-se como uma rede de segurança para informá-lo desde o início, se você estiver escrevendo o código assíncrono que não se encaixa esperado padrões e pode ter efeitos negativos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As HttpApplicationState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplicationState ^ Application { System::Web::HttpApplicationState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Application : System.Web.HttpApplicationState" Usage="System.Web.HttpContext.Application" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see cref="T:System.Web.HttpApplicationState" /> para a solicitação HTTP atual.</summary>
        <value>O <see cref="T:System.Web.HttpApplicationState" /> para a solicitação HTTP atual.  
  
Para obter o objeto <see cref="T:System.Web.HttpApplication" /> para a solicitação HTTP atual, use <see cref="P:System.Web.HttpContext.ApplicationInstance" />. (O ASP.NET usa <see langword="ApplicationInstance" /> em vez de <see langword="Application" /> como um nome de propriedade para consultar a instância <see cref="T:System.Web.HttpApplication" /> atual, a fim de evitar confusão entre o ASP.NET e o ASP clássico. No ASP clássico, <see langword="Application" /> se refere ao dicionário de estados de aplicativo global.)</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.ApplicationInstance" />
      </Docs>
    </Member>
    <Member MemberName="ApplicationInstance">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplication ApplicationInstance { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplication ApplicationInstance" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ApplicationInstance" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationInstance As HttpApplication" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplication ^ ApplicationInstance { System::Web::HttpApplication ^ get(); void set(System::Web::HttpApplication ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationInstance : System.Web.HttpApplication with get, set" Usage="System.Web.HttpContext.ApplicationInstance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplication</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o objeto <see cref="T:System.Web.HttpApplication" /> para a atual solicitação HTTP.</summary>
        <value>O <see cref="T:System.Web.HttpApplication" /> para a solicitação HTTP atual.  
  
O ASP.NET usa <see langword="ApplicationInstance" /> em vez de <see langword="Application" /> como um nome de propriedade para consultar a instância <see cref="T:System.Web.HttpApplication" /> atual, a fim de evitar confusão entre o ASP.NET e o ASP clássico. No ASP clássico, <see langword="Application" /> se refere ao dicionário de estados de aplicativo global.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">O aplicativo Web está em execução no IIS 7.0 em modo integrado e foi feita uma tentativa para alterar o valor da propriedade de um valor não nulo para <see langword="null" />.</exception>
        <altmember cref="P:System.Web.HttpContext.Application" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPreloadMode">
      <MemberSignature Language="C#" Value="public System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AsyncPreloadMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPreloadMode As AsyncPreloadModeFlags" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Configuration::AsyncPreloadModeFlags AsyncPreloadMode { System::Web::Configuration::AsyncPreloadModeFlags get(); void set(System::Web::Configuration::AsyncPreloadModeFlags value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPreloadMode : System.Web.Configuration.AsyncPreloadModeFlags with get, set" Usage="System.Web.HttpContext.AsyncPreloadMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Configuration.AsyncPreloadModeFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um objeto que contém sinalizadores que pertencem ao modo de pré-carregamento assíncrono.</summary>
        <value>Um objeto que contém sinalizadores que pertencem ao modo de pré-carregamento assíncrono.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na primeira vez em que esta propriedade é acessada, o objeto que contém sinalizadores para o modo de pré-carregamento assíncrono é carregado a partir de <xref:System.Web.Configuration.HttpRuntimeSection.AsyncPreloadMode%2A> configuração no arquivo de configuração.  
  
 Embora essa propriedade pode ser definida por meio de programação, alterar o valor da propriedade só tem efeito se a propriedade é definida antes do `ExecuteRequestHandler` etapa no pipeline de solicitação do ASP.NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As Cache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Caching::Cache ^ Cache { System::Web::Caching::Cache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.Caching.Cache" Usage="System.Web.HttpContext.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see cref="T:System.Web.Caching.Cache" /> para o domínio do aplicativo atual.</summary>
        <value>O <see cref="T:System.Web.Caching.Cache" /> para o domínio do aplicativo atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Há uma instância do <xref:System.Web.Caching.Cache> classe por domínio de aplicativo. Como resultado, o <xref:System.Web.Caching.Cache> objeto que é retornado pelo <xref:System.Web.HttpContext.Cache%2A> propriedade é o <xref:System.Web.Caching.Cache> objeto para todas as solicitações no domínio do aplicativo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberSignature Language="F#" Value="member this.ClearError : unit -&gt; unit" Usage="httpContext.ClearError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Limpa todos os erros da solicitação HTTP atual.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.Error" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Web.HttpContext Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.HttpContext Current" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Current As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::HttpContext ^ Current { System::Web::HttpContext ^ get(); void set(System::Web::HttpContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Web.HttpContext with get, set" Usage="System.Web.HttpContext.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o objeto <see cref="T:System.Web.HttpContext" /> para a atual solicitação HTTP.</summary>
        <value>A instância <see cref="T:System.Web.HttpContext" /> da atual solicitação HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade é uma propriedade estática do <xref:System.Web.HttpContext> classe. Os armazenamentos de propriedade a <xref:System.Web.HttpContext> instância que se aplica à solicitação atual. As propriedades dessa instância são as propriedades não estáticas do <xref:System.Web.HttpContext> classe.  
  
 Você também pode usar o <xref:System.Web.UI.Page.Context%2A?displayProperty=nameWithType> propriedade para acessar o <xref:System.Web.HttpContext> objeto para a solicitação HTTP atual.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Web.HttpContext.Current%2A> propriedade para acessar o <xref:System.Web.HttpContext.AddError%2A?displayProperty=nameWithType> e <xref:System.Web.HttpContext.ClearError%2A?displayProperty=nameWithType> métodos e as <xref:System.Web.HttpContext.AllErrors%2A?displayProperty=nameWithType> propriedade. O exemplo cria três exceções personalizadas usando o <xref:System.Web.HttpContext.AddError%2A> método e usa o <xref:System.Web.HttpContext.AllErrors%2A> propriedade ao carregar essas exceções para uma matriz. Em seguida, grava a página que contém a matriz e usa o <xref:System.Web.HttpContext.ClearError%2A> método para limpar todos os erros do <xref:System.Web.UI.Page.Context%2A> propriedade.  
  
```csharp  
protected void Page_Load(object sender, EventArgs e)  
{  
    HttpContext context = HttpContext.Current;  
    Response.Write("<p>HttpContext.Current Example:</p>");  
  
    // Add three custom exceptions.  
    context.AddError(new Exception("New Exception #1"));  
    context.AddError(new Exception("New Exception #2"));  
    context.AddError(new Exception("New Exception #3"));  
  
    // Capture all the new Exceptions in an array.  
    Exception[] errs = context.AllErrors;  
  
    foreach (Exception ex in errs)  
    {  
        Response.Write("<p>" + Server.HtmlEncode(ex.ToString()) + "</p>");  
    }  
  
    // Clear the exceptions so ASP.NET won't handle them.  
    context.ClearError();  
}  
```  
  
```vb  
Protected Sub Page_Load(sender As Object, e As EventArgs)  
Dim context As HttpContext = HttpContext.Current  
Response.Write("<p>HttpContext.Current Example:</p>")  
  
' Add three custom exceptions.  
context.AddError(New Exception("New Exception #1"))  
context.AddError(New Exception("New Exception #2"))  
context.AddError(New Exception("New Exception #3"))  
  
' Capture all the new Exceptions in an array.  
Dim errs As Exception() = context.AllErrors  
  
For Each ex As Exception In errs  
Response.Write("<p>" & Server.HtmlEncode(ex.ToString()) & "</p>")  
Next  
  
' Clear the exceptions so ASP.NET won't handle them.  
context.ClearError()  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Response" />
        <altmember cref="P:System.Web.HttpContext.Request" />
      </Docs>
    </Member>
    <Member MemberName="CurrentHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler CurrentHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler CurrentHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ CurrentHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.CurrentHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see cref="T:System.Web.IHttpHandler" /> que representa o manipulador atualmente em execução.</summary>
        <value>Um objeto <see cref="T:System.Web.IHttpHandler" /> que representa o manipulador atualmente em execução.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O manipulador atualmente em execução que é referenciado pela <xref:System.Web.HttpContext.CurrentHandler%2A> propriedade pode ser diferente do que o manipulador que é referenciado pelo <xref:System.Web.HttpContext.Handler%2A> propriedade. Isso pode ocorrer quando outro manipulador solicitado usando o <xref:System.Web.HttpServerUtility.Execute%2A> método ou o <xref:System.Web.HttpServerUtility.Transfer%2A> método. Quando o manipulador atualmente em execução termina o processamento, o manipulador de determinados anteriormente é restaurado.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b">Visão geral de módulos HTTP e de manipuladores HTTP</related>
      </Docs>
    </Member>
    <Member MemberName="CurrentNotification">
      <MemberSignature Language="C#" Value="public System.Web.RequestNotification CurrentNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.RequestNotification CurrentNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentNotification As RequestNotification" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::RequestNotification CurrentNotification { System::Web::RequestNotification get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentNotification : System.Web.RequestNotification" Usage="System.Web.HttpContext.CurrentNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.RequestNotification</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor <see cref="T:System.Web.RequestNotification" /> que indica o evento <see cref="T:System.Web.HttpApplication" /> atual que está sendo processado.</summary>
        <value>Um dos valores de <see cref="T:System.Web.RequestNotification" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.HttpContext.CurrentNotification%2A> propriedade exige o modo de pipeline integrado no [!INCLUDE[iisver](~/includes/iisver-md.md)] e pelo menos o .NET Framework versão 3.0. Quando estiver disponível, a propriedade retorna um <xref:System.Web.RequestNotification> valor. O valor da <xref:System.Web.HttpContext.CurrentNotification%2A> propriedade indica qual evento no <xref:System.Web.HttpApplication> instância está processando no momento da solicitação.  
  
 O <xref:System.Web.HttpContext.CurrentNotification%2A> propriedade não se destina a ser definido. Em vez disso, ele é definido por [!INCLUDE[iisver](~/includes/iisver-md.md)] durante o processamento da solicitação no pipeline do ASP.NET. Definindo o <xref:System.Web.HttpContext.CurrentNotification%2A> propriedade resultará em um erro de compilação.  
  
 <xref:System.Web.HttpContext.CurrentNotification%2A> é introduzido no .NET Framework versão 3.5.  Para saber mais, confira [Versões e dependências](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Web.HttpContext.CurrentNotification%2A> propriedade para determinar quais eventos do <xref:System.Web.HttpApplication> objeto que está tratando a solicitação atual que está sendo processado. No exemplo, o manipulador de eventos trata vários eventos do <xref:System.Web.HttpApplication> objeto e o <xref:System.Web.HttpContext.CurrentNotification%2A> propriedade determina qual código é invocado para cada evento sendo manipulado.  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A operação exige o modo de pipeline integrado no [!INCLUDE[iisver](~/includes/iisver-md.md)] e, no mínimo, o .NET Framework versão 3.0.</exception>
        <altmember cref="P:System.Web.HttpContext.IsPostNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="DisposeOnPipelineCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken DisposeOnPipelineCompleted (IDisposable target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken DisposeOnPipelineCompleted(class System.IDisposable target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.DisposeOnPipelineCompleted(System.IDisposable)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisposeOnPipelineCompleted (target As IDisposable) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ DisposeOnPipelineCompleted(IDisposable ^ target);" />
      <MemberSignature Language="F#" Value="member this.DisposeOnPipelineCompleted : IDisposable -&gt; System.Web.ISubscriptionToken" Usage="httpContext.DisposeOnPipelineCompleted target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.IDisposable" />
      </Parameters>
      <Docs>
        <param name="target">O objeto cujo método <see cref="M:System.IDisposable.Dispose" /> deve ser chamado quando a parte da conexão <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> da solicitação é concluída.</param>
        <summary>Permite que o método <see cref="M:System.IDisposable.Dispose" /> de um objeto seja chamado quando a parte de conexão <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> dessa solicitação é concluída.</summary>
        <returns>O token de assinatura.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IDisposable.Dispose%2A> método do objeto de destino é chamado após a parte HTTP da solicitação e o <xref:System.Web.WebSockets.AspNetWebSocket> conexão ter sido encerrada. O <xref:System.Web.HttpContext> objeto não está disponível para inspeção.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public Exception Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception Error" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Error" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Error As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ Error { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Error : Exception" Usage="System.Web.HttpContext.Error" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o primeiro erro (se houver) acumulado durante o processamento da solicitação HTTP.</summary>
        <value>O primeiro <see cref="T:System.Exception" /> do processo de solicitação/resposta HTTP. Caso contrário, <see langword="null" /> se nenhum erro tiver sido acumulado durante o processamento da solicitação HTTP. O padrão é <see langword="null" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.HttpContext.ClearError" />
      </Docs>
    </Member>
    <Member MemberName="GetAppConfig">
      <MemberSignature Language="C#" Value="public static object GetAppConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetAppConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetAppConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAppConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetAppConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetAppConfig : string -&gt; obj" Usage="System.Web.HttpContext.GetAppConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A marca de configuração de aplicativo para o qual as informações são solicitadas.</param>
        <summary>Retorna informações de configuração solicitadas para o aplicativo atual.</summary>
        <returns>Um objeto contendo informações de configuração. (Converter a seção de configuração retornada para o tipo de configuração apropriado antes do uso.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Web.HttpContext.GetAppConfig%2A> foi substituído. Use o <xref:System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection%2A> método da <xref:System.Web.Configuration.WebConfigurationManager> classe para obter informações de configuração para o aplicativo atual.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Configuration.WebConfigurationManager" />
      </Docs>
    </Member>
    <Member MemberName="GetConfig">
      <MemberSignature Language="C#" Value="public object GetConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetConfig : string -&gt; obj" Usage="httpContext.GetConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.HttpContext.GetSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A marca de configuração para a qual as informações são solicitadas.</param>
        <summary>Retorna as informações de configuração solicitadas para a solicitação HTTP atual.</summary>
        <returns>O <see cref="T:System.Configuration.ConfigurationSection" /> especificado, <see langword="null" /> se a seção não existir ou ainda um objeto interno se a seção não estiver acessível no tempo de execução. (Converter o objeto retornado para o tipo de configuração apropriado antes do uso.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Web.HttpContext.GetConfig%2A> foi substituído. Use o <xref:System.Web.HttpContext.GetSection%2A> método para obter informações de configuração para a solicitação HTTP atual.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpContext.GetSection(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGlobalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém um recurso no nível de aplicativo.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Recursos em aplicativos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Layout de Site da Web do ASP.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="classKey">Uma cadeia de caracteres que representa a propriedade <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> do objeto de recurso solicitado.</param>
        <param name="resourceKey">Uma cadeia de caracteres que representa a propriedade <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> do objeto de recurso solicitado.</param>
        <summary>Obtém um objeto de recurso no nível de aplicativo baseado nas propriedades <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> e <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> especificadas.</summary>
        <returns>Um <see cref="T:System.Object" /> que representa o objeto de recurso no nível de aplicativo solicitado. Caso contrário, nulo se não for encontrado um objeto de recurso ou se ele for encontrado, mas não tiver a propriedade solicitada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.HttpContext.GetGlobalResourceObject%2A> método retorna um recurso global usando a cultura especificada no <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> propriedade.  
  
> [!NOTE]
>  Em alguns ambientes de edição, como [!INCLUDE[vwprvw](~/includes/vwprvw-md.md)], o editor pode gerar um tempo de design <xref:System.Resources.MissingManifestResourceException> exceção se você usar um ponto (.) no nome da chave de recurso global. No entanto, isso não afeta sua capacidade de editar ou salvar o arquivo, e você pode ignorar o erro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Não foi encontrado um objeto de recurso com o parâmetro <paramref name="classKey" /> especificado.  
  
\- ou - 
O assembly principal não contém os recursos da cultura neutra e esses recursos são necessários porque o assembly satélite adequado está ausente.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Recursos em aplicativos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Layout de Site da Web do ASP.NET</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Empacotando e implantando recursos</related>
      </Docs>
    </Member>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="classKey">Uma cadeia de caracteres que representa a propriedade <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> do objeto de recurso solicitado.</param>
        <param name="resourceKey">Uma cadeia de caracteres que representa uma propriedade <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> do objeto de recurso solicitado.</param>
        <param name="culture">Uma cadeia de caracteres que representa o objeto <see cref="T:System.Globalization.CultureInfo" /> do recurso solicitado.</param>
        <summary>Obtém um objeto de recurso no nível do aplicativo baseado nas propriedades <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> e <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> especificadas e no objeto <see cref="T:System.Globalization.CultureInfo" />.</summary>
        <returns>Um <see cref="T:System.Object" /> que representa o objeto de recurso no nível de aplicativo solicitado, o qual está localizado conforme a cultura específica; caso contrário, <see langword="null" /> se não for encontrado nenhum objeto de recurso ou se um objeto de recurso for encontrado, mas ele não tem a propriedade solicitada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Globalization.CultureInfo> objeto representa a cultura para a qual o recurso foi localizado. Se o recurso não estiver localizado para essa cultura, a pesquisa seguirá um processo de fallback para localizar um recurso apropriado. Para obter mais informações, consulte [Empacotamento e implantação de recursos](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
> [!NOTE]
>  Em alguns ambientes de edição, como o Visual Web Developer, o editor pode gerar um tempo de design <xref:System.Resources.MissingManifestResourceException> exceção se você usar um ponto (.) no nome da chave de recurso global. No entanto, isso não afeta sua capacidade de editar ou salvar o arquivo, e você pode ignorar o erro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Não foi encontrado nenhum objeto de recurso com o parâmetro <paramref name="classKey" /> especificado.  
  
\- ou - 
O assembly principal não contém os recursos da cultura neutra e esses recursos são necessários porque o assembly satélite adequado está ausente.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Recursos em aplicativos</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Empacotando e implantando recursos</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLocalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém um recurso de nível de página.</summary>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Recursos em aplicativos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Layout de Site da Web do ASP.NET</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Empacotando e implantando recursos</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">A propriedade <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> do objeto de recurso local.</param>
        <param name="resourceKey">Uma cadeia de caracteres que representa uma propriedade <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> do objeto de recurso solicitado</param>
        <summary>Obtém um objeto de recurso de nível de página com base nas propriedades <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> e <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> especificadas.</summary>
        <returns>Um <see cref="T:System.Object" /> que representa o objeto de recurso no nível de página solicitado; caso contrário, <see langword="null" /> se um objeto de recurso correspondente for encontrado, mas não um parâmetro <paramref name="resourceKey" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.HttpContext.GetLocalResourceObject%2A> método retorna um recurso local usando a cultura especificada no <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Não foi encontrado um objeto de recurso para o parâmetro <paramref name="virtualPath" /> especificado.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="virtualPath" /> especificado não está no diretório raiz do aplicativo atual.</exception>
        <exception cref="T:System.InvalidOperationException">A classe de recurso para a página não foi encontrada.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Recursos em aplicativos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Layout de Site da Web do ASP.NET</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Empacotando e implantando recursos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7a06d512-6fc3-40ca-9cb6-7f41d1a9fa28">Como: recuperar valores de recurso por meio de programação</related>
      </Docs>
    </Member>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="virtualPath">A propriedade <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> do objeto de recurso local.</param>
        <param name="resourceKey">Uma cadeia de caracteres que representa uma propriedade <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> do objeto de recurso solicitado.</param>
        <param name="culture">Uma cadeia de caracteres que representa o objeto <see cref="T:System.Globalization.CultureInfo" /> do objeto de recurso solicitado.</param>
        <summary>Obtém um objeto de recurso no nível da página com base nas propriedades <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> e <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> especificadas e no objeto <see cref="T:System.Globalization.CultureInfo" />.</summary>
        <returns>Um <see cref="T:System.Object" /> que representa o objeto de recurso local solicitado, que é localizado para a cultura especificada, caso contrário, <see langword="null" /> se um objeto de recurso correspondente for encontrado, mas não um parâmetro <paramref name="resourceKey" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o recurso não estiver localizado para essa cultura, a pesquisa seguirá um processo de fallback para localizar um recurso apropriado. Para obter mais informações, consulte [Empacotamento e implantação de recursos](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Não foi encontrado um objeto de recurso para o parâmetro <paramref name="virtualPath" /> especificado.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="virtualPath" /> especificado não está no diretório raiz do aplicativo atual.</exception>
        <exception cref="T:System.InvalidOperationException">A classe de recurso para a página não foi encontrada.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Recursos em aplicativos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Layout de Site da Web do ASP.NET</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Empacotando e implantando recursos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7a06d512-6fc3-40ca-9cb6-7f41d1a9fa28">Como: recuperar valores de recurso por meio de programação</related>
      </Docs>
    </Member>
    <Member MemberName="GetSection">
      <MemberSignature Language="C#" Value="public object GetSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSection (sectionName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSection(System::String ^ sectionName);" />
      <MemberSignature Language="F#" Value="member this.GetSection : string -&gt; obj" Usage="httpContext.GetSection sectionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sectionName">O caminho da seção de configuração (no formato XPath) e o nome do elemento de configuração.</param>
        <summary>Obtém uma seção de configuração especificada para a configuração padrão do aplicativo atual.</summary>
        <returns>O <see cref="T:System.Configuration.ConfigurationSection" /> especificado, <see langword="null" /> se a seção não existir ou ainda um objeto interno se a seção não estiver acessível no tempo de execução.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Handler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler Handler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler Handler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Handler" />
      <MemberSignature Language="VB.NET" Value="Public Property Handler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ Handler { System::Web::IHttpHandler ^ get(); void set(System::Web::IHttpHandler ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Handler : System.Web.IHttpHandler with get, set" Usage="System.Web.HttpContext.Handler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o objeto <see cref="T:System.Web.IHttpHandler" /> responsável por processar a solicitação HTTP.</summary>
        <value>Um <see cref="T:System.Web.IHttpHandler" /> responsável por processar a solicitação HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.HttpContext.Handler%2A> propriedade contém uma referência para o manipulador que processa a solicitação HTTP. O manipulador pode ser especificado usando o elemento ou usando um manipulador personalizado definido no código do usuário. Para obter mais informações sobre manipuladores, consulte [manipuladores HTTP e visão geral de módulos HTTP](https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b).  
  
 A referência para o <xref:System.Web.HttpContext.Handler%2A> propriedade permanece o mesmo, mesmo depois que a página atual foi alterada por um método do lado do servidor, como o <xref:System.Web.HttpServerUtility.Execute%2A> método ou o <xref:System.Web.HttpServerUtility.Transfer%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b">Visão geral de módulos HTTP e de manipuladores HTTP</related>
      </Docs>
    </Member>
    <Member MemberName="IsCustomErrorEnabled">
      <MemberSignature Language="C#" Value="public bool IsCustomErrorEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomErrorEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCustomErrorEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCustomErrorEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCustomErrorEnabled : bool" Usage="System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se os erros personalizados estão habilitados para a solicitação HTTP atual.</summary>
        <value>
          <see langword="true" /> se os erros personalizados estiverem habilitados; caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDebuggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDebuggingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDebuggingEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDebuggingEnabled : bool" Usage="System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a solicitação HTTP atual está no modo de depuração.</summary>
        <value>
          <see langword="true" /> se a solicitação está no modo de depuração, caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPostNotification">
      <MemberSignature Language="C#" Value="public bool IsPostNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsPostNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostNotification As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostNotification { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPostNotification : bool" Usage="System.Web.HttpContext.IsPostNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que é o ponto de processamento atual no pipeline do ASP.NET logo após a conclusão do processamento de um evento <see cref="T:System.Web.HttpApplication" />.</summary>
        <value>
          <see langword="true" /> se os erros personalizados estiverem habilitados; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.HttpContext.IsPostNotification%2A> propriedade só é compatível com o modo integrado do [!INCLUDE[iisver](~/includes/iisver-md.md)] e pelo menos o .NET Framework 3.0. Quando disponível, a propriedade retorna um valor booliano que indica se um evento no <xref:System.Web.HttpApplication> objeto concluiu o processamento.  
  
 O <xref:System.Web.HttpContext.IsPostNotification%2A> propriedade não se destina a ser definido. Em vez disso, ele é fornecido por [!INCLUDE[iisver](~/includes/iisver-md.md)] no tempo de execução do ASP.NET para cada notificação. Definindo o <xref:System.Web.HttpContext.IsPostNotification%2A> propriedade resultará em um erro de compilação.  
  
 Em cenários onde vários eventos do <xref:System.Web.HttpApplication> objeto são manipuladas por um manipulador de eventos, você pode usar o <xref:System.Web.HttpContext.IsPostNotification%2A> propriedade em combinação com o <xref:System.Web.RequestNotification> enumeração para determinar exatamente onde no ciclo de vida do aplicativo atual a solicitação é.  
  
 <xref:System.Web.HttpContext.IsPostNotification%2A> é introduzido no .NET Framework versão 3.5.  Para saber mais, confira [Versões e dependências](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Web.HttpContext.IsPostNotification%2A> propriedade para determinar quando um evento do <xref:System.Web.HttpApplication> objeto terminou de processar todos os manipuladores de evento associado. O manipulador de eventos personalizado neste exemplo trata vários eventos do <xref:System.Web.HttpApplication> objeto e o <xref:System.Web.HttpContext.IsPostNotification%2A> propriedade é usada para determinar qual código é invocado depois que um evento específico é tratado.  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A operação exige o modo de pipeline integrado em [!INCLUDE[iisver](~/includes/iisver-md.md)] e, no mínimo, o .NET Framework 3.0.</exception>
        <altmember cref="P:System.Web.HttpContext.CurrentNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequest">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequest" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequest" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequest As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequest { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequest : bool" Usage="System.Web.HttpContext.IsWebSocketRequest" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a solicitação é uma solicitação <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
        <value>
          <see langword="true" /> se a solicitação for uma solicitação <see cref="T:System.Web.WebSockets.AspNetWebSocket" />; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retornará `true` se a solicitação contém inicial <xref:System.Web.WebSockets.AspNetWebSocket> handshake e o `WebSocket` módulo do IIS está ativo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequestUpgrading">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequestUpgrading { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequestUpgrading" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequestUpgrading As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequestUpgrading { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequestUpgrading : bool" Usage="System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a conexão está atualizando de uma conexão HTTP para uma conexão <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
        <value>
          <see langword="true" /> Se a conexão está atualizando; Caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Items { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.IDictionary" Usage="System.Web.HttpContext.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma coleção de chave/valor que pode ser usada para organizar e compartilhar dados entre uma interface <see cref="T:System.Web.IHttpModule" /> e uma interface <see cref="T:System.Web.IHttpHandler" /> durante uma solicitação HTTP.</summary>
        <value>Uma coleção de chave/valor <see cref="T:System.Collections.IDictionary" /> que fornece acesso a um valor individual na coleção por uma chave especificada.</value>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms972109.aspx">Uma questão de contexto</related>
      </Docs>
    </Member>
    <Member MemberName="PageInstrumentation">
      <MemberSignature Language="C#" Value="public System.Web.Instrumentation.PageInstrumentationService PageInstrumentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Instrumentation.PageInstrumentationService PageInstrumentation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PageInstrumentation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PageInstrumentation As PageInstrumentationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Instrumentation::PageInstrumentationService ^ PageInstrumentation { System::Web::Instrumentation::PageInstrumentationService ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageInstrumentation : System.Web.Instrumentation.PageInstrumentationService" Usage="System.Web.HttpContext.PageInstrumentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Instrumentation.PageInstrumentationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma referência à instância de serviço de instrumentação de página para essa solicitação.</summary>
        <value>A instância do serviço Instrumentação de página para esta solicitação.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler PreviousHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler PreviousHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PreviousHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ PreviousHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.PreviousHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see cref="T:System.Web.IHttpHandler" /> para o manipulador pai.</summary>
        <value>Uma <see cref="T:System.Web.IHttpHandler" /> instância, ou <see langword="null" /> se nenhum manipulador anterior foi encontrado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.HttpContext.PreviousHandler%2A> propriedade corresponde ao último manipulador antes da solicitação atual foi executada.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b">Visão geral de módulos HTTP e de manipuladores HTTP</related>
      </Docs>
    </Member>
    <Member MemberName="Profile">
      <MemberSignature Language="C#" Value="public System.Web.Profile.ProfileBase Profile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Profile.ProfileBase Profile" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Profile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Profile As ProfileBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Profile::ProfileBase ^ Profile { System::Web::Profile::ProfileBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Profile : System.Web.Profile.ProfileBase" Usage="System.Web.HttpContext.Profile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Profile.ProfileBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see cref="T:System.Web.Profile.ProfileBase" /> para o perfil do usuário atual.</summary>
        <value>Um <see cref="T:System.Web.Profile.ProfileBase" /> se o arquivo de configuração de aplicativo contiver uma definição para as propriedades do perfil; caso contrário, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Web.HttpContext.Profile%2A> propriedade é usada para armazenamento persistente de dados estruturados usando uma API fortemente tipada. Quando um <xref:System.Web.HttpContext.Profile%2A> propriedade é acessada, mas nenhum valor for encontrado, uma instância vazia é retornada; `null` não será retornado.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Web.Profile" />
      </Docs>
    </Member>
    <Member MemberName="RemapHandler">
      <MemberSignature Language="C#" Value="public void RemapHandler (System.Web.IHttpHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemapHandler(class System.Web.IHttpHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemapHandler (handler As IHttpHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemapHandler(System::Web::IHttpHandler ^ handler);" />
      <MemberSignature Language="F#" Value="member this.RemapHandler : System.Web.IHttpHandler -&gt; unit" Usage="httpContext.RemapHandler handler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
      </Parameters>
      <Docs>
        <param name="handler">O objeto que deve processar a solicitação.</param>
        <summary>Permite que você especifique um manipulador para a solicitação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você definir `handler` para `null`, o manipulador padrão é usado para processar a solicitação. Você pode definir `handler` para qualquer um manipulador assíncrono ou para um manipulador síncrono. O manipulador deve implementar o <xref:System.Web.IHttpHandler> interface.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O método <see cref="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" /> foi chamado depois que o evento <see cref="E:System.Web.HttpApplication.MapRequestHandler" /> ocorreu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Request" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Request As HttpRequest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpRequest ^ Request { System::Web::HttpRequest ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.Web.HttpRequest" Usage="System.Web.HttpContext.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see cref="T:System.Web.HttpRequest" /> para a solicitação HTTP atual.</summary>
        <value>O <see cref="T:System.Web.HttpRequest" /> para a solicitação HTTP atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.HttpContext.Request%2A> propriedade fornece acesso programático para as propriedades e métodos do <xref:System.Web.HttpRequest> classe. Como as páginas ASP.NET contêm uma referência padrão para o <xref:System.Web> namespace (que contém o <xref:System.Web.HttpContext> classe), você pode fazer referência os membros de <xref:System.Web.HttpRequest> em uma página. aspx sem usar a referência de classe totalmente qualificado para <xref:System.Web.HttpContext>. Por exemplo, você pode usar `Request.Browser` para obter as funcionalidades do navegador do cliente. No entanto, se você quiser usar os membros de <xref:System.Web.HttpRequest> de um módulo de code-behind do ASP.NET, você deve incluir uma referência para o <xref:System.Web> namespace no módulo e uma referência totalmente qualificada para o contexto de solicitação/resposta ativa no momento e o classe <xref:System.Web> que você deseja usar. Por exemplo, em uma página code-behind você deve especificar o nome totalmente qualificado `HttpContext.Current.Request.Browser`.  
  
> [!NOTE]
>  ASP.NET irá acionar uma exceção se você tentar usar essa propriedade quando o <xref:System.Web.HttpRequest> objeto não está disponível. Por exemplo, isso seria verdadeiro no método Application_Start do arquivo global. asax ou em um método que é chamado do método Application_Start. No momento nenhuma solicitação HTTP foi criada ainda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">O aplicativo Web está em execução no IIS 7 no modo Integrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Response" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Response As HttpResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpResponse ^ Response { System::Web::HttpResponse ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Response : System.Web.HttpResponse" Usage="System.Web.HttpContext.Response" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see cref="T:System.Web.HttpResponse" /> para a resposta HTTP atual.</summary>
        <value>O <see cref="T:System.Web.HttpResponse" /> para a resposta HTTP atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.HttpContext.Response%2A> propriedade fornece acesso programático para as propriedades e métodos do <xref:System.Web.HttpResponse> classe. Como as páginas ASP.NET contêm uma referência padrão para o <xref:System.Web> namespace (que contém o <xref:System.Web.HttpContext> classe), você pode fazer referência os membros de <xref:System.Web.HttpContext> em uma página. aspx sem usar a referência de classe totalmente qualificado para <xref:System.Web.HttpContext>. Por exemplo, você pode usar `Response.Write("some output")` para gravar a saída em um fluxo de saída HTTP. No entanto, se você quiser usar os membros de <xref:System.Web.HttpResponse> de um módulo de code-behind do ASP.NET, você deve incluir uma referência para o <xref:System.Web> namespace no módulo e uma referência totalmente qualificada para o contexto de solicitação/resposta ativa no momento e a classe no <xref:System.Web> que você deseja usar. Por exemplo, em uma página code-behind você deve especificar o nome totalmente qualificado `HttpContext.Current.Response.Write("some output")`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">O aplicativo Web está em execução no IIS 7 no modo Integrado.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RewritePath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Redireciona uma solicitação para um recurso para um caminho diferente daquele indicado pela URL solicitada. <see cref="Overload:System.Web.HttpContext.RewritePath" /> é usado no estado de sessão sem cookies para retirar as IDs de sessão das URLs.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string -&gt; unit" Usage="httpContext.RewritePath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho de regravação interno.</param>
        <summary>Regrava a URL usando o caminho fornecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.HttpContext.RewritePath%28System.String%29> método redireciona uma solicitação para um recurso para um caminho diferente daquele que é indicado pela URL solicitada. Se você precisar redefinir o caminho virtual para que solicitações do cliente para recursos de servidor resolver corretamente, use a sobrecarga desse método que usa o `rebaseClientPath` parâmetro e defina o parâmetro como `false`.  
  
 Regravação de URL é útil quando você deseja reestruturar as páginas em seu aplicativo Web, e você deseja certificar-se de que as pessoas que usaram um indicador de URLs antigas ainda podem usá-los depois que você mover as páginas. Regravação de URL permite que você transparentemente encaminhar solicitações para o novo local da página.  
  
 Se você quiser habilitar um site para usar URLs que são mais fáceis e são otimizadas para mecanismos de pesquisa, uma alternativa mais robusta é usar o roteamento do ASP.NET. Para obter mais informações, consulte [roteamento do ASP.NET](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o <xref:System.Web.HttpContext.RewritePath%2A> método para habilitar um site da Web responda a URLs que não refletem a estrutura de arquivo no site da Web. O primeiro bloco de código é uma página da Web do ASP.NET chamado RewritePath.aspx. Ele requer uma cadeia de caracteres de consulta. Se o nome do seu site é WebSite1, a URL `http://localhost/WebSite1/RewritePath.aspx?page=1` exibe "Página 1" no navegador. O bloco de código que segue a página da Web é o `Application_BeginRequest` manipulador de eventos no arquivo global asax. Esse código intercepta as solicitações para URLs como `http://localhost/WebSite1/page1` e converte-os para o formulário que é necessário para RewritePath.aspx antes que eles são processados. Portanto, a URL `http://localhost/WebSite1/page1` invoca RewritePath.aspx com o parâmetro de cadeia de caracteres de consulta que exibe "Página 1" no navegador. Se uma URL, como `http://localhost/WebSite1/page1` é recebida, uma sobrecarga <xref:System.Web.HttpContext.RewritePath%2A> é invocado que permite que você forneça um valor para o <xref:System.Web.HttpRequest.PathInfo%2A> parâmetro de cadeia de caracteres de propriedade, bem como uma consulta.  
  
 [!code-aspx-csharp[HttpContext_RewritePath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/rewritepath.aspx#2)]
 [!code-aspx-vb[HttpContext_RewritePath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/rewritepath.aspx#2)]  
  
 [!code-csharp[HttpContext_RewritePath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/global.asax#1)]
 [!code-vb[HttpContext_RewritePath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/global.asax#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">O parâmetro <paramref name="path" /> não está no diretório raiz do aplicativo atual.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Roteamento do ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Passo a passo: Usando o roteamento do ASP.NET em um aplicativo Web Forms</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path, bool rebaseClientPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path, bool rebaseClientPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String, rebaseClientPath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path, bool rebaseClientPath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * bool -&gt; unit" Usage="httpContext.RewritePath (path, rebaseClientPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="rebaseClientPath" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">O caminho de regravação interno.</param>
        <param name="rebaseClientPath">
          <see langword="true" /> para redefinir o caminho virtual; <see langword="false" /> para manter o caminho virtual inalterado.</param>
        <summary>Regrava a URL usando o caminho especificado e um valor booliano que especifica se o caminho virtual para recursos de servidor é modificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.HttpContext.RewritePath%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> método é chamado pelo <xref:System.Web.HttpContext.RewritePath%28System.String%29?displayProperty=nameWithType> método com o `rebaseClientPath` parâmetro definido como `true`. Para garantir que o caminho virtual que é usado para construir caminhos para recursos não será modificado, defina as `rebaseClientPath` parâmetro para `false`. Um cenário comum em que você talvez queira definir `rebaseClientPath` para `false` é quando você precisa regravar a URL, e você estiver usando temas e redirecionar a URL para um recurso localizado em uma pasta diferente que o recurso solicitado.  
  
 Regravação de URL é útil quando você deseja reestruturar as páginas em seu aplicativo Web, e você deseja certificar-se de que as pessoas que usaram um indicador de URLs antigas ainda podem usá-los depois que você mover as páginas. Regravação de URL permite que você transparentemente encaminhar solicitações para o novo local da página.  
  
 Se você quiser habilitar um site para usar URLs que são mais fáceis e são otimizadas para mecanismos de pesquisa, uma alternativa mais robusta é usar o roteamento do ASP.NET. Para obter mais informações, consulte [roteamento do ASP.NET](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte o <xref:System.Web.HttpContext.RewritePath%28System.String%29> sobrecarga de método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">O parâmetro <paramref name="path" /> não está no diretório raiz do aplicativo atual.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Roteamento do ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Passo a passo: Usando o roteamento do ASP.NET em um aplicativo Web Forms</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filePath">O caminho de regravação interno.</param>
        <param name="pathInfo">Informações adicionais de caminho para um recurso. Para obter mais informações, consulte <see cref="P:System.Web.HttpRequest.PathInfo" />.</param>
        <param name="queryString">A cadeia de caracteres de consulta da solicitação.</param>
        <summary>Regrava a URL usando o caminho, as informações de caminho e as informações de cadeia de caracteres de consulta especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.HttpContext.RewritePath%2A> método redireciona uma solicitação para um recurso para outro recurso sem alterar a URL.  
  
 O `filePath` parâmetro não inclui o `pathInfo` conteúdo do parâmetro. Para a URL http://www.microsoft.com/virdir/page.html/tail, o `filePath` parâmetro é http://www.microsoft.com/virdir/page.htmle o `pathInfo` parâmetro é a parte final.  
  
 Regravação de URL é útil quando você deseja reestruturar as páginas em seu aplicativo Web, e você deseja certificar-se de que as pessoas que usaram um indicador de URLs antigas ainda podem usá-los depois que você mover as páginas. Regravação de URL permite que você transparentemente encaminhar solicitações para o novo local da página.  
  
 Se você quiser habilitar um site para usar URLs que são mais fáceis e são otimizadas para mecanismos de pesquisa, uma alternativa mais robusta é usar o roteamento do ASP.NET. Para obter mais informações, consulte [roteamento do ASP.NET](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Para obter um exemplo de código, incluindo um exemplo de como essa sobrecarga de método, consulte o <xref:System.Web.HttpContext.RewritePath%28System.String%29> sobrecarga de método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="path" /> não está no diretório raiz do aplicativo atual.</exception>
        <exception cref="T:System.Web.HttpException">O parâmetro <paramref name="filePath" /> não está no diretório raiz do aplicativo atual.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Roteamento do ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Passo a passo: Usando o roteamento do ASP.NET em um aplicativo Web Forms</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString, bool setClientFilePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString, bool setClientFilePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String, setClientFilePath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString, bool setClientFilePath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string * bool -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString, setClientFilePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
        <Parameter Name="setClientFilePath" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filePath">O caminho virtual para o recurso que atende à solicitação.</param>
        <param name="pathInfo">Informações adicionais sobre o caminho a ser usado para o redirecionamento de URL. Para obter mais informações, consulte <see cref="P:System.Web.HttpRequest.PathInfo" />.</param>
        <param name="queryString">A cadeia de caracteres de consulta de solicitação a ser usada para o redirecionamento de URL.</param>
        <param name="setClientFilePath">
          <see langword="true" /> para definir o caminho do arquivo usado para os recursos de cliente para o valor do parâmetro <paramref name="filePath" />; caso contrário, <see langword="false" />.</param>
        <summary>Regrava a URL usando o caminho virtual fornecido, informações de caminho, informações de cadeia de caracteres de consulta e um valor booliano que especifica se o caminho do arquivo de cliente é definido como o caminho de regravação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `filePath` parâmetro não inclui o conteúdo a `pathInfo` parâmetro. Para a URL http://www.microsoft.com/virdir/page.html/tail, o `filePath` parâmetro é http://www.microsoft.com/virdir/page.htmle o `pathInfo` parâmetro é a parte final.  
  
 Para garantir que o caminho virtual que é usado para construir caminhos para recursos não será modificado, defina as `setClientFilePath` parâmetro para `false`. Um cenário comum em que você talvez queira definir `setClientFilePath` para `false` é quando você precisa regravar a URL, e você estiver usando temas e redirecionar a URL para um recurso localizado em uma pasta diferente que o recurso solicitado.  
  
 Regravação de URL é útil quando você deseja reestruturar as páginas em seu aplicativo Web, e você deseja certificar-se de que as pessoas que usaram um indicador de URLs antigas ainda podem usá-los depois que você mover as páginas. Regravação de URL permite que você transparentemente encaminhar solicitações para o novo local da página.  
  
 Se você quiser habilitar um site para usar URLs que são mais fáceis e são otimizadas para mecanismos de pesquisa, uma alternativa mais robusta é usar o roteamento do ASP.NET. Para obter mais informações, consulte [roteamento do ASP.NET](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte o <xref:System.Web.HttpContext.RewritePath%28System.String%29> sobrecarga de método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="path" /> não está no diretório raiz do aplicativo atual.</exception>
        <exception cref="T:System.Web.HttpException">O parâmetro <paramref name="filePath" /> não está no diretório raiz do aplicativo atual.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Roteamento do ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Passo a passo: Usando o roteamento do ASP.NET em um aplicativo Web Forms</related>
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As HttpServerUtility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpServerUtility ^ Server { System::Web::HttpServerUtility ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Server : System.Web.HttpServerUtility" Usage="System.Web.HttpContext.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see cref="T:System.Web.HttpServerUtility" /> que fornece métodos usados no processamento de solicitações da Web.</summary>
        <value>O <see cref="T:System.Web.HttpServerUtility" /> para a solicitação HTTP atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.HttpContext.Server%2A> propriedade fornece acesso programático para as propriedades e métodos do <xref:System.Web.HttpServerUtility> classe. Como as páginas ASP.NET contêm uma referência padrão para o <xref:System.Web> namespace (que contém o <xref:System.Web.HttpContext> classe), você pode fazer referência os membros de <xref:System.Web.HttpContext> em uma página. aspx sem usar a referência de classe totalmente qualificado para <xref:System.Web.HttpContext>. Por exemplo, você pode usar `Server.CreateObject("MyCOMComponent")` para criar uma instância de um objeto COM no servidor. No entanto, se você quiser usar os membros de <xref:System.Web.HttpServerUtility> de um módulo de code-behind do ASP.NET, você deve incluir uma referência para o <xref:System.Web> namespace no módulo e uma referência totalmente qualificada para o contexto de solicitação/resposta ativa no momento e o classe <xref:System.Web> que você deseja usar. Por exemplo, em uma página code-behind você deve especificar o nome totalmente qualificado `HttpContext.Current.Server.CreateObject("MyCOMComponent")`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Session" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Session As HttpSessionState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::SessionState::HttpSessionState ^ Session { System::Web::SessionState::HttpSessionState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Session : System.Web.SessionState.HttpSessionState" Usage="System.Web.HttpContext.Session" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see cref="T:System.Web.SessionState.HttpSessionState" /> para a solicitação HTTP atual.</summary>
        <value>O objeto <see cref="T:System.Web.SessionState.HttpSessionState" /> para a solicitação HTTP atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.HttpContext.Session%2A> propriedade fornece acesso programático para as propriedades e métodos do <xref:System.Web.SessionState.HttpSessionState> classe.  
  
 Para usar o estado de sessão, que você precisa habilitá-lo. Para obter informações sobre como habilitar o estado de sessão, consulte **Configurando o estado de sessão** na [visão geral do estado de sessão ASP.NET](https://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).  
  
 Para obter informações sobre como salvar os valores no estado de sessão, consulte [como: salvar valores no estado de sessão](https://msdn.microsoft.com/library/a6cb2e3a-df49-4b12-9d9a-eed45541c165). Para obter informações sobre como ler os valores do estado de sessão, consulte [como: valores de leitura do estado de sessão](https://msdn.microsoft.com/library/2ef449bc-5c17-4785-b7cf-378c601af8f5).  
  
   
  
## Examples  
 Os exemplos a seguir mostram como salvar os valores no estado de sessão e como ler valores de estado de sessão.  
  
 Esses exemplos precisam de:  
  
-   Um aplicativo ASP.NET que tenha habilitado o estado de sessão.  
  
-   Uma classe de página de Web Forms que tem acesso para o <xref:System.Web.UI.Page.Session%2A?displayProperty=nameWithType> propriedade ou qualquer classe que tem acesso ao <xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType> propriedade.  
  
```csharp  
string firstName = "Jeff";  
string lastName = "Smith";  
string city = "Seattle";  
  
// Save to session state in a Web Forms page class.  
Session["FirstName"] = firstName;  
Session["LastName"] = lastName;  
Session["City"] = city;  
  
// Read from session state in a Web Forms page class.  
firstName = (string)(Session["FirstName"]);  
lastName = (string)(Session["LastName"]);  
city = (string)(Session["City"]);  
  
// Outside of Web Forms page class, use HttpContext.Current.  
HttpContext context = HttpContext.Current;  
context.Session["FirstName"] = firstName;  
firstName = (string)(context.Session["FirstName"]);  
  
```  
  
```vb  
Dim firstName As String = "Jeff"  
Dim lastName As String = "Smith"  
Dim city As String = "Seattle"  
  
' Save to session state in a Web Forms page class.  
Session("FirstName") = firstName  
Session("LastName") = lastName  
Session("City") = city  
  
' Read from session state in a Web Forms page class.  
firstName = DirectCast(Session("FirstName"), String)  
lastName = DirectCast(Session("LastName"), String)  
city = DirectCast(Session("City"), String)  
  
' Outside of Web Forms page class, use HttpContext.Current.  
Dim context As HttpContext = HttpContext.Current  
context.Session("FirstName") = firstName  
firstName = DirectCast(context.Session("FirstName"), String)  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSessionStateBehavior">
      <MemberSignature Language="C#" Value="public void SetSessionStateBehavior (System.Web.SessionState.SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSessionStateBehavior(valuetype System.Web.SessionState.SessionStateBehavior sessionStateBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSessionStateBehavior(System::Web::SessionState::SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="F#" Value="member this.SetSessionStateBehavior : System.Web.SessionState.SessionStateBehavior -&gt; unit" Usage="httpContext.SetSessionStateBehavior sessionStateBehavior" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionStateBehavior" Type="System.Web.SessionState.SessionStateBehavior" />
      </Parameters>
      <Docs>
        <param name="sessionStateBehavior">Um dos valores de enumeração que especifica qual o tipo de comportamento de estado de sessão necessário.</param>
        <summary>Define o tipo de comportamento de estado de sessão que é necessário para dar suporte a uma solicitação HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na implementação do padrão ASP.NET, um manipulador de solicitação HTTP indica se ele requer o estado de sessão com a implementação de <xref:System.Web.SessionState.IRequiresSessionState> interface ou o <xref:System.Web.SessionState.IReadOnlySessionState> interface. O <xref:System.Web.HttpContext.SetSessionStateBehavior%2A> método e o <xref:System.Web.SessionState.SessionStateBehavior> enumeração permitem que você forneça mais detalhes sobre que tipo de suporte do estado de sessão é necessário para lidar com uma solicitação. Para obter mais informações, consulte a enumeração <xref:System.Web.SessionState.SessionStateBehavior>.  
  
 O <xref:System.Web.HttpContext.SetSessionStateBehavior%2A> método deve ser chamado antes do <xref:System.Web.HttpApplication.AcquireRequestState> eventos de pipeline. Chamadas que ocorrem durante ou após este evento fará com que um <xref:System.InvalidOperationException> exceção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O método foi chamado depois que o evento <see cref="E:System.Web.HttpApplication.AcquireRequestState" /> foi gerado.</exception>
        <altmember cref="T:System.Web.SessionState.SessionStateBehavior" />
      </Docs>
    </Member>
    <Member MemberName="SkipAuthorization">
      <MemberSignature Language="C#" Value="public bool SkipAuthorization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipAuthorization" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.SkipAuthorization" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipAuthorization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipAuthorization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipAuthorization : bool with get, set" Usage="System.Web.HttpContext.SkipAuthorization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que especifica se o objeto <see cref="T:System.Web.Security.UrlAuthorizationModule" /> deve ignorar a verificação de autorização da solicitação atual.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Web.Security.UrlAuthorizationModule" /> precisar ignorar a verificação de autorização; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.HttpContext.SkipAuthorization%2A> propriedade destina para uso avançado pelos módulos de autenticação que precisam para redirecionar para uma página que permite conexões anônimas. O módulo de autenticação de formulários e o módulo de autenticação do Passport definidos <xref:System.Web.HttpContext.SkipAuthorization%2A> ao redirecionar para uma página de logon configurado. Definindo <xref:System.Web.HttpContext.SkipAuthorization%2A> requer o `ControlPrincipal` sinalizador seja definido. Para obter informações sobre o `ControlPrincipal` sinalizador, consulte <xref:System.Security.Permissions.SecurityPermissionFlag>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type service);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.System#IServiceProvider#GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetService (service As Type) As Object Implements IServiceProvider.GetService" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IServiceProvider.GetService(Type ^ service) = IServiceProvider::GetService;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="service">Um tipo de serviço <see cref="T:System.Web.HttpContext" /> para definir o provedor de serviço.</param>
        <summary>Retorna um objeto para o tipo de serviço atual.</summary>
        <returns>Um <see cref="T:System.Web.HttpContext" />; caso contrário, <see langword="null" /> se nenhum serviço for encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é útil para obter acesso a subjacente <xref:System.Web.HttpWorkerRequest> objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThreadAbortOnTimeout">
      <MemberSignature Language="C#" Value="public bool ThreadAbortOnTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ThreadAbortOnTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ThreadAbortOnTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ThreadAbortOnTimeout { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ThreadAbortOnTimeout : bool with get, set" Usage="System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que especifica se o tempo de execução do ASP.NET deve chamar <see cref="M:System.Threading.Thread.Abort" /> no thread que está atendendo a essa solicitação quando a solicitação expira.</summary>
        <value>
          <see langword="true" /> se <see cref="M:System.Threading.Thread.Abort" /> for chamado quando a thread expirar; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em manipuladores e módulos que estão usando o <xref:System.Web.HttpRequest.TimedOutToken%2A?displayProperty=nameWithType> propriedade para implementar o cancelamento cooperativo, talvez você queira desabilitar o <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> comportamento que o ASP.NET executa por padrão, quando uma solicitação expira. Definir essa propriedade como `false` pode ajudá-lo a garantir que as rotinas de cancelamento e limpeza serão executada sem ser interrompido por ASP.NET.  
  
 Se você definir essa propriedade como `false`, ASP.NET não exibirá automaticamente uma página de erro de "Solicitação expirou" quando ocorre um tempo limite. O aplicativo é responsável por definir o conteúdo da resposta adequadamente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timestamp">
      <MemberSignature Language="C#" Value="public DateTime Timestamp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Timestamp" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Timestamp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Timestamp As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Timestamp { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.Timestamp : DateTime" Usage="System.Web.HttpContext.Timestamp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o carimbo de data/hora inicial da solicitação HTTP atual.</summary>
        <value>O carimbo de data/hora da solicitação HTTP atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O carimbo de hora retornado do <xref:System.Web.HttpContext.Timestamp%2A> propriedade é a hora local do servidor e é definida durante a instanciação do <xref:System.Web.HttpContext> objeto. A hora local é igual à hora UTC e o deslocamento do UTC.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Trace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Trace As TraceContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceContext ^ Trace { System::Web::TraceContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Trace : System.Web.TraceContext" Usage="System.Web.HttpContext.Trace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see cref="T:System.Web.TraceContext" /> para a resposta HTTP atual.</summary>
        <value>O <see cref="T:System.Web.TraceContext" /> para a resposta HTTP atual.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.User" />
      <MemberSignature Language="VB.NET" Value="Public Property User As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::IPrincipal ^ User { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.User : System.Security.Principal.IPrincipal with get, set" Usage="System.Web.HttpContext.User" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define informações de segurança para a solicitação HTTP atual.</summary>
        <value>Informações de segurança da solicitação HTTP atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.HttpContext.User%2A> propriedade fornece acesso programático para as propriedades e métodos do <xref:System.Security.Principal.IPrincipal> interface.  
  
 Como as páginas ASP.NET contêm uma referência padrão para o <xref:System.Web> namespace (que contém o <xref:System.Web.HttpContext> classe), você pode fazer referência os membros de <xref:System.Web.HttpContext> em uma página. aspx sem usar a referência de classe totalmente qualificado para <xref:System.Web.HttpContext>. Por exemplo, você pode usar `User.Identity.Name` obter o nome do usuário em cujo nome o processo atual está em execução. No entanto, se você quiser usar os membros de <xref:System.Security.Principal.IPrincipal> de um módulo de code-behind do ASP.NET, você deve incluir uma referência para o <xref:System.Web> namespace no módulo e uma referência totalmente qualificada para o contexto de solicitação/resposta ativa no momento e o classe <xref:System.Web> que você deseja usar. Por exemplo, em uma página code-behind você deve especificar o nome totalmente qualificado `HttpContext.Current.User.Identity.Name`.  
  
   
  
## Examples  
 O exemplo a seguir mostra como acessar propriedades do usuário atual por meio de <xref:System.Web.HttpContext.User%2A> propriedade. Essas propriedades são usadas para definir o título da página da Web.  
  
 Se o aplicativo usa a autenticação do Windows, o nome de usuário inclui o domínio. Por exemplo, o título da página seria "Home page para o domínio \ nomedousuário".  
  
 [!code-csharp[System.Web.HttpContext.User#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext.User/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.HttpContext.User#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext.User/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="http://www.asp.net/mvc/tutorials/security/using-oauth-providers-with-mvc">Usando provedores OAuth com o MVC 4</related>
        <related type="ExternalDocumentation" href="http://www.asp.net/web-forms/tutorials/aspnet-45/getting-started-with-aspnet-45-web-forms/checkout-and-payment-with-paypal">Introdução ao 4.5 Web Forms do ASP.NET - check-out e pagamento com o PayPal</related>
        <related type="ExternalDocumentation" href="http://www.asp.net/web-api/overview/creating-web-apis/using-web-api-with-entity-framework/using-web-api-with-entity-framework,-part-6">Usando a API da Web com o Entity Framework - parte 6</related>
        <related type="ExternalDocumentation" href="http://www.asp.net/mvc/tutorials/older-versions/nerddinner/secure-applications-using-authentication-and-authorization">Nerd jantar - proteger aplicativos usando a autenticação e autorização</related>
      </Docs>
    </Member>
    <Member MemberName="WebSocketNegotiatedProtocol">
      <MemberSignature Language="C#" Value="public string WebSocketNegotiatedProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebSocketNegotiatedProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketNegotiatedProtocol As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WebSocketNegotiatedProtocol { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketNegotiatedProtocol : string" Usage="System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o protocolo negociado que foi enviado do servidor para o cliente para uma conexão <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
        <value>O protocolo negociado.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WebSocketRequestedProtocols">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;string&gt; WebSocketRequestedProtocols { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;string&gt; WebSocketRequestedProtocols" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketRequestedProtocols As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::String ^&gt; ^ WebSocketRequestedProtocols { System::Collections::Generic::IList&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketRequestedProtocols : System.Collections.Generic.IList&lt;string&gt;" Usage="System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a lista ordenada de protocolos solicitados pelo cliente.</summary>
        <value>Os protocolos solicitados, ou <see langword="null" /> se não for um <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> solicitação ou se nenhuma lista estiver presente.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>