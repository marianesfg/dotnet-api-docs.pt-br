<Type Name="TextPointer" FullName="System.Windows.Documents.TextPointer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="20e032541a3b46004aebc1cb03effddcadbc38ce" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52228425" /></Metadata><TypeSignature Language="C#" Value="public class TextPointer : System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextPointer extends System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.TextPointer" />
  <TypeSignature Language="VB.NET" Value="Public Class TextPointer&#xA;Inherits ContentPosition" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextPointer : System::Windows::Documents::ContentPosition" />
  <TypeSignature Language="F#" Value="type TextPointer = class&#xA;    inherit ContentPosition" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Documents.ContentPosition</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Representa uma posição dentro de um <see cref="T:System.Windows.Documents.FlowDocument" /> ou <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Documents.TextPointer> classe apresenta a seguinte terminologia:  
  
-   Posicione - inerentemente, um <xref:System.Windows.Documents.TextPointer> sempre aponta para um *posição* no conteúdo.  Essas posições de qualquer um se enquadram entre caracteres de conteúdo, ou entre o fluxo de conteúdo de elemento de marcas que definem a estrutura do conteúdo.  
  
-   Posição atual - porque um <xref:System.Windows.Documents.TextPointer> sempre indica uma posição e porque muitas das operações que podem ser executadas por meio de um <xref:System.Windows.Documents.TextPointer> são relativas a posição no momento apontada pelo <xref:System.Windows.Documents.TextPointer>, faz sentido simplesmente se referem à posição indicada por uma <xref:System.Windows.Documents.TextPointer> como o *posição atual*.  
  
-   Posição de inserção - um *posição de inserção* é uma posição em que o novo conteúdo pode ser adicionado sem interromper todas as regras semânticas para o conteúdo associado.  Na prática, um ponto de inserção é em qualquer lugar no conteúdo em que um cursor do sistema pode ser posicionado.  Um exemplo de válida <xref:System.Windows.Documents.TextPointer> posição que não é um ponto de inserção é a posição entre dois adjacentes <xref:System.Windows.Documents.Paragraph> marcas (ou seja, entre a marca de fechamento do parágrafo anterior e a marca de abertura do próximo parágrafo).  
  
-   Símbolo - para as finalidades <xref:System.Windows.Documents.TextPointer> operações que envolvem símbolos, qualquer um dos seguintes é considerado uma *símbolo*:  
  
    -   Uma marca de abertura ou para um <xref:System.Windows.Documents.TextElement> elemento.  
  
    -   Um <xref:System.Windows.UIElement> elemento contido em um <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Observe que essas uma <xref:System.Windows.UIElement> sempre são contados como exatamente um símbolo; qualquer conteúdo adicional ou elementos contidos pelo <xref:System.Windows.UIElement> não são contadas como símbolos.  
  
    -   Cada 16-bit [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caractere dentro de um texto <xref:System.Windows.Documents.Run> elemento.  
  
-   Contêiner de texto – *contêiner de texto* é o elemento de que forma a borda final para o conteúdo de fluxo em questão, a posição indicada por um <xref:System.Windows.Documents.TextPointer> sempre está dentro de um contêiner de texto.  Atualmente, um contêiner de texto deve ser um <xref:System.Windows.Documents.FlowDocument> ou um <xref:System.Windows.Controls.TextBlock>.  Em termos gerais, as operações entre <xref:System.Windows.Documents.TextPointer> não há suporte para instâncias em contêineres de texto diferente.  
  
-   Documento – o conteúdo em um contêiner de texto é conhecido como um *documento*, como na <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> método e o <xref:System.Windows.Documents.TextPointer.DocumentStart%2A> e <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A> propriedades.  
  
 O <xref:System.Windows.Documents.TextPointer> classe destina-se para facilitar a passagem e a manipulação de conteúdo que é representado por [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] elementos de conteúdo de fluxo; em geral, esses elementos derivam <xref:System.Windows.Documents.TextElement>.  Algumas das operações que <xref:System.Windows.Documents.TextPointer> facilita incluem o seguinte:  
  
-   Execute uma comparação ordinal da posição atual com uma segunda posição especificada.  Consulte o <xref:System.Windows.Documents.TextPointer.CompareTo%2A> método.  
  
-   Determine o tipo de conteúdo adjacente à posição atual em uma direção especificada.  Consulte a <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> método e <xref:System.Windows.Documents.TextPointerContext> enumeração.  
  
-   Obter o <xref:System.Windows.Documents.TextElement> que tem como escopo ou adjacente à posição atual.  Ver <xref:System.Windows.Documents.Paragraph> e o <xref:System.Windows.Documents.TextPointer.GetAdjacentElement%2A> método.  
  
-   Obter o contêiner de texto que tem como escopo o documento atual.  Consulte a propriedade <xref:System.Windows.Documents.TextPointer.Parent%2A>.  
  
-   Obter um número especificado de caracteres precede ou segue a posição atual.  Consulte o <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> método.  
  
-   Insira uma cadeia de caracteres da posição atual.  Consulte o <xref:System.Windows.Documents.TextPointer.InsertTextInRun%2A> método.  
  
-   Encontre os limites de linha no conteúdo.  Consulte a <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> método e <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> propriedade.  
  
-   Converter entre <xref:System.Windows.Documents.TextPointer> deslocamentos de posições e o símbolo em conteúdo.  Consulte a <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> e <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> métodos.  
  
-   Executar o teste de clique visual ao converter entre um <xref:System.Windows.Documents.TextPointer> posição e um <xref:System.Windows.Point> que representa as coordenadas relativas.  
  
-   Localize uma posição de inserção mais próximos ou verifique se a posição atual é um ponto de inserção.  Consulte a <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> e <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> métodos e as <xref:System.Windows.Documents.TextPointer.IsAtInsertionPosition%2A> propriedade.  
  
 A posição e <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> indicado por um <xref:System.Windows.Documents.TextPointer> objeto são imutáveis.  Quando o conteúdo é editado ou alterado, a posição indicada por um <xref:System.Windows.Documents.TextPointer> não é alterado em relação ao texto ao redor; em vez disso, o deslocamento da posição desde o início do conteúdo é ajustado de forma correspondente para refletir a nova posição relativa na conteúdo.  Por exemplo, um <xref:System.Windows.Documents.TextPointer> que indica uma posição no início de um determinado parágrafo continua a apontar para o início do parágrafo, mesmo quando o conteúdo é inserido ou excluído antes ou depois do parágrafo.  
  
 O <xref:System.Windows.Documents.TextPointer> classe fornece construtores públicos.  Uma instância do <xref:System.Windows.Documents.TextPointer> é criado usando as propriedades ou métodos de outros objetos (incluindo outros <xref:System.Windows.Documents.TextPointer> objetos). A lista a seguir fornece alguns exemplos de métodos e propriedades que criar e retornam um <xref:System.Windows.Documents.TextPointer>.  Esta lista não é completa:  
  
-   De um <xref:System.Windows.Documents.TextRange>: <xref:System.Windows.Documents.TextRange.Start%2A> e <xref:System.Windows.Documents.TextRange.End%2A>.  
  
-   De um <xref:System.Windows.Documents.TextElement>: <xref:System.Windows.Documents.TextElement.ContentStart%2A>, <xref:System.Windows.Documents.TextElement.ContentEnd%2A>, <xref:System.Windows.Documents.TextElement.ElementStart%2A>, e <xref:System.Windows.Documents.TextElement.ElementEnd%2A>.  
  
-   De um <xref:System.Windows.Controls.TextBlock> (contêiner de texto): <xref:System.Windows.Controls.TextBlock.ContentStart%2A>, <xref:System.Windows.Controls.TextBlock.ContentEnd%2A>, e <xref:System.Windows.Controls.TextBlock.GetPositionFromPoint%2A>.  
  
-   De um <xref:System.Windows.Documents.FlowDocument> (contêiner de texto): <xref:System.Windows.Documents.FlowDocument.ContentStart%2A>, e <xref:System.Windows.Documents.FlowDocument.ContentEnd%2A>  
  
-   De uma já existente <xref:System.Windows.Documents.TextPointer>: <xref:System.Windows.Documents.TextPointer.DocumentStart%2A>, <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A>, <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A>, e <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar um <xref:System.Windows.Documents.TextPointer> para localizar uma posição dentro do primeiro <xref:System.Windows.Documents.Run> elemento em um contêiner de texto especificado.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer1)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer1)]  
  
 O exemplo a seguir implementa um algoritmo find simplista usando <xref:System.Windows.Documents.TextPointer> instalações.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.TextRange" />
    <altmember cref="T:System.Windows.Documents.TextPointerContext" />
    <altmember cref="T:System.Windows.Documents.TextElement" />
  </Docs>
  <Members>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : System.Windows.Documents.TextPointer -&gt; int" Usage="textPointer.CompareTo position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">Um <see cref="T:System.Windows.Documents.TextPointer" /> que especifica uma posição para comparar à posição atual.</param>
        <summary>Executa uma comparação ordinal entre as posições especificadas pelo <see cref="T:System.Windows.Documents.TextPointer" /> atual e um segundo <see cref="T:System.Windows.Documents.TextPointer" /> especificado.</summary>
        <returns>– 1 se o <see cref="T:System.Windows.Documents.TextPointer" /> atual preceder <paramref name="position" />, 0 se os locais forem iguais, +1 se o <see cref="T:System.Windows.Documents.TextPointer" /> atual seguir <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um valor de -1 indica que a posição especificada pelo atual <xref:System.Windows.Documents.TextPointer> precede a posição especificada pela `position`.  Um valor de 0 indica que o indicado posições são iguais.  Um valor de + 1 positivo indica que a posição especificada pelo atual <xref:System.Windows.Documents.TextPointer> segue a posição especificada pela `position`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso para esse método.  No exemplo, o <xref:System.Windows.Documents.TextPointer.CompareTo%2A> método é usado em conjunto com o <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> método para testar se um especificado <xref:System.Windows.Documents.TextElement> está vazio.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="position" /> especifica uma posição fora do contêiner de texto associado à posição atual.</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteTextInRun">
      <MemberSignature Language="C#" Value="public int DeleteTextInRun (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 DeleteTextInRun(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeleteTextInRun (count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int DeleteTextInRun(int count);" />
      <MemberSignature Language="F#" Value="member this.DeleteTextInRun : int -&gt; int" Usage="textPointer.DeleteTextInRun count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">O número de caracteres a serem excluídos, começando na posição atual. Especifique um valor positivo para excluir os caracteres que seguem a posição atual; especifique um valor negativo para excluir caracteres que precedem a posição atual.</param>
        <summary>Exclui o número especificado de caracteres da posição indicada pelo <see cref="T:System.Windows.Documents.TextPointer" /> atual.</summary>
        <returns>O número de caracteres de fato excluídos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Especifique um valor positivo para excluir caracteres que seguem a posição atual (como em <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>); Especifique um valor negativo para excluir caracteres que precedem a posição atual (como em <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 O número de caracteres realmente excluído pode ser menor que o número especificado por `count`.  Isso ocorre em casos onde `count` especifica mais caracteres do que existem para ser excluído.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O método é chamado em uma posição em que texto não é permitido.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetTextInRun" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DocumentEnd">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentEnd As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentEnd { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentEnd : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um <see cref="T:System.Windows.Documents.TextPointer" /> no fim do conteúdo no contêiner de texto associado à posição atual.</summary>
        <value>Um <see cref="T:System.Windows.Documents.TextPointer" /> no final do conteúdo no contêiner de texto associado à posição atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Documents.TextPointer.Parent%2A> para retornado <xref:System.Windows.Documents.TextPointer> sempre é um contêiner de texto (<xref:System.Windows.Controls.TextBlock> ou <xref:System.Windows.Documents.FlowDocument>), em vez de um <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="DocumentStart">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentStart As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentStart { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentStart : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um <see cref="T:System.Windows.Documents.TextPointer" /> no início do conteúdo no contêiner de texto associado à posição atual.</summary>
        <value>Um <see cref="T:System.Windows.Documents.TextPointer" /> no início do conteúdo no contêiner de texto associado à posição atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use a posição retornada por essa propriedade como uma posição de linha de base da qual trabalhar com deslocamentos relativos para outras posições.  O <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> e <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> métodos fornecem uma maneira de converter entre posições e posição deslocamentos.  
  
 O <xref:System.Windows.Documents.TextPointer.Parent%2A> para retornado <xref:System.Windows.Documents.TextPointer> sempre é um contêiner de texto (<xref:System.Windows.Controls.TextBlock> ou <xref:System.Windows.Documents.FlowDocument>), em vez de um <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="GetAdjacentElement">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject GetAdjacentElement (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject GetAdjacentElement(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAdjacentElement (direction As LogicalDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyObject ^ GetAdjacentElement(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetAdjacentElement : System.Windows.Documents.LogicalDirection -&gt; System.Windows.DependencyObject" Usage="textPointer.GetAdjacentElement direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Um dos valores <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica a direção lógica na qual pesquisar um elemento adjacente.</param>
        <summary>Retorna o elemento, se houver, que limita o <see cref="T:System.Windows.Documents.TextPointer" /> atual na direção lógica especificada.</summary>
        <returns>O elemento adjacente no <paramref name="direction" /> especificado ou <see langword="null" /> se nenhum elemento adjacente existir.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O elemento retornado é geralmente um <xref:System.Windows.Documents.TextElement>.  Um <xref:System.Windows.UIElement> pode ser retornado quando o <xref:System.Windows.Documents.TextPointer> indica uma posição dentro de uma <xref:System.Windows.Documents.BlockUIContainer> elemento ou um <xref:System.Windows.Documents.InlineUIContainer> elemento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetCharacterRect">
      <MemberSignature Language="C#" Value="public System.Windows.Rect GetCharacterRect (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect GetCharacterRect(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCharacterRect (direction As LogicalDirection) As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Rect GetCharacterRect(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetCharacterRect : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Rect" Usage="textPointer.GetCharacterRect direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Um dos valores <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica a direção lógica na qual localizar uma caixa delimitadora de conteúdo.</param>
        <summary>Retorna uma caixa delimitadora (<see cref="T:System.Windows.Rect" />) para o conteúdo que limita o <see cref="T:System.Windows.Documents.TextPointer" /> atual na direção lógica especificada.</summary>
        <returns>Uma caixa delimitadora para o conteúdo que limita o <see cref="T:System.Windows.Documents.TextPointer" /> atual na direção especificada ou <see cref="P:System.Windows.Rect.Empty" /> se informações de layout atuais e válidas não estiverem disponíveis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextElement> as bordas não são consideradas conteúdo para os fins deste método.  Se o <xref:System.Windows.Documents.TextPointer> é posicionado antes de uma <xref:System.Windows.Documents.TextElement> edge, o valor de retorno é uma caixa delimitadora para o próximo não -<xref:System.Windows.Documents.TextElement> conteúdo na direção especificada.  Se não houver nenhum conteúdo na direção especificada, uma largura de zero <xref:System.Windows.Rect> é retornado com uma altura correspondente a altura das qualquer anteriores conteúda.  
  
 A operação executada por esse método depende de um layout válido.  Quando necessário, esse método tenta gerar automaticamente um layout válido antes de continuar com a operação.  Regenerar um layout pode ser uma operação relativamente cara.  Use o <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> propriedade para verificar se há um layout válido antes de executar operações que podem regenerar o layout.  Veja [Layout](~/docs/framework/wpf/advanced/layout.md) para obter mais informações.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      </Docs>
    </Member>
    <Member MemberName="GetInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetInsertionPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetInsertionPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Um dos valores <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica a direção lógica na qual pesquisar a posição de inserção mais próxima.</param>
        <summary>Retorna um <see cref="T:System.Windows.Documents.TextPointer" /> para a posição de inserção mais próxima na direção lógica especificada.</summary>
        <returns>Um <see cref="T:System.Windows.Documents.TextPointer" /> para a posição de inserção mais próxima na direção especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um ponto de inserção é uma posição em que o novo conteúdo pode ser adicionado sem interromper todas as regras semânticas para o conteúdo associado.  Na prática, um ponto de inserção é em qualquer lugar no conteúdo em que um cursor do sistema pode ser posicionado.  Um exemplo de válida <xref:System.Windows.Documents.TextPointer> posição que não é um ponto de inserção é a posição entre dois adjacentes <xref:System.Windows.Documents.Paragraph> marcas (ou seja, entre a marca de fechamento do parágrafo anterior e a marca de abertura do próximo parágrafo).  
  
 Se o <xref:System.Windows.Documents.TextPointer> já aponta para uma posição de inserção válido, mas a marca de fechamento para uma sequência de formatação vazio segue diretamente nessa posição na direção de determinado, em seguida, a <xref:System.Windows.Documents.TextPointer> retornado por este método é ajustado para apontar para a inserção posição logo após o fechamento da sequência de formatação. Por exemplo, considere a sequência de marcação `<Bold>a</Bold>b`. Observe que há duas posições de inserção entre as letras `a` e `b` — um que precede o `Bold` marca e um diretamente após o fechamento `Bold` marca. Se <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> é chamado em um <xref:System.Windows.Documents.TextPointer> para a posição logo após a letra `a` e antes do fechamento `Bold` marca e com um `direction` de <xref:System.Windows.Documents.LogicalDirection.Forward>, retornado <xref:System.Windows.Documents.TextPointer> é ajustado para apontar para o posição imediatamente antes da letra `b`, após o fechamento `Bold` marca. Um ajuste semelhante é feito para abrir as marcas de formatação ao trabalhar na direção lógica oposta. Este método destina-se a fornecer um meio de desambiguidade entre as posições de inserção em casos semelhantes.  
  
 Esse método também pode ser usado para ser seletivo sobre pontos de inserção quando uma sequência de marcas estruturais está envolvida. Por exemplo, quando estiver em uma posição entre as marcas de parágrafo de abertura e fechamento, a direção de parâmetro pode ser usada para selecionar o ponto de inserção mais próximo no início do parágrafo seguinte (especificando <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>) ou no final no (parágrafo anterior especificando <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 Se o ponteiro já está na posição de inserção, e não há nenhuma marca de formatação adjacente especificado na `direction`, retornado <xref:System.Windows.Documents.TextPointer> aponta para a mesma posição que chamada <xref:System.Windows.Documents.TextPointer>.  
  
 É possível que nenhuma posição de inserção válido existe em relação à posição apontada to por um <xref:System.Windows.Documents.TextPointer>.  Isso pode acontecer se o conteúdo referenciado está estruturalmente incompleto, como em uma tabela vazia ou uma lista.  Nesses casos, esse método simplesmente retorna uma <xref:System.Windows.Documents.TextPointer> para a mesma posição que o <xref:System.Windows.Documents.TextPointer> do qual esse método foi chamado.  Esse método sempre retorna válido <xref:System.Windows.Documents.TextPointer>.  
  
   
  
## Examples  
 Este exemplo mostra como usar o <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> método para verificar se determinado <xref:System.Windows.Documents.TextElement> está vazia de conteúdo imprimível.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLineStartPosition">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna um <see cref="T:System.Windows.Documents.TextPointer" /> para o início de uma linha especificada em relação ao <see cref="T:System.Windows.Documents.TextPointer" /> atual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count);" />
      <MemberSignature Language="F#" Value="member this.GetLineStartPosition : int -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetLineStartPosition count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">O número de marcadores de início de linha a serem ignorados ao determinar a linha para a qual a posição inicial será retornada. Valores negativos especificam linhas precedentes, 0 especifica a linha atual e valores positivos especificam linhas subsequentes.</param>
        <summary>Retorna um <see cref="T:System.Windows.Documents.TextPointer" /> para o início de uma linha especificada em relação ao <see cref="T:System.Windows.Documents.TextPointer" /> atual.</summary>
        <returns>Um <see cref="T:System.Windows.Documents.TextPointer" /> que aponta para o início da linha especificada (com o <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> definido como <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />) ou <see langword="null" /> se a linha especificada estiver fora do intervalo ou não puder ser localizada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.Windows.Documents.TextPointer> aponta para uma posição ambígua, por exemplo, entre duas linhas, a linha na direção especificada por <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> é selecionado como a linha de início relativa.  
  
 A operação executada por esse método depende de um layout válido.  Quando necessário, esse método tenta gerar automaticamente um layout válido antes de continuar com a operação.  Regenerar um layout pode ser uma operação relativamente cara.  Use <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> para verificar se há um layout válido antes de executar operações que podem regenerar o layout.  Veja [Layout](~/docs/framework/wpf/advanced/layout.md) para obter mais informações.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count, out int actualCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count, [out] int32&amp; actualCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer, ByRef actualCount As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count, [Runtime::InteropServices::Out] int % actualCount);" />
      <MemberSignature Language="F#" Value="member this.GetLineStartPosition : int *  -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetLineStartPosition (count, actualCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="actualCount" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="count">O número de marcadores de início de linha a serem ignorados ao determinar a linha para a qual a posição inicial será retornada. Valores negativos especificam linhas precedentes, 0 especifica a linha atual e valores positivos especificam linhas subsequentes.</param>
        <param name="actualCount">Quando este método retorna, contém o número real de marcadores de início de linha que foram ignorados ao determinar a linha para a qual retornar a posição inicial.  Este valor poderá ser menor que <paramref name="count" /> se o início ou final do conteúdo for encontrado antes que o número especificado de linhas seja ignorado. Este parâmetro é passado não inicializado.</param>
        <summary>Retorna um <see cref="T:System.Windows.Documents.TextPointer" /> para o início de uma linha especificada em relação ao <see cref="T:System.Windows.Documents.TextPointer" /> atual e informa quantas linhas foram ignoradas.</summary>
        <returns>Um <see cref="T:System.Windows.Documents.TextPointer" /> que apontará para o início da linha especificada (com o <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> definido como <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />) ou para o início da linha mais próxima à linha especificada se a linha especificada estiver fora do intervalo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.Windows.Documents.TextPointer> aponta para uma posição ambígua, por exemplo, entre duas linhas, a linha na direção especificada pelo <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> propriedade é selecionada como a linha de início relativa.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextContextPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextContextPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextContextPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextContextPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextContextPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextContextPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetNextContextPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Um dos valores <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica a direção lógica na qual pesquisar o próximo símbolo.</param>
        <summary>Retorna um ponteiro para o próximo símbolo na direção lógica especificada.</summary>
        <returns>Um <see cref="T:System.Windows.Documents.TextPointer" /> para o próximo símbolo na direção solicitada ou <see langword="null" /> se o <see cref="T:System.Windows.Documents.TextPointer" /> atual limitar o início ou o fim do conteúdo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer um dos seguintes é considerado um símbolo:  
  
-   Uma marca de abertura ou para um <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Um <xref:System.Windows.UIElement> elemento contido em um <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Observe que essas uma <xref:System.Windows.UIElement> sempre são contados como exatamente um símbolo; qualquer conteúdo adicional ou elementos contidos pelo <xref:System.Windows.UIElement> não são contadas como símbolos.  
  
-   De 16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caractere dentro de um texto <xref:System.Windows.Documents.Run> elemento.  
  
 Se o próximo símbolo é categorizado como <xref:System.Windows.Documents.TextPointerContext.EmbeddedElement>, <xref:System.Windows.Documents.TextPointerContext.ElementStart>, ou <xref:System.Windows.Documents.TextPointerContext.ElementEnd> (conforme identificado pela <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> método), em seguida, a <xref:System.Windows.Documents.TextPointer> retornado por este método é adiantado por exatamente um símbolo da posição atual.  
  
 Se o próximo símbolo é categorizado como <xref:System.Windows.Documents.TextPointerContext.Text>, em seguida, a <xref:System.Windows.Documents.TextPointer> retornado por este método é ultrapassaram o texto para o próximo símbolo que não sejam de texto (ou seja, a próxima posição em que o <xref:System.Windows.Documents.TextPointerContext> não é <xref:System.Windows.Documents.TextPointerContext.Text>).  A contagem exata de símbolo cruzada pode ser calculada com antecedência, chamando o <xref:System.Windows.Documents.TextPointer.GetTextRunLength%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso para esse método.  O exemplo usa o <xref:System.Windows.Documents.TextPointer.GetNextContextPosition%2A> método em conjunto com o <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> método percorrer e extrair os símbolos em um especificado <xref:System.Windows.Documents.TextElement>.  
  
 Embora o exemplo pode ser usado para extrair uma [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] estrutura para o conteúdo de um determinado <xref:System.Windows.Documents.TextElement>, ele é destinado apenas para fins ilustrativos e não deve ser usado no código de produção.  Consulte o <xref:System.Xml> namespace para um rico conjunto de tipos projetados para trabalhar com e processamento de XML.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextcontextposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextcontextposition)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextInsertionPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetNextInsertionPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Um dos valores <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica a direção lógica na qual pesquisar a próxima posição de inserção.</param>
        <summary>Retorna um <see cref="T:System.Windows.Documents.TextPointer" /> para a próxima posição de inserção na direção lógica especificada.</summary>
        <returns>Um <see cref="T:System.Windows.Documents.TextPointer" /> que identifica a próxima posição de inserção na direção solicitada ou <see langword="null" /> se a próxima posição de inserção não puder ser encontrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma *posição de inserção* é uma posição em que o novo conteúdo pode ser adicionado sem interromper todas as regras semânticas para o conteúdo associado.  Na prática, um ponto de inserção é em qualquer lugar no conteúdo em que um cursor do sistema pode ser posicionado.  Um exemplo de válida <xref:System.Windows.Documents.TextPointer> posição que não é um ponto de inserção é a posição entre dois adjacentes <xref:System.Windows.Documents.Paragraph> marcas (ou seja, entre a marca de fechamento do parágrafo anterior e a marca de abertura do próximo parágrafo).  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso para esse método. O exemplo usa o <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> método para percorrer os limites do elemento de conteúdo para contar o número de <xref:System.Windows.Documents.Paragraph> elementos apresentam entre dois especificado <xref:System.Windows.Documents.TextPointer> instâncias.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="GetOffsetToPosition">
      <MemberSignature Language="C#" Value="public int GetOffsetToPosition (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetOffsetToPosition(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOffsetToPosition (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetOffsetToPosition(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.GetOffsetToPosition : System.Windows.Documents.TextPointer -&gt; int" Usage="textPointer.GetOffsetToPosition position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">Um <see cref="T:System.Windows.Documents.TextPointer" /> que especifica uma posição da qual encontrar a distância (em símbolos).</param>
        <summary>Retorna a contagem de símbolos entre o <see cref="T:System.Windows.Documents.TextPointer" /> atual e um segundo <see cref="T:System.Windows.Documents.TextPointer" /> especificado.</summary>
        <returns>O número relativo de símbolos entre o <see cref="T:System.Windows.Documents.TextPointer" /> atual e <paramref name="position" />.  Um valor negativo indica que o <see cref="T:System.Windows.Documents.TextPointer" /> atual segue a posição especificada por <paramref name="position" />, 0 indica que as posições são iguais e um valor positivo indica que o <see cref="T:System.Windows.Documents.TextPointer" /> atual precede a posição especificada por <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer um dos seguintes é considerado um símbolo:  
  
-   Uma marca de abertura ou para um <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Um <xref:System.Windows.UIElement> elemento contido em um <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Observe que essas uma <xref:System.Windows.UIElement> sempre são contados como exatamente um símbolo; qualquer conteúdo adicional ou elementos contidos pelo <xref:System.Windows.UIElement> não são contadas como símbolos.  
  
-   De 16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caractere dentro de um texto <xref:System.Windows.Documents.Run> elemento.  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso para esse método. O exemplo usa o <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> método para encontrar os deslocamentos de dois <xref:System.Windows.Documents.TextPointer> instâncias e, em seguida, usa essas informações para salvar e restaurar a seleção em um <xref:System.Windows.Controls.RichTextBox>.  O exemplo supõe que o conteúdo do <xref:System.Windows.Controls.RichTextBox> não foram alterados entre uma seleção de salvamento e restauração de uma seleção.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="position" /> especifica uma posição fora do contêiner de texto associado à posição atual.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetPositionAtOffset" />
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPointerContext">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointerContext GetPointerContext (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Documents.TextPointerContext GetPointerContext(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPointerContext (direction As LogicalDirection) As TextPointerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointerContext GetPointerContext(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetPointerContext : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointerContext" Usage="textPointer.GetPointerContext direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Um dos valores <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica a direção lógica na qual determinar a categoria do conteúdo adjacente.</param>
        <summary>Retorna um indicador de categoria para o conteúdo adjacente ao <see cref="T:System.Windows.Documents.TextPointer" /> atual na direção lógica especificada.</summary>
        <returns>Um dos valores <see cref="T:System.Windows.Documents.TextPointerContext" /> que indica a categoria para o conteúdo adjacente na direção lógica especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra um uso para esse método. O exemplo usa o <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> método para implementar um algoritmo para calcular o saldo de abertura e fechamento de marcas de elemento entre dois especificado <xref:System.Windows.Documents.TextPointer> posições.  Cada marca de elemento de abertura é contada como + 1 e cada elemento de marca de fechamento é contabilizada como -1.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPositionAtOffset">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna um <see cref="T:System.Windows.Documents.TextPointer" /> à posição indicada pelo deslocamento especificado, em símbolos, do início do conteúdo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset);" />
      <MemberSignature Language="F#" Value="member this.GetPositionAtOffset : int -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetPositionAtOffset offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="offset">Um deslocamento, em símbolos, para o qual calcular e retornar a posição.  Se o deslocamento for negativo, a posição será calculada na direção lógica oposta àquela indicada pela propriedade <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" />.</param>
        <summary>Retorna um <see cref="T:System.Windows.Documents.TextPointer" /> à posição indicada pelo deslocamento especificado nos símbolos, desde o início do <see cref="T:System.Windows.Documents.TextPointer" /> atual.</summary>
        <returns>Um <see cref="T:System.Windows.Documents.TextPointer" /> para a posição indicada pelo deslocamento especificado ou <see langword="null" /> se nenhuma posição correspondente puder ser encontrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer um dos seguintes é considerado um símbolo:  
  
-   Uma marca de abertura ou para o <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Um <xref:System.Windows.UIElement> elemento contido em um <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Observe que essas uma <xref:System.Windows.UIElement> sempre são contados como exatamente um símbolo; qualquer conteúdo adicional ou elementos contidos pelo <xref:System.Windows.UIElement> não são contadas como símbolos.  
  
-   De 16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caractere dentro de um texto <xref:System.Windows.Documents.Run> elemento.  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso para esse método. O exemplo usa o <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> método para implementar um par de métodos, um para calcular o deslocamento para uma posição especificada em relação a qualquer parágrafo de hospedagem e o outro para retornar um <xref:System.Windows.Documents.TextPointer> para um deslocamento especificado de um determinado parágrafo.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getpositionatoffset)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getpositionatoffset)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset, System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset, valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer, direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset, System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetPositionAtOffset : int * System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetPositionAtOffset (offset, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="offset">Um deslocamento, em símbolos, para o qual calcular e retornar a posição.  Se o deslocamento for negativo, o <see cref="T:System.Windows.Documents.TextPointer" /> retornado precede o atual <see cref="T:System.Windows.Documents.TextPointer" />, caso contrário, ele sucede.</param>
        <param name="direction">Um dos valores <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica a direção da lógica do <see cref="T:System.Windows.Documents.TextPointer" /> retornado.</param>
        <summary>Retorna um <see cref="T:System.Windows.Documents.TextPointer" /> à posição indicada pelo deslocamento especificado nos símbolos, desde o início do <see cref="T:System.Windows.Documents.TextPointer" /> atual e na direção especificada.</summary>
        <returns>Um <see cref="T:System.Windows.Documents.TextPointer" /> para a posição indicada pelo deslocamento especificado ou <see langword="null" /> se o deslocamento ultrapassar o fim do conteúdo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer um dos seguintes é considerado um símbolo:  
  
-   Uma marca de abertura ou para o <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Um <xref:System.Windows.UIElement> elemento contido em um <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Observe que essas uma <xref:System.Windows.UIElement> sempre são contados como exatamente um símbolo; qualquer conteúdo adicional ou elementos contidos pelo <xref:System.Windows.UIElement> não são contadas como símbolos.  
  
-   De 16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caractere dentro de um texto <xref:System.Windows.Documents.Run> elemento.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTextInRun">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna o texto adjacente ao <see cref="T:System.Windows.Documents.TextPointer" /> atual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public string GetTextInRun (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTextInRun(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetTextInRun : System.Windows.Documents.LogicalDirection -&gt; string" Usage="textPointer.GetTextInRun direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Um dos valores <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica a direção lógica na qual localizar e retornar qualquer texto adjacente.</param>
        <summary>Retorna uma cadeia de caracteres que contém qualquer texto adjacente ao <see cref="T:System.Windows.Documents.TextPointer" /> atual na direção lógica especificada.</summary>
        <returns>Uma cadeia de caracteres que contém qualquer texto adjacente na direção lógica especificada ou <see cref="F:System.String.Empty" /> se nenhum texto adjacente puder ser encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retornará somente ininterruptas execuções de texto.  Nada será retornado se nenhum tipo de símbolo diferente de <xref:System.Windows.Documents.TextPointerContext.Text> adjacente ao atual <xref:System.Windows.Documents.TextPointer> na direção especificada.  Da mesma forma, o texto será retornado apenas até o próximo símbolo que não sejam de texto.  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso para esse método. O exemplo usa o <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> método para implementar um extrator de texto simples.  O método retorna uma concatenação de cadeia de caracteres de todo o texto entre dois especificado <xref:System.Windows.Documents.TextPointer> instâncias.  
  
 Embora o exemplo pode ser usado para extrair qualquer texto entre dois <xref:System.Windows.Documents.TextPointer> instâncias, ele é destinado apenas para fins ilustrativos e não deve ser usado no código de produção.  Use a propriedade <xref:System.Windows.Documents.TextRange.Text%2A?displayProperty=nameWithType> em seu lugar.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_gettextinrun)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_gettextinrun)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public int GetTextInRun (System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection, textBuffer As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextInRun(System::Windows::Documents::LogicalDirection direction, cli::array &lt;char&gt; ^ textBuffer, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.GetTextInRun : System.Windows.Documents.LogicalDirection * char[] * int * int -&gt; int" Usage="textPointer.GetTextInRun (direction, textBuffer, startIndex, count)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
        <Parameter Name="textBuffer" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction">Um dos valores <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica a direção lógica na qual localizar e copiar qualquer texto adjacente.</param>
        <param name="textBuffer">Um buffer em que qualquer texto é copiado.</param>
        <param name="startIndex">Um índice em <paramref name="textBuffer" /> no qual começar a gravar o texto copiado.</param>
        <param name="count">O número máximo de caracteres a serem copiados.</param>
        <summary>Copia o número máximo especificado de caracteres de qualquer texto adjacente na direção especificada para uma matriz de caracteres fornecida pelo cliente.</summary>
        <returns>O número de caracteres de fato copiados para <paramref name="textBuffer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retornará somente ininterruptas execuções de texto.  Nada será retornado se nenhum tipo de símbolo diferente de <xref:System.Windows.Documents.TextPointerContext.Text> adjacente ao atual <xref:System.Windows.Documents.TextPointer> na direção especificada.  Da mesma forma, o texto será retornado apenas até o próximo símbolo que não sejam de texto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="startIndex" /> é menor que 0 ou maior que a propriedade <see cref="P:System.Array.Length" /> de <paramref name="textBuffer" />.  
  
- ou - 
 <paramref name="count" /> é menor que 0 ou maior que o espaço restante em <paramref name="textBuffer" /> (<paramref name="textBuffer" />.<see cref="P:System.Array.Length" /> menos <paramref name="startIndex" />).</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextRunLength">
      <MemberSignature Language="C#" Value="public int GetTextRunLength (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextRunLength(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextRunLength (direction As LogicalDirection) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextRunLength(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetTextRunLength : System.Windows.Documents.LogicalDirection -&gt; int" Usage="textPointer.GetTextRunLength direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Um dos valores <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica a direção lógica na qual contar o número de caracteres.</param>
        <summary>Retorna o número de caracteres Unicode entre o <see cref="T:System.Windows.Documents.TextPointer" /> atual e o próximo símbolo que não é texto, na direção lógica especificada.</summary>
        <returns>O número de caracteres Unicode entre o <see cref="T:System.Windows.Documents.TextPointer" /> atual e o próximo símbolo que não é texto.  Esse número poderá ser 0 se não houver nenhum texto adjacente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer um dos seguintes é considerado um símbolo:  
  
-   Uma marca de abertura ou para o <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Um <xref:System.Windows.UIElement> elemento contido em um <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Observe que essas uma <xref:System.Windows.UIElement> sempre são contados como exatamente um símbolo; qualquer conteúdo adicional ou elementos contidos pelo <xref:System.Windows.UIElement> não são contadas como símbolos.  
  
-   De 16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caractere dentro de um texto <xref:System.Windows.Documents.Run> elemento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasValidLayout">
      <MemberSignature Language="C#" Value="public bool HasValidLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValidLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValidLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValidLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValidLayout : bool" Usage="System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.HasValidLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o contêiner de texto associado à posição atual tem um layout válido (atualizado).</summary>
        <value><see langword="true" /> Se o layout é atuais e válidas. Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando necessário, as operações que dependem de um layout válido (como o <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> método, <xref:System.Windows.Documents.TextPointer.GetCharacterRect%2A> método, e <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> propriedade) tentar gerar automaticamente um layout válido antes de continuar com a operação.  Regenerar um layout pode ser uma operação relativamente cara.  Use essa propriedade para verificar se há um layout válido antes de executar operações que podem regenerar o layout.  Veja [Layout](~/docs/framework/wpf/advanced/layout.md) para obter mais informações.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertLineBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertLineBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertLineBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertLineBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertLineBreak();" />
      <MemberSignature Language="F#" Value="member this.InsertLineBreak : unit -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.InsertLineBreak " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Insere uma quebra de linha na posição atual.</summary>
        <returns>Um <see cref="T:System.Windows.Documents.TextPointer" /> posicionado imediatamente após o elemento <see cref="T:System.Windows.Documents.LineBreak" /> inserido por este método.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertParagraphBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertParagraphBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertParagraphBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertParagraphBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertParagraphBreak();" />
      <MemberSignature Language="F#" Value="member this.InsertParagraphBreak : unit -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.InsertParagraphBreak " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Insere uma quebra de parágrafo na posição atual.</summary>
        <returns>Um <see cref="T:System.Windows.Documents.TextPointer" /> no início (<see cref="P:System.Windows.Documents.TextElement.ContentStart" />) do novo parágrafo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se esse método é chamado quando a posição atual está dentro de uma existente <xref:System.Windows.Documents.Paragraph> elemento, o parágrafo existente e qualquer conteúdo que ele contém são divididas em dois parágrafos na posição atual.  Se esse método é chamado quando a posição atual não está dentro de um parágrafo existente, um novo parágrafo vazio é inserido.  Se esse método é chamado em uma posição inadequado para dividir ou inserindo um parágrafo (por exemplo, se a posição atual está dentro de um <xref:System.Windows.Documents.Hyperlink> elemento), uma exceção será lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Este método é chamado em uma posição que não pode ser dividida para acomodar um novo parágrafo, como no escopo de um <see cref="T:System.Windows.Documents.Hyperlink" /> ou <see cref="T:System.Windows.Documents.InlineUIContainer" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertTextInRun">
      <MemberSignature Language="C#" Value="public void InsertTextInRun (string textData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertTextInRun(string textData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertTextInRun (textData As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertTextInRun(System::String ^ textData);" />
      <MemberSignature Language="F#" Value="member this.InsertTextInRun : string -&gt; unit" Usage="textPointer.InsertTextInRun textData" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.InsertTextInRun(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textData" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textData">O texto a ser inserido.</param>
        <summary>Insere o texto especificado no <see cref="T:System.Windows.Documents.Run" /> de texto na posição atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.Windows.Documents.TextPointer> não está no escopo por um <xref:System.Windows.Documents.Run> elemento, um <xref:System.Windows.Documents.Run> é inserido juntamente com o `textData`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A posição atual não está dentro de um elemento <see cref="T:System.Windows.Documents.Run" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="textData" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAtInsertionPosition">
      <MemberSignature Language="C#" Value="public bool IsAtInsertionPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtInsertionPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtInsertionPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtInsertionPosition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAtInsertionPosition : bool" Usage="System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.IsAtInsertionPosition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a posição atual é uma posição de inserção.</summary>
        <value><see langword="true" /> Se a posição atual é um ponto de inserção; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um ponto de inserção é uma posição em que o novo conteúdo pode ser adicionado sem interromper todas as regras semânticas para o conteúdo associado.  Na prática, um ponto de inserção é em qualquer lugar no conteúdo em que um cursor do sistema pode ser posicionado.  Um exemplo de válida <xref:System.Windows.Documents.TextPointer> posição que não é um ponto de inserção é a posição entre dois adjacentes <xref:System.Windows.Documents.Paragraph> marcas (ou seja, entre a marca de fechamento do parágrafo anterior e a marca de abertura do próximo parágrafo).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="IsAtLineStartPosition">
      <MemberSignature Language="C#" Value="public bool IsAtLineStartPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtLineStartPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtLineStartPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtLineStartPosition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAtLineStartPosition : bool" Usage="System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a posição atual está no início de uma linha.</summary>
        <value><see langword="true" /> Se a posição atual está no início de uma linha; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.Windows.Documents.TextPointer> aponta para uma posição ambígua, por exemplo, entre duas linhas, a linha na direção especificada pelo <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> propriedade é selecionada como a linha de início relativa.  
  
 A operação executada por esta propriedade depende de um layout válido.  Quando necessário, esse método tenta gerar automaticamente um layout válido antes de continuar com a operação.  Regenerar um layout pode ser uma operação relativamente cara.  Use o <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> propriedade para verificar se há um layout válido antes de executar operações que podem regenerar o layout.  Veja [Layout](~/docs/framework/wpf/advanced/layout.md) para obter mais informações.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      </Docs>
    </Member>
    <Member MemberName="IsInSameDocument">
      <MemberSignature Language="C#" Value="public bool IsInSameDocument (System.Windows.Documents.TextPointer textPosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsInSameDocument(class System.Windows.Documents.TextPointer textPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsInSameDocument (textPosition As TextPointer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsInSameDocument(System::Windows::Documents::TextPointer ^ textPosition);" />
      <MemberSignature Language="F#" Value="member this.IsInSameDocument : System.Windows.Documents.TextPointer -&gt; bool" Usage="textPointer.IsInSameDocument textPosition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textPosition" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="textPosition">Um <see cref="T:System.Windows.Documents.TextPointer" /> que especifica uma posição para comparar à posição atual.</param>
        <summary>Indica se a posição especificada estiver no mesmo contêiner de texto que a posição atual.</summary>
        <returns><see langword="true" /> se <paramref name="textPosition" /> indicar uma posição que estiver no mesmo contêiner de texto que a posição atual; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A maioria das operações que envolvem vários <xref:System.Windows.Documents.TextPointer> instâncias são válidas somente se as instâncias em questão indicarem posições em que estão no mesmo escopo de contêiner de texto.  Por exemplo o <xref:System.Windows.Documents.TextPointer.CompareTo%2A> e <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> métodos não podem ser usados com um <xref:System.Windows.Documents.TextPointer> para uma posição fora do contêiner de texto associado à posição atual.  Use esse método para verificar se determinado <xref:System.Windows.Documents.TextPointer> é compatível com a posição atual para essas operações.  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso para esse método.  O exemplo usa o <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> método para verificar se determinado <xref:System.Windows.Documents.TextPointer> posicionado entre dois outros especificado <xref:System.Windows.Documents.TextPointer> instâncias em uma situação em que não há nenhuma garantia de que todos os três posições pertençam ao mesmo contêiner de texto.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_isinsamedocument)]
 [!code-vb[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_isinsamedocument)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="textPosition" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LogicalDirection">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.LogicalDirection LogicalDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Documents.LogicalDirection LogicalDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogicalDirection As LogicalDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::LogicalDirection LogicalDirection { System::Windows::Documents::LogicalDirection get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalDirection : System.Windows.Documents.LogicalDirection" Usage="System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.LogicalDirection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.LogicalDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a direção lógica associada à posição atual usada para resolver a ambiguidade do conteúdo associado à posição atual.</summary>
        <value>O <see cref="T:System.Windows.Documents.LogicalDirection" /> valor associado com a posição atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Como um exemplo de como essa propriedade é usada, o <xref:System.Windows.Documents.LogicalDirection> do <xref:System.Windows.Documents.TextPointer> retornado por um teste de clique método fornece uma ocorrência entre dois caracteres de texto. A direção lógica Especifica qual dos dois caracteres, na verdade, foi atingido — à esquerda ou à direita.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paragraph">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.Paragraph Paragraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.Paragraph Paragraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Paragraph" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Paragraph As Paragraph" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::Paragraph ^ Paragraph { System::Windows::Documents::Paragraph ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Paragraph : System.Windows.Documents.Paragraph" Usage="System.Windows.Documents.TextPointer.Paragraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.Paragraph</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o parágrafo que tem como escopo a posição atual, se houver.</summary>
        <value>O <see cref="T:System.Windows.Documents.Paragraph" /> que tem como escopo a posição atual, ou <see langword="null" /> se tal parágrafo não existe.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.Documents.TextPointer.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o pai lógico que tem como escopo a posição atual.</summary>
        <value>O pai lógico que tem como escopo a posição atual.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Paragraph" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="textPointer.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Este tipo ou membro dá suporte à infraestrutura [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] e não se destina a ser usado diretamente do código.</summary>
        <returns>A cadeia de caracteres que representa o objeto.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>