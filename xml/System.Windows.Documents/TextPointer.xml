<Type Name="TextPointer" FullName="System.Windows.Documents.TextPointer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="80ffc4468fcd8385587be234b88e4272ca043528" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37577923" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TextPointer : System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextPointer extends System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.TextPointer" />
  <TypeSignature Language="VB.NET" Value="Public Class TextPointer&#xA;Inherits ContentPosition" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextPointer : System::Windows::Documents::ContentPosition" />
  <TypeSignature Language="F#" Value="type TextPointer = class&#xA;    inherit ContentPosition" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Documents.ContentPosition</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents a position within a <see cref="T:System.Windows.Documents.FlowDocument" /> or <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Documents.TextPointer> classe apresenta a seguinte terminologia:  
  
-   Posicione - inerentemente, um <xref:System.Windows.Documents.TextPointer> sempre aponta para um *posição* no conteúdo.  Essas posições de qualquer um se enquadram entre caracteres de conteúdo, ou entre o fluxo de conteúdo de elemento de marcas que definem a estrutura do conteúdo.  
  
-   Posição atual - porque um <xref:System.Windows.Documents.TextPointer> sempre indica uma posição e porque muitas das operações que podem ser executadas por meio de um <xref:System.Windows.Documents.TextPointer> são relativas a posição no momento apontada pelo <xref:System.Windows.Documents.TextPointer>, faz sentido simplesmente se referem à posição indicada por uma <xref:System.Windows.Documents.TextPointer> como o *posição atual*.  
  
-   Posição de inserção - um *posição de inserção* é uma posição em que o novo conteúdo pode ser adicionado sem interromper todas as regras semânticas para o conteúdo associado.  Na prática, um ponto de inserção é em qualquer lugar no conteúdo em que um cursor do sistema pode ser posicionado.  Um exemplo de válida <xref:System.Windows.Documents.TextPointer> posição que não é um ponto de inserção é a posição entre dois adjacentes <xref:System.Windows.Documents.Paragraph> marcas (ou seja, entre a marca de fechamento do parágrafo anterior e a marca de abertura do próximo parágrafo).  
  
-   Símbolo - para as finalidades <xref:System.Windows.Documents.TextPointer> operações que envolvem símbolos, qualquer um dos seguintes é considerado uma *símbolo*:  
  
    -   Uma marca de abertura ou para um <xref:System.Windows.Documents.TextElement> elemento.  
  
    -   Um <xref:System.Windows.UIElement> elemento contido em um <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Observe que essas uma <xref:System.Windows.UIElement> sempre são contados como exatamente um símbolo; qualquer conteúdo adicional ou elementos contidos pelo <xref:System.Windows.UIElement> não são contadas como símbolos.  
  
    -   Cada 16-bit [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caractere dentro de um texto <xref:System.Windows.Documents.Run> elemento.  
  
-   Contêiner de texto – *contêiner de texto* é o elemento de que forma a borda final para o conteúdo de fluxo em questão, a posição indicada por um <xref:System.Windows.Documents.TextPointer> sempre está dentro de um contêiner de texto.  Atualmente, um contêiner de texto deve ser um <xref:System.Windows.Documents.FlowDocument> ou um <xref:System.Windows.Controls.TextBlock>.  Em termos gerais, as operações entre <xref:System.Windows.Documents.TextPointer> não há suporte para instâncias em contêineres de texto diferente.  
  
-   Documento – o conteúdo em um contêiner de texto é conhecido como um *documento*, como na <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> método e o <xref:System.Windows.Documents.TextPointer.DocumentStart%2A> e <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A> propriedades.  
  
 O <xref:System.Windows.Documents.TextPointer> classe destina-se para facilitar a passagem e a manipulação de conteúdo que é representado por [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] elementos de conteúdo de fluxo; em geral, esses elementos derivam <xref:System.Windows.Documents.TextElement>.  Algumas das operações que <xref:System.Windows.Documents.TextPointer> facilita incluem o seguinte:  
  
-   Execute uma comparação ordinal da posição atual com uma segunda posição especificada.  Consulte o <xref:System.Windows.Documents.TextPointer.CompareTo%2A> método.  
  
-   Determine o tipo de conteúdo adjacente à posição atual em uma direção especificada.  Consulte a <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> método e <xref:System.Windows.Documents.TextPointerContext> enumeração.  
  
-   Obter o <xref:System.Windows.Documents.TextElement> que tem como escopo ou adjacente à posição atual.  Ver <xref:System.Windows.Documents.Paragraph> e o <xref:System.Windows.Documents.TextPointer.GetAdjacentElement%2A> método.  
  
-   Obter o contêiner de texto que tem como escopo o documento atual.  Consulte a propriedade <xref:System.Windows.Documents.TextPointer.Parent%2A>.  
  
-   Obter um número especificado de caracteres precede ou segue a posição atual.  Consulte o <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> método.  
  
-   Insira uma cadeia de caracteres da posição atual.  Consulte o <xref:System.Windows.Documents.TextPointer.InsertTextInRun%2A> método.  
  
-   Encontre os limites de linha no conteúdo.  Consulte a <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> método e <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> propriedade.  
  
-   Converter entre <xref:System.Windows.Documents.TextPointer> deslocamentos de posições e o símbolo em conteúdo.  Consulte a <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> e <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> métodos.  
  
-   Executar o teste de clique visual ao converter entre um <xref:System.Windows.Documents.TextPointer> posição e um <xref:System.Windows.Point> que representa as coordenadas relativas.  
  
-   Localize uma posição de inserção mais próximos ou verifique se a posição atual é um ponto de inserção.  Consulte a <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> e <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> métodos e as <xref:System.Windows.Documents.TextPointer.IsAtInsertionPosition%2A> propriedade.  
  
 A posição e <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> indicado por um <xref:System.Windows.Documents.TextPointer> objeto são imutáveis.  Quando o conteúdo é editado ou alterado, a posição indicada por um <xref:System.Windows.Documents.TextPointer> não é alterado em relação ao texto ao redor; em vez disso, o deslocamento da posição desde o início do conteúdo é ajustado de forma correspondente para refletir a nova posição relativa na conteúdo.  Por exemplo, um <xref:System.Windows.Documents.TextPointer> que indica uma posição no início de um determinado parágrafo continua a apontar para o início do parágrafo, mesmo quando o conteúdo é inserido ou excluído antes ou depois do parágrafo.  
  
 O <xref:System.Windows.Documents.TextPointer> classe fornece construtores públicos.  Uma instância do <xref:System.Windows.Documents.TextPointer> é criado usando as propriedades ou métodos de outros objetos (incluindo outros <xref:System.Windows.Documents.TextPointer> objetos). A lista a seguir fornece alguns exemplos de métodos e propriedades que criar e retornam um <xref:System.Windows.Documents.TextPointer>.  Esta lista não é completa:  
  
-   De um <xref:System.Windows.Documents.TextRange>: <xref:System.Windows.Documents.TextRange.Start%2A> e <xref:System.Windows.Documents.TextRange.End%2A>.  
  
-   De um <xref:System.Windows.Documents.TextElement>: <xref:System.Windows.Documents.TextElement.ContentStart%2A>, <xref:System.Windows.Documents.TextElement.ContentEnd%2A>, <xref:System.Windows.Documents.TextElement.ElementStart%2A>, e <xref:System.Windows.Documents.TextElement.ElementEnd%2A>.  
  
-   De um <xref:System.Windows.Controls.TextBlock> (contêiner de texto): <xref:System.Windows.Controls.TextBlock.ContentStart%2A>, <xref:System.Windows.Controls.TextBlock.ContentEnd%2A>, e <xref:System.Windows.Controls.TextBlock.GetPositionFromPoint%2A>.  
  
-   De um <xref:System.Windows.Documents.FlowDocument> (contêiner de texto): <xref:System.Windows.Documents.FlowDocument.ContentStart%2A>, e <xref:System.Windows.Documents.FlowDocument.ContentEnd%2A>  
  
-   De uma já existente <xref:System.Windows.Documents.TextPointer>: <xref:System.Windows.Documents.TextPointer.DocumentStart%2A>, <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A>, <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A>, e <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar um <xref:System.Windows.Documents.TextPointer> para localizar uma posição dentro do primeiro <xref:System.Windows.Documents.Run> elemento em um contêiner de texto especificado.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer1)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer1)]  
  
 O exemplo a seguir implementa um algoritmo find simplista usando <xref:System.Windows.Documents.TextPointer> instalações.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.TextRange" />
    <altmember cref="T:System.Windows.Documents.TextPointerContext" />
    <altmember cref="T:System.Windows.Documents.TextElement" />
  </Docs>
  <Members>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : System.Windows.Documents.TextPointer -&gt; int" Usage="textPointer.CompareTo position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">A <see cref="T:System.Windows.Documents.TextPointer" /> that specifies a position to compare to the current position.</param>
        <summary>Performs an ordinal comparison between the positions specified by the current <see cref="T:System.Windows.Documents.TextPointer" /> and a second specified <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>–1 if the current <see cref="T:System.Windows.Documents.TextPointer" /> precedes <paramref name="position" />; 0 if the locations are the same; +1 if the current <see cref="T:System.Windows.Documents.TextPointer" /> follows <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um valor de -1 indica que a posição especificada pelo atual <xref:System.Windows.Documents.TextPointer> precede a posição especificada pela `position`.  Um valor de 0 indica que o indicado posições são iguais.  Um valor de + 1 positivo indica que a posição especificada pelo atual <xref:System.Windows.Documents.TextPointer> segue a posição especificada pela `position`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso para esse método.  No exemplo, o <xref:System.Windows.Documents.TextPointer.CompareTo%2A> método é usado em conjunto com o <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> método para testar se um especificado <xref:System.Windows.Documents.TextElement> está vazio.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="position" /> specifies a position outside of the text container associated with the current position.</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteTextInRun">
      <MemberSignature Language="C#" Value="public int DeleteTextInRun (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 DeleteTextInRun(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeleteTextInRun (count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int DeleteTextInRun(int count);" />
      <MemberSignature Language="F#" Value="member this.DeleteTextInRun : int -&gt; int" Usage="textPointer.DeleteTextInRun count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">The number of characters to delete, starting at the current position. Specify a positive value to delete characters that follow the current position; specify a negative value to delete characters that precede the current position.</param>
        <summary>Deletes the specified number of characters from the position indicated by the current <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>The number of characters actually deleted.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Especifique um valor positivo para excluir caracteres que seguem a posição atual (como em <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>); Especifique um valor negativo para excluir caracteres que precedem a posição atual (como em <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 O número de caracteres realmente excluído pode ser menor que o número especificado por `count`.  Isso ocorre em casos onde `count` especifica mais caracteres do que existem para ser excluído.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The method is called at a position where text is not allowed.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetTextInRun" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DocumentEnd">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentEnd As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentEnd { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentEnd : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Windows.Documents.TextPointer" /> at the end of content in the text container associated with the current position.</summary>
        <value>Um <see cref="T:System.Windows.Documents.TextPointer" /> no final do conteúdo no contêiner de texto associado à posição atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Documents.TextPointer.Parent%2A> para retornado <xref:System.Windows.Documents.TextPointer> sempre é um contêiner de texto (<xref:System.Windows.Controls.TextBlock> ou <xref:System.Windows.Documents.FlowDocument>), em vez de um <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="DocumentStart">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentStart As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentStart { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentStart : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Windows.Documents.TextPointer" /> at the beginning of content in the text container associated with the current position.</summary>
        <value>Um <see cref="T:System.Windows.Documents.TextPointer" /> no início do conteúdo no contêiner de texto associado à posição atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use a posição retornada por essa propriedade como uma posição de linha de base da qual trabalhar com deslocamentos relativos para outras posições.  O <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> e <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> métodos fornecem uma maneira de converter entre posições e posição deslocamentos.  
  
 O <xref:System.Windows.Documents.TextPointer.Parent%2A> para retornado <xref:System.Windows.Documents.TextPointer> sempre é um contêiner de texto (<xref:System.Windows.Controls.TextBlock> ou <xref:System.Windows.Documents.FlowDocument>), em vez de um <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="GetAdjacentElement">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject GetAdjacentElement (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject GetAdjacentElement(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAdjacentElement (direction As LogicalDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyObject ^ GetAdjacentElement(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetAdjacentElement : System.Windows.Documents.LogicalDirection -&gt; System.Windows.DependencyObject" Usage="textPointer.GetAdjacentElement direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction in which to search for an adjacent element.</param>
        <summary>Returns the element, if any, that borders the current <see cref="T:System.Windows.Documents.TextPointer" /> in the specified logical direction.</summary>
        <returns>The adjacent element in the specified <paramref name="direction" />, or <see langword="null" /> if no adjacent element exists.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O elemento retornado é geralmente um <xref:System.Windows.Documents.TextElement>.  Um <xref:System.Windows.UIElement> pode ser retornado quando o <xref:System.Windows.Documents.TextPointer> indica uma posição dentro de uma <xref:System.Windows.Documents.BlockUIContainer> elemento ou um <xref:System.Windows.Documents.InlineUIContainer> elemento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetCharacterRect">
      <MemberSignature Language="C#" Value="public System.Windows.Rect GetCharacterRect (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect GetCharacterRect(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCharacterRect (direction As LogicalDirection) As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Rect GetCharacterRect(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetCharacterRect : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Rect" Usage="textPointer.GetCharacterRect direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction in which to find a content bounding box.</param>
        <summary>Returns a bounding box (<see cref="T:System.Windows.Rect" />) for content that borders the current <see cref="T:System.Windows.Documents.TextPointer" /> in the specified logical direction.</summary>
        <returns>A bounding box for content that borders the current <see cref="T:System.Windows.Documents.TextPointer" /> in the specified direction, or <see cref="P:System.Windows.Rect.Empty" /> if current, valid layout information is unavailable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextElement> as bordas não são consideradas conteúdo para os fins deste método.  Se o <xref:System.Windows.Documents.TextPointer> é posicionado antes de uma <xref:System.Windows.Documents.TextElement> edge, o valor de retorno é uma caixa delimitadora para o próximo não -<xref:System.Windows.Documents.TextElement> conteúdo na direção especificada.  Se não houver nenhum conteúdo na direção especificada, uma largura de zero <xref:System.Windows.Rect> é retornado com uma altura correspondente a altura das qualquer anteriores conteúda.  
  
 A operação executada por esse método depende de um layout válido.  Quando necessário, esse método tenta gerar automaticamente um layout válido antes de continuar com a operação.  Regenerar um layout pode ser uma operação relativamente cara.  Use o <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> propriedade para verificar se há um layout válido antes de executar operações que podem regenerar o layout.  Veja [Layout](~/docs/framework/wpf/advanced/layout.md) para obter mais informações.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      </Docs>
    </Member>
    <Member MemberName="GetInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetInsertionPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetInsertionPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction in which to search for the closest insertion position.</param>
        <summary>Returns a <see cref="T:System.Windows.Documents.TextPointer" /> to the closest insertion position in the specified logical direction.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> to the closest insertion position in the specified direction.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um ponto de inserção é uma posição em que o novo conteúdo pode ser adicionado sem interromper todas as regras semânticas para o conteúdo associado.  Na prática, um ponto de inserção é em qualquer lugar no conteúdo em que um cursor do sistema pode ser posicionado.  Um exemplo de válida <xref:System.Windows.Documents.TextPointer> posição que não é um ponto de inserção é a posição entre dois adjacentes <xref:System.Windows.Documents.Paragraph> marcas (ou seja, entre a marca de fechamento do parágrafo anterior e a marca de abertura do próximo parágrafo).  
  
 Se o <xref:System.Windows.Documents.TextPointer> já aponta para uma posição de inserção válido, mas a marca de fechamento para uma sequência de formatação vazio segue diretamente nessa posição na direção de determinado, em seguida, a <xref:System.Windows.Documents.TextPointer> retornado por este método é ajustado para apontar para a inserção posição logo após o fechamento da sequência de formatação. Por exemplo, considere a sequência de marcação `<Bold>a</Bold>b`. Observe que há duas posições de inserção entre as letras `a` e `b` — um que precede o `Bold` marca e um diretamente após o fechamento `Bold` marca. Se <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> é chamado em um <xref:System.Windows.Documents.TextPointer> para a posição logo após a letra `a` e antes do fechamento `Bold` marca e com um `direction` de <xref:System.Windows.Documents.LogicalDirection.Forward>, retornado <xref:System.Windows.Documents.TextPointer> é ajustado para apontar para o posição imediatamente antes da letra `b`, após o fechamento `Bold` marca. Um ajuste semelhante é feito para abrir as marcas de formatação ao trabalhar na direção lógica oposta. Este método destina-se a fornecer um meio de desambiguidade entre as posições de inserção em casos semelhantes.  
  
 Esse método também pode ser usado para ser seletivo sobre pontos de inserção quando uma sequência de marcas estruturais está envolvida. Por exemplo, quando estiver em uma posição entre as marcas de parágrafo de abertura e fechamento, a direção de parâmetro pode ser usada para selecionar o ponto de inserção mais próximo no início do parágrafo seguinte (especificando <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>) ou no final no (parágrafo anterior especificando <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 Se o ponteiro já está na posição de inserção, e não há nenhuma marca de formatação adjacente especificado na `direction`, retornado <xref:System.Windows.Documents.TextPointer> aponta para a mesma posição que chamada <xref:System.Windows.Documents.TextPointer>.  
  
 É possível que nenhuma posição de inserção válido existe em relação à posição apontada to por um <xref:System.Windows.Documents.TextPointer>.  Isso pode acontecer se o conteúdo referenciado está estruturalmente incompleto, como em uma tabela vazia ou uma lista.  Nesses casos, esse método simplesmente retorna uma <xref:System.Windows.Documents.TextPointer> para a mesma posição que o <xref:System.Windows.Documents.TextPointer> do qual esse método foi chamado.  Esse método sempre retorna válido <xref:System.Windows.Documents.TextPointer>.  
  
   
  
## Examples  
 Este exemplo mostra como usar o <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> método para verificar se determinado <xref:System.Windows.Documents.TextElement> está vazia de conteúdo imprimível.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLineStartPosition">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a <see cref="T:System.Windows.Documents.TextPointer" /> to the beginning of a line that is specified relative to the current <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count);" />
      <MemberSignature Language="F#" Value="member this.GetLineStartPosition : int -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetLineStartPosition count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">The number of start-of-line markers to skip when determining the line for which to return the starting position. Negative values specify preceding lines, 0 specifies the current line, and positive values specify following lines.</param>
        <summary>Returns a <see cref="T:System.Windows.Documents.TextPointer" /> to the beginning of a line that is specified relative to the current <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> pointing to the beginning of the specified line (with the <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> set to <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />), or <see langword="null" /> if the specified line is out of range or otherwise cannot be located.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.Windows.Documents.TextPointer> aponta para uma posição ambígua, por exemplo, entre duas linhas, a linha na direção especificada por <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> é selecionado como a linha de início relativa.  
  
 A operação executada por esse método depende de um layout válido.  Quando necessário, esse método tenta gerar automaticamente um layout válido antes de continuar com a operação.  Regenerar um layout pode ser uma operação relativamente cara.  Use <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> para verificar se há um layout válido antes de executar operações que podem regenerar o layout.  Veja [Layout](~/docs/framework/wpf/advanced/layout.md) para obter mais informações.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count, out int actualCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count, [out] int32&amp; actualCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer, ByRef actualCount As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count, [Runtime::InteropServices::Out] int % actualCount);" />
      <MemberSignature Language="F#" Value="member this.GetLineStartPosition : int *  -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetLineStartPosition (count, actualCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="actualCount" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="count">The number of start-of-line markers to skip when determining the line for which to return the starting position. Negative values specify preceding lines, 0 specifies the current line, and positive values specify following lines.</param>
        <param name="actualCount">When this method returns, contains the actual number of start-of-line markers that were skipped when determining the line for which to return the starting position.  This value may be less than <c>count</c> if the beginning or end of content is encountered before the specified number of lines are skipped. This parameter is passed uninitialized.</param>
        <summary>Returns a <see cref="T:System.Windows.Documents.TextPointer" /> to the beginning of a line that is specified relative to the current <see cref="T:System.Windows.Documents.TextPointer" />, and reports how many lines were skipped.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> pointing to the beginning of the specified line (with the <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> set to <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />), or to the beginning of the line closest to the specified line if the specified line is out of range.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.Windows.Documents.TextPointer> aponta para uma posição ambígua, por exemplo, entre duas linhas, a linha na direção especificada pelo <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> propriedade é selecionada como a linha de início relativa.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextContextPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextContextPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextContextPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextContextPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextContextPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextContextPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetNextContextPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction in which to search for the next symbol.</param>
        <summary>Returns a pointer to the next symbol in the specified logical direction.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> to the next symbol in the requested direction, or <see langword="null" /> if the current <see cref="T:System.Windows.Documents.TextPointer" /> borders the start or end of content.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer um dos seguintes é considerado um símbolo:  
  
-   Uma marca de abertura ou para um <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Um <xref:System.Windows.UIElement> elemento contido em um <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Observe que essas uma <xref:System.Windows.UIElement> sempre são contados como exatamente um símbolo; qualquer conteúdo adicional ou elementos contidos pelo <xref:System.Windows.UIElement> não são contadas como símbolos.  
  
-   De 16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caractere dentro de um texto <xref:System.Windows.Documents.Run> elemento.  
  
 Se o próximo símbolo é categorizado como <xref:System.Windows.Documents.TextPointerContext.EmbeddedElement>, <xref:System.Windows.Documents.TextPointerContext.ElementStart>, ou <xref:System.Windows.Documents.TextPointerContext.ElementEnd> (conforme identificado pela <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> método), em seguida, a <xref:System.Windows.Documents.TextPointer> retornado por este método é adiantado por exatamente um símbolo da posição atual.  
  
 Se o próximo símbolo é categorizado como <xref:System.Windows.Documents.TextPointerContext.Text>, em seguida, a <xref:System.Windows.Documents.TextPointer> retornado por este método é ultrapassaram o texto para o próximo símbolo que não sejam de texto (ou seja, a próxima posição em que o <xref:System.Windows.Documents.TextPointerContext> não é <xref:System.Windows.Documents.TextPointerContext.Text>).  A contagem exata de símbolo cruzada pode ser calculada com antecedência, chamando o <xref:System.Windows.Documents.TextPointer.GetTextRunLength%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso para esse método.  O exemplo usa o <xref:System.Windows.Documents.TextPointer.GetNextContextPosition%2A> método em conjunto com o <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> método percorrer e extrair os símbolos em um especificado <xref:System.Windows.Documents.TextElement>.  
  
 Embora o exemplo pode ser usado para extrair uma [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] estrutura para o conteúdo de um determinado <xref:System.Windows.Documents.TextElement>, ele é destinado apenas para fins ilustrativos e não deve ser usado no código de produção.  Consulte o <xref:System.Xml> namespace para um rico conjunto de tipos projetados para trabalhar com e processamento de XML.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextcontextposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextcontextposition)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextInsertionPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetNextInsertionPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction in which to search for the next insertion position.</param>
        <summary>Returns a <see cref="T:System.Windows.Documents.TextPointer" /> to the next insertion position in the specified logical direction.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> that identifies the next insertion position in the requested direction, or <see langword="null" /> if no next insertion position can be found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma *posição de inserção* é uma posição em que o novo conteúdo pode ser adicionado sem interromper todas as regras semânticas para o conteúdo associado.  Na prática, um ponto de inserção é em qualquer lugar no conteúdo em que um cursor do sistema pode ser posicionado.  Um exemplo de válida <xref:System.Windows.Documents.TextPointer> posição que não é um ponto de inserção é a posição entre dois adjacentes <xref:System.Windows.Documents.Paragraph> marcas (ou seja, entre a marca de fechamento do parágrafo anterior e a marca de abertura do próximo parágrafo).  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso para esse método. O exemplo usa o <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> método para percorrer os limites do elemento de conteúdo para contar o número de <xref:System.Windows.Documents.Paragraph> elementos apresentam entre dois especificado <xref:System.Windows.Documents.TextPointer> instâncias.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="GetOffsetToPosition">
      <MemberSignature Language="C#" Value="public int GetOffsetToPosition (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetOffsetToPosition(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOffsetToPosition (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetOffsetToPosition(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.GetOffsetToPosition : System.Windows.Documents.TextPointer -&gt; int" Usage="textPointer.GetOffsetToPosition position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">A <see cref="T:System.Windows.Documents.TextPointer" /> that specifies a position to find the distance (in symbols) to.</param>
        <summary>Returns the count of symbols between the current <see cref="T:System.Windows.Documents.TextPointer" /> and a second specified <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>The relative number of symbols between the current <see cref="T:System.Windows.Documents.TextPointer" /> and <paramref name="position" />.  A negative value indicates that the current <see cref="T:System.Windows.Documents.TextPointer" /> follows the position specified by <paramref name="position" />, 0 indicates that the positions are equal, and a positive value indicates that the current <see cref="T:System.Windows.Documents.TextPointer" /> precedes the position specified by <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer um dos seguintes é considerado um símbolo:  
  
-   Uma marca de abertura ou para um <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Um <xref:System.Windows.UIElement> elemento contido em um <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Observe que essas uma <xref:System.Windows.UIElement> sempre são contados como exatamente um símbolo; qualquer conteúdo adicional ou elementos contidos pelo <xref:System.Windows.UIElement> não são contadas como símbolos.  
  
-   De 16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caractere dentro de um texto <xref:System.Windows.Documents.Run> elemento.  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso para esse método. O exemplo usa o <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> método para encontrar os deslocamentos de dois <xref:System.Windows.Documents.TextPointer> instâncias e, em seguida, usa essas informações para salvar e restaurar a seleção em um <xref:System.Windows.Controls.RichTextBox>.  O exemplo supõe que o conteúdo do <xref:System.Windows.Controls.RichTextBox> não foram alterados entre uma seleção de salvamento e restauração de uma seleção.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="position" /> specifies a position outside of the text container associated with the current position.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetPositionAtOffset" />
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPointerContext">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointerContext GetPointerContext (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Documents.TextPointerContext GetPointerContext(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPointerContext (direction As LogicalDirection) As TextPointerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointerContext GetPointerContext(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetPointerContext : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointerContext" Usage="textPointer.GetPointerContext direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction in which to determine the category for adjacent content.</param>
        <summary>Returns a category indicator for the content adjacent to the current <see cref="T:System.Windows.Documents.TextPointer" /> in the specified logical direction.</summary>
        <returns>One of the <see cref="T:System.Windows.Documents.TextPointerContext" /> values that indicates the category for adjacent content in the specified logical direction.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra um uso para esse método. O exemplo usa o <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> método para implementar um algoritmo para calcular o saldo de abertura e fechamento de marcas de elemento entre dois especificado <xref:System.Windows.Documents.TextPointer> posições.  Cada marca de elemento de abertura é contada como + 1 e cada elemento de marca de fechamento é contabilizada como -1.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPositionAtOffset">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a <see cref="T:System.Windows.Documents.TextPointer" /> to the position indicated by the specified offset, in symbols, from the beginning of content.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset);" />
      <MemberSignature Language="F#" Value="member this.GetPositionAtOffset : int -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetPositionAtOffset offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="offset">An offset, in symbols, for which to calculate and return the position.  If the offset is negative, the position is calculated in the logical direction opposite of that indicated by the <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> property.</param>
        <summary>Returns a <see cref="T:System.Windows.Documents.TextPointer" /> to the position indicated by the specified offset, in symbols, from the beginning of the current <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> to the position indicated by the specified offset, or <see langword="null" /> if no corresponding position can be found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer um dos seguintes é considerado um símbolo:  
  
-   Uma marca de abertura ou para o <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Um <xref:System.Windows.UIElement> elemento contido em um <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Observe que essas uma <xref:System.Windows.UIElement> sempre são contados como exatamente um símbolo; qualquer conteúdo adicional ou elementos contidos pelo <xref:System.Windows.UIElement> não são contadas como símbolos.  
  
-   De 16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caractere dentro de um texto <xref:System.Windows.Documents.Run> elemento.  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso para esse método. O exemplo usa o <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> método para implementar um par de métodos, um para calcular o deslocamento para uma posição especificada em relação a qualquer parágrafo de hospedagem e o outro para retornar um <xref:System.Windows.Documents.TextPointer> para um deslocamento especificado de um determinado parágrafo.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getpositionatoffset)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getpositionatoffset)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset, System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset, valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer, direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset, System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetPositionAtOffset : int * System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetPositionAtOffset (offset, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="offset">An offset, in symbols, for which to calculate and return the position.  If the offset is negative, the returned <see cref="T:System.Windows.Documents.TextPointer" /> precedes the current <see cref="T:System.Windows.Documents.TextPointer" />; otherwise, it follows.</param>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction of the returned <see cref="T:System.Windows.Documents.TextPointer" />.</param>
        <summary>Returns a <see cref="T:System.Windows.Documents.TextPointer" /> to the position indicated by the specified offset, in symbols, from the beginning of the current <see cref="T:System.Windows.Documents.TextPointer" /> and in the specified direction.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> to the position indicated by the specified offset, or <see langword="null" /> if the offset extends past the end of the content.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer um dos seguintes é considerado um símbolo:  
  
-   Uma marca de abertura ou para o <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Um <xref:System.Windows.UIElement> elemento contido em um <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Observe que essas uma <xref:System.Windows.UIElement> sempre são contados como exatamente um símbolo; qualquer conteúdo adicional ou elementos contidos pelo <xref:System.Windows.UIElement> não são contadas como símbolos.  
  
-   De 16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caractere dentro de um texto <xref:System.Windows.Documents.Run> elemento.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTextInRun">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns text adjacent to the current <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public string GetTextInRun (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTextInRun(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetTextInRun : System.Windows.Documents.LogicalDirection -&gt; string" Usage="textPointer.GetTextInRun direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction in which to find and return any adjacent text.</param>
        <summary>Returns a string containing any text adjacent to the current <see cref="T:System.Windows.Documents.TextPointer" /> in the specified logical direction.</summary>
        <returns>A string containing any adjacent text in the specified logical direction, or <see cref="F:System.String.Empty" /> if no adjacent text can be found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retornará somente ininterruptas execuções de texto.  Nada será retornado se nenhum tipo de símbolo diferente de <xref:System.Windows.Documents.TextPointerContext.Text> adjacente ao atual <xref:System.Windows.Documents.TextPointer> na direção especificada.  Da mesma forma, o texto será retornado apenas até o próximo símbolo que não sejam de texto.  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso para esse método. O exemplo usa o <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> método para implementar um extrator de texto simples.  O método retorna uma concatenação de cadeia de caracteres de todo o texto entre dois especificado <xref:System.Windows.Documents.TextPointer> instâncias.  
  
 Embora o exemplo pode ser usado para extrair qualquer texto entre dois <xref:System.Windows.Documents.TextPointer> instâncias, ele é destinado apenas para fins ilustrativos e não deve ser usado no código de produção.  Use a propriedade <xref:System.Windows.Documents.TextRange.Text%2A?displayProperty=nameWithType> em seu lugar.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_gettextinrun)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_gettextinrun)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public int GetTextInRun (System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection, textBuffer As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextInRun(System::Windows::Documents::LogicalDirection direction, cli::array &lt;char&gt; ^ textBuffer, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.GetTextInRun : System.Windows.Documents.LogicalDirection * char[] * int * int -&gt; int" Usage="textPointer.GetTextInRun (direction, textBuffer, startIndex, count)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
        <Parameter Name="textBuffer" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction in which to find and copy any adjacent text.</param>
        <param name="textBuffer">A buffer into which any text is copied.</param>
        <param name="startIndex">An index into <c>textBuffer</c> at which to begin writing copied text.</param>
        <param name="count">The maximum number of characters to copy.</param>
        <summary>Copies the specified maximum number of characters from any adjacent text in the specified direction into a caller-supplied character array.</summary>
        <returns>The number of characters actually copied into <paramref name="textBuffer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retornará somente ininterruptas execuções de texto.  Nada será retornado se nenhum tipo de símbolo diferente de <xref:System.Windows.Documents.TextPointerContext.Text> adjacente ao atual <xref:System.Windows.Documents.TextPointer> na direção especificada.  Da mesma forma, o texto será retornado apenas até o próximo símbolo que não sejam de texto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="startIndex" /> is less than 0 or greater than the <see cref="P:System.Array.Length" /> property of <paramref name="textBuffer" />.  -or-  <paramref name="count" /> is less than 0 or greater than the remaining space in <paramref name="textBuffer" /> (<paramref name="textBuffer" />.<see cref="P:System.Array.Length" /> minus <paramref name="startIndex" />).</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextRunLength">
      <MemberSignature Language="C#" Value="public int GetTextRunLength (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextRunLength(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextRunLength (direction As LogicalDirection) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextRunLength(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetTextRunLength : System.Windows.Documents.LogicalDirection -&gt; int" Usage="textPointer.GetTextRunLength direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction in which to count the number of characters.</param>
        <summary>Returns the number of Unicode characters between the current <see cref="T:System.Windows.Documents.TextPointer" /> and the next non-text symbol, in the specified logical direction.</summary>
        <returns>The number of Unicode characters between the current <see cref="T:System.Windows.Documents.TextPointer" /> and the next non-text symbol.  This number may be 0 if there is no adjacent text.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer um dos seguintes é considerado um símbolo:  
  
-   Uma marca de abertura ou para o <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Um <xref:System.Windows.UIElement> elemento contido em um <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Observe que essas uma <xref:System.Windows.UIElement> sempre são contados como exatamente um símbolo; qualquer conteúdo adicional ou elementos contidos pelo <xref:System.Windows.UIElement> não são contadas como símbolos.  
  
-   De 16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caractere dentro de um texto <xref:System.Windows.Documents.Run> elemento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasValidLayout">
      <MemberSignature Language="C#" Value="public bool HasValidLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValidLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValidLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValidLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValidLayout : bool" Usage="System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.HasValidLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the text container associated with the current position has a valid (up-to-date) layout.</summary>
        <value>
          <see langword="true" /> Se o layout é atuais e válidas. Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando necessário, as operações que dependem de um layout válido (como o <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> método, <xref:System.Windows.Documents.TextPointer.GetCharacterRect%2A> método, e <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> propriedade) tentar gerar automaticamente um layout válido antes de continuar com a operação.  Regenerar um layout pode ser uma operação relativamente cara.  Use essa propriedade para verificar se há um layout válido antes de executar operações que podem regenerar o layout.  Veja [Layout](~/docs/framework/wpf/advanced/layout.md) para obter mais informações.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertLineBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertLineBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertLineBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertLineBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertLineBreak();" />
      <MemberSignature Language="F#" Value="member this.InsertLineBreak : unit -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.InsertLineBreak " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inserts a line break at the current position.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> positioned immediately after the <see cref="T:System.Windows.Documents.LineBreak" /> element inserted by this method.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertParagraphBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertParagraphBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertParagraphBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertParagraphBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertParagraphBreak();" />
      <MemberSignature Language="F#" Value="member this.InsertParagraphBreak : unit -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.InsertParagraphBreak " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inserts a paragraph break at the current position.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> to the beginning (<see cref="P:System.Windows.Documents.TextElement.ContentStart" />) of the new paragraph.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se esse método é chamado quando a posição atual está dentro de uma existente <xref:System.Windows.Documents.Paragraph> elemento, o parágrafo existente e qualquer conteúdo que ele contém são divididas em dois parágrafos na posição atual.  Se esse método é chamado quando a posição atual não está dentro de um parágrafo existente, um novo parágrafo vazio é inserido.  Se esse método é chamado em uma posição inadequado para dividir ou inserindo um parágrafo (por exemplo, se a posição atual está dentro de um <xref:System.Windows.Documents.Hyperlink> elemento), uma exceção será lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This method is called on a position that cannot be split to accommodate a new paragraph, such as in the scope of a <see cref="T:System.Windows.Documents.Hyperlink" /> or <see cref="T:System.Windows.Documents.InlineUIContainer" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertTextInRun">
      <MemberSignature Language="C#" Value="public void InsertTextInRun (string textData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertTextInRun(string textData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertTextInRun (textData As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertTextInRun(System::String ^ textData);" />
      <MemberSignature Language="F#" Value="member this.InsertTextInRun : string -&gt; unit" Usage="textPointer.InsertTextInRun textData" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.InsertTextInRun(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textData" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textData">The text to insert.</param>
        <summary>Inserts the specified text into the text <see cref="T:System.Windows.Documents.Run" /> at the current position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.Windows.Documents.TextPointer> não está no escopo por um <xref:System.Windows.Documents.Run> elemento, um <xref:System.Windows.Documents.Run> é inserido juntamente com o `textData`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The current position is not within a <see cref="T:System.Windows.Documents.Run" /> element.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="textData" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAtInsertionPosition">
      <MemberSignature Language="C#" Value="public bool IsAtInsertionPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtInsertionPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtInsertionPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtInsertionPosition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAtInsertionPosition : bool" Usage="System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.IsAtInsertionPosition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the current position is an insertion position.</summary>
        <value>
          <see langword="true" /> Se a posição atual é um ponto de inserção; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um ponto de inserção é uma posição em que o novo conteúdo pode ser adicionado sem interromper todas as regras semânticas para o conteúdo associado.  Na prática, um ponto de inserção é em qualquer lugar no conteúdo em que um cursor do sistema pode ser posicionado.  Um exemplo de válida <xref:System.Windows.Documents.TextPointer> posição que não é um ponto de inserção é a posição entre dois adjacentes <xref:System.Windows.Documents.Paragraph> marcas (ou seja, entre a marca de fechamento do parágrafo anterior e a marca de abertura do próximo parágrafo).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="IsAtLineStartPosition">
      <MemberSignature Language="C#" Value="public bool IsAtLineStartPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtLineStartPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtLineStartPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtLineStartPosition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAtLineStartPosition : bool" Usage="System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the current position is at the beginning of a line.</summary>
        <value>
          <see langword="true" /> Se a posição atual está no início de uma linha; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.Windows.Documents.TextPointer> aponta para uma posição ambígua, por exemplo, entre duas linhas, a linha na direção especificada pelo <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> propriedade é selecionada como a linha de início relativa.  
  
 A operação executada por esta propriedade depende de um layout válido.  Quando necessário, esse método tenta gerar automaticamente um layout válido antes de continuar com a operação.  Regenerar um layout pode ser uma operação relativamente cara.  Use o <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> propriedade para verificar se há um layout válido antes de executar operações que podem regenerar o layout.  Veja [Layout](~/docs/framework/wpf/advanced/layout.md) para obter mais informações.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      </Docs>
    </Member>
    <Member MemberName="IsInSameDocument">
      <MemberSignature Language="C#" Value="public bool IsInSameDocument (System.Windows.Documents.TextPointer textPosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsInSameDocument(class System.Windows.Documents.TextPointer textPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsInSameDocument (textPosition As TextPointer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsInSameDocument(System::Windows::Documents::TextPointer ^ textPosition);" />
      <MemberSignature Language="F#" Value="member this.IsInSameDocument : System.Windows.Documents.TextPointer -&gt; bool" Usage="textPointer.IsInSameDocument textPosition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textPosition" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="textPosition">A <see cref="T:System.Windows.Documents.TextPointer" /> that specifies a position to compare to the current position.</param>
        <summary>Indicates whether the specified position is in the same text container as the current position.</summary>
        <returns>
          <see langword="true" /> if <paramref name="textPosition" /> indicates a position that is in the same text container as the current position; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A maioria das operações que envolvem vários <xref:System.Windows.Documents.TextPointer> instâncias são válidas somente se as instâncias em questão indicarem posições em que estão no mesmo escopo de contêiner de texto.  Por exemplo o <xref:System.Windows.Documents.TextPointer.CompareTo%2A> e <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> métodos não podem ser usados com um <xref:System.Windows.Documents.TextPointer> para uma posição fora do contêiner de texto associado à posição atual.  Use esse método para verificar se determinado <xref:System.Windows.Documents.TextPointer> é compatível com a posição atual para essas operações.  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso para esse método.  O exemplo usa o <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> método para verificar se determinado <xref:System.Windows.Documents.TextPointer> posicionado entre dois outros especificado <xref:System.Windows.Documents.TextPointer> instâncias em uma situação em que não há nenhuma garantia de que todos os três posições pertençam ao mesmo contêiner de texto.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_isinsamedocument)]
 [!code-vb[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_isinsamedocument)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="textPosition" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LogicalDirection">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.LogicalDirection LogicalDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Documents.LogicalDirection LogicalDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogicalDirection As LogicalDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::LogicalDirection LogicalDirection { System::Windows::Documents::LogicalDirection get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalDirection : System.Windows.Documents.LogicalDirection" Usage="System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.LogicalDirection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.LogicalDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the logical direction associated with the current position which is used to disambiguate content associated with the current position.</summary>
        <value>O <see cref="T:System.Windows.Documents.LogicalDirection" /> valor associado com a posição atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Como um exemplo de como essa propriedade é usada, o <xref:System.Windows.Documents.LogicalDirection> do <xref:System.Windows.Documents.TextPointer> retornado por um teste de clique método fornece uma ocorrência entre dois caracteres de texto. A direção lógica Especifica qual dos dois caracteres, na verdade, foi atingido — à esquerda ou à direita.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paragraph">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.Paragraph Paragraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.Paragraph Paragraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Paragraph" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Paragraph As Paragraph" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::Paragraph ^ Paragraph { System::Windows::Documents::Paragraph ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Paragraph : System.Windows.Documents.Paragraph" Usage="System.Windows.Documents.TextPointer.Paragraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.Paragraph</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the paragraph that scopes the current position, if any.</summary>
        <value>O <see cref="T:System.Windows.Documents.Paragraph" /> que tem como escopo a posição atual, ou <see langword="null" /> se tal parágrafo não existe.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.Documents.TextPointer.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the logical parent that scopes the current position.</summary>
        <value>O pai lógico que tem como escopo a posição atual.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Paragraph" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="textPointer.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>This type or member supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended to be used directly from your code.</summary>
        <returns>The string that represents the object.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>