<Type Name="ClaimsPrincipalPermission" FullName="System.IdentityModel.Services.ClaimsPrincipalPermission">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="97a920f61b9b131d328d66e3be820d13c431fae9" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36558489" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ClaimsPrincipalPermission : System.Security.IPermission, System.Security.ISecurityEncodable, System.Security.Permissions.IUnrestrictedPermission" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit ClaimsPrincipalPermission extends System.Object implements class System.Security.IPermission, class System.Security.ISecurityEncodable, class System.Security.Permissions.IUnrestrictedPermission" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ClaimsPrincipalPermission&#xA;Implements IPermission, ISecurityEncodable, IUnrestrictedPermission" />
  <TypeSignature Language="C++ CLI" Value="public ref class ClaimsPrincipalPermission sealed : System::Security::IPermission, System::Security::ISecurityEncodable, System::Security::Permissions::IUnrestrictedPermission" />
  <TypeSignature Language="F#" Value="type ClaimsPrincipalPermission = class&#xA;    interface IPermission&#xA;    interface ISecurityEncodable&#xA;    interface IUnrestrictedPermission" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel.Services</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Security.IPermission</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.ISecurityEncodable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.Permissions.IUnrestrictedPermission</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Represents a permission that uses a <see cref="T:System.Security.Claims.ClaimsAuthorizationManager" /> implementation to determine if access to a resource should be granted to the active principal. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> classe fornece a capacidade de executar verificações de acesso obrigatório usando o <xref:System.Security.Claims.ClaimsAuthorizationManager> que está configurado para um aplicativo. Invocando o <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> estático ou método <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.CheckAccess%2A> método, você pode fornecer proteção aos recursos de dentro do caminho de execução do seu código de acordo com a política de autorização definida para o Gerenciador de autenticação de declarações. Verificações de acesso declarativo podem ser executadas usando o <xref:System.IdentityModel.Services.ClaimsPrincipalPermissionAttribute> classe.  
  
> [!IMPORTANT]
>  O <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> classe usa o Gerenciador de autorização de declarações configurado pelo <xref:System.IdentityModel.Configuration.IdentityConfiguration> que é definido no <xref:System.IdentityModel.Services.FederatedAuthentication.FederationConfiguration%2A?displayProperty=nameWithType> propriedade. Isso é verdadeiro em todos os casos, mesmo em cenários em que o WS-Federation não é usado; Por exemplo, aplicativos da Web (WCF) ativos e aplicativos de Console. Você pode especificar o Gerenciador de autorização de declarações na configuração ou programaticamente. Para especificar o Gerenciador de autorização de declarações em um arquivo de configuração, defina o [ &lt;claimsAuthorizationManager&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/claimsauthorizationmanager.md) elemento em um [ &lt;identityConfiguration&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/identityconfiguration.md) elemento e certifique-se de que essa configuração de identidade é referenciada pelo [ &lt;federationConfiguration&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/federationconfiguration.md) elemento que é carregado pelo tempo de execução (por exemplo, por Definindo o `identityConfigurationName` atributo). Para definir o Gerenciador de autorização de declarações por meio de programação, fornecer um manipulador para o <xref:System.IdentityModel.Services.FederatedAuthentication.FederationConfigurationCreated?displayProperty=nameWithType> evento.  
  
 Em um nível, a funcionalidade fornecida pelo <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> é semelhante para as verificações de acesso baseado em função (RBAC) fornecidas por meio a <xref:System.Security.Permissions.PrincipalPermission> classe; no entanto, a <xref:System.Security.Claims.ClaimsAuthorizationManager> classe executa a verificação com base em declarações apresentadas pela entidade de ativos. Isso permite que mais granularidade que está disponível por meio de RBAC puro, onde várias permissões normalmente são coletadas em uma única função. Talvez, mais importante, a autorização baseada em declarações permite a separação melhor da política de autorização e lógica de negócios porque permissão pode ser solicitada para uma ação específica em um recurso no código e política de back-end pode ser usada para configurar quais declarações o Apresentando a entidade deve ter para atender à demanda. Como o RBAC, <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> executa uma verificação de acesso com base em usuário, ou seja, ao contrário de segurança de acesso ao código implementada pelas classes que derivam de <xref:System.Security.CodeAccessPermission> classe e use um exame da pilha para garantir que todos os chamadores do código receberam uma permissão, <xref:System.IdentityModel.Services.ClaimsPrincipalPermission>executa sua verificação somente no objeto atual.  
  
 Estático <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.CheckAccess%2A> método verifica o acesso para uma ação especificada em um recurso especificado. O recurso e a ação são cadeias de caracteres e normalmente são URIs. Você também pode inicializar uma instância de <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> com uma ação, um recurso e a chamada a <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> método. Embora o construtor usa apenas um único recurso e a ação, <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> objetos podem ser combinados por meio de <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Union%2A> e <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Intersect%2A> métodos. Uma permissão criada usando esses métodos pode conter vários pares de ação de recurso.  
  
 Ambos os métodos determinam o acesso ao chamar o <xref:System.Security.Claims.ClaimsAuthorizationManager.CheckAccess%2A?displayProperty=nameWithType> método do Gerenciador de autorização de declarações configurado com um <xref:System.Security.Claims.AuthorizationContext> composto de entidade de segurança ativa (<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>), o recurso e a ação. Elas geram um <xref:System.Security.SecurityException> se a entidade de segurança atual não está autorizada a executar a ação no recurso; caso contrário, execução vai.  
  
 No caso de um <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> que contém vários pares de ação de recurso, o <xref:System.Security.Claims.ClaimsAuthorizationManager.CheckAccess%2A?displayProperty=nameWithType> método é invocado para cada um dos pares de ação de recurso contidos na permissão.  Para a chamada <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> para ter êxito, a entidade de segurança ativa deve estar autorizada para todos os pares de ação de recurso contidos na permissão.  
  
   
  
## Examples  
 O exemplo a seguir mostra como proteger um recurso usando o <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> método, o <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.CheckAccess%2A> método, ou um <xref:System.IdentityModel.Services.ClaimsPrincipalPermissionAttribute> declaração. Em cada caso, configurado <xref:System.Security.Claims.ClaimsAuthorizationManager> é invocado para avaliar o objeto atual em relação ao recurso especificado e a ação. Se o servidor principal atual não tem autorização para a ação especificada no recurso especificado, um <xref:System.Security.SecurityException> lançado; caso contrário, a execução continua.  
  
 [!code-csharp[WifCppWithCam#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifcppwithcam/cs/wifcppwithcam/program.cs#1)]  
  
 O XML a seguir mostra a configuração mínima necessária para usar uma autorização de declarações personalizadas manager com o <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> classe. Você deve, no mínimo, declará o `system.identityModel` e o `system.identityModel.services` seções o `<configSection>` elemento e, em seguida, especifique o Gerenciador de autorização em um [ &lt;claimsAuthorizationManager&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/claimsauthorizationmanager.md)elemento sob a configuração de identidade padrão. Isso garantirá que o Gerenciador de autorização é referenciado da configuração de Federação do padrão. Como alternativa, você pode especificar o nome da configuração de identidade sob a qual o Gerenciador de autorização é especificado no `identityConfigurationName` atributo o [ &lt;federationConfiguration&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/federationconfiguration.md) elemento.  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<configuration>  
  <configSections>  
    <!-- WIF configuration sections -->  
    <section name="system.identityModel" type="System.IdentityModel.Configuration.SystemIdentityModelSection, System.IdentityModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=B77A5C561934E089"/>  
    <section name="system.identityModel.services" type="System.IdentityModel.Services.Configuration.SystemIdentityModelServicesSection, System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=B77A5C561934E089"/>  
  </configSections>  
  
  <startup>  
    <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />  
  </startup>  
  
  <system.identityModel>  
    <identityConfiguration>  
      <claimsAuthorizationManager type ="MyClaimsAuthorizationManager.MyClaimsAuthorizationManager, MyClaimsAuthorizationManager"/>  
    </identityConfiguration>  
  </system.identityModel>  
  
</configuration>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IdentityModel.Services.ClaimsPrincipalPermissionAttribute" />
    <altmember cref="P:System.IdentityModel.Services.FederatedAuthentication.FederationConfiguration" />
    <altmember cref="T:System.Security.Claims.ClaimsAuthorizationManager" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ClaimsPrincipalPermission (string resource, string action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string resource, string action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (resource As String, action As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ClaimsPrincipalPermission(System::String ^ resource, System::String ^ action);" />
      <MemberSignature Language="F#" Value="new System.IdentityModel.Services.ClaimsPrincipalPermission : string * string -&gt; System.IdentityModel.Services.ClaimsPrincipalPermission" Usage="new System.IdentityModel.Services.ClaimsPrincipalPermission (resource, action)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="resource" Type="System.String" />
        <Parameter Name="action" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resource">The resource on which the principal should be authorized.</param>
        <param name="action">The action for which the principal should be authorized.</param>
        <summary>Creates a new instance of the <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> objeto é inicializado com o par de ação de recurso especificado. Você pode chamar o <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> método para executar uma verificação de acesso.  
  
 Embora o construtor usa apenas um único recurso e a ação, <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> objetos podem ser combinados por meio de <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Union%2A> e <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Intersect%2A> métodos. A permissão criada por meio desses métodos pode conter vários pares de ação de recurso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="resource" /> is <see langword="null" /> or an empty string.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CheckAccess">
      <MemberSignature Language="C#" Value="public static void CheckAccess (string resource, string action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CheckAccess(string resource, string action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.CheckAccess(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CheckAccess (resource As String, action As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CheckAccess(System::String ^ resource, System::String ^ action);" />
      <MemberSignature Language="F#" Value="static member CheckAccess : string * string -&gt; unit" Usage="System.IdentityModel.Services.ClaimsPrincipalPermission.CheckAccess (resource, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2103:ReviewImperativeSecurity", Justification="It is expected that the runtime’s behavior would rely on changing data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resource" Type="System.String" />
        <Parameter Name="action" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resource">The resource on which the principal should be authorized.</param>
        <param name="action">The action for which the principal should be authorized.</param>
        <summary>Checks if the current principal is authorized to perform the specified action on the specified resource.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A entidade de segurança deve ser autorizada para a ação especificada no recurso especificado ou o <xref:System.Security.SecurityException> exceção será lançada.  
  
 O <xref:System.Security.Claims.ClaimsAuthorizationManager.CheckAccess%2A?displayProperty=nameWithType> método do Gerenciador de autorização de declarações configurado é invocado com um <xref:System.Security.Claims.AuthorizationContext> composto de entidade de segurança ativa (<xref:System.Threading.Thread.CurrentPrincipal%2A>), o recurso e a ação.  
  
   
  
## Examples  
 O exemplo a seguir mostra como proteger um recurso usando o <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.CheckAccess%2A> método. O Gerenciador de autorização de declarações configurado é invocado para avaliar o objeto atual em relação ao recurso especificado e a ação. Se o servidor principal atual não tem autorização para a ação especificada no recurso especificado, um <xref:System.Security.SecurityException> lançado; caso contrário, a execução continua.  
  
 [!code-csharp[WifCppWithCam#2](~/samples/snippets/csharp/VS_Snippets_Misc/wifcppwithcam/cs/wifcppwithcam/program.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The current principal is not assignable from <see cref="T:System.Security.Claims.ClaimsPrincipal" />.  -or-  There is no <see cref="T:System.Security.Claims.ClaimsAuthorizationManager" /> configured.</exception>
        <exception cref="T:System.Security.SecurityException">The authorization check failed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Security.IPermission Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::IPermission ^ Copy();" />
      <MemberSignature Language="F#" Value="abstract member Copy : unit -&gt; System.Security.IPermission&#xA;override this.Copy : unit -&gt; System.Security.IPermission" Usage="claimsPrincipalPermission.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2103:ReviewImperativeSecurity", Justification="It is expected that the runtime’s behavior would rely on changing data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a copy of the current <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" /> instance.</summary>
        <returns>A <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" /> copied from the current instance.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Demand();" />
      <MemberSignature Language="F#" Value="abstract member Demand : unit -&gt; unit&#xA;override this.Demand : unit -&gt; unit" Usage="claimsPrincipalPermission.Demand " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Checks if the current principal is authorized for the resource-action pairs associated with the current instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O servidor principal atual deve estar autorizado para todos os pares de ação de recurso associados à instância ou o <xref:System.Security.SecurityException> exceção será lançada.  
  
 Embora o construtor usa apenas um único recurso e a ação, <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> objetos podem ser combinados por meio de <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Union%2A> e <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Intersect%2A> métodos. A permissão criada por meio desses métodos pode conter vários pares de ação de recurso.  
  
 O <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> método invoca o <xref:System.Security.Claims.ClaimsAuthorizationManager.CheckAccess%2A?displayProperty=nameWithType> método do Gerenciador de autorização de declarações configurado com um <xref:System.Security.Claims.AuthorizationContext> composto de entidade de segurança ativa (<xref:System.Threading.Thread.CurrentPrincipal%2A>), o recurso e a ação para cada um dos pares de ação de recurso contidos a permissão. Para o <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> tenha êxito ativo principal deve estar autorizada para todos os pares de ação de recurso que estão contidos na permissão.  
  
   
  
## Examples  
 O exemplo a seguir mostra como proteger um recurso usando o <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> método. O Gerenciador de autorização de declarações configurado é invocado para avaliar o objeto atual em relação ao recurso especificado e a ação. Se o servidor principal atual não tem autorização para a ação especificada no recurso especificado, um <xref:System.Security.SecurityException> lançado; caso contrário, a execução continua.  
  
 [!code-csharp[WifCppWithCam#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifcppwithcam/cs/wifcppwithcam/program.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The current principal is not assignable from <see cref="T:System.Security.Claims.ClaimsPrincipal" />.  -or-  There is no <see cref="T:System.Security.Claims.ClaimsAuthorizationManager" /> configured.</exception>
        <exception cref="T:System.Security.SecurityException">The authorization check failed.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromXml">
      <MemberSignature Language="C#" Value="public void FromXml (System.Security.SecurityElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FromXml(class System.Security.SecurityElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.FromXml(System.Security.SecurityElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FromXml (element As SecurityElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void FromXml(System::Security::SecurityElement ^ element);" />
      <MemberSignature Language="F#" Value="abstract member FromXml : System.Security.SecurityElement -&gt; unit&#xA;override this.FromXml : System.Security.SecurityElement -&gt; unit" Usage="claimsPrincipalPermission.FromXml element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Security.SecurityElement" />
      </Parameters>
      <Docs>
        <param name="element">The XML encoding to use to reconstruct the permission.</param>
        <summary>Reconstructs the current permission and its state from the specified XML encoding.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reconstrói uma permissão de codificação XML criado por uma chamada para o <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.ToXml%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The encoding contains unrecognized elements or attributes or improperly formed XML.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public System.Security.IPermission Intersect (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Intersect(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.Intersect(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Function Intersect (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::IPermission ^ Intersect(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member Intersect : System.Security.IPermission -&gt; System.Security.IPermission&#xA;override this.Intersect : System.Security.IPermission -&gt; System.Security.IPermission" Usage="claimsPrincipalPermission.Intersect target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">The permission to intersect with the current permission. It must be an instance of <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />.</param>
        <summary>Returns a permission that is the intersection of the current permission and the specified permission.</summary>
        <returns>A new <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" /> that represents the intersection of the current permission and the specified permission; or <see langword="null" /> if <paramref name="target" /> is <paramref name="null" /> or is not an instance of <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A permissão que é retornada tem apenas os pares de ação de recursos que estavam presentes na permissão atual e a permissão especificada. Pares de ação de recurso que existiam em apenas um ou outro as permissões não são incluídos. Para um <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> para ter êxito na nova permissão, o servidor principal atual só precisa ser autorizados para os pares de ação de recurso que eram comuns para a permissão atual e a permissão especificada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsSubsetOf (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.IsSubsetOf(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSubsetOf (target As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubsetOf(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member IsSubsetOf : System.Security.IPermission -&gt; bool&#xA;override this.IsSubsetOf : System.Security.IPermission -&gt; bool" Usage="claimsPrincipalPermission.IsSubsetOf target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">The permission to be tested for the subset relationship. It must be an instance of <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />.</param>
        <summary>Returns a value that indicates whether current permission is a subset of the specified permission.</summary>
        <returns>
          <see langword="true" /> if current permission is a subset of the specified permission; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A permissão atual é um subconjunto de permissão especificada se todos os pares de ação de recurso contidos na permissão atual também estão presentes na permissão especificada. Se `target` é `null` ou não é uma instância de <xref:System.IdentityModel.Services.ClaimsPrincipalPermission>, o <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.IsSubsetOf%2A> retorna `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnrestricted">
      <MemberSignature Language="C#" Value="public bool IsUnrestricted ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsUnrestricted() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.IsUnrestricted" />
      <MemberSignature Language="VB.NET" Value="Public Function IsUnrestricted () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsUnrestricted();" />
      <MemberSignature Language="F#" Value="abstract member IsUnrestricted : unit -&gt; bool&#xA;override this.IsUnrestricted : unit -&gt; bool" Usage="claimsPrincipalPermission.IsUnrestricted " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a value that indicates whether the permission is unrestricted.</summary>
        <returns>
          <see langword="true" /> if the permission is unrestricted; otherwise, <see langword="false" />. Always returns <see langword="true" /> indicating that permission is unrestricted.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public System.Security.SecurityElement ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.SecurityElement ToXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.ToXml" />
      <MemberSignature Language="VB.NET" Value="Public Function ToXml () As SecurityElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::SecurityElement ^ ToXml();" />
      <MemberSignature Language="F#" Value="abstract member ToXml : unit -&gt; System.Security.SecurityElement&#xA;override this.ToXml : unit -&gt; System.Security.SecurityElement" Usage="claimsPrincipalPermission.ToXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the XML encoded form of the current permission and its state.</summary>
        <returns>The XML encoded form of the current permission and its state.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A entidade de segurança pode ser reconstruída com forma de XML codificada chamando o <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.FromXml%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public System.Security.IPermission Union (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Union(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.Union(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Function Union (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::IPermission ^ Union(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member Union : System.Security.IPermission -&gt; System.Security.IPermission&#xA;override this.Union : System.Security.IPermission -&gt; System.Security.IPermission" Usage="claimsPrincipalPermission.Union target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">The permission to combine with current permission. It must be of type <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />.</param>
        <summary>Returns a new permission that is the union of the current permission and the specified permission. <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" /> object that has all of the resource-action pairs that are present in the current instance and the target instance.</summary>
        <returns>A new <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" /> that represents the union of the current permission and the specified permission; or <see langword="null" /> if <paramref name="target" /> is <paramref name="null" /> or is not an instance of <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A permissão que é retornada tem todos os pares de ação de recurso que estão presentes na permissão de atual e todos os pares de ação de recurso são apresentam a permissão especificada. Para um <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> para ter êxito na nova permissão, o servidor principal atual deve estar autorizado para todos os pares de ação de recurso que existiam na permissão de atual e todos os pares de ação de recurso que existiam na permissão especificada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>