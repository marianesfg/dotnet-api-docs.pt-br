<Type Name="Regex" FullName="System.Text.RegularExpressions.Regex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1866099bd5c49e319c79697649ac39b180a8d4df" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52217557" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Regex : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Regex extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.Regex" />
  <TypeSignature Language="VB.NET" Value="Public Class Regex&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Regex : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Regex = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa uma expressão regular imutável.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex> classe representa o mecanismo de expressões regulares do .NET Framework. Ele pode ser usado para analisar rapidamente grandes quantidades de texto para localizar padrões de caracteres específicos; para extrair, editar, substituir ou excluir subcadeias de caracteres de texto; e adicionar as cadeias de caracteres extraídas a uma coleção para gerar um relatório.  
  
> [!NOTE]
>  Se seu interesse principal é validar uma cadeia de caracteres, determinando se ele está em conformidade com um padrão específico, você pode usar o <xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType> classe.  
  
 Para usar expressões regulares, você define o padrão que você deseja identificar em um fluxo de texto usando a sintaxe documentada no [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Em seguida, você pode, opcionalmente, criar uma instância de um <xref:System.Text.RegularExpressions.Regex> objeto. Por fim, você pode chamar um método que executa alguma operação, como substituição de texto que corresponde ao padrão de expressão regular ou identificar uma correspondência de padrões.  
  
> [!NOTE]
>  Para alguns padrões comuns de expressões regulares, consulte [exemplos de expressões regulares](~/docs/standard/base-types/regular-expression-examples.md). Também há um número de bibliotecas online de padrões de expressão regular, como um de cada [Expressions.info Regular](https://www.regular-expressions.info/examples.html).  
  
<a name="remarks"></a> Para obter mais informações sobre como usar o <xref:System.Text.RegularExpressions.Regex> de classe, consulte as seções a seguir neste tópico:  
  
-   [Regex vs. Métodos de cadeia de caracteres](#regex_vs_string)  
  
-   [Portas estáticas vs. Métodos de instância](#static_vs_instance)  
  
-   [Executando operações de expressão Regular](#regex_ops)  
  
-   [Definindo um valor de tempo limite](#define_timeout)  
  
 Para saber mais sobre a linguagem de expressão regular, confira [Linguagem de expressão regular - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md) ou faça download e imprima um dos seguintes folhetos:  
  
 [Referência rápida no formato Word (.docx)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)  
 [Referência rápida no formato PDF (.pdf)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)  
  
<a name="regex_vs_string"></a>   
## <a name="regex-vs-string-methods"></a>Regex x métodos da cadeia de caracteres  
 O <xref:System.String?displayProperty=nameWithType> classe inclui vários métodos de pesquisa e comparação que você pode usar para executar a correspondência de padrões com texto. Por exemplo, o <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.EndsWith%2A?displayProperty=nameWithType>, e <xref:System.String.StartsWith%2A?displayProperty=nameWithType> métodos de determinam se uma instância de cadeia de caracteres contém uma subcadeia de caracteres especificada; e o <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, <xref:System.String.IndexOfAny%2A?displayProperty=nameWithType>, <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>, e <xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType> métodos retornam o início posição de uma subcadeia de caracteres especificada em uma cadeia de caracteres. Use os métodos do <xref:System.String?displayProperty=nameWithType> classe quando você estiver procurando por uma cadeia de caracteres específica. Use o <xref:System.Text.RegularExpressions.Regex> classe quando você está procurando um padrão específico em uma cadeia de caracteres. Para obter mais informações e exemplos, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md).  
  
 [Para comentários](#remarks)  
  
<a name="static_vs_instance"></a>   
## <a name="static-vs-instance-methods"></a>Métodos estáticos x instância  
 Depois de definir um padrão de expressão regular, você possa fornecê-la ao mecanismo de expressões regulares em qualquer uma das duas maneiras:  
  
-   Instanciando um <xref:System.Text.RegularExpressions.Regex> objeto que representa a expressão regular. Para fazer isso, você passa o padrão de expressão regular para um <xref:System.Text.RegularExpressions.Regex.%23ctor%2A> construtor. Um <xref:System.Text.RegularExpressions.Regex> objeto é imutável; quando você instancia um <xref:System.Text.RegularExpressions.Regex> do objeto com uma expressão regular, que a expressão regular do objeto não pode ser alterado.  
  
-   Fornecendo a expressão regular e o texto da pesquisa para um `static` (`Shared` no Visual Basic) <xref:System.Text.RegularExpressions.Regex> método. Isso permite que você use uma expressão regular sem criar explicitamente um <xref:System.Text.RegularExpressions.Regex> objeto.  
  
 Todos os <xref:System.Text.RegularExpressions.Regex> métodos de identificação padrão incluem estáticos e sobrecargas de instância.  
  
 O mecanismo de expressões regulares deve compilar um padrão específico antes que o padrão pode ser usado. Porque <xref:System.Text.RegularExpressions.Regex> objetos são imutáveis, esse é um procedimento única que ocorre quando um <xref:System.Text.RegularExpressions.Regex> construtor de classe ou um método estático é chamado. Para eliminar a necessidade de compilar repetidamente uma única expressão regular, o mecanismo de expressões regulares armazena em cache as expressões regulares compiladas usadas em chamadas de método estático. Como resultado, os métodos de correspondência de expressão regular oferecem desempenho comparável para estático e métodos de instância.  
  
> [!IMPORTANT]
>  Do .NET Framework versões 1.0 e 1.1, compilado todas as expressões regulares, se eles foram usados no método estático ou instância chama, foram armazenados em cache. Somente as expressões regulares usadas em chamadas de método estático começando com o .NET Framework 2.0, são armazenados em cache.  
  
 No entanto, o cache pode afetar adversamente desempenho nos dois casos a seguir:  
  
-   Quando você usa chamadas de método estático com um grande número de expressões regulares. Por padrão, o mecanismo de expressões regulares armazena em cache as expressões regulares estáticas de usados recentemente 15. Se seu aplicativo usa mais de 15 expressões regulares estáticas, algumas expressões regulares devem ser recompilados. Para evitar essa recompilação, você pode aumentar o <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> propriedade.  
  
-   Quando você cria uma instância nova <xref:System.Text.RegularExpressions.Regex> objetos com expressões regulares que foram compilados anteriormente. Por exemplo, o código a seguir define uma expressão regular para localizar palavras duplicadas em um fluxo de texto. Embora o exemplo usa uma única expressão regular, ele cria uma nova <xref:System.Text.RegularExpressions.Regex> objeto para processar cada linha de texto. Isso resulta na recompilação da expressão regular com cada iteração do loop.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#1)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#1)]  
  
     Para evitar a recompilação, você deve instanciar um único <xref:System.Text.RegularExpressions.Regex> objeto que é acessível a todo o código que precisa dele, conforme mostrado no seguinte exemplo reescrito.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#2)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#2)]  
  
 [Para comentários](#remarks)  
  
<a name="regex_ops"></a>   
## <a name="performing-regular-expression-operations"></a>Executando operações de expressão regular  
 Se você decidir criar uma instância de um <xref:System.Text.RegularExpressions.Regex> do objeto e chamar seus métodos ou chamar métodos estáticos, o <xref:System.Text.RegularExpressions.Regex> classe oferece a funcionalidade de correspondência de padrões a seguir:  
  
-   Validação de uma correspondência. Você chama o <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> método para determinar se uma correspondência está presente.  
  
-   Recuperação de uma única correspondência. Você chama o <xref:System.Text.RegularExpressions.Regex.Match%2A> método para recuperar um <xref:System.Text.RegularExpressions.Match> objeto que representa a primeira correspondência em uma cadeia de caracteres ou em parte de uma cadeia de caracteres. Correspondências subsequentes podem ser recuperadas chamando o <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> método.  
  
-   Recuperação de todas as correspondências. Você chama o <xref:System.Text.RegularExpressions.Regex.Matches%2A> método para recuperar um <xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType> objeto que representa todas as correspondências encontradas em uma cadeia de caracteres ou em parte de uma cadeia de caracteres.  
  
-   Substituição de texto correspondente. Você chama o <xref:System.Text.RegularExpressions.Regex.Replace%2A> método para substituir o texto correspondido. O texto de substituição também pode ser definido por uma expressão regular. Além disso, alguns dos <xref:System.Text.RegularExpressions.Regex.Replace%2A> métodos incluem um <xref:System.Text.RegularExpressions.MatchEvaluator> parâmetro que permite que você definir programaticamente o texto de substituição.  
  
-   Criação de uma matriz de cadeia de caracteres é formada por partes de uma cadeia de caracteres de entrada. Você chama o <xref:System.Text.RegularExpressions.Regex.Split%2A> método para dividir uma cadeia de caracteres de entrada nas posições definidas pela expressão regular.  
  
 Além de seus métodos de correspondência de padrões, o <xref:System.Text.RegularExpressions.Regex> classe inclui vários métodos de finalidade especial:  
  
-   O <xref:System.Text.RegularExpressions.Regex.Escape%2A> método ignora os caracteres que podem ser interpretados como operadores de expressão regular em uma expressão regular ou uma cadeia de caracteres de entrada.  
  
-   O <xref:System.Text.RegularExpressions.Regex.Unescape%2A> método remove esses caracteres de escape.  
  
-   O <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> método cria um assembly que contém expressões regulares predefinidas. O .NET Framework contém exemplos desses assemblies de finalidade especial no <xref:System.Web.RegularExpressions?displayProperty=nameWithType> namespace.  
  
 [Para comentários](#remarks)  
  
<a name="define_timeout"></a>   
## <a name="defining-a-time-out-value"></a>Definindo um valor de tempo limite  
 O .NET Framework dá suporte a uma linguagem de expressão regular completa que fornece substancial de energia e flexibilidade na correspondência de padrão. No entanto, a potência e flexibilidade vêm com um custo: o risco de mau desempenho. Expressões regulares que um desempenho insatisfatório são surpreendentemente fácil de criar. Em alguns casos, as operações de expressão regular que confiam no retrocesso excessivo podem parecer parar de responder quando eles processam texto que quase corresponda ao padrão de expressão regular. Para obter mais informações sobre o mecanismo de expressões regulares do .NET Framework, consulte [detalhes do comportamento de expressões regulares](~/docs/standard/base-types/details-of-regular-expression-behavior.md). Para obter mais informações sobre o retrocesso excessivo, consulte [retrocesso](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode definir um intervalo de tempo limite para correspondências de expressões regulares. Se o mecanismo de expressão regular não pode identificar uma correspondência dentro deste intervalo de tempo, a operação de correspondência gera uma <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção. Na maioria dos casos, isso impede que o mecanismo de expressões regulares desperdício de energia de processamento tentando corresponder o texto que quase corresponda ao padrão de expressão regular. Ele também pode indicar, no entanto, que o intervalo de tempo limite tenha sido definido muito baixo, ou que a carga atual do computador causou uma degradação geral no desempenho.  
  
 Como tratar a exceção depende da causa da exceção. Se a exceção ocorre porque o intervalo de tempo limite está definido muito baixo ou devido à carga excessiva do computador, você pode aumentar o intervalo de tempo limite e repita a operação de correspondência. Se a exceção ocorre porque a expressão regular depende de retrocesso excessivo, você pode presumir que uma correspondência não existe e, opcionalmente, você pode registrar informações que ajudarão você a modificar o padrão de expressão regular.  
  
 Você pode definir um intervalo de tempo limite ao chamar o <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> construtor ao instanciar um objeto de expressão regular. Para métodos estáticos, você pode definir um intervalo de tempo limite, chamando uma sobrecarga de um método correspondente que tenha um `matchTimeout` parâmetro. Se você não definir explicitamente um valor de tempo limite, o valor de tempo limite padrão é determinado da seguinte maneira:  
  
-   Usando o tempo limite de todo o aplicativo existe valor, se houver um. Isso pode ser qualquer valor de tempo limite se aplica ao domínio do aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é instanciado ou é feita a chamada de método estático. Você pode definir o valor de tempo limite de todo o aplicativo por meio da chamada a <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> método para atribuir a representação de cadeia de caracteres de um <xref:System.TimeSpan> valor à propriedade "REGEX_DEFAULT_MATCH_TIMEOUT".  
  
-   Usando o valor <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>, se nenhum valor de tempo limite de todo o aplicativo tiver sido definido.  
  
> [!IMPORTANT]
>  É recomendável que você defina um valor de tempo limite em todas as operações de correspondência de padrão de expressão regular. Para obter mais informações, consulte [práticas recomendadas para expressões regulares](~/docs/standard/base-types/best-practices.md).  
  
 [Para comentários](#remarks)  
  
   
  
## Examples  
 O exemplo a seguir usa uma expressão regular para verificar as ocorrências repetidas de palavras em uma cadeia de caracteres. A expressão regular `\b(?<word>\w+)\s+(\k<word>)\b` pode ser interpretado como mostrado na tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\b`|Começa a correspondência em um limite de palavra.|  
|`(?<word>\w+)`|Corresponder a um ou mais caracteres de palavra até um limite de palavra. Nomeie esse grupo capturado `word`.|  
|`\s+`|Corresponde a um ou mais caracteres de espaço em branco.|  
|`(\k<word>)`|Corresponde ao grupo capturado chamado `word`.|  
|`\b`|Corresponder a um limite de palavra.|  
  
 [!code-cpp[Regex_Words#0](~/samples/snippets/cpp/VS_Snippets_CLR/Regex_Words/CPP/words.cpp#0)]
 [!code-csharp[Regex_Words#0](~/samples/snippets/csharp/VS_Snippets_CLR/Regex_Words/CS/words.cs#0)]
 [!code-vb[Regex_Words#0](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex_Words/VB/words.vb#0)]  
  
 O exemplo a seguir ilustra o uso de uma expressão regular para verificar se uma cadeia de caracteres representa um valor de moeda ou tem o formato correto para representar um valor de moeda. Nesse caso, a expressão regular é criada dinamicamente a partir de <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, e <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> propriedades para a cultura do usuário atual. Se o sistema atual da cultura é en-US, a expressão regular resultante é `^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`. Essa expressão regular pode ser interpretada conforme mostrado na tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`^`|Começar do início da cadeia de caracteres.|  
|`\s*`|Corresponder a zero ou mais caracteres de espaço em branco.|  
|`[\+-]?`|Corresponde a zero ou uma ocorrência do sinal positivo ou o sinal negativo.|  
|`\s?`|Corresponder a zero ou a um caractere de espaço em branco.|  
|`\$?`|Corresponde a zero ou uma ocorrência do sinal de dólar.|  
|`\s?`|Corresponder a zero ou a um caractere de espaço em branco.|  
|`\d*`|Corresponde a zero ou mais dígitos decimais.|  
|`\.?`|Corresponder a zero ou um símbolo de vírgula decimal.|  
|`\d{2}?`|Corresponde zero ou uma vez de dois dígitos decimais.|  
|`(\d*\.?\d{2}?){1}`|Corresponder ao padrão de dígitos integral e fracionário, separados por um símbolo de ponto decimal, pelo menos uma vez.|  
|`$`|Corresponder ao final da cadeia de caracteres.|  
  
 Nesse caso, a expressão regular pressupõe que uma cadeia de caracteres de moeda válidos não contém símbolos de separador de grupo e se ele tem sem dígitos fracionais ou o número de dígitos fracionários definidas pela cultura atual <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A> propriedade.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/cs/regex_example1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/vb/regex_example1.vb#1)]  
  
 Como a expressão regular nesse exemplo é criada dinamicamente, não sabemos em tempo de design se o símbolo de moeda da cultura atual, a vírgula decimal ou sinais positivos e negativos podem ser interpretados incorretamente pelo mecanismo de expressões regulares como regular operadores de linguagem de expressão. Para evitar qualquer interpretação errônea, o exemplo passa cada cadeia de caracteres gerada dinamicamente para o <xref:System.Text.RegularExpressions.Regex.Escape%2A> método.  
  
 ]]></format>
    </remarks>
    <threadsafe>O <see cref="T:System.Text.RegularExpressions.Regex" /> classe é imutável (somente leitura) e thread-safe. <see cref="T:System.Text.RegularExpressions.Regex" /> objetos podem ser criados em qualquer thread e compartilhados entre os threads. Para obter mais informações, consulte [acesso Thread-Safe](~/docs/standard/base-types/thread-safety-in-regular-expressions.md).</threadsafe>
    <altmember cref="T:System.Configuration.RegexStringValidator" />
    <related type="Article" href="~/docs/standard/base-types/regular-expressions.md">Expressões regulares do .NET Framework</related>
    <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementos de linguagem de expressão regular</related>
    <related type="ExternalDocumentation" href="https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular expressions quick reference.docx">Expressões regulares - referência rápida (download no formato Word)</related>
    <related type="ExternalDocumentation" href="https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular expressions quick reference.pdf">Expressões regulares - referência rápida (download no formato PDF)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementos de linguagem de expressão regular</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Observe que esse construtor é protegido; ele só pode ser chamado por classes derivadas do <xref:System.Text.RegularExpressions.Regex> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex pattern" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.RegularExpressions.Regex" /> para a expressão regular especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que simbolicamente descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte o [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md) tópicos.  
  
 Chamar o <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29> construtor é equivalente a chamar o <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> construtor com um valor de <xref:System.Text.RegularExpressions.RegexOptions.None> para o `options` argumento.  
  
 Um <xref:System.Text.RegularExpressions.Regex> objeto é imutável, o que significa que ele pode ser usado somente para o padrão de correspondência definem quando ela é criada. No entanto, ele pode ser usado várias vezes sem que está sendo recompilado.  
  
 Este construtor cria uma instância de um objeto de expressão regular que tenta uma correspondência diferencia maiusculas de minúsculas de qualquer caractere alfabético definidos em `pattern`. Para uma correspondência que diferencia maiusculas de minúsculas, use o <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> construtor.  
  
   
  
## Examples  
 O exemplo a seguir ilustra como usar esse construtor para criar uma instância de uma expressão regular que corresponde a qualquer palavra que começa com as letras "a" ou "t".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/constructors1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/constructors1.vb#1)]  
  
 Observe que o padrão de expressão regular não pode coincidir com a palavra "The" no início do texto, porque as comparações diferenciam maiusculas de minúsculas por padrão. Para obter um exemplo de comparação diferencia maiusculas de minúsculas, consulte o <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> construtor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" /> é <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Este construtor cria um <see cref="T:System.Text.RegularExpressions.Regex" /> objeto que usa o valor de tempo limite padrão do domínio do aplicativo no qual ele é criado. Se um valor de tempo limite não tiver sido definido para o domínio de aplicativo, o <see cref="T:System.Text.RegularExpressions.Regex" /> o valor do objeto usa <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impede que a operação de atingir o tempo limite. O construtor recomendados para a criação de um <see cref="T:System.Text.RegularExpressions.Regex" /> objeto é <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite que você definir o intervalo de tempo limite.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementos de linguagem de expressão regular</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">O objeto que contém um padrão serializado e informações da <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</param>
        <param name="context">O destino dessa serialização. (Este parâmetro não é usado; especifique <see langword="null" />.)</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.RegularExpressions.Regex" /> utilizando dados serializados.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">O padrão que <paramref name="info" /> contém é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="info" /> contém um sinalizador <see cref="T:System.Text.RegularExpressions.RegexOptions" /> inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que modificam a expressão regular.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.RegularExpressions.Regex" /> para a expressão regular especificada, com opções que modifiquem o padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que simbolicamente descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte o [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md) tópicos.  
  
 Um <xref:System.Text.RegularExpressions.Regex> objeto é imutável, o que significa que ele pode ser usado apenas para os parâmetros de correspondência definem quando ela é criada. No entanto, ele pode ser usado várias vezes sem que está sendo recompilado.  
  
   
  
## Examples  
 O exemplo a seguir ilustra como usar esse construtor para criar uma instância de uma expressão regular que corresponde a qualquer palavra que começa com as letras "a" ou "t".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/Constructors2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/Constructors2.vb#2)]  
  
 Observe que a coleção match inclui a palavra "The", que inicia o texto porque o `options` parâmetro definido comparações diferencia maiusculas de minúsculas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> contém um sinalizador inválido.</exception>
        <block subset="none" type="usage">
          <para>Este construtor cria um <see cref="T:System.Text.RegularExpressions.Regex" /> objeto que usa o valor de tempo limite padrão do domínio do aplicativo no qual ele é criado. Se um valor de tempo limite não tiver sido definido para o domínio de aplicativo, o <see cref="T:System.Text.RegularExpressions.Regex" /> o valor do objeto usa <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impede que a operação de atingir o tempo limite. O construtor recomendados para a criação de um <see cref="T:System.Text.RegularExpressions.Regex" /> objeto é <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite que você definir o intervalo de tempo limite.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementos de linguagem de expressão regular</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions, matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options, matchTimeout)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que modificam a expressão regular.</param>
        <param name="matchTimeout">Um intervalo de tempo limite ou <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que o método não deve atingir o tempo limite.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.RegularExpressions.Regex" /> para a expressão regular especificada, com opções que modificam o padrão e um valor que especifica quanto tempo um padrão que corresponde ao método deve tentar uma correspondência antes de atingir o tempo limite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que simbolicamente descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte o [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md) tópicos.  
  
 Um <xref:System.Text.RegularExpressions.Regex> objeto é imutável, o que significa que ele pode ser usado somente para o padrão de correspondência que você definir quando você cria. No entanto, ele pode ser usado várias vezes sem que está sendo recompilado.  
  
 O `matchTimeout` parâmetro especifica quanto tempo um padrão de correspondência de método deve tentar encontrar uma correspondência antes de expirar. Se nenhuma correspondência for encontrada desse intervalo de tempo, o método de correspondência gera uma <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção. `matchTimeout` substitui qualquer valor de tempo limite padrão definido para o domínio de aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Os métodos de correspondência de instância que observa o `matchTimeout` intervalo de tempo limite incluem o seguinte:  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%2A>  
  
-   <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>  
  
 Como definir um intervalo de tempo limite impede que as expressões regulares que confiam no retrocesso excessivo do que parece parar de responder ao processar a entrada que contém correspondências próximas. Para obter mais informações, consulte [práticas recomendadas para expressões regulares](~/docs/standard/base-types/best-practices.md) e [retrocesso](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Para definir um intervalo de tempo limite razoável, considere os seguintes fatores:  
  
-   O comprimento e a complexidade do padrão de expressão regular. Expressões regulares mais longas e complexas requerem mais tempo do que aqueles mais curtos e simples.  
  
-   A carga esperada máquina. Processamento leva mais tempo em sistemas que têm alta utilização de CPU e memória.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> construtor para instanciar um <xref:System.Text.RegularExpressions.Regex> objeto com um valor de tempo limite de um segundo. O padrão de expressão regular `(a+)+$`, que faz a correspondência de uma ou várias sequências de um ou mais caracteres de “a” no final de uma linha, está sujeito ao retrocesso excessivo. Se um <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> é gerada, o exemplo aumenta o valor de tempo limite até o valor máximo de três segundos. Caso contrário, ele abandona a tentativa de corresponder ao padrão.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> não é um valor <see cref="T:System.Text.RegularExpressions.RegexOptions" /> válido.  
  
- ou - 
 <paramref name="matchTimeout" /> é negativo, zero ou maior que aproximadamente 24 dias.</exception>
        <block subset="none" type="usage">
          <para>É recomendável que você defina o <paramref name="matchTimeout" /> parâmetro para um valor apropriado, como dois segundos. Se você desabilitar os tempos limite especificando <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, o mecanismo de expressão regular oferece um desempenho ligeiramente melhor. No entanto, você deve desabilitar os tempos limite somente sob as seguintes condições: 
-Quando a entrada processada por uma expressão regular é derivada de uma origem conhecida e confiável ou é formado por texto estático. Isso exclui o texto que tenha sido dinamicamente inseridos pelos usuários.  
  
-Quando o padrão de expressão regular tenha sido integralmente testado para garantir que ele manipulará com eficiência corresponde, não correspondências e o próximo corresponde.  
  
-Quando o padrão de expressão regular contém sem elementos de linguagem que são conhecidos por causar retrocesso excessivo durante o processamento de uma correspondência quase.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">Retrocesso</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementos de linguagem de expressão regular</related>
      </Docs>
    </Member>
    <Member MemberName="CacheSize">
      <MemberSignature Language="C#" Value="public static int CacheSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CacheSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CacheSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CacheSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CacheSize : int with get, set" Usage="System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o número máximo de entradas no cache estático atual de expressões regulares compiladas.</summary>
        <value>O número máximo de entradas no cache estático.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex> classe mantém um cache interno de expressões regulares compiladas usado em chamadas de método estático. Se o valor especificado em uma operação de conjuntos é menor que o tamanho do cache atual, as entradas de cache são descartadas até que o tamanho do cache é igual ao valor especificado.  
  
 Por padrão, o cache contém 15 compilado expressões regulares estáticas. Seu aplicativo normalmente não precisará modificar o tamanho do cache. Use o <xref:System.Text.RegularExpressions.Regex.CacheSize%2A> somente quando você deseja desativar o cache ou quando você tiver um cache excepcionalmente grande de propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor em uma operação de conjuntos é menor que zero.</exception>
        <block subset="none" type="usage">
          <para>No .NET Framework anteriores ao [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)], expressões regulares usadas em estáticos e chamadas de método de instância foram armazenados em cache. Começando com o [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)], apenas regulares são armazenadas em cache as expressões usadas em chamadas de método estático.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="capnames">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable capnames;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable capnames" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capnames" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capnames As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ capnames;" />
      <MemberSignature Language="F#" Value="val mutable capnames : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.capnames" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Usado por um objeto <see cref="T:System.Text.RegularExpressions.Regex" /> gerado pelo método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CapNames">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary CapNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary CapNames" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CapNames" />
      <MemberSignature Language="VB.NET" Value="Protected Property CapNames As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ CapNames { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CapNames : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.CapNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um dicionário que mapeia grupos de captura nomeados para seus valores de índice.</summary>
        <value>Um dicionário que mapeia grupos de captura nomeados para seus valores de índice.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Observe que essa propriedade será protegida; só pode ser acessado de uma classe que deriva de <xref:System.Text.RegularExpressions.Regex> classe.  
  
 Uma operação de conjuntos tenta converter o valor atribuído à propriedade para um <xref:System.Collections.Hashtable> do objeto; se essa conversão falhar, ele chama o <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> construtor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor atribuído à propriedade <see cref="P:System.Text.RegularExpressions.Regex.CapNames" /> em uma operação de conjuntos é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="caps">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable caps;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable caps" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.caps" />
      <MemberSignature Language="VB.NET" Value="Protected Friend caps As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ caps;" />
      <MemberSignature Language="F#" Value="val mutable caps : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.caps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Usado por um objeto <see cref="T:System.Text.RegularExpressions.Regex" /> gerado pelo método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Caps">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary Caps { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Caps" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Caps" />
      <MemberSignature Language="VB.NET" Value="Protected Property Caps As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ Caps { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Caps : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.Caps" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um dicionário que mapeia grupos de captura numerados para seus valores de índice.</summary>
        <value>Um dicionário que mapeia grupos de captura numerados para seus valores de índice.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Observe que essa propriedade será protegida; só pode ser acessado de uma classe que deriva de <xref:System.Text.RegularExpressions.Regex> classe.  
  
 Uma operação de conjuntos tenta converter o valor atribuído à propriedade para um <xref:System.Collections.Hashtable> do objeto; se essa conversão falhar, ele chama o <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> construtor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor atribuído à propriedade <see cref="P:System.Text.RegularExpressions.Regex.Caps" /> em uma operação de conjuntos é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="capsize">
      <MemberSignature Language="C#" Value="protected internal int capsize;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly int32 capsize" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capsize" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capsize As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected public: int capsize;" />
      <MemberSignature Language="F#" Value="val mutable capsize : int" Usage="System.Text.RegularExpressions.Regex.capsize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Usado por um objeto <see cref="T:System.Text.RegularExpressions.Regex" /> gerado pelo método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="capslist">
      <MemberSignature Language="C#" Value="protected internal string[] capslist;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string[] capslist" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capslist" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capslist As String() " />
      <MemberSignature Language="C++ CLI" Value="protected public: cli::array &lt;System::String ^&gt; ^ capslist;" />
      <MemberSignature Language="F#" Value="val mutable capslist : string[]" Usage="System.Text.RegularExpressions.Regex.capslist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Usado por um objeto <see cref="T:System.Text.RegularExpressions.Regex" /> gerado pelo método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompileToAssembly">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compila expressões regulares e as salva em disco em um único assembly.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

No .NET Core, chamadas para o `Regex.CompileToAssembly` método throw um <xref:System.PlatformNotSupportedException>; não há suporte para gravar um assembly.
  
       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Uma matriz que descreve as expressões regulares a compilar.</param>
        <param name="assemblyname">O nome do arquivo do assembly.</param>
        <summary>Compila um ou mais objetos <see cref="T:System.Text.RegularExpressions.Regex" /> especificados para um assembly nomeado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> método gera um assembly do .NET Framework na qual cada expressão regular definida no `regexinfos` matriz é representada por uma classe. Normalmente, o <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> método é chamado de um aplicativo separado que gera um assembly de expressões regulares compiladas. Cada expressão regular incluído no assembly tem as seguintes características:  
  
-   Ele é derivado do <xref:System.Text.RegularExpressions.Regex> classe.  
  
-   Ele é atribuído o nome totalmente qualificado que é definido pela `fullnamespace` e `name` parâmetros de seu correspondente <xref:System.Text.RegularExpressions.RegexCompilationInfo> objeto.  
  
-   Ele tem um padrão (ou sem parâmetros) construtor.  
  
 Normalmente, o código que instancia e usa a expressão regular compilada é encontrado em um assembly ou aplicativo que é separado do código que cria o assembly.  
  
   
  
## Examples  
 O exemplo a seguir cria um assembly denominado RegexLib.dll. O assembly inclui duas expressões regulares compiladas. A primeira, `Utilities.RegularExpressions.DuplicatedString`, corresponde a duas palavras contíguas idênticas. O segundo, `Utilities.RegularExpressions.EmailAddress`, verifica se uma cadeia de caracteres tem o formato correto para ser um endereço de email.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile1.vb#1)]  
  
 A expressão regular que verifica uma cadeia de caracteres para palavras duplicadas, em seguida, é instanciada e usada pelo exemplo a seguir.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Compilação bem-sucedida do segundo exemplo requer uma referência ao RegexLib.dll (o assembly criado no primeiro exemplo) a ser adicionado ao projeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor da propriedade <see cref="P:System.Reflection.AssemblyName.Name" /> do parâmetro <paramref name="assemblyname" /> é uma cadeia de caracteres vazia ou nula.  
  
- ou - 
O padrão de expressão regular de um ou mais objetos em <paramref name="regexinfos" /> contém sintaxe inválida.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyname" /> ou <paramref name="regexinfos" /> é <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Somente .NET Core: a criação de um assembly de expressões regulares compiladas não é uma operação compatível.</exception>
        <block subset="none" type="usage">
          <para>Se você estiver desenvolvendo em um sistema que tem [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ou suas versões pontuais instalados, que você direcione [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], e você usar o <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> expressões regulares compiladas de método para criar um assembly que contém. Tentativa de usar uma das expressões regulares em que o assembly em um sistema que tem [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] gera uma exceção. Para solucionar esse problema, pode-se seguir uma das seguintes alternativas: 
-Compilar o assembly que contém as expressões regulares compiladas em um sistema que tem [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] em vez de versões mais recentes instalados.  
  
-Em vez de chamar <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> e recuperando a expressão regular compilada de um assembly, use estáticas ou de instância <see cref="T:System.Text.RegularExpressions.Regex" /> métodos com o <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> opção quando você instancia um <see cref="T:System.Text.RegularExpressions.Regex" /> de objeto ou chamar uma expressão regular método de correspondência de padrão.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Compilação e reutilização</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Uma matriz que descreve as expressões regulares a compilar.</param>
        <param name="assemblyname">O nome do arquivo do assembly.</param>
        <param name="attributes">Uma matriz que define os atributos a serem aplicados ao assembly.</param>
        <summary>Compila um ou mais objetos <see cref="T:System.Text.RegularExpressions.Regex" /> especificados para um assembly nomeado com os atributos especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> método gera um assembly do .NET Framework na qual cada expressão regular definida no `regexinfos` matriz é representada por uma classe. Normalmente, o <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> método é chamado de um aplicativo separado que gera um assembly de expressões regulares compiladas. Cada expressão regular incluído no assembly tem as seguintes características:  
  
-   Ele é derivado do <xref:System.Text.RegularExpressions.Regex> classe.  
  
-   Ele é atribuído o nome totalmente qualificado que é definido pela `fullnamespace` e `name` parâmetros de seu correspondente <xref:System.Text.RegularExpressions.RegexCompilationInfo> objeto.  
  
-   Ele tem um padrão (ou sem parâmetros) construtor.  
  
 Normalmente, o código que instancia e usa a expressão regular compilada é encontrado em um assembly ou aplicativo que é separado do código que cria o assembly.  
  
 Porque o <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> método gera um assembly do .NET Framework de uma chamada de método em vez de usar a palavra-chave de definição de classe da linguagem específica (como `class` em c# ou `Class`...`End Class` no Visual Basic), ele não permite que os atributos do .NET Framework a ser atribuído ao assembly usando a sintaxe de atributo padrão da linguagem de desenvolvimento. O `attributes` parâmetro fornece um método alternativo para definir os atributos que se aplicam ao assembly. Para cada atributo que você deseja aplicar ao assembly, faça o seguinte:  
  
1.  Criar uma matriz de <xref:System.Type> objetos que representam os tipos de parâmetro do construtor de atributo que você deseja chamar.  
  
2.  Recuperar um <xref:System.Type> objeto que representa a classe de atributo que você deseja aplicar ao novo assembly.  
  
3.  Chame o <xref:System.Type.GetConstructor%2A> método do atributo <xref:System.Type> o objeto para recuperar um <xref:System.Reflection.ConstructorInfo> objeto que representa o construtor de atributo que você deseja chamar. Passe o <xref:System.Type.GetConstructor%2A> método a matriz de <xref:System.Type> objetos que representam os tipos de parâmetro do construtor.  
  
4.  Criar um <xref:System.Object> matriz que define os parâmetros para passar para o construtor do atributo.  
  
5.  Criar uma instância de um <xref:System.Reflection.Emit.CustomAttributeBuilder> objeto, passando a seu construtor o <xref:System.Reflection.ConstructorInfo> objeto recuperado na etapa 3 e o <xref:System.Object> matriz criada na etapa 4.  
  
 Em seguida, você pode passar uma matriz desses <xref:System.Reflection.Emit.CustomAttributeBuilder> objetos, em vez do `attributes` parâmetro para o <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir cria um assembly denominado RegexLib.dll e aplica o <xref:System.Reflection.AssemblyTitleAttribute> de atributo a ele. O assembly inclui duas expressões regulares compiladas. A primeira, `Utilities.RegularExpressions.DuplicatedString`, corresponde a duas palavras contíguas idênticas. O segundo, `Utilities.RegularExpressions.EmailAddress`, verifica se uma cadeia de caracteres tem o formato correto para ser um endereço de email.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile3.vb#3)]  
  
 Você pode verificar se o <xref:System.Reflection.AssemblyTitleAttribute> atributo foi aplicado ao assembly examinando seu manifesto com um utilitário de reflexão, como ILDasm.  
  
 A expressão regular que verifica uma cadeia de caracteres para palavras duplicadas, em seguida, é instanciada e usada pelo exemplo a seguir.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Compilação bem-sucedida do segundo exemplo requer uma referência ao RegexLib.dll (o assembly criado no primeiro exemplo) a ser adicionado ao projeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor da propriedade <see cref="P:System.Reflection.AssemblyName.Name" /> do parâmetro <paramref name="assemblyname" /> é uma cadeia de caracteres vazia ou nula.  
  
- ou - 
O padrão de expressão regular de um ou mais objetos em <paramref name="regexinfos" /> contém sintaxe inválida.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyname" /> ou <paramref name="regexinfos" /> é <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Somente .NET Core: a criação de um assembly de expressões regulares compiladas não é uma operação compatível.</exception>
        <block subset="none" type="usage">
          <para>Se você estiver desenvolvendo em um sistema que tem [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ou suas versões pontuais instalados, que você direcione [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], e você usar o <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> expressões regulares compiladas de método para criar um assembly que contém. Tentativa de usar uma das expressões regulares em que o assembly em um sistema que tem [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] gera uma exceção. Para solucionar esse problema, pode-se seguir uma das seguintes alternativas: 
-Compilar o assembly que contém as expressões regulares compiladas em um sistema que tem [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] em vez de versões mais recentes instalados.  
  
-Em vez de chamar <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> e recuperando a expressão regular compilada de um assembly, use estáticas ou de instância <see cref="T:System.Text.RegularExpressions.Regex" /> métodos com o <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> opção quando você instancia um <see cref="T:System.Text.RegularExpressions.Regex" /> de objeto ou chamar uma expressão regular método de correspondência de padrão.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Compilação e reutilização</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes, System::String ^ resourceFile);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] * string -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes, resourceFile)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
        <Parameter Name="resourceFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Uma matriz que descreve as expressões regulares a compilar.</param>
        <param name="assemblyname">O nome do arquivo do assembly.</param>
        <param name="attributes">Uma matriz que define os atributos a serem aplicados ao assembly.</param>
        <param name="resourceFile">O nome do arquivo de recurso Win32 a ser incluído no assembly.</param>
        <summary>Compila um ou mais objetos <see cref="T:System.Text.RegularExpressions.Regex" /> especificados e um arquivo de recurso especificado para um assembly nomeado com os atributos especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName% 2CSystem.Reflection.Emit.CustomAttributeBuilder%5b%5D%2CSystem.String%29 > método gera um assembly do .NET Framework na qual cada expressão regular definida no `regexinfos` matriz é representada por uma classe. Normalmente, o [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D% 2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5b%5D%2CSystem.String%29 > método é chamado de um aplicativo separado que gera um assembly de expressões regulares compiladas. Cada expressão regular incluído no assembly tem as seguintes características:  
  
-   Ele é derivado do <xref:System.Text.RegularExpressions.Regex> classe.  
  
-   Ele é atribuído o nome totalmente qualificado que é definido pela `fullnamespace` e `name` parâmetros de seu correspondente <xref:System.Text.RegularExpressions.RegexCompilationInfo> objeto.  
  
-   Ele tem um padrão (ou sem parâmetros) construtor.  
  
 Normalmente, o código que instancia e usa a expressão regular compilada é encontrado em um assembly ou aplicativo que é separado do código que cria o assembly.  
  
 Porque o <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> método gera um assembly do .NET Framework de uma chamada de método em vez de usar a palavra-chave de definição de classe da linguagem específica (como `class` em c# ou `Class`...`End Class` no Visual Basic), ele não permite que os atributos do .NET Framework a ser atribuído ao assembly usando a sintaxe de atributo padrão da linguagem de desenvolvimento. O `attributes` parâmetro fornece um método alternativo para definir os atributos que se aplicam ao assembly. Para cada atributo que você deseja aplicar ao assembly, faça o seguinte:  
  
1.  Criar uma matriz de <xref:System.Type> objetos que representam os tipos de parâmetro do construtor de atributo que você deseja chamar.  
  
2.  Recuperar um <xref:System.Type> objeto que representa a classe de atributo que você deseja aplicar ao novo assembly.  
  
3.  Chame o <xref:System.Type.GetConstructor%2A> método do atributo <xref:System.Type> o objeto para recuperar um <xref:System.Reflection.ConstructorInfo> objeto que representa o construtor de atributo que você deseja chamar. Passe o <xref:System.Type.GetConstructor%2A> método a matriz de <xref:System.Type> objetos que representam os tipos de parâmetro do construtor  
  
4.  Criar um <xref:System.Object> matriz que define os parâmetros para passar para o construtor do atributo.  
  
5.  Criar uma instância de um <xref:System.Reflection.Emit.CustomAttributeBuilder> objeto, passando a seu construtor o <xref:System.Reflection.ConstructorInfo> objeto recuperado na etapa 3 e o <xref:System.Object> matriz criada na etapa 4.  
  
 Em seguida, você pode passar uma matriz desses <xref:System.Reflection.Emit.CustomAttributeBuilder> objetos, em vez do `attributes` parâmetro para o [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly% 28System.Text.RegularExpressions.RegexCompilationInfo%5b%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5b%5D%2CSystem.String%29 > método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor da propriedade <see cref="P:System.Reflection.AssemblyName.Name" /> do parâmetro <paramref name="assemblyname" /> é uma cadeia de caracteres vazia ou nula.  
  
- ou - 
O padrão de expressão regular de um ou mais objetos em <paramref name="regexinfos" /> contém sintaxe inválida.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyname" /> ou <paramref name="regexinfos" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">O parâmetro <paramref name="resourceFile" /> designa um arquivo de recurso Win32 inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo designado pelo parâmetro <paramref name="resourceFile" /> não pôde ser encontrado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Somente .NET Core: a criação de um assembly de expressões regulares compiladas não é uma operação compatível.</exception>
        <block subset="none" type="usage">
          <para>Se você estiver desenvolvendo em um sistema que tem [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ou suas versões pontuais instalados, que você direcione [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], e você usar o <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> expressões regulares compiladas de método para criar um assembly que contém. Tentativa de usar uma das expressões regulares em que o assembly em um sistema que tem [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] gera uma exceção. Para solucionar esse problema, pode-se seguir uma das seguintes alternativas: 
-Compilar o assembly que contém as expressões regulares compiladas em um sistema que tem [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] em vez de versões mais recentes instalados.  
  
-Em vez de chamar <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> e recuperando a expressão regular compilada de um assembly, use estáticas ou de instância <see cref="T:System.Text.RegularExpressions.Regex" /> métodos com o <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> opção quando você instancia um <see cref="T:System.Text.RegularExpressions.Regex" /> de objeto ou chamar uma expressão regular método de correspondência de padrão.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Compilação e reutilização</related>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="public static string Escape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Escape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Escape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Escape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Escape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Escape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">A cadeia de caracteres de entrada que contém o texto a ser convertido.</param>
        <summary>Ignora um conjunto mínimo de caracteres (\\, *, +, ?, |, {, [, (, ), ^, $, ., # e espaço em branco) substituindo-os por seus códigos de escape. Isso instrui o mecanismo de expressões regulares para interpretar esses caracteres literalmente em vez de metacaracteres.</summary>
        <returns>Uma cadeia de caracteres com metacaracteres convertidos em sua forma de escape.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Escape%2A> Converte uma cadeia de caracteres, de modo que o mecanismo de expressões regulares interpretará qualquer metacaracteres que ele pode conter como literais de caracteres. Por exemplo, considere uma expressão regular que foi projetada para extrair os comentários que são delimitados reta abrindo e fechando os colchetes ([e]) do texto. No exemplo a seguir, a expressão regular "[(.*?)]" é interpretado como uma classe de caractere. Em vez de correspondência de comentários inseridos no texto de entrada, a expressão regular corresponde a cada abertura ou o parêntese de fechamento, o período, o asterisco ou o ponto de interrogação.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#1)]  
  
 No entanto, se o colchete de abertura é escapado, passando-o para o <xref:System.Text.RegularExpressions.Regex.Escape%2A> método, a expressão regular é bem-sucedida na correspondência de comentários que são inseridos na cadeia de entrada. O exemplo a seguir ilustra essa situação.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#2)]  
  
 Em uma expressão regular que é definida por meio de um texto estático, os caracteres que devem ser interpretadas literalmente em vez de metacaracteres podem ter escape, precedendo-as com um símbolo de barra invertida (\\), bem como ao chamar o <xref:System.Text.RegularExpressions.Regex.Escape%2A> método. Em uma expressão regular que é definida dinamicamente usando caracteres que não são conhecidos em tempo de design, chamando o <xref:System.Text.RegularExpressions.Regex.Escape%2A> método é particularmente importante para garantir que o mecanismo de expressões regulares interpreta os caracteres individuais como literais em vez disso de metacaracteres.  
  
> [!NOTE]
>  Se um padrão de expressão regular inclui o sinal numérico (#) ou caracteres de espaço em branco literais, elas devem ser substituídas se o texto de entrada é analisado com o <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> opção habilitada.  
  
 Enquanto o <xref:System.Text.RegularExpressions.Regex.Escape%2A> método ignora a simples abertura colchete ([) e abrindo caracteres de chaves ({}), ele não escapa seus caracteres de fechamento correspondente (] e}). Na maioria dos casos, esses de escape não é necessário. Se um colchete de fechamento ou a chave não for precedido por seu caractere de abertura correspondente, o mecanismo de expressões regulares o interpreta literalmente. Se um braket de abertura ou chaves são interpretados como um metacaractere, o mecanismo de expressões regulares interpreta correspondente primeiro caractere como um metacaractere de fechamento. Se isso não é o comportamento desejado, o colchete de fechamento ou chave deve ser escapado acrescentando explicitamente a barra invertida (\\) caracteres. Para obter uma ilustração, consulte a seção de exemplo.  
  
   
  
## Examples  
 O exemplo a seguir extrai os comentários de texto. Ele pressupõe que os comentários são delimitados por um símbolo de comentário begin e um símbolo de comentário de final selecionado pelo usuário. Porque os símbolos de comentário devem ser interpretadas literalmente, eles são passados para o <xref:System.Text.RegularExpressions.Regex.Escape%2A> método para garantir que eles não podem ser interpretados incorretamente como metacaracteres. Além disso, o exemplo verifica explicitamente se o símbolo de comentário final inserido pelo usuário é um colchete de fechamento (]) ou uma chave (}). Se for, um caractere de barra invertida (\\) é anexado ao colchete ou chave para que ele é interpretado literalmente. Observe que o exemplo também usa o <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> coleção para exibir o comentário, em vez do comentário junto com seus símbolos de comentário de abertura e fechamento.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguagem de expressões regulares - referência rápida</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f49cc9cc-db7d-4058-8b8a-422bc08b29b0">Escapes de caracteres em expressões regulares</related>
      </Docs>
    </Member>
    <Member MemberName="factory">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexRunnerFactory factory;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Text.RegularExpressions.RegexRunnerFactory factory" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.factory" />
      <MemberSignature Language="VB.NET" Value="Protected Friend factory As RegexRunnerFactory " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexRunnerFactory ^ factory;" />
      <MemberSignature Language="F#" Value="val mutable factory : System.Text.RegularExpressions.RegexRunnerFactory" Usage="System.Text.RegularExpressions.Regex.factory" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexRunnerFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Usado por um objeto <see cref="T:System.Text.RegularExpressions.Regex" /> gerado pelo método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Regex ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="regex.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNames">
      <MemberSignature Language="C#" Value="public string[] GetGroupNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetGroupNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetGroupNames();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNames : unit -&gt; string[]" Usage="regex.GetGroupNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma matriz de nomes de grupo de captura para a expressão regular.</summary>
        <returns>Uma matriz de cadeia de caracteres de nomes de grupo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A coleção de nomes de grupo contém o conjunto de cadeias de caracteres usada para grupos de captura do nome da expressão. Mesmo se os grupos de captura não são explicitamente nomeados, eles são automaticamente atribuídos nomes numéricos ("0", "1", "2", "3" e assim por diante). O "0" chamado grupo representa todo o texto correspondido pelo padrão de expressão regular. Os grupos numerados antecedem grupos nomeados explicitamente na coleção e grupos nomeados aparecem na ordem em que eles são definidos no padrão de expressão regular.  
  
 Você pode usar o <xref:System.Array.Length%2A> propriedade na matriz retornada por esse método para determinar o número de grupos em uma expressão regular.  
  
   
  
## Examples  
 O exemplo a seguir define uma finalidade geral `ShowMatches` método que exibe os nomes dos grupos de expressão regular e o texto correspondido.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/cs/getgroupnames1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/vb/getgroupnames1.vb#1)]  
  
 Nesse caso, o padrão de expressão regular `\b(?<FirstWord>\w+)\s?((\w+)\s)*(?<LastWord>\w+)?(?<Punctuation>\p{Po})` destina-se para analisar uma frase simples e para identificar sua primeira palavra, a última palavra e a marca de pontuação final. A tabela a seguir mostra como o padrão de expressão regular é interpretado:  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\b`|Começa a correspondência em um limite de palavra.|  
|`(?<FirstWord>\w+)`|Corresponde a um ou mais caracteres de palavra. Esse é o `FirstWord` grupo nomeado.|  
|\s?|Corresponder a zero ou a um caractere de espaço em branco.|  
|(\w+)|Corresponde a um ou mais caracteres de palavra. Este é o segundo grupo de captura.|  
|\s|Corresponde a um caractere de espaço em branco.|  
|((\w+)\s)*|Corresponde a zero ou mais ocorrências de um ou mais caracteres de palavra seguidos por um espaço em branco. Este é o primeiro grupo de captura.|  
|(?\<LastWord>\w+)?|Corresponde a zero ou uma ocorrência de um ou mais caracteres de palavra. Esse é o `LastWord` grupo nomeado.|  
|(? \<Pontuação > \p{Po})|Corresponder a um caractere cuja categoria Unicode é a pontuação, outros. Esse é o `Punctuation` grupo nomeado.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Agrupando construtores em expressões regulares</related>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNumbers">
      <MemberSignature Language="C#" Value="public int[] GetGroupNumbers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] GetGroupNumbers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNumbers () As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ GetGroupNumbers();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNumbers : unit -&gt; int[]" Usage="regex.GetGroupNumbers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma matriz de números de grupo de captura que correspondem aos nomes de grupos em uma matriz.</summary>
        <returns>Uma matriz de inteiros de números de grupo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Grupos de captura nomeados e não podem ser acessados por um número. Grupos não nomeados são numerados da esquerda para direita, começando com 1. (Grupo de captura no índice 0 (zero) representa a correspondência como um todo).  Grupos nomeados são numerados da esquerda para direita, começando com um número que é maior que o número de sem nome grupos de captura.  
  
 Fazendo referência a um grupo por seu número, em vez de por nome de cadeia de caracteres pode fornecer um acesso mais rápido.  
  
   
  
## Examples  
 O exemplo a seguir define uma expressão regular, `\b((?<word>\w+)\s*)+(?<end>[.?!])`, que corresponde a uma sentença. A expressão regular inclui três grupos de captura: um grupo sem nome que captura uma palavra individual, juntamente com um caractere de espaço que pode segui-lo; um grupo chamado `word` que captura as palavras individuais na frase; e um grupo chamado `end` que captura a pontuação que termina a sentença. O exemplo chama o <xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A> método para obter os números de capturar todos os grupos e, em seguida, exibe sua cadeia de caracteres capturada. Além disso, o <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> método é usado para indicar se um grupo numerado específico corresponde a um grupo nomeado.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/cs/getgroupnumbers1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/vb/getgroupnumbers1.vb#1)]  
  
 O padrão da expressão regular é interpretado conforme a tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\b`|Começa a correspondência em um limite de palavra.|  
|`(?<word>\w+)`|Corresponde a um ou mais caracteres de palavra e o atribui as cadeias de caracteres correspondidas a um grupo chamado `word`.|  
|`\s*`|Corresponder a zero ou mais caracteres de espaço em branco.|  
|`((?<word>\w+)\s*)`|Atribuir o `word` grupo capturado, seguido por qualquer capturados caracteres de espaço em branco para o primeiro grupo capturado.|  
|`((?<word>\w+)\s*)+`|Corresponder ao padrão de um ou mais caracteres de palavra seguido por qualquer caractere de espaço em branco uma ou mais vezes.|  
|`(?<end>[.?!])`|Corresponde a um ponto, um ponto de interrogação ou um ponto de exclamação. Atribua o caractere correspondente para o `end` grupo de captura.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Agrupando construtores em expressões regulares</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNameFromNumber">
      <MemberSignature Language="C#" Value="public string GroupNameFromNumber (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GroupNameFromNumber(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNameFromNumber (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GroupNameFromNumber(int i);" />
      <MemberSignature Language="F#" Value="member this.GroupNameFromNumber : int -&gt; string" Usage="regex.GroupNameFromNumber i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">O número do grupo a ser convertido para o nome de grupo correspondente.</param>
        <summary>Obtém o nome do grupo que corresponde ao número do grupo especificado.</summary>
        <returns>Uma cadeia de caracteres que contém o nome de grupo associado ao número de grupo especificado. Se não houver nenhum nome de grupo que corresponda a <paramref name="i" />, o método retornará <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um padrão de expressão regular pode conter grupos captura nomeados ou numerados, que delineiam subexpressões dentro de uma correspondência de padrões. Grupos numerados que são delimitados pela sintaxe (*subexpressão*) e são atribuídos números com base em sua ordem na expressão regular. Grupos nomeados são delimitados pela sintaxe (?`<` *nome*`>`*subexpressão*) ou (?' *nome*'*subexpressão*), onde *nome* é o nome pelo qual a subexpressão será identificada. (Para saber mais, confira [Constructos de agrupamento](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)). O <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> método identifica grupos nomeados e numerados grupos por suas posições ordinais na expressão regular. A posição ordinal zero sempre representa a expressão regular inteira. Numerada todos os grupos são contados, em seguida, antes de grupos nomeados, independentemente de sua posição atual no padrão de expressão regular.  
  
 Se `i` é o número de um grupo nomeado, o método retorna o nome do grupo. Se `i` é o número de um grupo sem nome, o método retorna a representação de cadeia de caracteres do número. Por exemplo, se `i` for 1, o método retorna "1". Se `i` não é o número de um grupo de captura, o método retorna <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Se for encontrada uma correspondência de padrões, o valor retornado por esse método, em seguida, pode ser usado para recuperar o <xref:System.Text.RegularExpressions.Group> objeto que representa o grupo capturado do <xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType> propriedade. O <xref:System.Text.RegularExpressions.GroupCollection> objeto é retornado pelo <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir define um padrão de expressão regular que corresponde a uma linha de endereço que contém um nome de cidade dos EUA, nome do estado e CEP. O exemplo usa o <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> método para recuperar os nomes dos grupos de captura. Ele usa esses nomes para recuperar os grupos capturados correspondentes para correspondências.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/cs/groupnamefromnumberex.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/vb/groupnamefromnumberex.vb#1)]  
  
 O padrão de expressão regular é definido pela seguinte expressão:  
  
 `(?<city>[A-Za-z\s]+), (?<state>[A-Za-z]{2}) (?<zip>\d{5}(-\d{4})?)`  
  
 A tabela a seguir mostra como o padrão da expressão regular é interpretado.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`(?<city>[A-Za-z\s]+)`|Corresponder a um ou mais caractere alfabético ou espaço em branco. Atribuir o nome esse grupo capturado `city`.|  
|`,`|Corresponde a uma vírgula (,) seguida por um caractere de espaço em branco.|  
|`(?<state>[A-Za-z]{2})`|Corresponde a dois caracteres alfabéticos. Atribuir o nome esse grupo capturado `state`. Esse grupo deve ser seguido por um caractere de espaço em branco.|  
|`(?<zip>\d{5}(-\d{4})?)`|Corresponde a cinco dígitos numéricos seguidos por zero ou uma ocorrência de um hífen seguido por quatro dígitos. Atribuir o nome esse grupo capturado `zip`.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Agrupando construtores</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNumberFromName">
      <MemberSignature Language="C#" Value="public int GroupNumberFromName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GroupNumberFromName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNumberFromName (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GroupNumberFromName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GroupNumberFromName : string -&gt; int" Usage="regex.GroupNumberFromName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome do grupo a ser convertido para o número de grupo correspondente.</param>
        <summary>Retorna o número do grupo que corresponde ao nome do grupo especificado.</summary>
        <returns>O número do grupo que corresponde ao nome do grupo especificado ou -1 se <paramref name="name" /> não for um nome de grupo válido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um padrão de expressão regular pode conter grupos captura nomeados ou numerados, que delineiam subexpressões dentro de uma correspondência de padrões. Grupos numerados que são delimitados pela sintaxe (*subexpressão*) e são atribuídos números com base em sua ordem na expressão regular. Grupos nomeados são delimitados pela sintaxe (?`<` *nome*`>`*subexpressão*) ou (?' *nome*'*subexpressão*), onde *nome* é o nome pelo qual a subexpressão será identificada. (Para saber mais, confira [Constructos de agrupamento](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)). O <xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A> método identifica grupos nomeados e numerados grupos por suas posições ordinais na expressão regular. A posição ordinal zero sempre representa a expressão regular inteira. Numerada todos os grupos são contados, em seguida, antes de grupos nomeados, independentemente de sua posição atual no padrão de expressão regular.  
  
 Se `name` é a representação de cadeia de caracteres de um número de grupo que está presente no padrão de expressão regular, o método retorna esse número. Se `name` corresponde a uma nomeada captura o grupo que está presente no padrão de expressão regular, o método retornará seu número correspondente. A comparação de `name` com o grupo de nome diferencia maiusculas de minúsculas. Se `name` não corresponde ao nome de um grupo de captura ou para a representação de cadeia de caracteres do número de um grupo de captura, o método retornará -1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Agrupando construtores</related>
      </Docs>
    </Member>
    <Member MemberName="InfiniteMatchTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que uma operação de correspondência de padrões não deve atingir o tempo limite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> classe de construtor e um número de uso de métodos de correspondência estático a <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> constante para indicar que a tentativa de encontrar uma correspondência de padrões deve não atingir o tempo limite.  
  
> [!WARNING]
>  Definir o valor de tempo limite do mecanismo de expressões regulares como <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> pode fazer com que expressões regulares que confiam no retrocesso excessivo para parecer parar de responder durante o processamento de texto que quase corresponda ao padrão de expressão regular. Se você desabilitar os tempos limite, você deve garantir que sua expressão regular não confiar no retrocesso excessivo e que se trata de texto que quase corresponda ao padrão de expressão regular.  
>   
>  Para obter mais informações sobre como lidar com o retrocesso, consulte [retrocesso](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 O <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> constante que pode ser fornecida como o valor da `matchTimeout` argumento dos seguintes membros:  
  
-   <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.RegexCompilationInfo.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.String%2CSystem.String%2CSystem.Boolean%2CSystem.TimeSpan%29?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      </Docs>
    </Member>
    <Member MemberName="InitializeReferences">
      <MemberSignature Language="C#" Value="protected void InitializeReferences ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeReferences() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.InitializeReferences" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeReferences ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeReferences();" />
      <MemberSignature Language="F#" Value="member this.InitializeReferences : unit -&gt; unit" Usage="regex.InitializeReferences " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usado por um objeto <see cref="T:System.Text.RegularExpressions.Regex" /> gerado pelo método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">As referências já foram inicializadas.</exception>
      </Docs>
    </Member>
    <Member MemberName="internalMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.TimeSpan internalMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend internalMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="protected public: TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="F#" Value="val mutable internalMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.OptionalField(VersionAdded=2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A quantidade de tempo máxima que pode decorrer em uma operação de correspondência de padrões antes que a operação atinja o tempo limite.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsMatch">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica se a expressão regular encontra uma correspondência na cadeia de caracteres de entrada.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguagem de expressões regulares - referência rápida</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string -&gt; bool" Usage="regex.IsMatch input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <summary>Indica se a expressão regular especificada no construtor <see cref="T:System.Text.RegularExpressions.Regex" /> encontra uma correspondência em uma cadeia de caracteres de entrada especificada.</summary>
        <returns>
          <see langword="true" /> se a expressão regular encontrar uma correspondência; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> método normalmente é usado para validar uma cadeia de caracteres ou para garantir que uma cadeia de caracteres está em conformidade com um padrão específico sem recuperar essa cadeia de caracteres para a manipulação de subsequente. Se você quiser determinar se um ou mais cadeias de caracteres correspondem a um padrão de expressão regular e, em seguida, recuperá-los para a manipulação subsequente, a chamada a <xref:System.Text.RegularExpressions.Regex.Match%2A> ou <xref:System.Text.RegularExpressions.Regex.Matches%2A> método.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é lançada se o tempo de execução da operação de correspondência exceder o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um intervalo de tempo limite ao chamar o construtor, a exceção é lançada se a operação exceder qualquer valor de tempo limite estabelecido para o domínio do aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido na <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio do aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> método para determinar se uma cadeia de caracteres é um número de peça válido. A expressão regular pressupõe que o número de peça tem um formato específico que consiste em três conjuntos de caracteres separados por hifens. O primeiro conjunto que contém quatro caracteres, deve conter um caractere alfanumérico seguido por dois caracteres numéricos seguidos por um caractere alfanumérico. O segundo conjunto, que consiste em três caracteres, deve ser numérico. O terceiro conjunto consiste em quatro caracteres, deve ter três caracteres numéricos seguidos por um caractere alfanumérico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch2.vb#2)]  
  
 O padrão da expressão regular é:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 A tabela a seguir mostra como o padrão da expressão regular é interpretado.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`^`|Começa a correspondência no início da linha.|  
|`[a-zA-Z0-9]`|Corresponder um caractere alfabético único (`a` por meio `z` ou `A` por meio de `Z`) ou um caractere numérico.|  
|`\d{2}`|Corresponde a dois caracteres numéricos.|  
|`[a-zA-Z0-9]`|Corresponder um caractere alfabético único (`a` por meio `z` ou `A` por meio de `Z`) ou um caractere numérico.|  
|`-`|Corresponder a um hífen.|  
|`\d{3}`|Corresponde exatamente três caracteres numéricos.|  
|`(-\d{3}){2}`|Localizar um hífen seguido por três caracteres numéricos e corresponder duas ocorrências desse padrão.|  
|`[a-zA-Z0-9]`|Corresponder um caractere alfabético único (`a` por meio `z` ou `A` por meio de `Z`) ou um caractere numérico.|  
|`$`|Termina a correspondência no final da linha.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementos de linguagem de expressão regular</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String, startat As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string * int -&gt; bool" Usage="regex.IsMatch (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="startat">A posição do caractere em que a pesquisa será iniciada.</param>
        <summary>Indica se a expressão regular especificada no construtor <see cref="T:System.Text.RegularExpressions.Regex" /> encontra uma correspondência na cadeia de caracteres de entrada especificada, começando na posição inicial especificada na cadeia de caracteres.</summary>
        <returns>
          <see langword="true" /> se a expressão regular encontrar uma correspondência; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> método normalmente é usado para validar uma cadeia de caracteres ou para garantir que uma cadeia de caracteres está em conformidade com um padrão específico sem recuperar essa cadeia de caracteres para a manipulação de subsequente. Se você quiser determinar se um ou mais cadeias de caracteres correspondem a um padrão de expressão regular e, em seguida, recuperá-los para a manipulação subsequente, a chamada a <xref:System.Text.RegularExpressions.Regex.Match%2A> ou <xref:System.Text.RegularExpressions.Regex.Matches%2A> método.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é lançada se o tempo de execução da operação de correspondência exceder o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um intervalo de tempo limite ao chamar o construtor, a exceção é lançada se a operação exceder qualquer valor de tempo limite estabelecido para o domínio do aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido na <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio do aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> método para determinar se uma cadeia de caracteres é um número de peça válido. Ele procura por um número de parte que segue um caractere de dois-pontos (:) em uma cadeia de caracteres. O <xref:System.String.IndexOf%28System.Char%29> método é usado para determinar a posição do caractere dois-pontos, que é então passado para o <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> método. A expressão regular pressupõe que o número de peça tem um formato específico que consiste em três conjuntos de caracteres separados por hifens. O primeiro conjunto que contém quatro caracteres, deve conter um caractere alfanumérico seguido por dois caracteres numéricos seguidos por um caractere alfanumérico. O segundo conjunto, que consiste em três caracteres, deve ser numérico. O terceiro conjunto consiste em quatro caracteres, deve ter três caracteres numéricos seguidos por um caractere alfanumérico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch3.vb#3)]  
  
 O padrão da expressão regular é:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 A tabela a seguir mostra como o padrão da expressão regular é interpretado.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`[a-zA-Z0-9]`|Corresponder um caractere alfabético único (`a` por meio `z` ou `A` por meio de `Z`) ou um caractere numérico.|  
|`\d{2}`|Corresponde a dois caracteres numéricos.|  
|`[a-zA-Z0-9]`|Corresponder um caractere alfabético único (`a` por meio `z` ou `A` por meio de `Z`) ou um caractere numérico.|  
|`-`|Corresponder a um hífen.|  
|`\d{3}`|Corresponde exatamente três caracteres numéricos.|  
|`(-\d{3}){2}`|Localizar um hífen seguido por três caracteres numéricos e corresponder duas ocorrências desse padrão.|  
|`[a-zA-Z0-9]`|Corresponder um caractere alfabético único (`a` por meio `z` ou `A` por meio de `Z`) ou um caractere numérico.|  
|`$`|Termina a correspondência no final da linha.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> é menor que zero ou maior que o tamanho de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementos de linguagem de expressão regular</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <summary>Indica se a expressão regular especificada encontra uma correspondência na cadeia de caracteres de entrada especificada.</summary>
        <returns>
          <see langword="true" /> se a expressão regular encontrar uma correspondência; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> método normalmente é usado para validar uma cadeia de caracteres ou para garantir que uma cadeia de caracteres está em conformidade com um padrão específico sem recuperar essa cadeia de caracteres para a manipulação de subsequente. Se você quiser determinar se um ou mais cadeias de caracteres correspondem a um padrão de expressão regular e, em seguida, recuperá-los para a manipulação subsequente, a chamada a <xref:System.Text.RegularExpressions.Regex.Match%2A> ou <xref:System.Text.RegularExpressions.Regex.Matches%2A> método.  
  
 Estático <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> método é equivalente à construção de uma <xref:System.Text.RegularExpressions.Regex> objeto com o padrão de expressão regular especificado por `pattern` e chamar o <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> método de instância. Esse padrão de expressão regular é armazenado em cache para fornecer recuperação rápida pelo mecanismo de expressão regular.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que simbolicamente descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção será lançada se o tempo de execução da operação de correspondência exceder o intervalo de tempo limite especificado para o domínio do aplicativo no qual o método é chamado. Se nenhum tempo limite é definido nas propriedades do domínio do aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> método para determinar se uma cadeia de caracteres é um número de peça válido. A expressão regular pressupõe que o número de peça tem um formato específico que consiste em três conjuntos de caracteres separados por hifens. O primeiro conjunto que contém quatro caracteres, deve conter um caractere alfanumérico seguido por dois caracteres numéricos seguidos por um caractere alfanumérico. O segundo conjunto, que consiste em três caracteres, deve ser numérico. O terceiro conjunto consiste em quatro caracteres, deve ter três caracteres numéricos seguidos por um caractere alfanumérico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch1.vb#1)]  
  
 O padrão da expressão regular é:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 A tabela a seguir mostra como o padrão da expressão regular é interpretado.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`^`|Começa a correspondência no início da linha.|  
|`[a-zA-Z0-9]`|Corresponder um caractere alfabético único (`a` por meio `z` ou `A` por meio de `Z`) ou um caractere numérico.|  
|`\d{2}`|Corresponde a dois caracteres numéricos.|  
|`[a-zA-Z0-9]`|Corresponder um caractere alfabético único (`a` por meio `z` ou `A` por meio de `Z`) ou um caractere numérico.|  
|`-`|Corresponder a um hífen.|  
|`\d{3}`|Corresponde exatamente três caracteres numéricos.|  
|`(-\d{3}){2}`|Localizar um hífen seguido por três caracteres numéricos e corresponder duas ocorrências desse padrão.|  
|`[a-zA-Z0-9]`|Corresponder um caractere alfabético único (`a` por meio `z` ou `A` por meio de `Z`) ou um caractere numérico.|  
|`$`|Termina a correspondência no final da linha.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="pattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <block subset="none" type="usage">
          <para>Esse método expire após um intervalo que é igual ao valor de tempo limite padrão do domínio do aplicativo no qual o método é chamado. Se um valor de tempo limite não tiver sido definido para o domínio de aplicativo, o valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impede que o método de tempo limite, é usado. O método estático recomendado para verificar uma correspondência de padrões é <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite que você definir o intervalo de tempo limite.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementos de linguagem de expressão regular</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que fornece opções para correspondência.</param>
        <summary>Indica se a expressão regular especificada encontra uma correspondência na cadeia de caracteres de entrada especificada, usando as opções de correspondência especificadas.</summary>
        <returns>
          <see langword="true" /> se a expressão regular encontrar uma correspondência; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> método normalmente é usado para validar uma cadeia de caracteres ou para garantir que uma cadeia de caracteres está em conformidade com um padrão específico sem recuperar essa cadeia de caracteres para a manipulação de subsequente. Se você quiser determinar se um ou mais cadeias de caracteres correspondem a um padrão de expressão regular e, em seguida, recuperá-los para a manipulação subsequente, a chamada a <xref:System.Text.RegularExpressions.Regex.Match%2A> ou <xref:System.Text.RegularExpressions.Regex.Matches%2A> método.  
  
 Estático <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método é equivalente à construção de uma <xref:System.Text.RegularExpressions.Regex> objeto com o padrão de expressão regular especificado por `pattern` e as opções de expressão regular especificadas por `options` e chamando o <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> instância método. Esse padrão de expressão regular é armazenado em cache para fornecer recuperação rápida pelo mecanismo de expressão regular.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que simbolicamente descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção será lançada se o tempo de execução da operação de correspondência exceder o intervalo de tempo limite especificado para o domínio do aplicativo no qual o método é chamado. Se nenhum tempo limite é definido nas propriedades do domínio do aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> método para determinar se uma cadeia de caracteres é um número de peça válido. A expressão regular pressupõe que o número de peça tem um formato específico que consiste em três conjuntos de caracteres separados por hifens. O primeiro conjunto que contém quatro caracteres, deve conter um caractere alfanumérico seguido por dois caracteres numéricos seguidos por um caractere alfanumérico. O segundo conjunto, que consiste em três caracteres, deve ser numérico. O terceiro conjunto consiste em quatro caracteres, deve ter três caracteres numéricos seguidos por um caractere alfanumérico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch4.vb#4)]  
  
 O padrão da expressão regular é:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 A tabela a seguir mostra como o padrão da expressão regular é interpretado.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`^`|Começar a correspondência no início da cadeia de caracteres.|  
|`[A-Z0-9]`|Corresponder qualquer caractere alfabético único partir `A` por meio de `Z`, ou qualquer caractere numérico.|  
|`\d{2}`|Corresponde a dois caracteres numéricos.|  
|`[A-Z0-9]`|Corresponder qualquer caractere alfabético único partir `A` por meio de `Z`, ou qualquer caractere numérico.|  
|`-`|Corresponder a um hífen.|  
|`\d{3}`|Corresponde exatamente três caracteres numéricos.|  
|`(-\d{3}){2}`|Localizar um hífen seguido por três caracteres numéricos e corresponder a duas ocorrências desse padrão...|  
|`[A-Z0-9]`|Corresponder qualquer caractere alfabético único partir `A` por meio de `Z`, ou qualquer caractere numérico.|  
|`$`|Encerrar a correspondência ao final da cadeia de caracteres.|  
  
 Chamar o <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método com o `options` parâmetro definido como <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> é equivalente a definir a seguinte expressão regular:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Para comparação, consulte o exemplo para o <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="pattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> não é um valor <see cref="T:System.Text.RegularExpressions.RegexOptions" /> válido.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <block subset="none" type="usage">
          <para>Esse método expire após um intervalo que é igual ao valor de tempo limite padrão do domínio do aplicativo no qual ele é chamado. Se um valor de tempo limite não tiver sido definido para o domínio de aplicativo, o valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impede que o método de tempo limite, é usado. O método estático recomendado para verificar uma correspondência de padrões é <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite que você definir o intervalo de tempo limite.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementos de linguagem de expressão regular</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que fornece opções para correspondência.</param>
        <param name="matchTimeout">Um intervalo de tempo limite ou <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que o método não deve atingir o tempo limite.</param>
        <summary>Indica se a expressão regular especificada encontra uma correspondência na cadeia de caracteres de entrada especificada, usando as opções de correspondência e intervalo de tempo limite especificados.</summary>
        <returns>
          <see langword="true" /> se a expressão regular encontrar uma correspondência; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> método normalmente é usado para validar uma cadeia de caracteres ou para garantir que uma cadeia de caracteres está em conformidade com um padrão específico sem recuperar essa cadeia de caracteres para a manipulação de subsequente. Se você quiser determinar se um ou mais cadeias de caracteres correspondem a um padrão de expressão regular e, em seguida, recuperá-los para a manipulação subsequente, a chamada a <xref:System.Text.RegularExpressions.Regex.Match%2A> ou <xref:System.Text.RegularExpressions.Regex.Matches%2A> método.  
  
 Estático <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método é equivalente à construção de uma <xref:System.Text.RegularExpressions.Regex> objeto com o padrão de expressão regular especificado por `pattern` e as opções de expressão regular especificadas por `options` e chamando o <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> instância método. Esse padrão de expressão regular é armazenado em cache para fornecer recuperação rápida pelo mecanismo de expressão regular.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que simbolicamente descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O `matchTimeout` parâmetro especifica como long uma correspondência de método deve tentar encontrar uma correspondência antes de expirar. Como definir um intervalo de tempo limite impede que as expressões regulares que confiam no retrocesso excessivo do que parece parar de responder ao processar a entrada que contém correspondências próximas. Para obter mais informações, consulte [práticas recomendadas para expressões regulares](~/docs/standard/base-types/best-practices.md) e [retrocesso](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Se nenhuma correspondência for encontrada desse intervalo de tempo, o método gerará uma <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção. `matchTimeout` substitui qualquer valor de tempo limite padrão definido para o domínio do aplicativo no qual o método é executado.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método para determinar se uma cadeia de caracteres é um número de peça válido. A expressão regular pressupõe que o número de peça tem um formato específico que consiste em três conjuntos de caracteres separados por hifens. O primeiro conjunto que contém quatro caracteres, deve conter um caractere alfanumérico seguido por dois caracteres numéricos seguidos por um caractere alfanumérico. O segundo conjunto, que consiste em três caracteres, deve ser numérico. O terceiro conjunto consiste em quatro caracteres, deve ter três caracteres numéricos seguidos por um caractere alfanumérico. Correspondência de padrão de expressão regular deve envolver a mínima pesquisar a cadeia de caracteres de entrada, portanto, o método define um intervalo de tempo limite de 500 milissegundos.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch5.vb#5)]  
  
 O padrão da expressão regular é:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 A tabela a seguir mostra como o padrão da expressão regular é interpretado.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`^`|Começar a correspondência no início da cadeia de caracteres.|  
|`[A-Z0-9]`|Corresponder qualquer caractere alfabético único partir `A` por meio de `Z`, ou qualquer caractere numérico.|  
|`\d{2}`|Corresponde a dois caracteres numéricos.|  
|`[A-Z0-9]`|Corresponder qualquer caractere alfabético único partir `A` por meio de `Z`, ou qualquer caractere numérico.|  
|`-`|Corresponder a um hífen.|  
|`\d{3}`|Corresponde exatamente três caracteres numéricos.|  
|`(-\d{3}){2}`|Localizar um hífen seguido por três caracteres numéricos e corresponder duas ocorrências desse padrão.|  
|`[A-Z0-9]`|Corresponder qualquer caractere alfabético único partir `A` por meio de `Z`, ou qualquer caractere numérico.|  
|`$`|Encerrar a correspondência ao final da cadeia de caracteres.|  
  
 Chamar o <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método com o `options` parâmetro definido como <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> é equivalente a definir a seguinte expressão regular:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Para comparação, consulte o exemplo para o <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="pattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> não é um valor <see cref="T:System.Text.RegularExpressions.RegexOptions" /> válido.  
  
- ou - 
 <paramref name="matchTimeout" /> é negativo, zero ou maior que aproximadamente 24 dias.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite.</exception>
        <block subset="none" type="usage">
          <para>É recomendável que você defina o <paramref name="matchTimeout" /> parâmetro para um valor apropriado, como dois segundos. Se você desabilitar os tempos limite especificando <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, o mecanismo de expressão regular oferece um desempenho ligeiramente melhor. No entanto, você deve desabilitar os tempos limite somente sob as seguintes condições: 
-Quando a entrada processada por uma expressão regular é derivada de uma origem conhecida e confiável ou é formado por texto estático. Isso exclui o texto que tenha sido dinamicamente inseridos pelos usuários.  
  
-Quando o padrão de expressão regular tenha sido integralmente testado para garantir que ele manipulará com eficiência corresponde, não correspondências e o próximo corresponde.  
  
-Quando o padrão de expressão regular contém sem elementos de linguagem que são conhecidos por causar retrocesso excessivo durante o processamento de uma correspondência quase.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementos de linguagem de expressão regular</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Match">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pesquisa em uma cadeia de caracteres de entrada uma subcadeia de caracteres que corresponde a um padrão de expressão regular e retorna a primeira ocorrência como um único objeto <see cref="T:System.Text.RegularExpressions.Match" />.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguagem de expressões regulares - referência rápida</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Match : string -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <summary>Pesquisa a primeira ocorrência da expressão regular especificada na cadeia de caracteres de entrada especificada no construtor <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Um objeto que contém informações sobre a correspondência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> método retorna a primeira subcadeia de caracteres que corresponde a um padrão de expressão regular em uma cadeia de caracteres de entrada. Para obter informações sobre os elementos de linguagem usada para criar um padrão de expressão regular, consulte [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Você pode determinar se o padrão de expressão regular foi encontrado na cadeia de entrada Verificando o valor retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Group.Success%2A> propriedade. Se uma correspondência for encontrada, retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Capture.Value%2A> propriedade contém a subcadeia de caracteres de `input` que corresponde ao padrão de expressão regular. Se nenhuma correspondência for encontrada, seu valor é <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Esse método retorna a primeira subcadeia de caracteres em `input` que corresponde ao padrão de expressão regular. Você pode recuperar correspondências subsequentes chamando repetidamente retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> método. Você também pode recuperar todas as correspondências em uma única chamada de método chamando o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> método.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é lançada se o tempo de execução da operação de correspondência exceder o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um intervalo de tempo limite ao chamar o construtor, a exceção é lançada se a operação exceder qualquer valor de tempo limite estabelecido para o domínio do aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido na <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio do aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
   
  
## Examples  
 O exemplo a seguir localiza o padrão de expressão regular corresponde a uma cadeia de caracteres e, em seguida, lista correspondente grupos, capturas e posições de captura.  
  
 [!code-cpp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp#8)]
 [!code-csharp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs#8)]
 [!code-vb[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb#8)]  
  
 O padrão de expressão regular `(\w+)\s+(car)` corresponde a ocorrências da palavra "car" junto com a palavra que precede a ele. Ele será interpretado como mostrado na tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`(\w+)`|Corresponde a um ou mais caracteres de palavra. Este é o primeiro grupo de captura.|  
|`\s+`|Corresponde a um ou mais caracteres de espaço em branco.|  
|(car)|Corresponde a cadeia de caracteres literal "car". Este é o segundo grupo de captura.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguagem de expressões regulares - referência rápida</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, startat As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="startat">A posição do caractere baseada em zero na qual iniciar a pesquisa.</param>
        <summary>Procura a cadeia de caracteres de entrada para a primeira ocorrência de uma expressão regular, começando na posição inicial especificada na cadeia de caracteres.</summary>
        <returns>Um objeto que contém informações sobre a correspondência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> método retorna a primeira subcadeia de caracteres que corresponde a um padrão de expressão regular, iniciando em ou após o `startat` posição, em uma cadeia de caracteres de entrada de caracteres. Para obter informações sobre os elementos de linguagem usada para criar um padrão de expressão regular, consulte [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O padrão de expressão regular para o qual o <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> pesquisas de método é definido pela chamada para uma da <xref:System.Text.RegularExpressions.Regex> construtores da classe. Para obter mais informações sobre os elementos que podem formar uma expressão regular padrão, consulte [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Opcionalmente, você pode especificar uma posição inicial na cadeia de caracteres usando o `startat` parâmetro. Quando o mecanismo de expressão regular analisa da esquerda para a direita (o padrão), a correspondência e a verificação movem rightward, começando no caractere especificado na `startat`. Quando o mecanismo de expressão regular analisa da direita para esquerda (quando o padrão de expressão regular é construído com o <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> opção), a correspondência e a verificação mover na direção oposta e começar com o caractere na `startat` -1. Se você não especificar uma posição inicial, a pesquisa começará no padrão `startat` posição. Se a expressão regular pesquisa da esquerda para a direita, o padrão `startat` posição está na extremidade esquerda da `input`; se ele pesquisa da direita para a esquerda, o padrão `startat` posição está na extremidade direita da `input`.  
  
 Se você quiser restringir uma correspondência para que ele começa em uma posição de determinado caractere na cadeia de caracteres e o mecanismo de expressões regulares não examina o restante da cadeia de caracteres para uma correspondência, ancorar a expressão regular com um `\G` (à esquerda para uma esquerda para direita padrão, ou à direita de um padrão da direita para esquerda). Isso restringe a correspondência, portanto, ele deve começar exatamente no `startat`.  
  
 Você pode determinar se o padrão de expressão regular foi encontrado na cadeia de entrada Verificando o valor retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Group.Success%2A> propriedade. Se uma correspondência for encontrada, retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Capture.Value%2A> propriedade contém a subcadeia de caracteres de `input` que corresponde ao padrão de expressão regular. Se nenhuma correspondência for encontrada, seu valor é <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Esse método retorna a primeira subcadeia de caracteres encontrada em ou após o `startat` posição de caractere `input` que corresponde ao padrão de expressão regular. Você pode recuperar correspondências subsequentes chamando repetidamente retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> método. Você também pode recuperar todas as correspondências em uma única chamada de método chamando o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> método.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é lançada se o tempo de execução da operação de correspondência exceder o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um intervalo de tempo limite ao chamar o construtor, a exceção é lançada se a operação ultrapassa qualquer valor de tempo limite estabelecido para o domínio de aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido na <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio do aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> é menor que zero ou maior que o tamanho de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguagem de expressões regulares - referência rápida</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Match : string * string -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <summary>Pesquisa a primeira ocorrência da expressão regular especificada na cadeia de caracteres de entrada especificada.</summary>
        <returns>Um objeto que contém informações sobre a correspondência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> método retorna a primeira subcadeia de caracteres que corresponde a um padrão de expressão regular em uma cadeia de caracteres de entrada. Para obter informações sobre os elementos de linguagem usada para criar um padrão de expressão regular, consulte [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Estático <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> método é equivalente à construção de uma <xref:System.Text.RegularExpressions.Regex> do objeto com o padrão de expressão regular especificada e a instância de chamada <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> método. Nesse caso, o mecanismo de expressões regulares armazena em cache padrão de expressão regular.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que simbolicamente descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Você pode determinar se o padrão de expressão regular foi encontrado na cadeia de entrada Verificando o valor retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Group.Success%2A> propriedade. Se uma correspondência for encontrada, retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Capture.Value%2A> propriedade contém a subcadeia de caracteres de `input` que corresponde ao padrão de expressão regular. Se nenhuma correspondência for encontrada, seu valor é <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Esse método retorna a primeira subcadeia de caracteres em `input` que corresponde ao padrão de expressão regular. Você pode recuperar correspondências subsequentes chamando repetidamente retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> método. Você também pode recuperar todas as correspondências em uma única chamada de método chamando o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> método.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção será lançada se o tempo de execução da operação de correspondência exceder o intervalo de tempo limite especificado para o domínio do aplicativo no qual o método é chamado. Se nenhum tempo limite é definido nas propriedades do domínio do aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> método para localizar a primeira palavra que contém pelo menos um `z` caractere e, em seguida, chama o <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> método para encontrar as correspondências adicionais.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match1.vb#1)]  
  
 O padrão da expressão regular `\b\w*z+\w*\b` é interpretado conforme mostrado na tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\b`|Começa a correspondência em um limite de palavra.|  
|`\w*`|Corresponder a zero, um ou mais caracteres de palavra.|  
|`z+`|Corresponder a um ou mais ocorrências do `z` caractere.|  
|`\w*`|Corresponder a zero, um ou mais caracteres de palavra.|  
|`\b`|Termina a correspondência em um limite de palavra.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="pattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <block subset="none" type="usage">
          <para>Esse método expire após um intervalo que é igual ao valor de tempo limite padrão do domínio do aplicativo no qual ele é chamado. Se um valor de tempo limite não tiver sido definido para o domínio de aplicativo, o valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impede que o método de tempo limite, é usado. O método estático recomendado para recuperar uma correspondência de padrões é <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, que permite que você definir o intervalo de tempo limite.</para>
        </block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguagem de expressões regulares - referência rápida</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int beginning, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 beginning, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, beginning As Integer, length As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int beginning, int length);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, beginning, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="beginning" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="beginning">A posição do caractere baseado em zero na cadeia de caracteres de entrada que define a posição mais à esquerda a ser pesquisada.</param>
        <param name="length">O número de caracteres na subcadeia de caracteres a ser incluído na pesquisa.</param>
        <summary>Pesquisa a primeira ocorrência de uma expressão regular na cadeia de entrada, começando na posição inicial especificada e pesquisando apenas o número especificado de caracteres.</summary>
        <returns>Um objeto que contém informações sobre a correspondência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> método retorna a primeira subcadeia de caracteres que corresponde a um padrão de expressão regular em uma parte de uma cadeia de caracteres de entrada. Para obter informações sobre os elementos de linguagem usada para criar um padrão de expressão regular, consulte [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O padrão de expressão regular para o qual o <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> pesquisas de método é definido pela chamada para uma da <xref:System.Text.RegularExpressions.Regex> construtores da classe. Para obter mais informações sobre os elementos que podem formar uma expressão regular padrão, consulte [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> a parte da pesquisa de método `input` definido pelo `beginning` e `length` parâmetros para o padrão de expressão regular. `beginning` sempre define o índice do caractere mais à esquerda para incluir na pesquisa, e `length` define o número máximo de caracteres a procurar. Juntas, elas definem o intervalo de pesquisa. Se a pesquisa continua da esquerda para a direita (o padrão), o mecanismo de expressão regular pesquisará do caractere no índice `beginning` para o caractere no índice `beginning`  +  `length` – 1. Se o mecanismo de expressão regular foi instanciado usando o <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> opção para que a pesquisa continua da direita para a esquerda, as pesquisas de mecanismo de expressão regular do caractere no índice `beginning`  +  `length` – 1 para o caractere no índice `beginning`. Esse método retorna a primeira correspondência que encontrar dentro desse intervalo. Você pode recuperar correspondências subsequentes chamando repetidamente retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> método.  
  
 Você pode determinar se o padrão de expressão regular foi encontrado na cadeia de entrada Verificando o valor retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Group.Success%2A> propriedade. Se uma correspondência for encontrada, retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Capture.Value%2A> propriedade contém a subcadeia de caracteres de `input` que corresponde ao padrão de expressão regular. Se nenhuma correspondência for encontrada, seu valor é <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é lançada se o tempo de execução da operação de correspondência exceder o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um valor de tempo limite ao chamar o construtor, a exceção é lançada se a operação exceder qualquer valor de tempo limite estabelecido para o domínio do aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido na <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio do aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="beginning" /> é menor que zero ou maior que o tamanho de <paramref name="input" />.  
  
- ou - 
 <paramref name="length" /> é menor que zero ou maior que o tamanho de <paramref name="input" />.  
  
- ou - 
 <paramref name="beginning" /><see langword="+" /><paramref name="length" /><see langword="–1" /> identifica uma posição fora do intervalo de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguagem de expressões regulares - referência rápida</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que fornece opções para correspondência.</param>
        <summary>Procura a cadeia de caracteres de entrada para a primeira ocorrência da expressão regular especificada, usando as opções especificadas de correspondência.</summary>
        <returns>Um objeto que contém informações sobre a correspondência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método retorna a primeira subcadeia de caracteres que corresponde a um padrão de expressão regular em uma cadeia de caracteres de entrada. Para obter informações sobre os elementos de linguagem usada para criar um padrão de expressão regular, consulte [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Estático <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método é equivalente à construção de uma <xref:System.Text.RegularExpressions.Regex> do objeto com o <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> construtor e a instância de chamada <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> método.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que simbolicamente descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Você pode determinar se o padrão de expressão regular foi encontrado na cadeia de entrada Verificando o valor retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Group.Success%2A> propriedade. Se uma correspondência for encontrada, retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Capture.Value%2A> propriedade contém a subcadeia de caracteres de `input` que corresponde ao padrão de expressão regular. Se nenhuma correspondência for encontrada, seu valor é <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Esse método retorna a primeira subcadeia de caracteres encontrada no `input` que corresponde ao padrão de expressão regular. Você pode recuperar correspondências subsequentes chamando repetidamente retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Match.NextMatch%2A> método. Você também pode recuperar todas as correspondências em uma única chamada de método chamando o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> método.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção será lançada se o tempo de execução da operação de correspondência exceder o intervalo de tempo limite especificado para o domínio do aplicativo no qual o método é chamado. Se nenhum tempo limite é definido nas propriedades do domínio do aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
   
  
## Examples  
 O exemplo a seguir define uma expressão regular que corresponde a palavras que começam com a letra "a". Ele usa o <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> opção para garantir que a expressão regular localiza palavras iniciadas com os dois em letras maiusculas em minúsculas de "a" e a "a".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match2.vb#2)]  
  
 O padrão da expressão regular `\ba\w*\b` é interpretado conforme mostrado na tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\b`|Começa a correspondência em um limite de palavra.|  
|`a`|Corresponde ao caractere "a".|  
|`\w*`|Corresponder a zero, um ou mais caracteres de palavra.|  
|`\b`|Termina a correspondência em um limite de palavra.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="pattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> não é uma combinação bit a bit válida de valores de <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <block subset="none" type="usage">
          <para>Esse método expire após um intervalo que é igual ao valor de tempo limite padrão do domínio do aplicativo no qual ele é chamado. Se um valor de tempo limite não tiver sido definido para o domínio de aplicativo, o valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impede que o método de tempo limite, é usado. O método estático recomendado para recuperar uma correspondência de padrões é <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, que permite que você definir o intervalo de tempo limite.</para>
        </block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguagem de expressões regulares - referência rápida</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que fornece opções para correspondência.</param>
        <param name="matchTimeout">Um intervalo de tempo limite ou <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que o método não deve atingir o tempo limite.</param>
        <summary>Pesquisa a cadeia de caracteres de entrada da primeira ocorrência da expressão regular especificada, usando as opções de correspondência e intervalo de tempo limite especificados.</summary>
        <returns>Um objeto que contém informações sobre a correspondência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método retorna a primeira subcadeia de caracteres que corresponde a um padrão de expressão regular em uma cadeia de caracteres de entrada. Para obter informações sobre os elementos de linguagem usada para criar um padrão de expressão regular, consulte [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Estático <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método é equivalente à construção de uma <xref:System.Text.RegularExpressions.Regex> do objeto com o <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> construtor e a instância de chamada <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> método.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que simbolicamente descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Você pode determinar se o padrão de expressão regular foi encontrado na cadeia de entrada Verificando o valor retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Group.Success%2A> propriedade. Se uma correspondência for encontrada, retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Capture.Value%2A> propriedade contém a subcadeia de caracteres de `input` que corresponde ao padrão de expressão regular. Se nenhuma correspondência for encontrada, seu valor é <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Esse método retorna a primeira subcadeia de caracteres encontrada no `input` que corresponde ao padrão de expressão regular. Você pode recuperar correspondências subsequentes chamando repetidamente retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Match.NextMatch%2A> método. Você também pode recuperar todas as correspondências em uma única chamada de método chamando o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> método.  
  
 O `matchTimeout` parâmetro especifica como long uma correspondência de método deve tentar encontrar uma correspondência antes de expirar. Como definir um intervalo de tempo limite impede que as expressões regulares que confiam no retrocesso excessivo do que parece parar de responder ao processar a entrada que contém correspondências próximas. Para obter mais informações, consulte [práticas recomendadas para expressões regulares](~/docs/standard/base-types/best-practices.md) e [retrocesso](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Se nenhuma correspondência for encontrada desse intervalo de tempo, o método gerará uma <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção. `matchTimeout` substitui qualquer valor de tempo limite padrão definido para o domínio do aplicativo no qual o método é executado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="pattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> não é uma combinação bit a bit válida de valores de <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
- ou - 
 <paramref name="matchTimeout" /> é negativo, zero ou maior que aproximadamente 24 dias.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <block subset="none" type="usage">
          <para>É recomendável que você defina o <paramref name="matchTimeout" /> parâmetro para um valor apropriado, como dois segundos. Se você desabilitar os tempos limite especificando <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, o mecanismo de expressão regular oferece um desempenho ligeiramente melhor. No entanto, você deve desabilitar os tempos limite somente sob as seguintes condições: 
-Quando a entrada processada por uma expressão regular é derivada de uma origem conhecida e confiável ou é formado por texto estático. Isso exclui o texto que tenha sido dinamicamente inseridos pelos usuários.  
  
-Quando o padrão de expressão regular tenha sido integralmente testado para garantir que ele manipulará com eficiência corresponde, não correspondências e o próximo corresponde.  
  
-Quando o padrão de expressão regular contém sem elementos de linguagem que são conhecidos por causar retrocesso excessivo durante o processamento de uma correspondência quase.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguagem de expressões regulares - referência rápida</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Matches">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pesquisa em uma cadeia de caracteres de entrada todas as ocorrências de uma expressão regular e retorna todas as correspondências.</summary>
        <block subset="none" type="usage">
          <para>Quando uma tentativa de correspondência é repetida, chamando o <see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /> método, o mecanismo de expressões regulares fornece correspondências vazias tratamento especial. Geralmente, o mecanismo de expressões regulares começa a pesquisa para a próxima correspondência exatamente onde a correspondência anterior parou. No entanto, após uma correspondência vazia, o mecanismo de expressões regulares avança um caractere antes de tentar a próxima correspondência. Esse comportamento garante que o mecanismo de expressão regular será percorre a cadeia de caracteres. Caso contrário, como uma correspondência vazia não resulte em qualquer movimento de avanço, começaria a próxima correspondência exatamente no mesmo local que a correspondência anterior, e ela corresponderia repetidamente a mesma cadeia de caracteres vazia.  
  
No exemplo a seguir, o padrão de expressão regular <c>um *</c> procura por zero ou mais ocorrências da letra "a" na cadeia de caracteres "abaabb". Como a saída do exemplo mostra, resultante <see cref="T:System.Text.RegularExpressions.MatchCollection" /> objeto contém seis <see cref="T:System.Text.RegularExpressions.Match" /> objetos. A primeira tentativa de correspondência localiza o primeiro "a". O segundo inicia de correspondência de exatamente onde a primeira correspondem termina antes do primeiro b; ele localiza zero ocorrências de "a" e retorna uma cadeia de caracteres vazia. A terceira correspondência não começar a exatamente onde a segunda correspondência terminou, pois a segunda correspondência retornou uma cadeia de caracteres vazia. Em vez disso, ele começa a um caractere mais tarde, após o primeiro "b". A terceira correspondência localiza duas ocorrências de "a" e retorna "aa". A quarta tentativa de correspondência começa onde a terceira correspondência terminou, antes do segundo "b" e retorna uma cadeia de caracteres vazia. A quinta tentativa de correspondência novamente avança um caractere para que ele começa antes do terceiro "b" e retorna uma cadeia de caracteres vazia. A sexta correspondência começa após o último "b" e retorna uma cadeia de caracteres vazia novamente.  
  
[! código csharp[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/emptymatches1.cs#9)] [! código vb[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/emptymatches1.vb#9)]</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguagem de expressões regulares - referência rápida</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Matches : string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <summary>Pesquisa todas as ocorrências de uma expressão regular na cadeia de caracteres de entrada especificada.</summary>
        <returns>Uma coleção dos objetos <see cref="T:System.Text.RegularExpressions.Match" /> encontrados pela pesquisa. Se nenhuma correspondência for encontrada, o método retornará um objeto de coleção vazio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> método é semelhante ao <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> método, exceto que ele retorna informações sobre todas as correspondências encontradas na cadeia de entrada, em vez de uma única correspondência. É equivalente ao seguinte código:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#5)]  
  
 A coleção inclui apenas as correspondências e termina na primeira não-correspondência.  
  
 O padrão de expressão regular para o qual o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> pesquisas de método é definido pela chamada para uma da <xref:System.Text.RegularExpressions.Regex> construtores da classe. Para obter mais informações sobre os elementos que podem formar uma expressão regular padrão, consulte [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O <xref:System.Text.RegularExpressions.Regex.Matches%2A> método usa a avaliação lenta para preencher retornado <xref:System.Text.RegularExpressions.MatchCollection> objeto. Acessando membros desta coleção, como <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> e <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> faz com que a coleção a ser preenchido imediatamente. Para aproveitar a avaliação lenta, você deve iterar a coleção usando uma construção, tais como `foreach` em c# e `For Each`...`Next` no Visual Basic.  
  
 Por causa de sua avaliação lenta, chamando o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> método não lança uma <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção. No entanto, a exceção é lançada quando uma operação é executada na <xref:System.Text.RegularExpressions.MatchCollection> objeto retornado por esse método, se o <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> não é de propriedade <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> e uma operação de correspondência excede o intervalo de tempo limite.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> método para identificar quaisquer palavras em uma sentença que terminam em "es".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches1.vb#1)]  
  
 O padrão de expressão regular `\b\w+es\b` é definido conforme mostrado na tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\b`|Começa a correspondência em um limite de palavra.|  
|`\w+`|Corresponde a um ou mais caracteres de palavra.|  
|`es`|Corresponde a cadeia de caracteres literal "es".|  
|`\b`|Termina a correspondência em um limite de palavra.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> é <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementos de linguagem de expressão regular</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String, startat As Integer) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Matches : string * int -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="startat">A posição do caractere na cadeia de caracteres de entrada na qual a pesquisa será iniciada.</param>
        <summary>Pesquisa a cadeia de caracteres de entrada especificada para todas as ocorrências de uma expressão regular, começando na posição inicial especificada na cadeia de caracteres.</summary>
        <returns>Uma coleção dos objetos <see cref="T:System.Text.RegularExpressions.Match" /> encontrados pela pesquisa. Se nenhuma correspondência for encontrada, o método retornará um objeto de coleção vazio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> método é semelhante ao <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> método, exceto que ele retorna informações sobre todas as correspondências encontradas na cadeia de entrada, em vez de uma única correspondência. É equivalente ao seguinte código:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#6)]  
  
 O padrão de expressão regular para o qual o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> pesquisas de método é definido pela chamada para uma da <xref:System.Text.RegularExpressions.Regex> construtores da classe. Para obter mais informações sobre os elementos que podem formar uma expressão regular padrão, consulte [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O <xref:System.Text.RegularExpressions.Regex.Matches%2A> método usa a avaliação lenta para preencher retornado <xref:System.Text.RegularExpressions.MatchCollection> objeto. Acessando membros desta coleção, como <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> e <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> faz com que a coleção a ser preenchido imediatamente. Para aproveitar a avaliação lenta, você deve iterar a coleção usando uma construção, tais como `foreach` em c# e `For Each`...`Next` no Visual Basic.  
  
 Por causa de sua avaliação lenta, chamando o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> método não lança uma <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção. No entanto, a exceção é lançada quando uma operação é executada na <xref:System.Text.RegularExpressions.MatchCollection> objeto retornado por esse método, se o <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> não é de propriedade <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> e uma operação de correspondência excede o intervalo de tempo limite...  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> método para localizar a primeira palavra em uma sentença que termina em "es" e, em seguida, chama o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> método para identificar qualquer palavra adicional que terminam em "es".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches3.vb#3)]  
  
 O padrão de expressão regular `\b\w+es\b` é definido conforme mostrado na tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\b`|Começa a correspondência em um limite de palavra.|  
|`\w+`|Corresponde a um ou mais caracteres de palavra.|  
|`es`|Corresponde a cadeia de caracteres literal "es".|  
|`\b`|Termina a correspondência em um limite de palavra.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> é menor que zero ou maior que o tamanho de <paramref name="input" />.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementos de linguagem de expressão regular</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <summary>Pesquisa todas as ocorrências de uma expressão regular especificada na cadeia de entrada especificada.</summary>
        <returns>Uma coleção dos objetos <see cref="T:System.Text.RegularExpressions.Match" /> encontrados pela pesquisa. Se nenhuma correspondência for encontrada, o método retornará um objeto de coleção vazio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> método é semelhante ao <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> método, exceto que ele retorna informações sobre todas as correspondências encontradas na cadeia de entrada, em vez de uma única correspondência. É equivalente ao seguinte código:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#7)]  
  
 Estático `Matches` métodos são equivalentes a construção de uma <xref:System.Text.RegularExpressions.Regex> do objeto com o padrão de expressão regular especificada e chamando o método de instância `Matches`.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que simbolicamente descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O <xref:System.Text.RegularExpressions.Regex.Matches%2A> método usa a avaliação lenta para preencher retornado <xref:System.Text.RegularExpressions.MatchCollection> objeto. Acessando membros desta coleção, como <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> e <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> faz com que a coleção a ser preenchido imediatamente. Para aproveitar a avaliação lenta, você deve iterar a coleção usando uma construção, tais como `foreach` em c# e `For Each`...`Next` no Visual Basic.  
  
 Por causa de sua avaliação lenta, chamando o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> método não lança uma <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção. No entanto, a exceção é lançada quando uma operação é executada no <xref:System.Text.RegularExpressions.MatchCollection> objeto retornado por esse método, se um intervalo de tempo limite é definido pela propriedade "REGEX_DEFAULT_MATCH_TIMEOUT" do domínio do aplicativo atual e a operação de correspondência excede esse intervalo de tempo limite.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> método para identificar todas as palavras em uma sentença que termina em "es".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches2.vb#2)]  
  
 O padrão de expressão regular `\b\w+es\b` é definido conforme mostrado na tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\b`|Começa a correspondência em um limite de palavra.|  
|`\w+`|Corresponde a um ou mais caracteres de palavra.|  
|`es`|Corresponde a cadeia de caracteres literal "es".|  
|`\b`|Termina a correspondência em um limite de palavra.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="pattern" /> é <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Esse método expire após um intervalo que é igual ao valor de tempo limite padrão do domínio do aplicativo no qual ele é chamado. Se um valor de tempo limite não tiver sido definido para o domínio de aplicativo, o valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impede que o método de tempo limite, é usado. O método estático recomendado para recuperar o padrão de várias correspondências é <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite que você especifique o intervalo de tempo limite.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementos de linguagem de expressão regular</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que especifica opções para correspondência.</param>
        <summary>Pesquisa todas as ocorrências de uma expressão regular especificada na cadeia de caracteres de entrada especificada, usando as opções de correspondência especificadas.</summary>
        <returns>Uma coleção dos objetos <see cref="T:System.Text.RegularExpressions.Match" /> encontrados pela pesquisa. Se nenhuma correspondência for encontrada, o método retornará um objeto de coleção vazio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método é semelhante ao <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método, exceto que ele retorna informações sobre todas as correspondências encontradas na cadeia de entrada, em vez de uma única correspondência. É equivalente ao seguinte código:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#8)]  
  
 Estático `Matches` métodos são equivalentes a construção de uma <xref:System.Text.RegularExpressions.Regex> do objeto com o padrão de expressão regular especificada e chamando o método de instância `Matches`.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que simbolicamente descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O <xref:System.Text.RegularExpressions.Regex.Matches%2A> método usa a avaliação lenta para preencher retornado <xref:System.Text.RegularExpressions.MatchCollection> objeto. Acessando membros desta coleção, como <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> e <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> faz com que a coleção a ser preenchido imediatamente. Para aproveitar a avaliação lenta, você deve iterar a coleção usando uma construção, tais como `foreach` em c# e `For Each`...`Next` no Visual Basic.  
  
 Por causa de sua avaliação lenta, chamando o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> método não lança uma <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção. No entanto, a exceção é lançada quando uma operação é executada no <xref:System.Text.RegularExpressions.MatchCollection> objeto retornado por esse método, se um intervalo de tempo limite é definido pela propriedade "REGEX_DEFAULT_MATCH_TIMEOUT" do domínio do aplicativo atual e a operação de correspondência excede esse intervalo de tempo limite.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> método para identificar todas as palavras em uma sentença que termina em "es" e, em seguida, chama o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método para executar uma comparação diferencia maiusculas de minúsculas do padrão com a cadeia de caracteres de entrada. Como mostra a saída, os dois métodos retornam resultados diferentes.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches4.vb#4)]  
  
 O padrão de expressão regular `\b\w+es\b` é definido conforme mostrado na tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\b`|Começa a correspondência em um limite de palavra.|  
|`\w+`|Corresponde a um ou mais caracteres de palavra.|  
|`es`|Corresponde a cadeia de caracteres literal "es".|  
|`\b`|Termina a correspondência em um limite de palavra.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="pattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> não é uma combinação bit a bit válida de valores de <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <block subset="none" type="usage">
          <para>Esse método expire após um intervalo que é igual ao valor de tempo limite padrão do domínio do aplicativo no qual ele é chamado. Se um valor de tempo limite não tiver sido definido para o domínio de aplicativo, o valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impede que o método de tempo limite, é usado. O método estático recomendado para recuperar o padrão de várias correspondências é <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite que você definir o intervalo de tempo limite.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementos de linguagem de expressão regular</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que especifica opções para correspondência.</param>
        <param name="matchTimeout">Um intervalo de tempo limite ou <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que o método não deve atingir o tempo limite.</param>
        <summary>Pesquisa todas as ocorrências de uma expressão regular especificada na cadeia de caracteres de entrada especificada, usando as opções de correspondência especificadas e o intervalo de tempo limite.</summary>
        <returns>Uma coleção dos objetos <see cref="T:System.Text.RegularExpressions.Match" /> encontrados pela pesquisa. Se nenhuma correspondência for encontrada, o método retornará um objeto de coleção vazio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método é semelhante ao <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método, exceto que ele retorna informações sobre todas as correspondências encontradas na cadeia de entrada, em vez de uma única correspondência. É equivalente ao seguinte código:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#10)]  
  
 Estático `Matches` métodos são equivalentes a construção de uma <xref:System.Text.RegularExpressions.Regex> do objeto com o padrão de expressão regular especificada e chamando o método de instância `Matches`.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que simbolicamente descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O <xref:System.Text.RegularExpressions.Regex.Matches%2A> método usa a avaliação lenta para preencher retornado <xref:System.Text.RegularExpressions.MatchCollection> objeto. Acessando membros desta coleção, como <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> e <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> faz com que a coleção a ser preenchido imediatamente. Para aproveitar a avaliação lenta, você deve iterar a coleção usando uma construção, tais como `foreach` em c# e `For Each`...`Next` no Visual Basic.  
  
 Por causa de sua avaliação lenta, chamando o <xref:System.Text.RegularExpressions.Regex.Matches%2A> método não lança uma <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção. No entanto, uma exceção é lançada quando uma operação é executada na <xref:System.Text.RegularExpressions.MatchCollection> objeto retornado por esse método, se uma operação de correspondência exceder esse intervalo de tempo limite especificado pelo`matchTimeout` parâmetro.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método para executar uma comparação diferencia maiusculas de minúsculas que corresponde a qualquer palavra em uma sentença que termina em "es". Em seguida, ele chama o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método para executar uma comparação diferencia maiusculas de minúsculas do padrão com a cadeia de caracteres de entrada. Em ambos os casos, o intervalo de tempo limite é definido como um segundo. Como mostra a saída, os dois métodos retornam resultados diferentes.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches5.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches5.vb#11)]  
  
 O padrão de expressão regular `\b\w+es\b` é definido conforme mostrado na tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\b`|Começa a correspondência em um limite de palavra.|  
|`\w+`|Corresponde a um ou mais caracteres de palavra.|  
|`es`|Corresponde a cadeia de caracteres literal "es".|  
|`\b`|Termina a correspondência em um limite de palavra.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="pattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> não é uma combinação bit a bit válida de valores de <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
- ou - 
 <paramref name="matchTimeout" /> é negativo, zero ou maior que aproximadamente 24 dias.</exception>
        <block subset="none" type="usage">
          <para>É recomendável que você defina o <paramref name="matchTimeout" /> parâmetro para um valor apropriado, como dois segundos. Se você desabilitar os tempos limite especificando <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, o mecanismo de expressão regular oferece um desempenho ligeiramente melhor. No entanto, você deve desabilitar os tempos limite somente sob as seguintes condições: 
-Quando a entrada processada por uma expressão regular é derivada de uma origem conhecida e confiável ou é formado por texto estático. Isso exclui o texto que tenha sido dinamicamente inseridos pelos usuários.  
  
-Quando o padrão de expressão regular tenha sido integralmente testado para garantir que ele manipulará com eficiência corresponde, não correspondências e o próximo corresponde.  
  
-Quando o padrão de expressão regular contém sem elementos de linguagem que são conhecidos por causar retrocesso excessivo durante o processamento de uma correspondência quase.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementos de linguagem de expressão regular</related>
      </Docs>
    </Member>
    <Member MemberName="MatchTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan MatchTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MatchTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MatchTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MatchTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o intervalo de tempo limite da instância atual.</summary>
        <value>O intervalo de tempo máximo que pode decorrer em uma operação de correspondência de padrão antes que uma <see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" /> seja lançada ou <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> se os tempos limite estão desabilitados.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> propriedade define o intervalo de tempo máximo aproximado para um <xref:System.Text.RegularExpressions.Regex> instância para executar uma única operação correspondente antes da operação expirar. O mecanismo de expressões regulares gerará um <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção durante sua próxima verificação de tempo depois de decorrido o intervalo de tempo limite. Isso impede que o mecanismo de expressões regulares do processamento de cadeias de caracteres de entrada que exigem o retrocesso excessivo. Para obter mais informações, consulte [retrocesso](~/docs/standard/base-types/backtracking-in-regular-expressions.md) e [práticas recomendadas para expressões regulares](~/docs/standard/base-types/best-practices.md).  
  
 Esta propriedade é somente para leitura. Você pode definir explicitamente o valor de um indivíduo <xref:System.Text.RegularExpressions.Regex> objeto chamando o <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor; e você pode definir seu valor para todas as <xref:System.Text.RegularExpressions.Regex> operações em um domínio de aplicativo de correspondência, chamando o <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> método e fornecendo um <xref:System.TimeSpan> valor para a propriedade "REGEX_DEFAULT_MATCH_TIMEOUT", como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/cs/regexmatchtimeout1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/vb/regexmatchtimeout1.vb#1)]  
  
 Se você não definir explicitamente um intervalo de tempo limite, o valor padrão <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> é usadas e de correspondência de operações não têm tempo limite.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.RegexOptions Options { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.RegularExpressions.RegexOptions Options" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Options" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Options As RegexOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::RegularExpressions::RegexOptions Options { System::Text::RegularExpressions::RegexOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.Options : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.Options" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém as opções que foram passadas para o construtor <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <value>Um ou mais membros da enumeração <see cref="T:System.Text.RegularExpressions.RegexOptions" /> que representa as opções que foram passadas para o construtor <see cref="T:System.Text.RegularExpressions.Regex" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de <xref:System.Text.RegularExpressions.Regex.Options%2A> propriedade consiste em um ou mais membros do <xref:System.Text.RegularExpressions.RegexOptions> enumeração. Se nenhuma opção foi definida na <xref:System.Text.RegularExpressions.Regex> construtor de classe, seu valor é <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>. As opções disponíveis são discutidas em detalhes na [opções de expressão Regular](~/docs/standard/base-types/regular-expression-options.md) tópico.  
  
 Observe que o <xref:System.Text.RegularExpressions.Regex.Options%2A> propriedade não reflete opções embutidas definidas na expressão regular padrão em si.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> é a classe base das expressões regulares criadas pelo <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> método. Essas expressões regulares compiladas usam a implementação da classe base a <see cref="P:System.Text.RegularExpressions.Regex.Options" /> propriedade. Se for chamado de uma classe derivada, o <see cref="P:System.Text.RegularExpressions.Regex.Options" /> propriedade retorna as opções que foram passadas para o <paramref name="options" /> parâmetro do <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> construtor da classe que foi usado para definir a expressão regular.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/c82dc689-7e82-4767-a18d-cd24ce5f05e9">Opções de expressões regulares</related>
      </Docs>
    </Member>
    <Member MemberName="pattern">
      <MemberSignature Language="C#" Value="protected internal string pattern;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string pattern" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.pattern" />
      <MemberSignature Language="VB.NET" Value="Protected Friend pattern As String " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::String ^ pattern;" />
      <MemberSignature Language="F#" Value="val mutable pattern : string" Usage="System.Text.RegularExpressions.Regex.pattern" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Usado por um objeto <see cref="T:System.Text.RegularExpressions.Regex" /> gerado pelo método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Em uma cadeia de caracteres de entrada especificada, substitui as cadeias de caracteres que correspondem a um padrão de expressão regular por uma cadeia de caracteres de substituição especificada.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguagem de expressões regulares - referência rápida</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Substituições</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="regex.Replace (input, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="replacement">A cadeia de caracteres substituta.</param>
        <summary>Em uma cadeia de caracteres de entrada especificada, substitui todas as cadeias de caracteres que correspondem a um padrão de expressão regular por uma cadeia de caracteres de substituição especificada.</summary>
        <returns>Uma nova cadeia de caracteres idêntica à cadeia de caracteres de entrada, com exceção de que a cadeia de caracteres de substituição substitui cada cadeia de caracteres correspondente. Se o padrão de expressão regular não tiver uma correspondência na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pesquisa para encontrar correspondências começa no início do `input` cadeia de caracteres. A expressão regular é o padrão definido pelo construtor atual <xref:System.Text.RegularExpressions.Regex> objeto.  
  
 O `replacement` parâmetro especifica a cadeia de caracteres substituir cada correspondência na `input`. `replacement` pode consistir em qualquer combinação de texto literal e [substituições](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Por exemplo, o padrão de substituição `a*${test}b` insere a cadeia de caracteres "um *" seguido de subcadeia de caracteres que é correspondida pelo `test` grupo de captura, se houver, seguido pela cadeia de caracteres "b". O * caractere não é reconhecido como um metacaractere dentro de um padrão de substituição.  
  
> [!NOTE]
>  As substituições são os elementos de linguagem de expressão regular só são reconhecidos em um padrão de substituição. Todos os outros elementos de linguagem de expressão regular, incluindo [escapes de caracteres](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), são permitidas nos padrões de expressão regular apenas e não são reconhecidos em padrões de substituição.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção será lançada se o tempo de execução da operação de substituição excede o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um intervalo de tempo limite ao chamar o construtor, a exceção é lançada se a operação exceder qualquer valor de tempo limite estabelecido para o domínio do aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido na <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio do aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada  
  
 Como o método retorna `input` inalterado se não houver nenhuma correspondência, você pode usar o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar se o método tiver feito qualquer substituição para a cadeia de caracteres de entrada.  
  
   
  
## Examples  
 O exemplo a seguir define uma expressão regular, `\s+`, que corresponde a um ou mais caracteres de espaço em branco. A cadeia de caracteres de substituição, "", os substitui por um único caractere de espaço.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample5.vb#5)]  
  
 O exemplo a seguir define uma expressão regular, `(\p{Sc}\s?)?(\d+\.?((?<=\.)\d+)?)(?(1)|\s?\p{Sc})?`e um padrão de substituição, `$2`, que remove um líder ou um símbolo de moeda à direita de um valor numérico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample7.vb#7)]  
  
 A expressão regular é interpretada conforme mostrado na tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\p{Sc}`|Corresponde a um símbolo de moeda. `{Sc}` indica que qualquer caractere que é um membro do símbolo Unicode, categoria de moeda.|  
|`\s?`|Corresponder a zero ou a um caractere de espaço em branco.|  
|`(\p{Sc}\s?)?`|Corresponde a zero ou uma ocorrência da combinação de um símbolo de moeda seguido por zero ou um caractere de espaço em branco. Este é o primeiro grupo de captura.|  
|`\d+`|Corresponde a um ou mais dígitos decimais.|  
|`\.?`|Corresponde a zero ou uma ocorrência de um período (usado como um caractere separador decimal).|  
|`((?<=\.)\d+)?`|Se um período for o caractere anterior, corresponda a um ou mais dígitos decimais. Esse padrão pode corresponder a zero ou um tempo.|  
|`(\d+\.?((?<=\.)\d+)?)`|Corresponder ao padrão de um ou mais dígitos decimais seguidos por um período opcional e dígitos decimais adicionais. Este é o segundo grupo de captura. A chamada para o <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29> método substitui a correspondência inteira com o valor desse grupo capturado.|  
|<code>(?(1)&#124;\s?\p{Sc})?</code>|Se o primeiro grupo capturado existir, corresponde uma cadeia de caracteres vazia. Caso contrário, corresponde a zero ou um caractere de espaço em branco seguido por um símbolo de moeda.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="replacement" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguagem de expressões regulares - referência rápida</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Substituições</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="regex.Replace (input, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="evaluator">Um método personalizado que examina cada correspondência e retorna a cadeia de caracteres correspondida original ou uma cadeia de caracteres de substituição.</param>
        <summary>Em uma cadeia de caracteres de entrada especificada, substitui todas as cadeias de caracteres que correspondem a uma expressão regular especificada por uma cadeia de caracteres retornada por um delegado <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Uma nova cadeia de caracteres é idêntica à cadeia de entrada, com exceção de que a cadeia de substituição substitui cada cadeia de caracteres correspondente. Se o padrão de expressão regular não tiver uma correspondência na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> método é útil para trocar uma correspondência da expressão regular, se qualquer uma das seguintes condições for verdadeira:  
  
-   A cadeia de caracteres de substituição prontamente não pode ser especificada por um padrão de substituição de expressão regular.  
  
-   Os resultados da cadeia de caracteres de substituição de algum processamento feito na cadeia de caracteres correspondida.  
  
-   Os resultados da cadeia de caracteres de substituição de processamento condicional.  
  
 O método é equivalente a chamar o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> método e passar cada <xref:System.Text.RegularExpressions.Match> objeto retornado <xref:System.Text.RegularExpressions.MatchCollection> coleção para o `evaluator` delegar.  
  
 A expressão regular é o padrão definido pelo construtor atual <xref:System.Text.RegularExpressions.Regex> objeto.  
  
 O `evaluator` parâmetro é o delegado para um método personalizado que você define e que examina cada correspondência. O método personalizado deve ter a seguinte assinatura para coincidir com o <xref:System.Text.RegularExpressions.MatchEvaluator> delegar.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 O método personalizado retorna uma cadeia de caracteres que substitui a entrada correspondente.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção será lançada se o tempo de execução da operação de substituição excede o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um intervalo de tempo limite ao chamar o construtor, a exceção é lançada se a operação exceder qualquer valor de tempo limite estabelecido para o domínio do aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido na <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio do aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada  
  
 Como o método retorna `input` inalterado se não houver nenhuma correspondência, você pode usar o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar se o método tiver feito qualquer substituição para a cadeia de caracteres de entrada.  
  
   
  
## Examples  
 O exemplo de código a seguir exibe uma cadeia de caracteres original, corresponde a cada palavra na cadeia de caracteres original, converte o primeiro caractere de cada correspondência de letras maiusculas, em seguida, exibe a cadeia de caracteres convertida.  
  
 [!code-csharp[Regex.Replace-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Regex.Replace-Instance/cs/sample.cs#1)]
 [!code-vb[Regex.Replace-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex.Replace-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="evaluator" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Substituições</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguagem de expressões regulares - referência rápida</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int -&gt; string" Usage="regex.Replace (input, replacement, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="replacement">A cadeia de caracteres substituta.</param>
        <param name="count">O número máximo de vezes que a substituição pode ocorrer.</param>
        <summary>Em uma cadeia de caracteres de entrada especificada, substitui um número máximo especificado de cadeias de caracteres que correspondem a um padrão de expressão regular com uma cadeia de caracteres substituta especificada.</summary>
        <returns>Uma nova cadeia de caracteres idêntica à cadeia de caracteres de entrada, com exceção de que a cadeia de caracteres de substituição substitui cada cadeia de caracteres correspondente. Se o padrão de expressão regular não tiver uma correspondência na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pesquisa para encontrar correspondências começa no início do `input` cadeia de caracteres. A expressão regular é o padrão que é definido pelo construtor atual <xref:System.Text.RegularExpressions.Regex> objeto. Se `count` for negativo, substituições continuam até o final da cadeia de caracteres. Se `count` exceder o número de correspondências, todas as correspondências são substituídas.  
  
 O `replacement` parâmetro especifica a cadeia de caracteres que substitui a primeira `count` correspondências no `input`. `replacement` pode consistir em qualquer combinação de texto literal e [substituições](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Por exemplo, o padrão de substituição `a*${test}b` insere a cadeia de caracteres "um *" seguido de subcadeia de caracteres que é correspondida pelo `test` grupo de captura, se houver, seguido pela cadeia de caracteres "b". O * caractere não é reconhecido como um metacaractere dentro de um padrão de substituição.  
  
> [!NOTE]
>  As substituições são os elementos de linguagem de expressão regular só são reconhecidos em um padrão de substituição. Todos os outros elementos de linguagem de expressão regular, incluindo [escapes de caracteres](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), são permitidas nos padrões de expressão regular apenas e não são reconhecidos em padrões de substituição.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção será lançada se o tempo de execução da operação de substituição excede o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um intervalo de tempo limite ao chamar o construtor, a exceção é lançada se a operação exceder qualquer valor de tempo limite estabelecido para o domínio do aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido na <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio do aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada  
  
 Como o método retorna `input` inalterado se não houver nenhuma correspondência, você pode usar o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar se o método tiver feito qualquer substituição para a cadeia de caracteres de entrada.  
  
   
  
## Examples  
 O exemplo a seguir substitui as primeiras cinco ocorrências de caracteres duplicados com um único caractere. O padrão de expressão regular `(\w)\1` corresponde a ocorrências consecutivas de um único caractere e atribui a primeira ocorrência ao primeiro grupo de captura. O padrão de substituição `$1` substitui a correspondência inteira com o primeiro grupo capturado.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample8.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="replacement" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguagem de expressões regulares - referência rápida</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Substituições</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="replacement">A cadeia de caracteres substituta.</param>
        <summary>Em uma cadeia de caracteres de entrada especificada, substitui todas as cadeias de caracteres que correspondem a uma expressão regular especificada por uma cadeia de caracteres de substituição especificada.</summary>
        <returns>Uma nova cadeia de caracteres idêntica à cadeia de caracteres de entrada, com exceção de que a cadeia de caracteres de substituição substitui cada cadeia de caracteres correspondente. Se <paramref name="pattern" /> não tiver uma correspondência na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estático `Replace` métodos são equivalentes a construção de uma <xref:System.Text.RegularExpressions.Regex> do objeto com o padrão de expressão regular especificada e chamando o método de instância `Replace`.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que simbolicamente descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md). A pesquisa para encontrar correspondências começa no início do `input` cadeia de caracteres.  
  
 O `replacement` parâmetro especifica a cadeia de caracteres substituir cada correspondência na `input`. `replacement` pode consistir em qualquer combinação de texto literal e [substituições](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Por exemplo, o padrão de substituição `a*${test}b` insere a cadeia de caracteres "um *" seguido de subcadeia de caracteres que é correspondida pelo `test` grupo de captura, se houver, seguido pela cadeia de caracteres "b". O * caractere não é reconhecido como um metacaractere dentro de um padrão de substituição.  
  
> [!NOTE]
>  As substituições são os elementos de linguagem de expressão regular só são reconhecidos em um padrão de substituição. Todos os outros elementos de linguagem de expressão regular, incluindo [escapes de caracteres](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), são permitidas nos padrões de expressão regular apenas e não são reconhecidos em padrões de substituição.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção será lançada se o tempo de execução da operação de substituição excede o intervalo de tempo limite especificado para o domínio do aplicativo no qual o método é chamado. Se nenhum tempo limite é definido nas propriedades do domínio do aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
 Como o método retorna `input` inalterado se não houver nenhuma correspondência, você pode usar o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar se o método tiver feito qualquer substituição para a cadeia de caracteres de entrada.  
  
   
  
## Examples  
 O exemplo a seguir define uma expressão regular, `\s+`, que corresponde a um ou mais caracteres de espaço em branco. A cadeia de caracteres de substituição, "", os substitui por um único caractere de espaço.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample6.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample6.vb#6)]  
  
 O exemplo a seguir usa o <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> método para substituir os nomes de máquina e a unidade locais em um caminho UNC com um caminho de arquivo local. A expressão regular usa o <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propriedade para incluir o nome do computador local e o <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> método para incluir os nomes das unidades lógicas. Para executar o exemplo com êxito, você deve substituir a cadeia de caracteres literal "MinhaMaquina" pelo nome do seu computador local.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace3.vb#3)]  
  
 O padrão de expressão regular é definido pela seguinte expressão:  
  
 `"\\\\(?i:" + Environment.MachineName + ")(?:\.\w+)*\\((?i:[" + driveNames + "]))\$"`  
  
 A tabela a seguir mostra como o padrão da expressão regular é interpretado.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\\\\`|Barras invertidas consecutivas de correspondência dois (`\`) caracteres. Porque o caractere de barra invertida é interpretado como o caractere de escape, cada barra invertida deve ser escapada com outra barra invertida.|  
|`(?i:" + Environment.MachineName + ")`|Executar uma correspondência diferencia maiusculas de minúsculas da cadeia de caracteres que é retornada pelo <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propriedade.|  
|`(?:\.\w+)*`|Correspondência ao ponto final (`.`) caractere seguido por um ou mais caracteres de palavra. Essa correspondência pode ocorrer a zero ou mais vezes. A subexpressão coincidente não é capturada.|  
|`\\`|Corresponder a uma barra invertida (`\`) caracteres.|  
|`((?i:[" + driveNames + "]))`|Execute uma correspondência não diferencia maiusculas da classe de caracteres que consiste o lettters unidade individual. Essa correspondência é a primeira subexpressão capturada.|  
|`\$`|Corresponder ao sinal de cifrão literal (`$`) caracteres.|  
  
 O padrão de substituição `$1` substitui a correspondência inteira à primeira subexpressão capturada. Ou seja, ele substitui o nome UNC de máquina e a unidade com a letra da unidade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> ou <paramref name="replacement" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <block subset="none" type="usage">
          <para>Esse método expire após um intervalo que é igual ao valor de tempo limite padrão do domínio do aplicativo no qual ele é chamado. Se um valor de tempo limite não tiver sido definido para o domínio de aplicativo, o valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impede que o método de tempo limite, é usado. O método recomendado de estático para uma correspondência de padrões de substituição é <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite que você definir o intervalo de tempo limite.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Substituições</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementos de linguagem de expressão regular</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="evaluator">Um método personalizado que examina cada correspondência e retorna a cadeia de caracteres correspondida original ou uma cadeia de caracteres de substituição.</param>
        <summary>Em uma cadeia de caracteres de entrada especificada, substitui todas as cadeias de caracteres que correspondem a uma expressão regular especificada por uma cadeia de caracteres retornada por um delegado <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Uma nova cadeia de caracteres é idêntica à cadeia de entrada, com exceção de que a cadeia de substituição substitui cada cadeia de caracteres correspondente. Se <paramref name="pattern" /> não tiver uma correspondência na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> método é útil para trocar uma correspondência da expressão regular, se qualquer uma das seguintes condições for verdadeira:  
  
-   A cadeia de caracteres de substituição prontamente não pode ser especificada por um padrão de substituição de expressão regular.  
  
-   Os resultados da cadeia de caracteres de substituição de algum processamento feito na cadeia de caracteres correspondida.  
  
-   Os resultados da cadeia de caracteres de substituição de processamento condicional.  
  
 O método é equivalente a chamar o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> método e passar cada <xref:System.Text.RegularExpressions.Match> objeto retornado <xref:System.Text.RegularExpressions.MatchCollection> coleção para o `evaluator` delegar.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que simbolicamente descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O `evaluator` parâmetro é o delegado para um método personalizado que você define e que examina cada correspondência. O método personalizado deve ter a seguinte assinatura para coincidir com o <xref:System.Text.RegularExpressions.MatchEvaluator> delegar.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 O método personalizado retorna uma cadeia de caracteres que substitui a entrada correspondente.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção será lançada se o tempo de execução da operação de substituição excede o intervalo de tempo limite especificado para o domínio do aplicativo no qual o método é chamado. Se nenhum tempo limite é definido nas propriedades do domínio do aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
 Como o método retorna `input` inalterado se não houver nenhuma correspondência, você pode usar o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar se o método tiver feito qualquer substituição para a cadeia de caracteres de entrada.  
  
   
  
## Examples  
 O exemplo a seguir usa uma expressão regular para extrair as palavras individuais de uma cadeia de caracteres e, em seguida, usa uma <xref:System.Text.RegularExpressions.MatchEvaluator> delegado para chamar um método chamado `WordScramble` que embaralha as letras individuais na palavra. Para fazer isso, o `WordScramble` método cria uma matriz que contém os caracteres na correspondência. Ele também cria uma matriz paralela preenchidas com números de ponto flutuante aleatórios. As matrizes são classificadas por meio da chamada a <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> método e a matriz classificada é fornecido como um argumento para um <xref:System.String> construtor de classe. Essa cadeia de caracteres criada recentemente, em seguida, é retornada pelo `WordScramble` método. O padrão de expressão regular `\w+` corresponde a um ou mais caracteres de palavra; mecanismo de expressões regulares continuar adicionando caracteres à correspondência até encontrar um caractere não pertencente a palavras, por exemplo, um caractere de espaço em branco.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace5.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace5.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> ou <paramref name="evaluator" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <block subset="none" type="usage">
          <para>Esse método expire após um intervalo que é igual ao valor de tempo limite padrão do domínio do aplicativo no qual ele é chamado. Se um valor de tempo limite não tiver sido definido para o domínio de aplicativo, o valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impede que o método de tempo limite, é usado. O método estático recomendado para avaliar e uma correspondência de padrões de substituição é <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite que você definir o intervalo de tempo limite.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Substituições</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementos de linguagem de expressão regular</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int -&gt; string" Usage="regex.Replace (input, evaluator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="evaluator">Um método personalizado que examina cada correspondência e retorna a cadeia de caracteres correspondida original ou uma cadeia de caracteres de substituição.</param>
        <param name="count">O número máximo de vezes que a substituição ocorrerá.</param>
        <summary>Em uma cadeia de caracteres de entrada especificada, substitui um número máximo especificado de cadeias de caracteres que correspondem a um padrão de expressão regular por uma cadeia de caracteres retornada por um delegado <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Uma nova cadeia de caracteres é idêntica à cadeia de entrada, com exceção de que a cadeia de substituição substitui cada cadeia de caracteres correspondente. Se o padrão de expressão regular não tiver uma correspondência na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType> método é útil para trocar uma correspondência da expressão regular, se qualquer uma das seguintes condições for verdadeira:  
  
-   A cadeia de caracteres de substituição prontamente não pode ser especificada por um padrão de substituição de expressão regular.  
  
-   Os resultados da cadeia de caracteres de substituição de algum processamento feito na cadeia de caracteres correspondida.  
  
-   Os resultados da cadeia de caracteres de substituição de processamento condicional.  
  
 O método é equivalente a chamar o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> método e passar o primeiro `count` <xref:System.Text.RegularExpressions.Match> objetos no retornado <xref:System.Text.RegularExpressions.MatchCollection> coleção para o `evaluator` delegar.  
  
 A expressão regular é o padrão definido pelo construtor atual <xref:System.Text.RegularExpressions.Regex> objeto.  
  
 O `evaluator` parâmetro é o delegado para um método personalizado que você define e que examina cada correspondência. O método personalizado deve ter a seguinte assinatura para coincidir com o <xref:System.Text.RegularExpressions.MatchEvaluator> delegar.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 O método personalizado retorna uma cadeia de caracteres que substitui a entrada correspondente.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção será lançada se o tempo de execução da operação de substituição excede o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um intervalo de tempo limite ao chamar o construtor, a exceção é lançada se a operação exceder qualquer valor de tempo limite estabelecido para o domínio do aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido na <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio do aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada  
  
 Como o método retorna `input` inalterado se não houver nenhuma correspondência, você pode usar o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar se o método tiver feito qualquer substituição para a cadeia de caracteres de entrada.  
  
   
  
## Examples  
 O exemplo a seguir usa uma expressão regular para deliberadamente incorretamente metade das palavras em uma lista. Ele usa a expressão regular `\w*(ie|ei)\w*` para corresponder a palavras que incluem os caracteres "ie" ou "ei". Ele passa a primeira metade das palavras correspondentes para o `ReverseLetter` método, que, por sua vez, usa o <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método para reverter o "i" e "e" na cadeia de caracteres correspondida. As palavras restantes permanecem inalteradas.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace7.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace7.vb#11)]  
  
 A expressão regular `\w*(ie|ei)\w*` é definida conforme mostrado na tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\w*`|Corresponder a zero ou mais caracteres de palavra.|  
|<code>(ie&#124;ei)</code>|Corresponde a "ie" ou "ei".|  
|`\w*`|Corresponder a zero ou mais caracteres de palavra.|  
  
 O padrão de expressão regular `([ie])([ie])` no `ReverseLetter` método corresponde o primeiro "i" ou "e" no diphthong "ie" ou "ei" e atribui a letra para o primeiro grupo de captura. Ele corresponde a segunda "i" ou "e" e atribui a letra para o segundo grupo de captura. Os dois caracteres são revertidos, em seguida, chamando o <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> método com o padrão de substituição `$2$1`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="evaluator" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Substituições</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguagem de expressões regulares - referência rápida</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; string" Usage="regex.Replace (input, replacement, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="replacement">A cadeia de caracteres substituta.</param>
        <param name="count">Número máximo de vezes que a substituição pode ocorrer.</param>
        <param name="startat">A posição do caractere na cadeia de caracteres de entrada na qual a pesquisa começa.</param>
        <summary>Em uma subcadeia de caracteres de entrada especificada, substitui um número máximo especificado de cadeias de caracteres que correspondem a um padrão de expressão regular com uma cadeia de caracteres substituta especificada.</summary>
        <returns>Uma nova cadeia de caracteres idêntica à cadeia de caracteres de entrada, com exceção de que a cadeia de caracteres de substituição substitui cada cadeia de caracteres correspondente. Se o padrão de expressão regular não tiver uma correspondência na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pesquisa para encontrar correspondências inicia `input` cadeia de caracteres na posição especificada pelo `startat` parâmetro. A expressão regular é o padrão definido pelo construtor atual <xref:System.Text.RegularExpressions.Regex> objeto. Se `count` for negativo, substituições continuam até o final da cadeia de caracteres. Se `count` exceder o número de correspondências, todas as correspondências são substituídas.  
  
 O `replacement` parâmetro especifica a cadeia de caracteres substituir cada correspondência na `input`. `replacement` pode consistir em qualquer combinação de texto literal e [substituições](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Por exemplo, o padrão de substituição `a*${test}b` insere a cadeia de caracteres "um *" seguido de subcadeia de caracteres que é correspondida pelo `test` grupo de captura, se houver, seguido pela cadeia de caracteres "b". O * caractere não é reconhecido como um metacaractere dentro de um padrão de substituição.  
  
> [!NOTE]
>  As substituições são os elementos de linguagem de expressão regular só são reconhecidos em um padrão de substituição. Todos os outros elementos de linguagem de expressão regular, incluindo [escapes de caracteres](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), são permitidas nos padrões de expressão regular apenas e não são reconhecidos em padrões de substituição.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção será lançada se o tempo de execução da operação de substituição excede o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um intervalo de tempo limite ao chamar o construtor, a exceção é lançada se a operação exceder qualquer valor de tempo limite estabelecido para o domínio do aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido na <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio do aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada  
  
 Como o método retorna `input` inalterado se não houver nenhuma correspondência, você pode usar o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar se o método tiver feito qualquer substituição para a cadeia de caracteres de entrada.  
  
   
  
## Examples  
 O exemplo a seguir usa espaçamento duplo nos todos, exceto a primeira linha de uma cadeia de caracteres. Ele define um padrão de expressão regular `^.*$`, que corresponde a uma linha de texto, chamadas a <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> método para corresponder a primeira linha da cadeia de caracteres e usa o `Match.Index` e `Match.Count` propriedades para determinar a posição inicial do segundo linha.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample9.vb#9)]  
  
 O padrão de expressão regular `^.*$` é definido conforme mostrado na tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`^`|Corresponde ao início de uma linha. (Observe que o <xref:System.Text.RegularExpressions.Regex> objeto foi instanciado usando o <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> opção; caso contrário, essa classe de caractere corresponderia apenas o início da cadeia de entrada.)|  
|`.*`|Corresponde qualquer caractere zero ou mais vezes.|  
|`$`|Corresponde ao final de uma linha. (Observe que o <xref:System.Text.RegularExpressions.Regex> objeto foi instanciado usando o <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> opção; caso contrário, essa classe de caractere corresponderia apenas o início da cadeia de entrada.)|  
  
 A cadeia de caracteres de substituição (`vbCrLf + "$&"` no Visual Basic, `"\n$&"` em c#) adiciona uma nova linha antes da cadeia de caracteres correspondida. Observe que `\n` na c# exemplo é interpretado como caractere de nova linha pelo compilador do c#; ele não representa um caractere de escape de expressão regular.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="replacement" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> é menor que zero ou maior que o tamanho de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Substituições</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguagem de expressões regulares - referência rápida</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="replacement">A cadeia de caracteres substituta.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que fornece opções para correspondência.</param>
        <summary>Em uma cadeia de caracteres de entrada especificada, substitui todas as cadeias de caracteres que correspondem a uma expressão regular especificada por uma cadeia de caracteres de substituição especificada. As opções especificadas modificam a operação de correspondência.</summary>
        <returns>Uma nova cadeia de caracteres idêntica à cadeia de caracteres de entrada, com exceção de que a cadeia de caracteres de substituição substitui cada cadeia de caracteres correspondente. Se <paramref name="pattern" /> não tiver uma correspondência na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estático `Replace` métodos são equivalentes a construção de uma <xref:System.Text.RegularExpressions.Regex> do objeto com o padrão de expressão regular especificada e chamando o método de instância `Replace`.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que simbolicamente descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Se você especificar <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> para o `options` parâmetro, a pesquisa para encontrar correspondências começa no final da cadeia de entrada e move para a esquerda; caso contrário, a pesquisa começa no início da cadeia de caracteres de entrada e movido para a direita.  
  
 O `replacement` parâmetro especifica a cadeia de caracteres substituir cada correspondência na `input`. `replacement` pode consistir em qualquer combinação de texto literal e [substituições](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Por exemplo, o padrão de substituição `a*${test}b` insere a cadeia de caracteres "um *" seguido de subcadeia de caracteres que é correspondida pelo `test` grupo de captura, se houver, seguido pela cadeia de caracteres "b". O * caractere não é reconhecido como um metacaractere dentro de um padrão de substituição.  
  
> [!NOTE]
>  As substituições são os elementos de linguagem de expressão regular só são reconhecidos em um padrão de substituição. Todos os outros elementos de linguagem de expressão regular, incluindo [escapes de caracteres](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), são permitidas nos padrões de expressão regular apenas e não são reconhecidos em padrões de substituição.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção será lançada se o tempo de execução da operação de substituição excede o intervalo de tempo limite especificado para o domínio do aplicativo no qual o método é chamado. Se nenhum tempo limite é definido nas propriedades do domínio do aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
 Como o método retorna `input` inalterado se não houver nenhuma correspondência, você pode usar o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar se o método tiver feito qualquer substituição para a cadeia de caracteres de entrada.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método para substituir os nomes de máquina e a unidade locais em um caminho UNC com um caminho de arquivo local. A expressão regular usa o <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propriedade para incluir o nome do computador local e o <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> método para incluir os nomes das unidades lógicas. Todas as comparações de cadeia de caracteres de expressão regular diferenciam maiusculas de minúsculas. Para executar o exemplo com êxito, você deve substituir a cadeia de caracteres literal "MinhaMaquina" pelo nome do seu computador local.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace4.vb#4)]  
  
 O padrão de expressão regular é definido pela seguinte expressão:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 A tabela a seguir mostra como o padrão da expressão regular é interpretado.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\\\\`|Barras invertidas consecutivas de correspondência dois (`\`) caracteres. Porque o caractere de barra invertida é interpretado como o caractere de escape, cada barra invertida deve ser escapada com outra barra invertida.|  
|`+ Environment.MachineName +`|Corresponder a cadeia de caracteres que é retornada pelo <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propriedade.|  
|`(?:\.\w+)*`|Correspondência ao ponto final (`.`) caractere seguido por um ou mais caracteres de palavra. Essa correspondência pode ocorrer a zero ou mais vezes. A subexpressão coincidente não é capturada.|  
|`\\`|Corresponder a uma barra invertida (`\`) caracteres.|  
|`([" + driveNames + "])`|Corresponde a classe de caracteres que consiste nas letras de unidade individuais. Essa correspondência é a primeira subexpressão capturada.|  
|`\$`|Corresponder ao sinal de cifrão literal (`$`) caracteres.|  
  
 O padrão de substituição `$1` substitui a correspondência inteira à primeira subexpressão capturada. Ou seja, ele substitui o nome UNC de máquina e a unidade com a letra da unidade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> ou <paramref name="replacement" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> não é uma combinação bit a bit válida de valores de <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <block subset="none" type="usage">
          <para>Esse método expire após um intervalo que é igual ao valor de tempo limite padrão do domínio do aplicativo no qual ele é chamado. Se um valor de tempo limite não tiver sido definido para o domínio de aplicativo, o valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impede que o método de tempo limite, é usado. O método recomendado de estático para uma correspondência de padrões de substituição é <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite que você definir o intervalo de tempo limite.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Substituições</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementos de linguagem de expressão regular</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="evaluator">Um método personalizado que examina cada correspondência e retorna a cadeia de caracteres correspondida original ou uma cadeia de caracteres de substituição.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que fornece opções para correspondência.</param>
        <summary>Em uma cadeia de caracteres de entrada especificada, substitui todas as cadeias de caracteres que correspondem a uma expressão regular especificada por uma cadeia de caracteres retornada por um delegado <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />. As opções especificadas modificam a operação de correspondência.</summary>
        <returns>Uma nova cadeia de caracteres é idêntica à cadeia de entrada, com exceção de que a cadeia de substituição substitui cada cadeia de caracteres correspondente. Se <paramref name="pattern" /> não tiver uma correspondência na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> método é útil para a substituição de uma correspondência de expressão regular na se qualquer uma das seguintes condições for verdadeira:  
  
-   A cadeia de caracteres de substituição prontamente não pode ser especificada por um padrão de substituição de expressão regular.  
  
-   Os resultados da cadeia de caracteres de substituição de algum processamento feito na cadeia de caracteres correspondida.  
  
-   Os resultados da cadeia de caracteres de substituição de processamento condicional.  
  
 O método é equivalente a chamar o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> método e passar cada <xref:System.Text.RegularExpressions.Match> objeto retornado <xref:System.Text.RegularExpressions.MatchCollection> coleção para o `evaluator` delegar.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que simbolicamente descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O `evaluator` parâmetro é o delegado para um método personalizado que você define e que examina cada correspondência. O método personalizado deve ter a seguinte assinatura para coincidir com o <xref:System.Text.RegularExpressions.MatchEvaluator> delegar.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 O método personalizado retorna uma cadeia de caracteres que substitui a entrada correspondente.  
  
 Se você especificar <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> para o `options` parâmetro, a pesquisa para encontrar correspondências começa no final da cadeia de entrada e move para a esquerda; caso contrário, a pesquisa começa no início da cadeia de caracteres de entrada e movido para a direita.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção será lançada se o tempo de execução da operação de substituição excede o intervalo de tempo limite especificado para o domínio do aplicativo no qual o método é chamado. Se nenhum tempo limite é definido nas propriedades do domínio do aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
 Como o método retorna `input` inalterado se não houver nenhuma correspondência, você pode usar o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar se o método tiver feito qualquer substituição para a cadeia de caracteres de entrada.  
  
   
  
## Examples  
 O exemplo a seguir usa uma expressão regular para extrair as palavras individuais de uma cadeia de caracteres e, em seguida, usa uma <xref:System.Text.RegularExpressions.MatchEvaluator> delegado para chamar um método chamado `WordScramble` que embaralha as letras individuais na palavra. Para fazer isso, o `WordScramble` método cria uma matriz que contém os caracteres na correspondência. Ele também cria uma matriz paralela preenchidas com números de ponto flutuante aleatórios. As matrizes são classificadas por meio da chamada a <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> método e a matriz classificada é fornecido como um argumento para um <xref:System.String> construtor de classe. Essa cadeia de caracteres criada recentemente, em seguida, é retornada pelo `WordScramble` método. O padrão de expressão regular `\w+` corresponde a um ou mais caracteres de palavra; mecanismo de expressões regulares continuar adicionando caracteres à correspondência até encontrar um caractere não pertencente a palavras, por exemplo, um caractere de espaço em branco. A chamada para o <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> método inclui o <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> opção para que o comentário no padrão de expressão regular `\w+  # Matches all the characters in a word.` é ignorado pelo mecanismo de expressões regulares.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace6.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace6.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> ou <paramref name="evaluator" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> não é uma combinação bit a bit válida de valores de <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Substituições</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementos de linguagem de expressão regular</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int * int -&gt; string" Usage="regex.Replace (input, evaluator, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="evaluator">Um método personalizado que examina cada correspondência e retorna a cadeia de caracteres correspondida original ou uma cadeia de caracteres de substituição.</param>
        <param name="count">O número máximo de vezes que a substituição ocorrerá.</param>
        <param name="startat">A posição do caractere na cadeia de caracteres de entrada na qual a pesquisa começa.</param>
        <summary>Em uma subcadeia de caracteres de entrada especificada, substitui um número máximo especificado de cadeias de caracteres que correspondem a um padrão de expressão regular por uma cadeia de caracteres retornada por um delegado <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Uma nova cadeia de caracteres é idêntica à cadeia de entrada, com exceção de que a cadeia de substituição substitui cada cadeia de caracteres correspondente. Se o padrão de expressão regular não tiver uma correspondência na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método é útil para trocar uma correspondência da expressão regular, se qualquer uma das seguintes condições for verdadeira:  
  
-   A cadeia de caracteres de substituição prontamente não pode ser especificada por um padrão de substituição de expressão regular.  
  
-   Os resultados da cadeia de caracteres de substituição de algum processamento feito na cadeia de caracteres correspondida.  
  
-   Os resultados da cadeia de caracteres de substituição de processamento condicional.  
  
 O método é equivalente a chamar o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> método e passar o primeiro `count` <xref:System.Text.RegularExpressions.Match> objetos no retornado <xref:System.Text.RegularExpressions.MatchCollection> coleção para o `evaluator` delegar.  
  
 A expressão regular é o padrão definido pelo construtor atual <xref:System.Text.RegularExpressions.Regex> objeto.  
  
 O `evaluator` parâmetro é o delegado para um método personalizado que você define e que examina cada correspondência. O método personalizado deve ter a seguinte assinatura para coincidir com o <xref:System.Text.RegularExpressions.MatchEvaluator> delegar.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 O método personalizado retorna uma cadeia de caracteres que substitui a entrada correspondente.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção será lançada se o tempo de execução da operação de substituição excede o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um intervalo de tempo limite ao chamar o construtor, a exceção é lançada se a operação exceder qualquer valor de tempo limite estabelecido para o domínio do aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido na <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio do aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada  
  
 Como o método retorna `input` inalterado se não houver nenhuma correspondência, você pode usar o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar se o método tiver feito qualquer substituição para a cadeia de caracteres de entrada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="evaluator" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> é menor que zero ou maior que o tamanho de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Substituições</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguagem de expressões regulares - referência rápida</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="replacement">A cadeia de caracteres substituta.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que fornece opções para correspondência.</param>
        <param name="matchTimeout">Um intervalo de tempo limite ou <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que o método não deve atingir o tempo limite.</param>
        <summary>Em uma cadeia de caracteres de entrada especificada, substitui todas as cadeias de caracteres que correspondem a uma expressão regular especificada por uma cadeia de caracteres de substituição especificada. Os parâmetros adicionais especificam opções que modificam a operação de correspondência e um intervalo de tempo limite se nenhuma correspondência é encontrada.</summary>
        <returns>Uma nova cadeia de caracteres idêntica à cadeia de caracteres de entrada, com exceção de que a cadeia de caracteres de substituição substitui cada cadeia de caracteres correspondente. Se <paramref name="pattern" /> não tiver uma correspondência na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estático `Replace` métodos são equivalentes a construção de uma <xref:System.Text.RegularExpressions.Regex> do objeto com o padrão de expressão regular especificada e chamando o método de instância `Replace`.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que simbolicamente descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Se você especificar <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> para o `options` parâmetro, a pesquisa para encontrar correspondências começa no final da cadeia de entrada e move para a esquerda; caso contrário, a pesquisa começa no início da cadeia de caracteres de entrada e movido para a direita.  
  
 O `replacement` parâmetro especifica a cadeia de caracteres substituir cada correspondência na `input`. `replacement` pode consistir em qualquer combinação de texto literal e [substituições](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Por exemplo, o padrão de substituição `a*${test}b` insere a cadeia de caracteres "um *" seguido de subcadeia de caracteres que é correspondida pelo `test` grupo de captura, se houver, seguido pela cadeia de caracteres "b". O * caractere não é reconhecido como um metacaractere dentro de um padrão de substituição.  
  
> [!NOTE]
>  As substituições são os elementos de linguagem de expressão regular só são reconhecidos em um padrão de substituição. Todos os outros elementos de linguagem de expressão regular, incluindo [escapes de caracteres](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), são permitidas nos padrões de expressão regular apenas e não são reconhecidos em padrões de substituição.  
  
 O `matchTimeout` parâmetro especifica como long uma correspondência de método deve tentar encontrar uma correspondência antes de expirar. Como definir um intervalo de tempo limite impede que as expressões regulares que confiam no retrocesso excessivo do que parece parar de responder ao processar a entrada que contém correspondências próximas. Para obter mais informações, consulte [práticas recomendadas para expressões regulares](~/docs/standard/base-types/best-practices.md) e [retrocesso](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Se nenhuma correspondência for encontrada desse intervalo de tempo, o método gerará uma <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção. `matchTimeout` substitui qualquer valor de tempo limite padrão definido para o domínio do aplicativo no qual o método é executado.  
  
 Como o método retorna `input` inalterado se não houver nenhuma correspondência, você pode usar o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar se o método tiver feito qualquer substituição para a cadeia de caracteres de entrada.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método para substituir os nomes de máquina e a unidade locais em um caminho UNC com um caminho de arquivo local. A expressão regular usa o <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propriedade para incluir o nome do computador local e o <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> método para incluir os nomes das unidades lógicas. Todas as comparações de cadeia de caracteres de expressão regular diferenciam maiusculas de minúsculas e qualquer operação única substituição expirar se não for encontrada uma correspondência em 0,5 segundo. Para executar o exemplo com êxito, você deve substituir a cadeia de caracteres literal "MinhaMaquina" pelo nome do seu computador local.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace12.cs#12)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace12.vb#12)]  
  
 O padrão de expressão regular é definido pela seguinte expressão:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 A tabela a seguir mostra como o padrão da expressão regular é interpretado.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\\\\`|Barras invertidas consecutivas de correspondência dois (`\`) caracteres. Porque o caractere de barra invertida é interpretado como o caractere de escape, cada barra invertida deve ser escapada com outra barra invertida.|  
|`+ Environment.MachineName +`|Corresponder a cadeia de caracteres que é retornada pelo <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propriedade.|  
|`(?:\.\w+)*`|Correspondência ao ponto final (`.`) caractere seguido por um ou mais caracteres de palavra. Essa correspondência pode ocorrer a zero ou mais vezes. A subexpressão coincidente não é capturada.|  
|`\\`|Corresponder a uma barra invertida (`\`) caracteres.|  
|`([" + driveNames + "])`|Corresponde a classe de caracteres que consiste nas letras de unidade individuais. Essa correspondência é a primeira subexpressão capturada.|  
|`\$`|Corresponder ao sinal de cifrão literal (`$`) caracteres.|  
  
 O padrão de substituição `$1` substitui a correspondência inteira à primeira subexpressão capturada. Ou seja, ele substitui o nome UNC de máquina e a unidade com a letra da unidade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> ou <paramref name="replacement" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> não é uma combinação bit a bit válida de valores de <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
- ou - 
 <paramref name="matchTimeout" /> é negativo, zero ou maior que aproximadamente 24 dias.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <block subset="none" type="usage">
          <para>É recomendável que você defina o <paramref name="matchTimeout" /> parâmetro para um valor apropriado, como dois segundos. Se você desabilitar os tempos limite especificando <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, o mecanismo de expressão regular oferece um desempenho ligeiramente melhor. No entanto, você deve desabilitar os tempos limite somente sob as seguintes condições: 
-Quando a entrada processada por uma expressão regular é derivada de uma origem conhecida e confiável ou é formado por texto estático. Isso exclui o texto que tenha sido dinamicamente inseridos pelos usuários.  
  
-Quando o padrão de expressão regular tenha sido integralmente testado para garantir que ele manipulará com eficiência corresponde, não correspondências e o próximo corresponde.  
  
-Quando o padrão de expressão regular contém sem elementos de linguagem que são conhecidos por causar retrocesso excessivo durante o processamento de uma correspondência quase.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Substituições</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementos de linguagem de expressão regular</related>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">Retrocesso</related>
        <related type="Article" href="https://msdn.microsoft.com/library/618e5afb-3a97-440d-831a-70e4c526a51c">Práticas recomendadas para expressões regulares no .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="evaluator">Um método personalizado que examina cada correspondência e retorna a cadeia de caracteres correspondida original ou uma cadeia de caracteres de substituição.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que fornecem opções para correspondência.</param>
        <param name="matchTimeout">Um intervalo de tempo limite ou <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que o método não deve atingir o tempo limite.</param>
        <summary>Em uma cadeia de caracteres de entrada especificada, substitui todas as subcadeias de caracteres que correspondem a uma expressão regular especificada por uma cadeia de caracteres retornada por um delegado <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />. Os parâmetros adicionais especificam opções que modificam a operação de correspondência e um intervalo de tempo limite se nenhuma correspondência é encontrada.</summary>
        <returns>Uma nova cadeia de caracteres idêntica à cadeia de caracteres de entrada, com exceção de que a cadeia de caracteres de substituição substitui cada cadeia de caracteres correspondente. Se <paramref name="pattern" /> não tiver uma correspondência na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> método é útil para trocar uma correspondência da expressão regular, se qualquer uma das seguintes condições for verdadeira:  
  
-   Se a cadeia de caracteres de substituição prontamente não pode ser especificada por um padrão de substituição de expressão regular.  
  
-   Se os resultados da cadeia de caracteres de substituição de algum processamento é realizado em cadeia de caracteres correspondida.  
  
-   Se a cadeia de caracteres de substituição resultante do processamento condicional.  
  
 O método é equivalente a chamar o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> método e passar cada <xref:System.Text.RegularExpressions.Match> objeto retornado <xref:System.Text.RegularExpressions.MatchCollection> coleção para o `evaluator` delegar.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que simbolicamente descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O `evaluator` parâmetro é o delegado para um método personalizado que você define e que examina cada correspondência. O método personalizado deve ter a seguinte assinatura para coincidir com o <xref:System.Text.RegularExpressions.MatchEvaluator> delegar.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 O método personalizado retorna uma cadeia de caracteres que substitui a entrada correspondente.  
  
 Se você especificar <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> para o `options` parâmetro, a pesquisa para encontrar correspondências começa no final da cadeia de entrada e move para a esquerda; caso contrário, a pesquisa começa no início da cadeia de caracteres de entrada e movido para a direita.  
  
 O `matchTimeout` parâmetro especifica como long uma correspondência de método deve tentar encontrar uma correspondência antes de expirar. Como definir um intervalo de tempo limite impede que as expressões regulares que confiam no retrocesso excessivo apareça para "parar de responder ao processar a entrada que contém correspondências próximas. Para obter mais informações, consulte [práticas recomendadas para expressões regulares](~/docs/standard/base-types/best-practices.md) e [retrocesso](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Se nenhuma correspondência for encontrada desse intervalo de tempo, o método gerará uma <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção. `matchTimeout` substitui qualquer valor de tempo limite padrão definido para o domínio do aplicativo no qual o método é executado.  
  
 Como o método retorna `input` inalterado se não houver nenhuma correspondência, você pode usar o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar se o método tiver feito qualquer substituição para a cadeia de caracteres de entrada.  
  
   
  
## Examples  
 O exemplo a seguir usa uma expressão regular para extrair as palavras individuais de uma cadeia de caracteres e, em seguida, usa uma <xref:System.Text.RegularExpressions.MatchEvaluator> delegado para chamar um método chamado `WordScramble` que embaralha as letras individuais na palavra. Para fazer isso, o `WordScramble` método cria uma matriz que contém os caracteres na correspondência. Ele também cria uma matriz paralela preenchidas com números de ponto flutuante aleatórios. As matrizes são classificadas por meio da chamada a <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> método e a matriz classificada é fornecido como um argumento para um <xref:System.String> construtor de classe. Essa cadeia de caracteres criada recentemente, em seguida, é retornada pelo `WordScramble` método. O padrão de expressão regular `\w+` corresponde a um ou mais caracteres de palavra; mecanismo de expressões regulares continuar adicionando caracteres à correspondência até encontrar um caractere não pertencente a palavras, por exemplo, um caractere de espaço em branco. A chamada para o <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> método inclui o <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> opção para que o comentário no padrão de expressão regular `\w+  # Matches all the characters in a word.` é ignorado pelo mecanismo de expressões regulares.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace13.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> ou <paramref name="evaluator" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> não é uma combinação bit a bit válida de valores de <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
- ou - 
 <paramref name="matchTimeout" /> é negativo, zero ou maior que aproximadamente 24 dias.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <block subset="none" type="usage">
          <para>É recomendável que você defina o <paramref name="matchTimeout" /> parâmetro para um valor apropriado, como dois segundos. Se você desabilitar os tempos limite especificando <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, o mecanismo de expressão regular oferece um desempenho ligeiramente melhor. No entanto, você deve desabilitar os tempos limite somente sob as seguintes condições: 
-Quando a entrada processada por uma expressão regular é derivada de uma origem conhecida e confiável ou é formado por texto estático. Isso exclui o texto que tenha sido dinamicamente inseridos pelos usuários.  
  
-Quando o padrão de expressão regular tenha sido integralmente testado para garantir que ele manipulará com eficiência corresponde, não correspondências e o próximo corresponde.  
  
-Quando o padrão de expressão regular contém sem elementos de linguagem que são conhecidos por causar retrocesso excessivo durante o processamento de uma correspondência quase.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Substituições</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementos de linguagem de expressão regular</related>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">Retrocesso</related>
        <related type="Article" href="https://msdn.microsoft.com/library/618e5afb-3a97-440d-831a-70e4c526a51c">Práticas recomendadas para expressões regulares no .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : bool" Usage="System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a expressão regular pesquisa da direita para a esquerda.</summary>
        <value>
          <see langword="true" /> Se a expressão regular pesquisa da direita para a esquerda; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.RightToLeft%2A> está `true` se o <xref:System.Text.RegularExpressions.Regex> instância foi criada com o <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> opção.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="roptions">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexOptions roptions;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.Text.RegularExpressions.RegexOptions roptions" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.roptions" />
      <MemberSignature Language="VB.NET" Value="Protected Friend roptions As RegexOptions " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexOptions roptions;" />
      <MemberSignature Language="F#" Value="val mutable roptions : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.roptions" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Usado por um objeto <see cref="T:System.Text.RegularExpressions.Regex" /> gerado pelo método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Divide uma cadeia de caracteres de entrada em uma matriz de subcadeias de caracteres nas posições definidas por uma correspondência de expressão regular.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguagem de expressões regulares - referência rápida</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Split : string -&gt; string[]" Usage="regex.Split input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres a ser dividida.</param>
        <summary>Divide uma cadeia de caracteres de entrada em uma matriz de subcadeias de caracteres nas posições definidas por um padrão de expressão regular especificado no construtor <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Uma matriz de cadeias de caracteres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> métodos são semelhantes para o <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> método, exceto que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> divide a cadeia de caracteres em um determinado por uma expressão regular, em vez de um conjunto de caracteres de delimitador. A cadeia de caracteres é dividida tantas vezes quanto possível. Se nenhum delimitador for encontrado, o valor de retorno contém um elemento cujo valor é a cadeia de caracteres de entrada original.  
  
 Se várias correspondências são adjacentes um ao outro, uma cadeia de caracteres vazia é inserida na matriz. Por exemplo, dividindo uma cadeia de caracteres em um hífen faz com que a matriz retornada incluir uma cadeia de caracteres vazia na posição em que dois hifens adjacentes forem encontrados, como mostra o código a seguir.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split1.vb#1)]  
  
 Se uma correspondência for encontrada no início ou no final da cadeia de caracteres de entrada, uma cadeia de caracteres vazia é incluída no início ou no final da matriz retornada. O exemplo a seguir usa o padrão de expressão regular `\d+` para dividir uma cadeia de caracteres de entrada em caracteres numéricos. Como a cadeia de caracteres começa e termina com a correspondência de caracteres numéricos, o valor do primeiro e o último elemento da matriz retornada é <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split21.cs#21)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split21.vb#21)]  
  
 Se os parênteses de captura são usados em um <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> expressão, qualquer capturada texto está incluído na matriz de cadeia de caracteres resultante. Por exemplo, se você dividir a cadeia de caracteres "Black-pear" em um hífen colocado dentro dos parênteses de captura, a matriz retornada inclui um elemento de cadeia de caracteres que contém o hífen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split2.vb#2)]  
  
 No entanto, quando o padrão de expressão regular inclui vários conjuntos de parênteses de captura, o comportamento desse método depende da versão do .NET Framework. No .NET Framework 1.0 e 1.1, se uma correspondência não for encontrada, dentro do primeiro conjunto de parênteses, a captura o texto capturado de parênteses adicionais de captura não está incluído na matriz retornada. Começando com o .NET Framework 2.0, todo o texto capturado também é adicionado à matriz retornada. Por exemplo, o código a seguir usa dois conjuntos de parênteses de captura para extrair os elementos de uma data, incluindo os delimitadores de data, de uma cadeia de caracteres de data. O primeiro conjunto de parênteses de captura captura o hífen e o segundo conjunto captura a barra invertida. Se o código de exemplo é compilado e executado sob o .NET Framework 1.0 ou 1.1, ele exclui os caracteres de barra "/"; Se ele for compilado e executado no .NET Framework 2.0 ou versões posteriores, inclui-los.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split3.vb#3)]  
  
 Se a expressão regular pode corresponder a cadeia de caracteres vazia, <xref:System.Text.RegularExpressions.Regex.Split%28System.String%29> dividirá a cadeia de caracteres em uma matriz de cadeias de caracteres de caractere único porque o delimitador de cadeia de caracteres vazia pode ser encontrado em cada local. Por exemplo:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split11.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split11.vb#11)]  
  
 Observe que a matriz retornada também inclui uma cadeia de caracteres vazia no início e no final da matriz.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é lançada se o tempo de execução da operação de divisão exceder o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um intervalo de tempo limite ao chamar o construtor, a exceção é lançada se a operação exceder qualquer valor de tempo limite estabelecido para o domínio do aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido na <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio do aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguagem de expressões regulares - referência rápida</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int -&gt; string[]" Usage="regex.Split (input, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres a ser dividida.</param>
        <param name="count">O número máximo de vezes que a divisão pode ocorrer.</param>
        <summary>Divide uma cadeia de entrada no número de vezes máximo especificado em uma matriz de subcadeias de caracteres, nas posições definidas por uma expressão regular especificada no construtor <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Uma matriz de cadeias de caracteres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> métodos são semelhantes para o <xref:System.String.Split%2A?displayProperty=nameWithType> método, exceto que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> divide a cadeia de caracteres em um determinado por uma expressão regular, em vez de um conjunto de caracteres de delimitador. O `count` parâmetro especifica o número máximo de subcadeias de caracteres na qual o `input` cadeia de caracteres pode ser dividida; a última cadeia de caracteres contém o resto anterior à divisão da cadeia de caracteres. Um `count` valor zero fornece o comportamento padrão de divisão como tantas vezes quanto possível.  
  
 Se várias correspondências são adjacentes um ao outro ou se uma correspondência for encontrada no início ou no final da `input`, e o número de correspondências encontradas é pelo menos dois menor que `count`, uma cadeia de caracteres vazia é inserida na matriz. Isto é, cadeias de caracteres vazias que resultam de correspondências adjacentes ou de correspondências no início ou no final da cadeia de entrada são contadas em determinar se o número de subcadeias de caracteres igual de correspondência `count`. No exemplo a seguir, a expressão regular `/d+` é usado para dividir uma cadeia de caracteres de entrada que inclui um ou mais dígitos decimais em um máximo de subcadeias de caracteres de três. Como o início da cadeia de entrada corresponde ao padrão de expressão regular, o primeiro elemento da matriz contém <xref:System.String.Empty?displayProperty=nameWithType>, o segundo contém o primeiro conjunto de caracteres alfabéticos na cadeia de entrada e a terceira contém o resto da cadeia de caracteres que segue a correspondência de terceiro.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split25.cs#25)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split25.vb#25)]  
  
 Se os parênteses de captura são usados em uma expressão regular, qualquer texto capturado está incluído na matriz de cadeias de caracteres de divisão. No entanto, quaisquer elementos de matriz que contêm texto capturado não são contados na determinação se atingiu o número de correspondências `count`. Por exemplo, dividindo a cadeia de caracteres "-damasco-Ameixa-pear-maçã" em um máximo de quatro resultados de subcadeias de caracteres em uma matriz de sete elementos, como o código a seguir mostra.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split4.vb#4)]  
  
 No entanto, quando o padrão de expressão regular inclui vários conjuntos de parênteses de captura, o comportamento desse método depende da versão do .NET Framework. No .NET Framework 1.0 e 1.1, apenas texto capturado do primeiro conjunto de parênteses de captura está incluído na matriz retornada. Começando com o .NET Framework 2.0, todo o texto capturado é adicionado à matriz retornada. No entanto, os elementos na matriz retornada que contêm texto capturado não são contados determinar se o número de subcadeias de caracteres igual de correspondência `count`. Por exemplo, no código a seguir, uma expressão regular usa dois conjuntos de parênteses de captura para extrair os elementos de uma data de uma cadeia de caracteres de data. O primeiro conjunto de parênteses de captura captura o hífen e o segundo conjunto captura a barra invertida. A chamada para o <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> método Especifica, em seguida, um máximo de dois elementos na matriz retornada. Se o código de exemplo é compilado e executado sob o .NET Framework 1.0 ou 1.1, o método retorna uma matriz de cadeia de caracteres de dois elementos. Se ele for compilado e executado no .NET Framework 2.0 ou versões posteriores, o método retorna uma matriz de cadeia de caracteres de três elementos.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split5.vb#5)]  
  
 Se a expressão regular pode corresponder a cadeia de caracteres vazia, <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> dividirá a cadeia de caracteres em uma matriz de cadeias de caracteres de caractere único porque o delimitador de cadeia de caracteres vazia pode ser encontrado em cada local. O exemplo a seguir divide a cadeia de caracteres "caracteres" em assim como quanto houver muitos elementos na cadeia de entrada. Como a cadeia de caracteres nula corresponde ao início da cadeia de entrada, uma cadeia de caracteres nula é inserida no início da matriz retornada. Isso faz com que o décimo elemento ser constituído de dois caracteres do final da cadeia de caracteres de entrada.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split12.vb#12)]  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é lançada se o tempo de execução da operação de divisão exceder o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um intervalo de tempo limite ao chamar o construtor, a exceção é lançada se a operação exceder qualquer valor de tempo limite estabelecido para o domínio do aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido na <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio do aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguagem de expressões regulares - referência rápida</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Split : string * string -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres a ser dividida.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <summary>Divide uma cadeia de caracteres de entrada em uma matriz de subcadeias de caracteres nas posições definidas por um padrão de expressão regular.</summary>
        <returns>Uma matriz de cadeias de caracteres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> métodos são semelhantes para o <xref:System.String.Split%2A?displayProperty=nameWithType> método, exceto que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> divide a cadeia de caracteres em um determinado por uma expressão regular, em vez de um conjunto de caracteres de delimitador. O `input` cadeia de caracteres é dividida tantas vezes quanto possível. Se `pattern` não for encontrado na `input` cadeia de caracteres, o valor de retorno contém um elemento cujo valor é o original `input` cadeia de caracteres.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que simbolicamente descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Usado em chamadas para estático de expressões regulares compiladas <xref:System.Text.RegularExpressions.Regex.Split%2A> métodos são armazenadas em cache automaticamente. Para gerenciar o tempo de vida de expressões regulares compiladas, use a instância <xref:System.Text.RegularExpressions.Regex.Split%2A> métodos.  
  
 Se várias correspondências são adjacentes um ao outro, uma cadeia de caracteres vazia é inserida na matriz. Por exemplo, dividindo uma cadeia de caracteres em um hífen faz com que a matriz retornada incluir uma cadeia de caracteres vazia na posição em que dois hifens adjacentes forem encontrados, como mostra o código a seguir.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split8.vb#8)]  
  
 Se uma correspondência for encontrada no início ou no final da cadeia de caracteres de entrada, uma cadeia de caracteres vazia é incluída no início ou no final da matriz retornada. O exemplo a seguir usa o padrão de expressão regular `\d+` para dividir uma cadeia de caracteres de entrada em caracteres numéricos. Como a cadeia de caracteres começa e termina com a correspondência de caracteres numéricos, o valor do primeiro e o último elemento da matriz retornada é <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split22.cs#22)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split22.vb#22)]  
  
 Se os parênteses de captura são usados em um <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> expressão, qualquer capturada texto está incluído na matriz de cadeia de caracteres resultante. Por exemplo, se você dividir a cadeia de caracteres "Black-pear" em um hífen colocado dentro dos parênteses de captura, a matriz retornada inclui um elemento de cadeia de caracteres que contém o hífen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 No entanto, quando o padrão de expressão regular inclui vários conjuntos de parênteses de captura, o comportamento desse método depende da versão do .NET Framework. No .NET Framework 1.0 e 1.1, se uma correspondência não for encontrada, dentro do primeiro conjunto de parênteses, a captura o texto capturado de parênteses adicionais de captura não está incluído na matriz retornada. Começando com o .NET Framework 2.0, todo o texto capturado também é adicionado à matriz retornada. Por exemplo, o código a seguir usa dois conjuntos de parênteses de captura para extrair os elementos de uma data, incluindo os delimitadores de data, de uma cadeia de caracteres de data. O primeiro conjunto de parênteses de captura captura o hífen e o segundo conjunto captura a barra invertida. Se o código de exemplo é compilado e executado sob o .NET Framework 1.0 ou 1.1, ele exclui os caracteres de barra "/"; Se ele for compilado e executado no .NET Framework 2.0 ou versões posteriores, inclui-los.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Se a expressão regular pode corresponder a cadeia de caracteres vazia, <xref:System.Text.RegularExpressions.Regex.Split%2A> dividirá a cadeia de caracteres em uma matriz de cadeias de caracteres de caractere único porque o delimitador de cadeia de caracteres vazia pode ser encontrado em cada local. Por exemplo:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split13.vb#13)]  
  
 Observe que a matriz retornada também inclui uma cadeia de caracteres vazia no início e no final da matriz.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção será lançada se o tempo de execução da operação de divisão exceder o intervalo de tempo limite especificado para o domínio do aplicativo no qual o método é chamado. Se nenhum tempo limite é definido nas propriedades do domínio do aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="pattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <block subset="none" type="usage">
          <para>Esse método expire após um intervalo que é igual ao valor de tempo limite padrão do domínio do aplicativo no qual o método é chamado. Se um valor de tempo limite não tiver sido definido para o domínio de aplicativo, o valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impede que o método de tempo limite, é usado. O método estático recomendado para a divisão de texto em uma correspondência de padrões é <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite que você definir o intervalo de tempo limite.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementos de linguagem de expressão regular</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer, startat As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * int -&gt; string[]" Usage="regex.Split (input, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres a ser dividida.</param>
        <param name="count">O número máximo de vezes que a divisão pode ocorrer.</param>
        <param name="startat">A posição do caractere na cadeia de caracteres de entrada em que a pesquisa será iniciada.</param>
        <summary>Divide uma cadeia de entrada no número de vezes máximo especificado em uma matriz de subcadeias de caracteres, nas posições definidas por uma expressão regular especificada no construtor <see cref="T:System.Text.RegularExpressions.Regex" />. A pesquisa do padrão de expressão regular é iniciada em uma posição de caractere especificada na cadeia de entrada.</summary>
        <returns>Uma matriz de cadeias de caracteres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> métodos são semelhantes para o <xref:System.String.Split%2A?displayProperty=nameWithType> método, exceto que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> divide a cadeia de caracteres em um determinado por uma expressão regular, em vez de um conjunto de caracteres de delimitador. O `count` parâmetro especifica o número máximo de subcadeias de caracteres na qual o `input` cadeia de caracteres é dividida; a última cadeia de caracteres contém o resto anterior à divisão da cadeia de caracteres. Um `count` valor zero fornece o comportamento padrão de divisão como tantas vezes quanto possível. O `startat` parâmetro define o ponto em que começa a pesquisa para o primeiro delimitador (Isso pode ser usado para ignorar espaço em branco à esquerda).  
  
 Se nenhuma correspondência for encontrada na `count`+ 1 posição na cadeia de caracteres, o método retorna uma matriz de um elemento que contém o `input` cadeia de caracteres. Se uma ou mais correspondências forem encontradas, o primeiro elemento da matriz retornada contém a primeira parte da cadeia de caracteres do primeiro caractere até um caractere antes da correspondência.  
  
 Se várias correspondências são adjacentes um ao outro e o número de correspondências encontradas é pelo menos dois menor que `count`, uma cadeia de caracteres vazia é inserida na matriz. Da mesma forma, se uma correspondência for encontrada no `startat`, que é o primeiro caractere na cadeia de caracteres, o primeiro elemento da matriz retornada é uma cadeia de caracteres vazia. Isto é, cadeias de caracteres vazias que resultam das correspondências adjacentes são contadas em determinar se o número de subcadeias de caracteres igual de correspondência `count`. No exemplo a seguir, a expressão regular `\d+` é usado para localizar a posição inicial da primeira subcadeia de caracteres de caracteres numéricos em uma cadeia de caracteres e, em seguida, dividir a cadeia de caracteres no máximo três vezes inicial nessa posição. Como o padrão de expressão regular corresponde ao início da cadeia de entrada, a matriz de cadeia de caracteres retornada consiste em uma cadeia de caracteres vazia, uma cadeia de caracteres alfabética de cinco caracteres e o restante da cadeia de caracteres,  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split26.cs#26)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split26.vb#26)]  
  
 Se os parênteses de captura são usados em uma expressão regular, qualquer texto capturado está incluído na matriz de cadeias de caracteres de divisão. No entanto, quaisquer elementos de matriz que contêm texto capturado não são contados na determinação se atingiu o número de correspondências `count`. Por exemplo, dividir a cadeia de caracteres ' "apple-apricot-plum-pear-pomegranate-pineapple-peach" em um máximo de quatro as subcadeias de caracteres começando no caractere 15 nos resultados da cadeia de caracteres em uma matriz de sete elementos, como mostra o código a seguir.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split6.vb#6)]  
  
 No entanto, quando o padrão de expressão regular inclui vários conjuntos de parênteses de captura, o comportamento desse método depende da versão do .NET Framework. No .NET Framework 1.0 e 1.1, se uma correspondência não for encontrada, dentro do primeiro conjunto de parênteses, a captura o texto capturado de parênteses adicionais de captura não está incluído na matriz retornada. Começando com o .NET Framework 2.0, todo o texto capturado também é adicionado à matriz retornada. Por exemplo, o código a seguir usa dois conjuntos de parênteses de captura para extrair as palavras individuais em uma cadeia de caracteres. O primeiro conjunto de parênteses de captura captura o hífen e o segundo conjunto captura a barra vertical. Se o código de exemplo é compilado e executado sob o .NET Framework 1.0 ou 1.1, ele exclui a vertical da barra caracteres; Se ele for compilado e executado no .NET Framework 2.0 ou versões posteriores, inclui-los.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split7.vb#7)]  
  
 Se a expressão regular pode corresponder a cadeia de caracteres vazia, <xref:System.Text.RegularExpressions.Regex.Split%2A> dividirá a cadeia de caracteres em uma matriz de cadeias de caracteres de caractere único porque o delimitador de cadeia de caracteres vazia pode ser encontrado em cada local. O exemplo a seguir divide os cadeia de caracteres "caracteres de" em tantos elementos já contém a cadeia de caracteres de entrada, começando com o caractere "a". Como a cadeia de caracteres nula corresponde ao final da cadeia de entrada, uma cadeia de caracteres nula é inserida no final da matriz retornada.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split14.cs#14)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split14.vb#14)]  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é lançada se o tempo de execução da operação de divisão exceder o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um intervalo de tempo limite ao chamar o construtor, a exceção é lançada se a operação exceder qualquer valor de tempo limite estabelecido para o domínio do aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido na <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio do aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> é menor que zero ou maior que o tamanho de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguagem de expressões regulares - referência rápida</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres a ser dividida.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que fornece opções para correspondência.</param>
        <summary>Divide uma cadeia de caracteres de entrada em uma matriz de subcadeias de caracteres nas posições definidas por um padrão de expressão regular especificado. As opções especificadas modificam a operação de correspondência.</summary>
        <returns>Uma matriz de cadeias de caracteres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> métodos são semelhantes para o <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> método, exceto que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> divide a cadeia de caracteres em um determinado por uma expressão regular, em vez de um conjunto de caracteres de delimitador. A cadeia de caracteres é dividida tantas vezes quanto possível. Se nenhum delimitador for encontrado, o valor de retorno contém um elemento cujo valor é o original `input` cadeia de caracteres.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que simbolicamente descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Usado em chamadas para estático de expressões regulares compiladas <xref:System.Text.RegularExpressions.Regex.Split%2A> métodos são armazenadas em cache automaticamente. Para gerenciar o tempo de vida de expressões regulares compiladas, use a instância <xref:System.Text.RegularExpressions.Regex.Split%2A> métodos.  
  
 Se várias correspondências são adjacentes um ao outro, uma cadeia de caracteres vazia é inserida na matriz. Por exemplo, dividindo uma cadeia de caracteres em um hífen faz com que a matriz retornada incluir uma cadeia de caracteres vazia na posição em que dois hifens adjacentes são encontrados.  
  
 Se uma correspondência for encontrada no início ou no final da cadeia de caracteres de entrada, uma cadeia de caracteres vazia é incluída no início ou no final da matriz retornada. O exemplo a seguir usa o padrão de expressão regular `[a-z]+` para dividir uma cadeia de caracteres de entrada em qualquer caractere alfabético maiusculo ou minúsculo. Como a cadeia de caracteres começa e termina com a correspondência de caracteres alfabéticos, o valor do primeiro e o último elemento da matriz retornada é <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split24.cs#24)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split24.vb#24)]  
  
 Se os parênteses de captura são usados em um <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> expressão, qualquer capturada texto está incluído na matriz de cadeia de caracteres resultante. Por exemplo, se você dividir a cadeia de caracteres "Black-pear" em um hífen colocado dentro dos parênteses de captura, a matriz retornada inclui um elemento de cadeia de caracteres que contém o hífen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 No entanto, quando o padrão de expressão regular inclui vários conjuntos de parênteses de captura, o comportamento desse método depende da versão do .NET Framework. No .NET Framework 1.0 e 1.1, se uma correspondência não for encontrada, dentro do primeiro conjunto de parênteses, a captura o texto capturado de parênteses adicionais de captura não está incluído na matriz retornada. Começando com o .NET Framework 2.0, todo o texto capturado também é adicionado à matriz retornada. Por exemplo, o código a seguir usa dois conjuntos de parênteses de captura para extrair os elementos de uma data, incluindo os delimitadores de data, de uma cadeia de caracteres de data. O primeiro conjunto de parênteses de captura captura o hífen e o segundo conjunto captura a barra invertida. Se o código de exemplo é compilado e executado sob o .NET Framework 1.0 ou 1.1, ele exclui os caracteres de barra "/"; Se ele for compilado e executado no .NET Framework 2.0 ou versões posteriores, inclui-los.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Se a expressão regular pode corresponder a cadeia de caracteres vazia, <xref:System.Text.RegularExpressions.Regex.Split%2A> dividirá a cadeia de caracteres em uma matriz de cadeias de caracteres de caractere único porque o delimitador de cadeia de caracteres vazia pode ser encontrado em cada local.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção será lançada se o tempo de execução da operação de divisão exceder o intervalo de tempo limite especificado para o domínio do aplicativo no qual o método é chamado. Se nenhum tempo limite é definido nas propriedades do domínio do aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="pattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> não é uma combinação bit a bit válida de valores de <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <block subset="none" type="usage">
          <para>Esse método expire após um intervalo que é igual ao valor de tempo limite padrão do domínio do aplicativo no qual o método é chamado. Se um valor de tempo limite não tiver sido definido para o domínio de aplicativo, o valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impede que o método de tempo limite, é usado. O método estático recomendado para a divisão de texto em uma correspondência de padrões é <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite que você definir o intervalo de tempo limite.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementos de linguagem de expressão regular</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres a ser dividida.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que fornece opções para correspondência.</param>
        <param name="matchTimeout">Um intervalo de tempo limite ou <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que o método não deve atingir o tempo limite.</param>
        <summary>Divide uma cadeia de caracteres de entrada em uma matriz de subcadeias de caracteres nas posições definidas por um padrão de expressão regular especificado. Os parâmetros adicionais especificam opções que modificam a operação de correspondência e um intervalo de tempo limite se nenhuma correspondência é encontrada.</summary>
        <returns>Uma matriz de cadeia de caracteres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> métodos são semelhantes para o <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> método, exceto que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> divide a cadeia de caracteres em um determinado por uma expressão regular, em vez de um conjunto de caracteres de delimitador. A cadeia de caracteres é dividida tantas vezes quanto possível. Se nenhum delimitador for encontrado, o valor de retorno contém um elemento cujo valor é o original `input` cadeia de caracteres.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que simbolicamente descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Usado em chamadas para estático de expressões regulares compiladas <xref:System.Text.RegularExpressions.Regex.Split%2A> métodos são armazenadas em cache automaticamente. Para gerenciar o tempo de vida de expressões regulares compiladas, use a instância <xref:System.Text.RegularExpressions.Regex.Split%2A> métodos.  
  
 Se várias correspondências são adjacentes um ao outro, uma cadeia de caracteres vazia é inserida na matriz. Por exemplo, dividindo uma cadeia de caracteres em um hífen faz com que a matriz retornada incluir uma cadeia de caracteres vazia na posição em que dois hifens adjacentes são encontrados.  
  
 Se uma correspondência for encontrada no início ou no final da cadeia de caracteres de entrada, uma cadeia de caracteres vazia é incluída no início ou no final da matriz retornada. O exemplo a seguir usa o padrão de expressão regular `[a-z]+` para dividir uma cadeia de caracteres de entrada em qualquer caractere alfabético maiusculo ou minúsculo. Como a cadeia de caracteres começa e termina com a correspondência de caracteres alfabéticos, o valor do primeiro e o último elemento da matriz retornada é <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split23.cs#23)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split23.vb#23)]  
  
 Se os parênteses de captura são usados em um <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> expressão, qualquer capturada texto está incluído na matriz de cadeia de caracteres resultante. Por exemplo, se você dividir a cadeia de caracteres "Black-pear" em um hífen colocado dentro dos parênteses de captura, a matriz retornada inclui um elemento de cadeia de caracteres que contém o hífen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 No entanto, quando o padrão de expressão regular inclui vários conjuntos de parênteses de captura, o comportamento desse método depende da versão do .NET Framework. No .NET Framework 1.0 e 1.1, se uma correspondência não for encontrada, dentro do primeiro conjunto de parênteses, a captura o texto capturado de parênteses adicionais de captura não está incluído na matriz retornada. Começando com o .NET Framework 2.0, todo o texto capturado também é adicionado à matriz retornada. Por exemplo, o código a seguir usa dois conjuntos de parênteses de captura para extrair os elementos de uma data, incluindo os delimitadores de data, de uma cadeia de caracteres de data. O primeiro conjunto de parênteses de captura captura o hífen e o segundo conjunto captura a barra invertida. Se o código de exemplo é compilado e executado sob o .NET Framework 1.0 ou 1.1, ele exclui os caracteres de barra "/"; Se ele for compilado e executado no .NET Framework 2.0 ou versões posteriores, inclui-los.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Se a expressão regular pode corresponder a cadeia de caracteres vazia, <xref:System.Text.RegularExpressions.Regex.Split%2A> dividirá a cadeia de caracteres em uma matriz de cadeias de caracteres de caractere único porque o delimitador de cadeia de caracteres vazia pode ser encontrado em cada local.  
  
 O `matchTimeout` parâmetro especifica como long uma correspondência de método deve tentar encontrar uma correspondência antes de expirar. Como definir um intervalo de tempo limite impede que as expressões regulares que confiam no retrocesso excessivo do que parece parar de responder ao processar a entrada que contém correspondências próximas. Para obter mais informações, consulte [práticas recomendadas para expressões regulares](~/docs/standard/base-types/best-practices.md) e [retrocesso](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Se nenhuma correspondência for encontrada desse intervalo de tempo, o método gerará uma <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção. `matchTimeout` substitui qualquer valor de tempo limite padrão definido para o domínio do aplicativo no qual o método é executado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="pattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> não é uma combinação bit a bit válida de valores de <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
- ou - 
 <paramref name="matchTimeout" /> é negativo, zero ou maior que aproximadamente 24 dias.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <block subset="none" type="usage">
          <para>É recomendável que você defina o <paramref name="matchTimeout" /> parâmetro para um valor apropriado, como dois segundos. Se você desabilitar os tempos limite especificando <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, o mecanismo de expressão regular oferece um desempenho ligeiramente melhor. No entanto, você deve desabilitar os tempos limite somente sob as seguintes condições: 
-Quando a entrada processada por uma expressão regular é derivada de uma origem conhecida e confiável ou é formado por texto estático. Isso exclui o texto que tenha sido dinamicamente inseridos pelos usuários.  
  
-Quando o padrão de expressão regular tenha sido integralmente testado para garantir que ele manipulará com eficiência corresponde, não correspondências e o próximo corresponde.  
  
-Quando o padrão de expressão regular contém sem elementos de linguagem que são conhecidos por causar retrocesso excessivo durante o processamento de uma correspondência quase.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementos de linguagem de expressão regular</related>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="si">O objeto a ser preenchido com informações de serialização.</param>
        <param name="context">O local para armazenar e recuperar dados serializados. Esse parâmetro está reservado para uso futuro.</param>
        <summary>Popula um objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> com os dados necessários para desserializar o objeto <see cref="T:System.Text.RegularExpressions.Regex" /> atual.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="regex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o padrão de expressão regular que foi passado para o construtor <see langword="Regex" />.</summary>
        <returns>O parâmetro <paramref name="pattern" /> passado para o construtor <see langword="Regex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que simbolicamente descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressão Regular – referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> é a classe base das expressões regulares criadas pelo <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> método. Eles compilado o uso de expressões regulares a <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> implementação da classe base. Se for chamado de uma classe derivada, o <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> método retorna a cadeia de caracteres que foi passada para o <paramref name="pattern" /> parâmetro do <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> construtor da classe que foi usado para definir a expressão regular.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="public static string Unescape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Unescape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unescape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Unescape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Unescape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Unescape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">A cadeia de caracteres de entrada que contém o texto a ser convertido.</param>
        <summary>Converte qualquer caractere de escape na cadeia de caracteres de entrada.</summary>
        <returns>Uma cadeia de caracteres com qualquer caractere de escape convertido em sua forma sem escape.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Unescape%2A> método executa uma das duas seguintes transformações:  
  
-   Ele reverte a transformação executada pelos <xref:System.Text.RegularExpressions.Regex.Escape%2A> método removendo o caractere de escape ("\\") de cada caractere de escape pelo método. Isso inclui o \\, *, +,?, &#124;, {, [, (,), ^, $,., # e caracteres de espaço em branco. Além disso, o <xref:System.Text.RegularExpressions.Regex.Unescape%2A> método unescapes o colchete de fechamento (]) e fechando os caracteres de chave (}).  
  
> [!NOTE]
>  <xref:System.Text.RegularExpressions.Regex.Unescape%2A> não é possível reverter uma cadeia de caracteres de escape perfeitamente porque ele não é possível deduzir precisamente quais caracteres foram substituídos,  
  
-   Ele substitui os valores hexadecimais em literais de cadeia de caracteres textuais com os caracteres imprimíveis reais. Por exemplo, ele substitui @"\x07" com "\a", ou @"\x0A" com "\n". Converte caracteres de escape suportadas como \a, \b, \e, \n, \r, \f, \v, \t e caracteres alfanuméricos.
  
 Se o <xref:System.Text.RegularExpressions.Regex.Unescape%2A> método encontra outras sequências de escape que não é possível converter, como \w ou \s, ele gerará um <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="str" /> inclui uma sequência de escape não reconhecida.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguagem de expressões regulares - referência rápida</related>
      </Docs>
    </Member>
    <Member MemberName="UseOptionC">
      <MemberSignature Language="C#" Value="protected bool UseOptionC ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionC() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionC" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionC () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionC();" />
      <MemberSignature Language="F#" Value="member this.UseOptionC : unit -&gt; bool" Usage="regex.UseOptionC " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usado por um objeto <see cref="T:System.Text.RegularExpressions.Regex" /> gerado pelo método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <returns>
          <see langword="true" /> se a propriedade <see cref="P:System.Text.RegularExpressions.Regex.Options" /> contiver a opção <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseOptionR">
      <MemberSignature Language="C#" Value="protected bool UseOptionR ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionR() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionR" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionR () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionR();" />
      <MemberSignature Language="F#" Value="member this.UseOptionR : unit -&gt; bool" Usage="regex.UseOptionR " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usado por um objeto <see cref="T:System.Text.RegularExpressions.Regex" /> gerado pelo método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <returns>
          <see langword="true" /> se a propriedade <see cref="P:System.Text.RegularExpressions.Regex.Options" /> contiver a opção <see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" />; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal static void ValidateMatchTimeout (TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig void ValidateMatchTimeout(valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Sub ValidateMatchTimeout (matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static void ValidateMatchTimeout(TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member ValidateMatchTimeout : TimeSpan -&gt; unit" Usage="System.Text.RegularExpressions.Regex.ValidateMatchTimeout matchTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="matchTimeout">O intervalo de tempo limite a ser verificado.</param>
        <summary>Verifique se o intervalo de tempo limite está dentro de um intervalo aceitável.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>