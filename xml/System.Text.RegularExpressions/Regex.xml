<Type Name="Regex" FullName="System.Text.RegularExpressions.Regex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fd2ccb43296a43eb9c1de7114e0d688441835233" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33684352" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Regex : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Regex extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.Regex" />
  <TypeSignature Language="VB.NET" Value="Public Class Regex&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Regex : System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa uma expressão regular imutável.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex> classe representa o mecanismo de expressão regular do .NET Framework. Ele pode ser usado para analisar rapidamente grandes quantidades de texto para localizar padrões de caracteres específica; para extrair, editar, substituir ou excluir subcadeias de caracteres de texto; e adicionar as cadeias de caracteres extraídas de uma coleção para gerar um relatório.  
  
> [!NOTE]
>  Se for o interesse principal validar uma cadeia de caracteres determinando se está de acordo com um padrão específico, você pode usar o <xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType> classe.  
  
 Para usar expressões regulares, defina o padrão que você deseja identificar em um fluxo de texto usando a sintaxe documentada no [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Em seguida, você pode opcionalmente instanciar uma <xref:System.Text.RegularExpressions.Regex> objeto. Por fim, você pode chamar um método que executa algumas operações, como substituir o texto que corresponde ao padrão de expressão regular ou identificar uma correspondência de padrão.  
  
> [!NOTE]
>  Para alguns padrões comuns de expressões regulares, consulte [exemplos de expressão Regular](~/docs/standard/base-types/regular-expression-examples.md). Também há um número de bibliotecas online de padrões de expressão regular, como a [Expressions.info Regular](https://www.regular-expressions.info/examples.html).  
  
<a name="remarks"></a> Para obter mais informações sobre como usar o <xref:System.Text.RegularExpressions.Regex> de classe, consulte as seções a seguir neste tópico:  
  
-   [Regex vs. Métodos de cadeia de caracteres](#regex_vs_string)  
  
-   [Portas estáticas vs. Métodos de instância](#static_vs_instance)  
  
-   [Executando operações de expressão Regular](#regex_ops)  
  
-   [Definindo um valor de tempo limite](#define_timeout)  
  
 Para saber mais sobre a linguagem de expressão regular, confira [Linguagem de expressão regular - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md) ou faça download e imprima um dos seguintes folhetos:  
  
 [Referência rápida no formato Word (.docx)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)  
 [Referência rápida no formato PDF (.pdf)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)  
  
<a name="regex_vs_string"></a>   
## <a name="regex-vs-string-methods"></a>Regex x métodos da cadeia de caracteres  
 O <xref:System.String?displayProperty=nameWithType> classe inclui vários métodos de pesquisa e comparação que você pode usar para executar a correspondência de padrão com o texto. Por exemplo, o <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.EndsWith%2A?displayProperty=nameWithType>, e <xref:System.String.StartsWith%2A?displayProperty=nameWithType> métodos determinam se uma instância de cadeia de caracteres contém uma subcadeia de caracteres especificada; e o <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, <xref:System.String.IndexOfAny%2A?displayProperty=nameWithType>, <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>, e <xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType> métodos retornam a posição inicial de uma subcadeia de caracteres especificada em uma cadeia de caracteres. Use os métodos do <xref:System.String?displayProperty=nameWithType> classe quando você estiver procurando por uma cadeia de caracteres específica. Use o <xref:System.Text.RegularExpressions.Regex> classe quando você estiver procurando por um padrão específico em uma cadeia de caracteres. Para obter mais informações e exemplos, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md).  
  
 [Para comentários](#remarks)  
  
<a name="static_vs_instance"></a>   
## <a name="static-vs-instance-methods"></a>Métodos estáticos x instância  
 Depois de definir um padrão de expressão regular, você pode fornecê-lo para o mecanismo de expressão regular em uma das duas maneiras:  
  
-   Instanciando um <xref:System.Text.RegularExpressions.Regex> objeto que representa a expressão regular. Para fazer isso, você passa o padrão de expressão regular para um <xref:System.Text.RegularExpressions.Regex.%23ctor%2A> construtor. Um <xref:System.Text.RegularExpressions.Regex> objeto é imutável; quando você instancia um <xref:System.Text.RegularExpressions.Regex> do objeto com uma expressão regular, que a expressão regular do objeto não pode ser alterado.  
  
-   Fornecendo a expressão regular e o texto da pesquisa para um `static` (`Shared` no Visual Basic) <xref:System.Text.RegularExpressions.Regex> método. Isso permite que você use uma expressão regular sem criar explicitamente uma <xref:System.Text.RegularExpressions.Regex> objeto.  
  
 Todos os <xref:System.Text.RegularExpressions.Regex> métodos de identificação padrão incluem estáticos e sobrecargas de instância.  
  
 O mecanismo de expressão regular deve compilar um padrão específico para que o padrão pode ser usado. Porque <xref:System.Text.RegularExpressions.Regex> objetos são imutáveis, este é um procedimento único que ocorre quando um <xref:System.Text.RegularExpressions.Regex> é chamado o construtor de classe ou um método estático. Para eliminar a necessidade de compilar repetidamente uma única expressão regular, o mecanismo de expressão regular armazena em cache as expressões regulares compiladas usadas nas chamadas de método estático. Como resultado, os métodos de correspondência de padrão de expressão regular oferecem desempenho comparável para estático e métodos de instância.  
  
> [!IMPORTANT]
>  Em expressões do .NET Framework versões 1.0 e 1.1, todas compiladas regulares, se eles foram usados no método estático ou instância chama, estiverem armazenadas em cache. Começando com o .NET Framework 2.0, apenas expressões regulares usadas em chamadas de método estático estão em cache.  
  
 No entanto, o cache pode afetar o desempenho nos seguintes casos:  
  
-   Quando você usa chamadas de método estático com um grande número de expressões regulares. Por padrão, o mecanismo de expressão regular armazena em cache as 15 usadas recentemente estáticas expressões regulares. Se seu aplicativo usa mais de 15 expressões regulares estáticas, algumas expressões regulares devem ser recompilados. Para evitar essa recompilação, você pode aumentar a <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> propriedade.  
  
-   Quando você cria uma instância nova <xref:System.Text.RegularExpressions.Regex> objetos com expressões regulares que foram compilados anteriormente. Por exemplo, o código a seguir define uma expressão regular para localizar palavras duplicadas em um fluxo de texto. Embora o exemplo usa uma única expressão regular, ele cria um novo <xref:System.Text.RegularExpressions.Regex> objeto para processar cada linha de texto. Isso resulta na recompilação de expressão regular com cada iteração do loop.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#1)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#1)]  
  
     Para evitar a recompilação, você deve criar uma instância de um único <xref:System.Text.RegularExpressions.Regex> objeto que é acessível a todos os códigos que requer, conforme mostrado no exemplo a seguir de reconfigurado.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#2)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#2)]  
  
 [Para comentários](#remarks)  
  
<a name="regex_ops"></a>   
## <a name="performing-regular-expression-operations"></a>Executando operações de expressão regular  
 Se você decidir criar uma instância de um <xref:System.Text.RegularExpressions.Regex> de objeto e chamar seus métodos ou chamar métodos estáticos, o <xref:System.Text.RegularExpressions.Regex> classe oferece a funcionalidade de correspondência de padrões a seguir:  
  
-   Validação de uma correspondência. Chamar o <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> método para determinar se houver uma correspondência.  
  
-   Recuperação de uma única correspondência. Você chama o <xref:System.Text.RegularExpressions.Regex.Match%2A> método para recuperar um <xref:System.Text.RegularExpressions.Match> objeto que representa a primeira correspondência em uma cadeia de caracteres ou em parte de uma cadeia de caracteres. Correspondências subsequentes podem ser recuperadas chamando o <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> método.  
  
-   Recuperação de todas as correspondências. Você chama o <xref:System.Text.RegularExpressions.Regex.Matches%2A> método para recuperar um <xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType> objeto que representa todas as correspondências encontradas em uma cadeia de caracteres ou em parte de uma cadeia de caracteres.  
  
-   Substituição de texto correspondente. Chamar o <xref:System.Text.RegularExpressions.Regex.Replace%2A> método para substituir o texto correspondente. O texto de substituição também pode ser definido por uma expressão regular. Além disso, alguns do <xref:System.Text.RegularExpressions.Regex.Replace%2A> métodos incluem um <xref:System.Text.RegularExpressions.MatchEvaluator> parâmetro que permite que você defina programaticamente o texto de substituição.  
  
-   Criação de uma matriz de cadeia de caracteres que é formada de partes de uma cadeia de caracteres de entrada. Chamar o <xref:System.Text.RegularExpressions.Regex.Split%2A> método para dividir uma cadeia de caracteres de entrada em posições que são definidas pela expressão regular.  
  
 Além de seus métodos de correspondência, a <xref:System.Text.RegularExpressions.Regex> classe inclui vários métodos de finalidade especial:  
  
-   O <xref:System.Text.RegularExpressions.Regex.Escape%2A> método ignora os caracteres que podem ser interpretados como operadores de expressão regular em uma expressão regular ou uma cadeia de caracteres de entrada.  
  
-   O <xref:System.Text.RegularExpressions.Regex.Unescape%2A> método remove esses caracteres de escape.  
  
-   O <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> método cria um assembly que contém expressões regulares predefinidas. O .NET Framework contém exemplos desses assemblies com finalidade especial no <xref:System.Web.RegularExpressions?displayProperty=nameWithType> namespace.  
  
 [Para comentários](#remarks)  
  
<a name="define_timeout"></a>   
## <a name="defining-a-time-out-value"></a>Definindo um valor de tempo limite  
 O .NET Framework oferece suporte a uma linguagem de expressão regular completa que fornece considerável potência e flexibilidade na correspondência de padrões. No entanto, a potência e flexibilidade vêm com um custo: o risco de baixo desempenho. Expressões regulares que insatisfatório são incrivelmente fácil de criar. Em alguns casos, operações de expressão regular que dependem de retrocesso excessiva podem aparecer pare de responder quando eles processem texto que quase corresponde ao padrão de expressão regular. Para obter mais informações sobre o mecanismo de expressão regular do .NET Framework, consulte [detalhes do comportamento de expressão Regular](~/docs/standard/base-types/details-of-regular-expression-behavior.md). Para obter mais informações sobre o retrocesso excessiva, consulte [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode definir um intervalo de tempo limite para correspondência de expressão regular. Se o mecanismo de expressão regular não pode identificar uma correspondência dentro deste intervalo de tempo, a operação de correspondência gera uma <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção. Na maioria dos casos, isso impede que o mecanismo de expressão regular desperdício de potência de processamento tentando correspondem ao texto que quase corresponde ao padrão de expressão regular. Ele também pode indicar, no entanto, que o intervalo de tempo limite tenha sido definido muito baixo ou que a carga atual da máquina causou uma geral degradação no desempenho.  
  
 Como lidar com a exceção depende da causa da exceção. Se a exceção ocorre porque o intervalo de tempo limite está definido muito baixo ou devido à carga excessiva de máquina, você pode aumentar o intervalo de tempo limite e repita a operação de correspondência. Se a exceção ocorre porque a expressão regular depende de retrocesso excessiva, você pode presumir que não existe uma correspondência, e, opcionalmente, você pode registrar informações que ajudarão você a modificar o padrão de expressão regular.  
  
 Você pode definir um intervalo de tempo limite ao chamar o <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> construtor quando você criar um objeto de expressão regular. Para métodos estáticos, você pode definir um intervalo de tempo limite ao chamar uma sobrecarga de um método de correspondência que tem um `matchTimeout` parâmetro. Se você não definir explicitamente um valor de tempo limite, o valor de tempo limite padrão é determinado como segue:  
  
-   Usando o tempo limite de todo o aplicativo se um valor existe. Isso pode ser qualquer valor de tempo limite se aplica ao domínio do aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é instanciado ou é feita a chamada de método estático. Você pode definir o valor de tempo limite de todo o aplicativo chamando o <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> método para atribuir a representação de cadeia de caracteres de uma <xref:System.TimeSpan> valor para a propriedade "REGEX_DEFAULT_MATCH_TIMEOUT".  
  
-   Usando o valor <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>, se nenhum valor de tempo limite de todo o aplicativo tiver sido definido.  
  
> [!IMPORTANT]
>  É recomendável que você defina um valor de tempo limite em todas as operações de correspondência de padrão de expressão regular. Para obter mais informações, consulte [práticas recomendadas para expressões regulares](~/docs/standard/base-types/best-practices.md).  
  
 [Para comentários](#remarks)  
  
   
  
## Examples  
 O exemplo a seguir usa uma expressão regular para verificar as ocorrências repetidas de palavras em uma cadeia de caracteres. A expressão regular `\b(?<word>\w+)\s+(\k<word>)\b` podem ser interpretados como mostrado na tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\b`|Inicie a correspondência em um limite de palavra.|  
|`(?<word>\w+)`|Corresponde a um ou mais caracteres de palavra até um limite de palavra. Este grupo capturado `word`.|  
|`\s+`|Corresponde a um ou mais caracteres de espaço em branco.|  
|`(\k<word>)`|Corresponde ao grupo capturado chamado `word`.|  
|`\b`|Corresponder a um limite de palavra.|  
  
 [!code-cpp[Regex_Words#0](~/samples/snippets/cpp/VS_Snippets_CLR/Regex_Words/CPP/words.cpp#0)]
 [!code-csharp[Regex_Words#0](~/samples/snippets/csharp/VS_Snippets_CLR/Regex_Words/CS/words.cs#0)]
 [!code-vb[Regex_Words#0](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex_Words/VB/words.vb#0)]  
  
 O exemplo a seguir ilustra o uso de uma expressão regular para verificar se uma cadeia de caracteres representa um valor de moeda ou tem o formato correto para representar um valor de moeda. Nesse caso, a expressão regular é criada dinamicamente a partir de <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, e <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> propriedades para a cultura do usuário atual. Se o sistema do atual cultura é en-US, a expressão regular resultante é `^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`. Essa expressão regular pode ser interpretada como mostrado na tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`^`|Começar do início da cadeia de caracteres.|  
|`\s*`|Corresponder a zero ou mais caracteres de espaço em branco.|  
|`[\+-]?`|Corresponde a zero ou uma ocorrência do sinal positivo ou o sinal negativo.|  
|`\s?`|Corresponder a zero ou a um caractere de espaço em branco.|  
|`\$?`|Corresponde a zero ou uma ocorrência do sinal de dólar.|  
|`\s?`|Corresponder a zero ou a um caractere de espaço em branco.|  
|`\d*`|Corresponde a zero ou mais dígitos decimais.|  
|`\.?`|Corresponde a zero ou um símbolo de ponto decimal.|  
|`\d{2}?`|Corresponde a duas casas decimais zero ou uma vez.|  
|`(\d*\.?\d{2}?){1}`|Corresponde ao padrão de dígitos integral e fracionário separados por um símbolo de ponto decimal, pelo menos uma vez.|  
|`$`|Coincidir com o fim da cadeia de caracteres.|  
  
 Nesse caso, a expressão regular pressupõe que uma cadeia de caracteres de moeda válidos não contém símbolos de separador de grupo e se ele tem sem dígitos fracionários ou o número de dígitos fracionários definido a cultura atual <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A> propriedade.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/cs/regex_example1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/vb/regex_example1.vb#1)]  
  
 Como a expressão regular neste exemplo é criada dinamicamente, não sabemos em tempo de design se o símbolo de moeda da cultura atual, a vírgula decimal ou sinais positivos e negativos podem ser interpretados incorretamente pelo mecanismo de expressão regular como operadores de linguagem de expressão regular. Para evitar qualquer interpretação incorreta, o exemplo passa cada cadeia de caracteres gerada dinamicamente para o <xref:System.Text.RegularExpressions.Regex.Escape%2A> método.  
  
 ]]></format>
    </remarks>
    <threadsafe>O <see cref="T:System.Text.RegularExpressions.Regex" /> classe é imutável (somente leitura) e thread-safe. <see cref="T:System.Text.RegularExpressions.Regex" /> objetos podem ser criados em qualquer segmento e compartilhados entre threads. Para obter mais informações, consulte [segurança de segmento](~/docs/standard/base-types/thread-safety-in-regular-expressions.md).</threadsafe>
    <altmember cref="T:System.Configuration.RegexStringValidator" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Observe que este construtor é protegido; ele só pode ser chamado por classes derivadas do <xref:System.Text.RegularExpressions.Regex> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.RegularExpressions.Regex" /> para a expressão regular especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que maneira simbólica descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte o [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md) tópicos.  
  
 Chamando o <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29> construtor é equivalente a chamar o <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> construtor com um valor de <xref:System.Text.RegularExpressions.RegexOptions.None> para o `options` argumento.  
  
 Um <xref:System.Text.RegularExpressions.Regex> objeto é imutável, o que significa que ele pode ser usado somente para o padrão de correspondência definem quando você criá-lo. No entanto, ele pode ser usada várias vezes sem ser recompilada.  
  
 Este construtor cria um objeto de expressão regular que tenta uma correspondência diferencia maiusculas de minúsculas dos caracteres alfabéticos definido no `pattern`. Para uma correspondência diferencia maiusculas de minúsculas, use o <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> construtor.  
  
   
  
## Examples  
 O exemplo a seguir ilustra como usar esse construtor para criar uma instância de uma expressão regular que corresponda a qualquer palavra que comece com as letras "a" ou "t".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/constructors1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/constructors1.vb#1)]  
  
 Observe que o padrão de expressão regular não pode coincidir com a palavra "A" no início do texto, pois comparações diferenciam maiusculas de minúsculas por padrão. Para obter um exemplo de comparação de maiusculas e minúsculas, consulte o <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> construtor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" /> é <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Este construtor cria um <see cref="T:System.Text.RegularExpressions.Regex" /> objeto que usa o valor de tempo limite padrão do domínio do aplicativo no qual ele é criado. Se um valor de tempo limite não tiver sido definido para o domínio de aplicativo, o <see cref="T:System.Text.RegularExpressions.Regex" /> o valor do objeto usa <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impede que a operação do tempo limite. O construtor recomendado para a criação de um <see cref="T:System.Text.RegularExpressions.Regex" /> objeto <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite que você defina o intervalo de tempo limite.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">O objeto que contém um padrão serializado e informações da <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</param>
        <param name="context">O destino dessa serialização. (Este parâmetro não é usado; especifique <see langword="null" />.)</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.RegularExpressions.Regex" /> utilizando dados serializados.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">O padrão que <paramref name="info" /> contém é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="info" /> contém um sinalizador <see cref="T:System.Text.RegularExpressions.RegexOptions" /> inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que modificam a expressão regular.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.RegularExpressions.Regex" /> para a expressão regular especificada, com opções que modifiquem o padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que maneira simbólica descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte o [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md) tópicos.  
  
 Um <xref:System.Text.RegularExpressions.Regex> objeto é imutável, o que significa que ele pode ser usado apenas para os parâmetros de correspondência definem quando você criá-lo. No entanto, ele pode ser usada várias vezes sem ser recompilada.  
  
   
  
## Examples  
 O exemplo a seguir ilustra como usar esse construtor para criar uma instância de uma expressão regular que corresponda a qualquer palavra que comece com as letras "a" ou "t".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/Constructors2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/Constructors2.vb#2)]  
  
 Observe que a coleção de correspondência inclui a palavra "The" que inicia o texto porque o `options` parâmetro definido comparações maiusculas de minúsculas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> contém um sinalizador inválido.</exception>
        <block subset="none" type="usage">
          <para>Este construtor cria um <see cref="T:System.Text.RegularExpressions.Regex" /> objeto que usa o valor de tempo limite padrão do domínio do aplicativo no qual ele é criado. Se um valor de tempo limite não tiver sido definido para o domínio de aplicativo, o <see cref="T:System.Text.RegularExpressions.Regex" /> o valor do objeto usa <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impede que a operação do tempo limite. O construtor recomendado para a criação de um <see cref="T:System.Text.RegularExpressions.Regex" /> objeto <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite que você defina o intervalo de tempo limite.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions, matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que modificam a expressão regular.</param>
        <param name="matchTimeout">Um intervalo de tempo limite ou <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que o método não deve atingir o tempo limite.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.RegularExpressions.Regex" /> para a expressão regular especificada, com opções que modificam o padrão e um valor que especifica quanto tempo um padrão que corresponde ao método deve tentar uma correspondência antes de atingir o tempo limite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que maneira simbólica descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte o [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md) tópicos.  
  
 Um <xref:System.Text.RegularExpressions.Regex> objeto é imutável, o que significa que ele pode ser usado somente para o padrão de correspondência que você defina quando você cria. No entanto, ele pode ser usada várias vezes sem ser recompilada.  
  
 O `matchTimeout` parâmetro especifica quanto tempo uma padrão de correspondência de método deve tentar localizar uma correspondência antes de expirar. Se nenhuma correspondência for encontrada desse intervalo de tempo, o método de correspondência gera uma <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção. `matchTimeout` substitui qualquer valor de tempo limite padrão definido para o domínio de aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Os métodos de correspondência de padrão de instância que observam o `matchTimeout` intervalo de tempo limite incluem o seguinte:  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%2A>  
  
-   <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>  
  
 Definir um intervalo de tempo limite impede que as expressões regulares que dependem de retrocesso excessiva de parece parar de responder ao processar a entrada que contém a próxima correspondência. Para obter mais informações, consulte [práticas recomendadas para expressões regulares](~/docs/standard/base-types/best-practices.md) e [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Para definir um intervalo de tempo limite razoável, considere os seguintes fatores:  
  
-   O comprimento e a complexidade do padrão de expressão regular. Expressões regulares mais longas e complexas requerem mais tempo do que aqueles menores e mais simples.  
  
-   A carga esperada máquina. Processamento leva mais tempo em sistemas que têm alta utilização de CPU e memória.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> construtor para instanciar um <xref:System.Text.RegularExpressions.Regex> com um valor de tempo limite de um segundo. O padrão de expressão regular `(a+)+$`, que faz a correspondência de uma ou várias sequências de um ou mais caracteres de “a” no final de uma linha, está sujeito ao retrocesso excessivo. Se um <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> é lançada, o exemplo aumenta o valor de tempo limite até o valor máximo de três segundos. Caso contrário, ele abandona tentar correspondem ao padrão.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> não é um valor <see cref="T:System.Text.RegularExpressions.RegexOptions" /> válido.  
  
 - ou -  
  
 <paramref name="matchTimeout" /> é negativo, zero ou maior que aproximadamente 24 dias.</exception>
        <block subset="none" type="usage">
          <para>Recomendamos que você defina o <paramref name="matchTimeout" /> parâmetro para um valor apropriado, como dois segundos. Se você desabilitar o tempo limite especificando <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, o mecanismo de expressão regular oferece um pouco melhor desempenho. No entanto, você deve desabilitar tempos limite apenas sob as seguintes condições:  
  
-   Quando a entrada processada por uma expressão regular é derivada de uma origem conhecida e confiável ou consiste em texto estático. Exclui o texto que tenha sido dinamicamente entrada pelos usuários.  
  
-   Quando o padrão de expressão regular tem foram testado para garantir que ele trata com eficiência corresponde não correspondências e próximo corresponde.  
  
-   Quando o padrão de expressão regular não contém linguagem elementos que causam retrocesso excessiva durante o processamento de uma correspondência near.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CacheSize">
      <MemberSignature Language="C#" Value="public static int CacheSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CacheSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CacheSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CacheSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o número máximo de entradas no cache estático atual de expressões regulares compiladas.</summary>
        <value>O número máximo de entradas no cache estático.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex> classe mantém um cache interno de expressões regulares compiladas usada nas chamadas de método estático. Se o valor especificado em uma operação de definição é menor que o tamanho do cache atual, as entradas de cache são descartadas até que o tamanho do cache é igual ao valor especificado.  
  
 Por padrão, o cache contém 15 compilado estáticas expressões regulares. Seu aplicativo normalmente não precisará modificar o tamanho do cache. Use o <xref:System.Text.RegularExpressions.Regex.CacheSize%2A> propriedade somente quando você deseja desativar o cache ou quando você tem um cache muito grande.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor em uma operação de conjuntos é menor que zero.</exception>
        <block subset="none" type="usage">
          <para>No .NET Framework antes do [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)], expressões regulares usadas em estáticos e chamadas de método de instância foram armazenados em cache. Começando com o [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)], regular somente as expressões usadas em chamadas de métodos estáticos são armazenados em cache.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="capnames">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable capnames;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable capnames" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capnames" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capnames As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ capnames;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Usado por um objeto <see cref="T:System.Text.RegularExpressions.Regex" /> gerado pelo método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CapNames">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary CapNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary CapNames" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CapNames" />
      <MemberSignature Language="VB.NET" Value="Protected Property CapNames As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ CapNames { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um dicionário que mapeia grupos de captura nomeados para seus valores de índice.</summary>
        <value>Um dicionário que mapeia grupos de captura nomeados para seus valores de índice.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Observe que esta propriedade será protegida. só pode ser acessado de uma classe que deriva de <xref:System.Text.RegularExpressions.Regex> classe.  
  
 Uma operação definida tenta converter o valor atribuído à propriedade para um <xref:System.Collections.Hashtable> objeto; se essa conversão falhar, ele chama o <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> construtor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor atribuído à propriedade <see cref="P:System.Text.RegularExpressions.Regex.CapNames" /> em uma operação de conjuntos é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="caps">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable caps;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable caps" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.caps" />
      <MemberSignature Language="VB.NET" Value="Protected Friend caps As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ caps;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Usado por um objeto <see cref="T:System.Text.RegularExpressions.Regex" /> gerado pelo método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Caps">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary Caps { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Caps" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Caps" />
      <MemberSignature Language="VB.NET" Value="Protected Property Caps As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ Caps { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um dicionário que mapeia grupos de captura numerados para seus valores de índice.</summary>
        <value>Um dicionário que mapeia grupos de captura numerados para seus valores de índice.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Observe que esta propriedade será protegida. só pode ser acessado de uma classe que deriva de <xref:System.Text.RegularExpressions.Regex> classe.  
  
 Uma operação definida tenta converter o valor atribuído à propriedade para um <xref:System.Collections.Hashtable> objeto; se essa conversão falhar, ele chama o <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> construtor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor atribuído à propriedade <see cref="P:System.Text.RegularExpressions.Regex.Caps" /> em uma operação de conjuntos é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="capsize">
      <MemberSignature Language="C#" Value="protected internal int capsize;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly int32 capsize" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capsize" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capsize As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected public: int capsize;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Usado por um objeto <see cref="T:System.Text.RegularExpressions.Regex" /> gerado pelo método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="capslist">
      <MemberSignature Language="C#" Value="protected internal string[] capslist;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string[] capslist" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capslist" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capslist As String() " />
      <MemberSignature Language="C++ CLI" Value="protected public: cli::array &lt;System::String ^&gt; ^ capslist;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Usado por um objeto <see cref="T:System.Text.RegularExpressions.Regex" /> gerado pelo método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompileToAssembly">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compila expressões regulares e as salva em disco em um único assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Uma matriz que descreve as expressões regulares a compilar.</param>
        <param name="assemblyname">O nome do arquivo do assembly.</param>
        <summary>Compila um ou mais objetos <see cref="T:System.Text.RegularExpressions.Regex" /> especificados para um assembly nomeado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> método gera um assembly do .NET Framework na qual cada expressão regular definida no `regexinfos` matriz é representada por uma classe. Normalmente, o <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> método é chamado de um aplicativo separado que gera um conjunto de expressões regulares compiladas. Cada expressão regular incluído no assembly tem as seguintes características:  
  
-   Ele é derivado de <xref:System.Text.RegularExpressions.Regex> classe.  
  
-   Ele recebe o nome totalmente qualificado que é definido pelo `fullnamespace` e `name` parâmetros de correspondente <xref:System.Text.RegularExpressions.RegexCompilationInfo> objeto.  
  
-   Ele tem um padrão (ou sem parâmetros) construtor.  
  
 Normalmente, o código que cria e usa a expressão regular compilada é encontrado em um assembly ou aplicativo que é separado do código que cria o assembly.  
  
   
  
## Examples  
 O exemplo a seguir cria um assembly chamado RegexLib.dll. O assembly inclui duas expressões regulares compiladas. A primeira, `Utilities.RegularExpressions.DuplicatedString`, corresponde a duas palavras idênticas de contíguas. O segundo, `Utilities.RegularExpressions.EmailAddress`, verifica se uma cadeia de caracteres tem o formato correto deve ser um endereço de email.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile1.vb#1)]  
  
 A expressão regular que verifica uma cadeia de caracteres para palavras duplicadas é instanciada e usada pelo exemplo a seguir.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Compilação bem-sucedida deste segundo exemplo requer uma referência a RegexLib.dll (o assembly criado pelo primeiro exemplo) a ser adicionado ao projeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor da propriedade <see cref="P:System.Reflection.AssemblyName.Name" /> do parâmetro <paramref name="assemblyname" /> é uma cadeia de caracteres vazia ou nula.  
  
 - ou -  
  
 O padrão de expressão regular de um ou mais objetos em <paramref name="regexinfos" /> contém sintaxe inválida.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyname" /> ou <paramref name="regexinfos" /> é <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Se você estiver desenvolvendo em um sistema que tem [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ou suas versões ponto instalados, destino [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], e você usar o <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> método para criar um assembly que contém compilado expressões regulares. Tentativa de usar uma das expressões regulares do assembly em um sistema que tem [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] lança uma exceção. Para solucionar esse problema, pode-se seguir uma das seguintes alternativas:  
  
-   Compile o assembly que contém as expressões regulares compiladas em um sistema que tem [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] em vez de versões mais recentes instalados.  
  
-   Em vez de chamar <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> e recuperar a expressão regular compilada de um assembly, use estáticas ou instância <see cref="T:System.Text.RegularExpressions.Regex" /> métodos com o <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> opção quando você cria uma instância um <see cref="T:System.Text.RegularExpressions.Regex" /> de objeto ou chamar uma expressão regular método de correspondência de padrão.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Uma matriz que descreve as expressões regulares a compilar.</param>
        <param name="assemblyname">O nome do arquivo do assembly.</param>
        <param name="attributes">Uma matriz que define os atributos a serem aplicados ao assembly.</param>
        <summary>Compila um ou mais objetos <see cref="T:System.Text.RegularExpressions.Regex" /> especificados para um assembly nomeado com os atributos especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> método gera um assembly do .NET Framework na qual cada expressão regular definida no `regexinfos` matriz é representada por uma classe. Normalmente, o <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> método é chamado de um aplicativo separado que gera um conjunto de expressões regulares compiladas. Cada expressão regular incluído no assembly tem as seguintes características:  
  
-   Ele é derivado de <xref:System.Text.RegularExpressions.Regex> classe.  
  
-   Ele recebe o nome totalmente qualificado que é definido pelo `fullnamespace` e `name` parâmetros de correspondente <xref:System.Text.RegularExpressions.RegexCompilationInfo> objeto.  
  
-   Ele tem um padrão (ou sem parâmetros) construtor.  
  
 Normalmente, o código que cria e usa a expressão regular compilada é encontrado em um assembly ou aplicativo que é separado do código que cria o assembly.  
  
 Porque o <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> método gera um assembly do .NET Framework de uma chamada de método em vez de usar a palavra-chave de definição de classe de um idioma específico (como `class` em c# ou `Class`...`End Class` no Visual Basic), ele não permite atributos do .NET Framework a ser atribuído ao conjunto usando sintaxe de atributo padrão do idioma de desenvolvimento. O `attributes` parâmetro fornece um método alternativo para definir os atributos que se aplicam ao assembly. Para cada atributo que você deseja aplicar ao assembly, faça o seguinte:  
  
1.  Crie uma matriz de <xref:System.Type> objetos que representam os tipos de parâmetro do construtor de atributo que você deseja chamar.  
  
2.  Recuperar um <xref:System.Type> que representa a classe de atributo que você deseja aplicar ao novo conjunto de objeto.  
  
3.  Chamar o <xref:System.Type.GetConstructor%2A> método do atributo <xref:System.Type> objeto para recuperar um <xref:System.Reflection.ConstructorInfo> objeto que representa o construtor de atributo que você deseja chamar. Passar o <xref:System.Type.GetConstructor%2A> método a matriz de <xref:System.Type> objetos que representam os tipos de parâmetro do construtor.  
  
4.  Criar um <xref:System.Object> matriz que define os parâmetros para passar para construtor o atributo do.  
  
5.  Criar uma instância de um <xref:System.Reflection.Emit.CustomAttributeBuilder> objeto passando seu construtor o <xref:System.Reflection.ConstructorInfo> objeto recuperado na etapa 3 e o <xref:System.Object> matriz criada na etapa 4.  
  
 Você pode passar uma matriz desses <xref:System.Reflection.Emit.CustomAttributeBuilder> objetos em vez do `attributes` parâmetro para o <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir cria um assembly chamado RegexLib.dll e aplica o <xref:System.Reflection.AssemblyTitleAttribute> de atributos a ele. O assembly inclui duas expressões regulares compiladas. A primeira, `Utilities.RegularExpressions.DuplicatedString`, corresponde a duas palavras idênticas de contíguas. O segundo, `Utilities.RegularExpressions.EmailAddress`, verifica se uma cadeia de caracteres tem o formato correto deve ser um endereço de email.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile3.vb#3)]  
  
 Você pode verificar se o <xref:System.Reflection.AssemblyTitleAttribute> atributo foi aplicado ao assembly examinando seu manifesto com um utilitário de reflexão como ILDasm.  
  
 A expressão regular que verifica uma cadeia de caracteres para palavras duplicadas é instanciada e usada pelo exemplo a seguir.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Compilação bem-sucedida deste segundo exemplo requer uma referência a RegexLib.dll (o assembly criado pelo primeiro exemplo) a ser adicionado ao projeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor da propriedade <see cref="P:System.Reflection.AssemblyName.Name" /> do parâmetro <paramref name="assemblyname" /> é uma cadeia de caracteres vazia ou nula.  
  
 - ou -  
  
 O padrão de expressão regular de um ou mais objetos em <paramref name="regexinfos" /> contém sintaxe inválida.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyname" /> ou <paramref name="regexinfos" /> é <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Se você estiver desenvolvendo em um sistema que tem [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ou suas versões ponto instalados, destino [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], e você usar o <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> método para criar um assembly que contém compilado expressões regulares. Tentativa de usar uma das expressões regulares do assembly em um sistema que tem [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] lança uma exceção. Para solucionar esse problema, pode-se seguir uma das seguintes alternativas:  
  
-   Compile o assembly que contém as expressões regulares compiladas em um sistema que tem [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] em vez de versões mais recentes instalados.  
  
-   Em vez de chamar <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> e recuperar a expressão regular compilada de um assembly, use estáticas ou instância <see cref="T:System.Text.RegularExpressions.Regex" /> métodos com o <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> opção quando você cria uma instância um <see cref="T:System.Text.RegularExpressions.Regex" /> de objeto ou chamar uma expressão regular método de correspondência de padrão.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes, System::String ^ resourceFile);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
        <Parameter Name="resourceFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Uma matriz que descreve as expressões regulares a compilar.</param>
        <param name="assemblyname">O nome do arquivo do assembly.</param>
        <param name="attributes">Uma matriz que define os atributos a serem aplicados ao assembly.</param>
        <param name="resourceFile">O nome do arquivo de recurso Win32 a ser incluído no assembly.</param>
        <summary>Compila um ou mais objetos <see cref="T:System.Text.RegularExpressions.Regex" /> especificados e um arquivo de recurso especificado para um assembly nomeado com os atributos especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29> method generates a .NET Framework assembly in which each regular expression defined in the `regexinfos` array is represented by a class. Typically, the [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29> method is called from a separate application that generates an assembly of compiled regular expressions. Cada expressão regular incluído no assembly tem as seguintes características:  
  
-   Ele é derivado de <xref:System.Text.RegularExpressions.Regex> classe.  
  
-   Ele recebe o nome totalmente qualificado que é definido pelo `fullnamespace` e `name` parâmetros de correspondente <xref:System.Text.RegularExpressions.RegexCompilationInfo> objeto.  
  
-   Ele tem um padrão (ou sem parâmetros) construtor.  
  
 Normalmente, o código que cria e usa a expressão regular compilada é encontrado em um assembly ou aplicativo que é separado do código que cria o assembly.  
  
 Porque o <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> método gera um assembly do .NET Framework de uma chamada de método em vez de usar a palavra-chave de definição de classe de um idioma específico (como `class` em c# ou `Class`...`End Class` no Visual Basic), ele não permite atributos do .NET Framework a ser atribuído ao conjunto usando sintaxe de atributo padrão do idioma de desenvolvimento. O `attributes` parâmetro fornece um método alternativo para definir os atributos que se aplicam ao assembly. Para cada atributo que você deseja aplicar ao assembly, faça o seguinte:  
  
1.  Crie uma matriz de <xref:System.Type> objetos que representam os tipos de parâmetro do construtor de atributo que você deseja chamar.  
  
2.  Recuperar um <xref:System.Type> que representa a classe de atributo que você deseja aplicar ao novo conjunto de objeto.  
  
3.  Chamar o <xref:System.Type.GetConstructor%2A> método do atributo <xref:System.Type> objeto para recuperar um <xref:System.Reflection.ConstructorInfo> objeto que representa o construtor de atributo que você deseja chamar. Passar o <xref:System.Type.GetConstructor%2A> método a matriz de <xref:System.Type> objetos que representam os tipos de parâmetro do construtor  
  
4.  Criar um <xref:System.Object> matriz que define os parâmetros para passar para construtor o atributo do.  
  
5.  Criar uma instância de um <xref:System.Reflection.Emit.CustomAttributeBuilder> objeto passando seu construtor o <xref:System.Reflection.ConstructorInfo> objeto recuperado na etapa 3 e o <xref:System.Object> matriz criada na etapa 4.  
  
 You can then pass an array of these <xref:System.Reflection.Emit.CustomAttributeBuilder> objects instead of the `attributes` parameter to the [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29> method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor da propriedade <see cref="P:System.Reflection.AssemblyName.Name" /> do parâmetro <paramref name="assemblyname" /> é uma cadeia de caracteres vazia ou nula.  
  
 - ou -  
  
 O padrão de expressão regular de um ou mais objetos em <paramref name="regexinfos" /> contém sintaxe inválida.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyname" /> ou <paramref name="regexinfos" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">O parâmetro <paramref name="resourceFile" /> designa um arquivo de recurso Win32 inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo designado pelo parâmetro <paramref name="resourceFile" /> não pôde ser encontrado.</exception>
        <block subset="none" type="usage">
          <para>Se você estiver desenvolvendo em um sistema que tem [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ou suas versões ponto instalados, destino [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], e você usar o <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> método para criar um assembly que contém compilado expressões regulares. Tentativa de usar uma das expressões regulares do assembly em um sistema que tem [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] lança uma exceção. Para solucionar esse problema, pode-se seguir uma das seguintes alternativas:  
  
-   Compile o assembly que contém as expressões regulares compiladas em um sistema que tem [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] em vez de versões mais recentes instalados.  
  
-   Em vez de chamar <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> e recuperar a expressão regular compilada de um assembly, use estáticas ou instância <see cref="T:System.Text.RegularExpressions.Regex" /> métodos com o <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> opção quando você cria uma instância um <see cref="T:System.Text.RegularExpressions.Regex" /> de objeto ou chamar uma expressão regular método de correspondência de padrão.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="public static string Escape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Escape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Escape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Escape(System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">A cadeia de caracteres de entrada que contém o texto a ser convertido.</param>
        <summary>Ignora um conjunto mínimo de caracteres (\\, *, +, ?, |, {, [, (, ), ^, $, ., # e espaço em branco) substituindo-os por seus códigos de escape. Isso instrui o mecanismo de expressões regulares para interpretar esses caracteres literalmente em vez de metacaracteres.</summary>
        <returns>Uma cadeia de caracteres com metacaracteres convertidos em sua forma de escape.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Escape%2A> Converte uma cadeia de caracteres para que o mecanismo de expressão regular interpretará qualquer metacaracteres que pode conter como literais de caracteres. Por exemplo, considere uma expressão regular que é projetada para extrair os comentários são delimitados reta abrindo e fechando colchetes ([e]) de texto. No exemplo a seguir, a expressão regular "[(.*?)]" será interpretado como uma classe de caracteres. Em vez de correspondência de comentários inseridos no texto de entrada, a expressão regular corresponde a cada abertura ou o parêntese de fechamento, o período, o asterisco ou o ponto de interrogação.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#1)]  
  
 No entanto, se o colchete de abertura é ignorado, passando-o para o <xref:System.Text.RegularExpressions.Regex.Escape%2A> método, a expressão regular for bem-sucedido na correspondência de comentários são incorporados na cadeia de entrada. O exemplo a seguir ilustra essa situação.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#2)]  
  
 Em uma expressão regular que é definida por meio de um texto estático, os caracteres que devem ser interpretadas literalmente em vez de como metacaracteres podem ser substituído, precedendo-as com um símbolo de barra invertida (\\) bem como ao chamar o <xref:System.Text.RegularExpressions.Regex.Escape%2A> método. Em uma expressão regular que é definida dinamicamente usando caracteres que não são conhecidos no tempo de design, chamar o <xref:System.Text.RegularExpressions.Regex.Escape%2A> método é particularmente importante garantir que o mecanismo de expressão regular interpreta os caracteres individuais como literais em vez de metacaracteres.  
  
> [!NOTE]
>  Se uma expressão regular padrão inclui o sinal numérico (#) ou os caracteres de espaço em branco literal, elas devem ser substituídas se o texto de entrada é analisado com o <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> opção habilitada.  
  
 Enquanto o <xref:System.Text.RegularExpressions.Regex.Escape%2A> método ignora a simples abertura colchete ([) e abrindo caracteres de chaves ({}), ele não escapa seus caracteres de fechamento correspondente (] e}). Na maioria dos casos, não é necessário escapar esses. Se um colchete de fechamento ou a chave não for precedido por seu caractere de abertura correspondente, o mecanismo de expressão regular interpretará literalmente. Se um braket de abertura ou a chave é interpretada como um metacaractere, o mecanismo de expressão regular interpreta correspondente primeiro caractere como um metacaractere de fechamento. Se isso não é o comportamento desejado, o colchete de fechamento ou chaves devem ser escapados acrescentando explicitamente a barra invertida (\\) caracteres. Para obter uma ilustração, consulte a seção de exemplo.  
  
   
  
## Examples  
 O exemplo a seguir extrai comentários do texto. Ele pressupõe que os comentários são delimitados por um símbolo de comentário de início e um símbolo de comentário final selecionado pelo usuário. Como os símbolos de comentário devem ser interpretadas literalmente, eles são passados para o <xref:System.Text.RegularExpressions.Regex.Escape%2A> método para garantir que eles não podem ser interpretados incorretamente como metacaracteres. Além disso, o exemplo verifica explicitamente se o símbolo de comentário final inserido pelo usuário é um colchete de fechamento (]) ou colchete (}). Se for, um caractere de barra invertida (\\) é colocado antes do colchete ou chave para que ele seja interpretado literalmente. Observe que o exemplo também usa o <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> coleção para exibir o comentário somente, em vez de comentário junto com seus símbolos de comentário de abertura e fechamento.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="factory">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexRunnerFactory factory;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Text.RegularExpressions.RegexRunnerFactory factory" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.factory" />
      <MemberSignature Language="VB.NET" Value="Protected Friend factory As RegexRunnerFactory " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexRunnerFactory ^ factory;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexRunnerFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Usado por um objeto <see cref="T:System.Text.RegularExpressions.Regex" /> gerado pelo método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNames">
      <MemberSignature Language="C#" Value="public string[] GetGroupNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetGroupNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetGroupNames();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma matriz de nomes de grupo de captura para a expressão regular.</summary>
        <returns>Uma matriz de cadeia de caracteres de nomes de grupo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A coleção de nomes de grupo contém o conjunto de cadeias de caracteres usado para grupos de captura de nome na expressão. Mesmo que grupos de captura não são explicitamente nomeados, eles recebem automaticamente nomes numéricos ("0", "1", "2", "3" e assim por diante). "0" denominado grupo representa todo o texto correspondido, o padrão de expressão regular. Grupos numerados precedem grupos explicitamente nomeados na coleção e grupos nomeados aparecem na ordem em que elas são definidas no padrão de expressão regular.  
  
 Você pode usar o <xref:System.Array.Length%2A> propriedade na matriz retornada por este método para determinar o número de grupos em uma expressão regular.  
  
   
  
## Examples  
 O exemplo a seguir define um uso geral `ShowMatches` método que exibe os nomes dos grupos de expressão regular e o texto correspondente.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/cs/getgroupnames1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/vb/getgroupnames1.vb#1)]  
  
 Nesse caso, o padrão de expressão regular `\b(?<FirstWord>\w+)\s?((\w+)\s)*(?<LastWord>\w+)?(?<Punctuation>\p{Po})` destina-se ao analisar uma frase simples e para identificar sua primeira palavra, a última palavra e a marca de pontuação final. A tabela a seguir mostra como o padrão de expressão regular é interpretado:  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\b`|Começa a correspondência em um limite de palavra.|  
|`(?<FirstWord>\w+)`|Corresponde a um ou mais caracteres de palavra. Este é o `FirstWord` chamado grupo.|  
|\s?|Corresponder a zero ou a um caractere de espaço em branco.|  
|(\w+)|Corresponde a um ou mais caracteres de palavra. Este é o segundo grupo de captura.|  
|\s|Corresponde a um caractere de espaço em branco.|  
|((\w+)\s)*|Corresponde a zero ou mais ocorrências de um ou mais caracteres de palavra, seguidos por um espaço em branco. Este é o primeiro grupo de captura.|  
|(?\<LastWord>\w+)?|Corresponde a zero ou uma ocorrência de um ou mais caracteres de texto. Este é o `LastWord` chamado grupo.|  
|(? \<Pontuação > \p{Po})|Corresponder um caractere cuja categoria Unicode é a pontuação, outros. Este é o `Punctuation` chamado grupo.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
      </Docs>
    </Member>
    <Member MemberName="GetGroupNumbers">
      <MemberSignature Language="C#" Value="public int[] GetGroupNumbers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] GetGroupNumbers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNumbers () As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ GetGroupNumbers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma matriz de números de grupo de captura que correspondem aos nomes de grupos em uma matriz.</summary>
        <returns>Uma matriz de inteiros de números de grupo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Grupos de captura nomeados e não podem ser acessados pelo número. Grupos sem nome são numerados da esquerda para direita começando com 1. (O grupo de captura no índice 0 (zero) representa a correspondência como um todo.)  Grupos nomeados são numerados da esquerda para a direita a partir um número que é maior que o número de sem nome grupos de captura.  
  
 Fazendo referência a um grupo por seu número, em vez de por nome de cadeia de caracteres pode fornecer acesso mais rápido.  
  
   
  
## Examples  
 O exemplo a seguir define uma expressão regular, `\b((?<word>\w+)\s*)+(?<end>[.?!])`, que corresponde a uma sentença. A expressão regular inclui três grupos de captura: um grupo sem nome que captura uma palavra individual junto com um caractere de espaço que pode segui-la; um grupo chamado `word` que captura as palavras individuais na frase; e um grupo chamado `end` que captura a pontuação que termina a sentença. O exemplo chama o <xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A> método para obter os números de capturar todos os grupos e, em seguida, exibe seu capturada cadeia de caracteres. Além disso, o <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> método é usado para indicar se um determinado grupo numerado corresponde a um grupo nomeado.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/cs/getgroupnumbers1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/vb/getgroupnumbers1.vb#1)]  
  
 O padrão da expressão regular é interpretado conforme a tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\b`|Começa a correspondência em um limite de palavra.|  
|`(?<word>\w+)`|Corresponde a um ou mais caracteres de palavra e atribuir as cadeias de caracteres correspondentes a um grupo chamado `word`.|  
|`\s*`|Corresponder a zero ou mais caracteres de espaço em branco.|  
|`((?<word>\w+)\s*)`|Atribuir o `word` capturada de grupo capturado, seguido por quaisquer caracteres de espaço em branco para o primeiro grupo capturado.|  
|`((?<word>\w+)\s*)+`|Corresponde ao padrão de um ou mais caracteres de palavra seguido por qualquer caractere de espaço em branco uma ou mais vezes.|  
|`(?<end>[.?!])`|Corresponde a um ponto, um ponto de interrogação ou um ponto de exclamação. Atribuir o caractere correspondente para o `end` grupo de captura.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
      </Docs>
    </Member>
    <Member MemberName="GroupNameFromNumber">
      <MemberSignature Language="C#" Value="public string GroupNameFromNumber (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GroupNameFromNumber(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNameFromNumber (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GroupNameFromNumber(int i);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">O número do grupo a ser convertido para o nome de grupo correspondente.</param>
        <summary>Obtém o nome do grupo que corresponde ao número do grupo especificado.</summary>
        <returns>Uma cadeia de caracteres que contém o nome de grupo associado ao número de grupo especificado. Se não houver nenhum nome de grupo que corresponda a <paramref name="i" />, o método retornará <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um padrão de expressão regular pode conter grupos capturas numerados ou nomeados, que delineiam subexpressões dentro de uma correspondência de padrão. Grupos numerados são delimitados pela sintaxe (*subexpressão*) e são atribuídos números com base em sua ordem na expressão regular. Grupos nomeados são delimitados pela sintaxe (?`<` *name*`>`*subexpression*) or (?' *nome*'*subexpressão*), onde *nome* é o nome pelo qual a subexpressão será identificada. (Para saber mais, confira [Constructos de agrupamento](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)). O <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> método identifica grupos nomeados e numerados grupos por suas posições ordinais na expressão regular. Posição ordinal zero sempre representa toda a expressão regular. Numerada todos os grupos são contabilizados antes de grupos nomeados, independentemente de sua posição atual no padrão de expressão regular.  
  
 Se `i` é o número de um grupo nomeado, o método retorna o nome do grupo. Se `i` é o número de um grupo sem nome, o método retorna a representação de cadeia de caracteres do número. Por exemplo, se `i` for 1, o método retornará "1". Se `i` não é o número de um grupo de captura, o método retornará <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Se for encontrada uma correspondência de padrão, o valor retornado por esse método, em seguida, pode ser usado para recuperar o <xref:System.Text.RegularExpressions.Group> objeto que representa o grupo capturado do <xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType> propriedade. O <xref:System.Text.RegularExpressions.GroupCollection> retornado pelo objeto de <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir define um padrão de expressão regular que corresponde a uma linha de endereço que contém o nome da cidade dos EUA, o nome de estado e CEP. O exemplo usa o <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> método para recuperar os nomes dos grupos de captura. Ele então usa esses nomes para recuperar os grupos capturados correspondentes de correspondências.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/cs/groupnamefromnumberex.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/vb/groupnamefromnumberex.vb#1)]  
  
 O padrão de expressão regular é definido pela seguinte expressão:  
  
 `(?<city>[A-Za-z\s]+), (?<state>[A-Za-z]{2}) (?<zip>\d{5}(-\d{4})?)`  
  
 A tabela a seguir mostra como o padrão da expressão regular é interpretado.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`(?<city>[A-Za-z\s]+)`|Corresponde a um ou mais caracteres alfabéticos ou espaço em branco. Atribuir o nome este grupo capturado `city`.|  
|`,`|Corresponde a uma vírgula (,) seguida por um caractere de espaço em branco.|  
|`(?<state>[A-Za-z]{2})`|Corresponde a dois caracteres alfabéticos. Atribuir o nome este grupo capturado `state`. Esse grupo deve ser seguido por um caractere de espaço em branco.|  
|`(?<zip>\d{5}(-\d{4})?)`|Corresponde a cinco dígitos numéricos seguidos de zero ou uma ocorrência de um hífen seguido por quatro dígitos. Atribuir o nome este grupo capturado `zip`.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      </Docs>
    </Member>
    <Member MemberName="GroupNumberFromName">
      <MemberSignature Language="C#" Value="public int GroupNumberFromName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GroupNumberFromName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNumberFromName (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GroupNumberFromName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome do grupo a ser convertido para o número de grupo correspondente.</param>
        <summary>Retorna o número do grupo que corresponde ao nome do grupo especificado.</summary>
        <returns>O número do grupo que corresponde ao nome do grupo especificado ou -1 se <paramref name="name" /> não for um nome de grupo válido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um padrão de expressão regular pode conter grupos capturas numerados ou nomeados, que delineiam subexpressões dentro de uma correspondência de padrão. Grupos numerados são delimitados pela sintaxe (*subexpressão*) e são atribuídos números com base em sua ordem na expressão regular. Grupos nomeados são delimitados pela sintaxe (?`<` *name*`>`*subexpression*) or (?' *nome*'*subexpressão*), onde *nome* é o nome pelo qual a subexpressão será identificada. (Para saber mais, confira [Constructos de agrupamento](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)). O <xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A> método identifica grupos nomeados e numerados grupos por suas posições ordinais na expressão regular. Posição ordinal zero sempre representa toda a expressão regular. Numerada todos os grupos são contabilizados antes de grupos nomeados, independentemente de sua posição atual no padrão de expressão regular.  
  
 Se `name` é a representação de cadeia de caracteres de um número de grupo que está presente no padrão de expressão regular, o método retorna esse número. Se `name` corresponde a uma nomeada captura o grupo que está presente no padrão de expressão regular, o método retorna o número correspondente. A comparação de `name` com o grupo diferencia maiusculas de minúsculas. Se `name` não corresponde ao nome de um grupo de captura ou a representação de cadeia de caracteres do número de um grupo de captura, o método retornará -1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteMatchTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteMatchTimeout;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que uma operação de correspondência de padrões não deve atingir o tempo limite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> construtor e um número estático uso correspondente de métodos de classe a <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> constante para indicar que a tentativa de encontrar uma correspondência de padrão deve sem tempo limite.  
  
> [!WARNING]
>  Definir o valor de tempo limite do mecanismo de expressão regular <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> pode fazer com que as expressões regulares que dependem de retrocesso excessivo para parar de responder durante o processamento de texto que quase corresponde ao padrão de expressão regular. Se você desabilitar o tempo limite, você deve garantir que sua expressão regular não depende de retrocesso excessiva e que se trata de texto que quase corresponde ao padrão de expressão regular.  
>   
>  Para obter mais informações sobre o tratamento de retrocesso, consulte [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 O <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> constante pode ser fornecida como o valor da `matchTimeout` argumento dos seguintes membros:  
  
-   <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.RegexCompilationInfo.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.String%2CSystem.String%2CSystem.Boolean%2CSystem.TimeSpan%29?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      </Docs>
    </Member>
    <Member MemberName="InitializeReferences">
      <MemberSignature Language="C#" Value="protected void InitializeReferences ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeReferences() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.InitializeReferences" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeReferences ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeReferences();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usado por um objeto <see cref="T:System.Text.RegularExpressions.Regex" /> gerado pelo método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">As referências já foram inicializadas.</exception>
      </Docs>
    </Member>
    <Member MemberName="internalMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.TimeSpan internalMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend internalMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="protected public: TimeSpan internalMatchTimeout;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.OptionalField(VersionAdded=2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A quantidade de tempo máxima que pode decorrer em uma operação de correspondência de padrões antes que a operação atinja o tempo limite.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsMatch">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica se a expressão regular encontra uma correspondência na cadeia de caracteres de entrada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <summary>Indica se a expressão regular especificada no construtor <see cref="T:System.Text.RegularExpressions.Regex" /> encontra uma correspondência em uma cadeia de caracteres de entrada especificada.</summary>
        <returns>
          <see langword="true" /> se a expressão regular encontrar uma correspondência; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> método normalmente é usado para validar uma cadeia de caracteres ou para garantir que uma cadeia de caracteres está de acordo com um padrão específico sem recuperar essa cadeia de caracteres para manipulação subsequente. Se você quiser determinar se um ou mais cadeias de caracteres correspondem a um padrão de expressão regular e, em seguida, recuperá-las para manipulação subsequente, chamada de <xref:System.Text.RegularExpressions.Regex.Match%2A> ou <xref:System.Text.RegularExpressions.Regex.Matches%2A> método.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é gerada se o tempo de execução da operação de correspondência excede o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um intervalo de tempo limite ao chamar o construtor, a exceção é gerada se a operação exceder qualquer valor de tempo limite estabelecida para o domínio de aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido no <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio de aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> método para determinar se uma cadeia de caracteres é um número de peça válido. A expressão regular presume que o número de peça tem um formato específico que consiste em três conjuntos de caracteres separados por hifens. O primeiro conjunto que contém quatro caracteres, deve conter um caractere alfanumérico seguido por dois caracteres numéricos, seguidos por um caractere alfanumérico. O segundo conjunto consiste em três caracteres, deve ser numérico. O terceiro conjunto consiste em quatro caracteres, deve ter três caracteres alfanuméricos, seguidos por um caractere alfanumérico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch2.vb#2)]  
  
 O padrão da expressão regular é:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 A tabela a seguir mostra como o padrão da expressão regular é interpretado.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`^`|Começar a correspondência no início da linha.|  
|`[a-zA-Z0-9]`|Corresponder um caractere alfabético (`a` por meio de `z` ou `A` por meio de `Z`) ou o caractere numérico.|  
|`\d{2}`|Corresponde a dois caracteres alfanuméricos.|  
|`[a-zA-Z0-9]`|Corresponder um caractere alfabético (`a` por meio de `z` ou `A` por meio de `Z`) ou o caractere numérico.|  
|`-`|Corresponder a um hífen.|  
|`\d{3}`|Corresponde exatamente três caracteres alfanuméricos.|  
|`(-\d{3}){2}`|Localizar um hífen seguido de três caracteres alfanuméricos e corresponder a duas ocorrências desse padrão.|  
|`[a-zA-Z0-9]`|Corresponder um caractere alfabético (`a` por meio de `z` ou `A` por meio de `Z`) ou o caractere numérico.|  
|`$`|Finalizar a correspondência no final da linha.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String, startat As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="startat">A posição do caractere em que a pesquisa será iniciada.</param>
        <summary>Indica se a expressão regular especificada no construtor <see cref="T:System.Text.RegularExpressions.Regex" /> encontra uma correspondência na cadeia de caracteres de entrada especificada, começando na posição inicial especificada na cadeia de caracteres.</summary>
        <returns>
          <see langword="true" /> se a expressão regular encontrar uma correspondência; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> método normalmente é usado para validar uma cadeia de caracteres ou para garantir que uma cadeia de caracteres está de acordo com um padrão específico sem recuperar essa cadeia de caracteres para manipulação subsequente. Se você quiser determinar se um ou mais cadeias de caracteres correspondem a um padrão de expressão regular e, em seguida, recuperá-las para manipulação subsequente, chamada de <xref:System.Text.RegularExpressions.Regex.Match%2A> ou <xref:System.Text.RegularExpressions.Regex.Matches%2A> método.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é gerada se o tempo de execução da operação de correspondência excede o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um intervalo de tempo limite ao chamar o construtor, a exceção é gerada se a operação exceder qualquer valor de tempo limite estabelecida para o domínio de aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido no <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio de aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> método para determinar se uma cadeia de caracteres é um número de peça válido. Ele procura por um número de peça que segue um caractere de dois-pontos (:) em uma cadeia de caracteres. O <xref:System.String.IndexOf%28System.Char%29> método é usado para determinar a posição do caractere dois-pontos, que é então passado para o <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> método. A expressão regular presume que o número de peça tem um formato específico que consiste em três conjuntos de caracteres separados por hifens. O primeiro conjunto que contém quatro caracteres, deve conter um caractere alfanumérico seguido por dois caracteres numéricos, seguidos por um caractere alfanumérico. O segundo conjunto consiste em três caracteres, deve ser numérico. O terceiro conjunto consiste em quatro caracteres, deve ter três caracteres alfanuméricos, seguidos por um caractere alfanumérico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch3.vb#3)]  
  
 O padrão da expressão regular é:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 A tabela a seguir mostra como o padrão da expressão regular é interpretado.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`[a-zA-Z0-9]`|Corresponder um caractere alfabético (`a` por meio de `z` ou `A` por meio de `Z`) ou o caractere numérico.|  
|`\d{2}`|Corresponde a dois caracteres alfanuméricos.|  
|`[a-zA-Z0-9]`|Corresponder um caractere alfabético (`a` por meio de `z` ou `A` por meio de `Z`) ou o caractere numérico.|  
|`-`|Corresponder a um hífen.|  
|`\d{3}`|Corresponde exatamente três caracteres alfanuméricos.|  
|`(-\d{3}){2}`|Localizar um hífen seguido de três caracteres alfanuméricos e corresponder a duas ocorrências desse padrão.|  
|`[a-zA-Z0-9]`|Corresponder um caractere alfabético (`a` por meio de `z` ou `A` por meio de `Z`) ou o caractere numérico.|  
|`$`|Finalizar a correspondência no final da linha.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> é menor que zero ou maior que o tamanho de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <summary>Indica se a expressão regular especificada encontra uma correspondência na cadeia de caracteres de entrada especificada.</summary>
        <returns>
          <see langword="true" /> se a expressão regular encontrar uma correspondência; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> método normalmente é usado para validar uma cadeia de caracteres ou para garantir que uma cadeia de caracteres está de acordo com um padrão específico sem recuperar essa cadeia de caracteres para manipulação subsequente. Se você quiser determinar se um ou mais cadeias de caracteres correspondem a um padrão de expressão regular e, em seguida, recuperá-las para manipulação subsequente, chamada de <xref:System.Text.RegularExpressions.Regex.Match%2A> ou <xref:System.Text.RegularExpressions.Regex.Matches%2A> método.  
  
 Estático <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> método é equivalente ao construir um <xref:System.Text.RegularExpressions.Regex> objeto com o padrão de expressão regular especificado por `pattern` e chamar o <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> método de instância. Esse padrão de expressão regular é armazenado em cache para fornecer recuperação rápida pelo mecanismo de expressão regular.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que maneira simbólica descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é gerada se o tempo de execução da operação de correspondência excede o intervalo de tempo limite especificado para o domínio de aplicativo no qual o método é chamado. Se nenhum tempo limite é definido nas propriedades do domínio de aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> método para determinar se uma cadeia de caracteres é um número de peça válido. A expressão regular presume que o número de peça tem um formato específico que consiste em três conjuntos de caracteres separados por hifens. O primeiro conjunto que contém quatro caracteres, deve conter um caractere alfanumérico seguido por dois caracteres numéricos, seguidos por um caractere alfanumérico. O segundo conjunto consiste em três caracteres, deve ser numérico. O terceiro conjunto consiste em quatro caracteres, deve ter três caracteres alfanuméricos, seguidos por um caractere alfanumérico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch1.vb#1)]  
  
 O padrão da expressão regular é:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 A tabela a seguir mostra como o padrão da expressão regular é interpretado.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`^`|Começar a correspondência no início da linha.|  
|`[a-zA-Z0-9]`|Corresponder um caractere alfabético (`a` por meio de `z` ou `A` por meio de `Z`) ou o caractere numérico.|  
|`\d{2}`|Corresponde a dois caracteres alfanuméricos.|  
|`[a-zA-Z0-9]`|Corresponder um caractere alfabético (`a` por meio de `z` ou `A` por meio de `Z`) ou o caractere numérico.|  
|`-`|Corresponder a um hífen.|  
|`\d{3}`|Corresponde exatamente três caracteres alfanuméricos.|  
|`(-\d{3}){2}`|Localizar um hífen seguido de três caracteres alfanuméricos e corresponder a duas ocorrências desse padrão.|  
|`[a-zA-Z0-9]`|Corresponder um caractere alfabético (`a` por meio de `z` ou `A` por meio de `Z`) ou o caractere numérico.|  
|`$`|Finalizar a correspondência no final da linha.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="pattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <block subset="none" type="usage">
          <para>Esse método expire após um intervalo que seja igual ao valor de tempo limite padrão do domínio do aplicativo no qual o método é chamado. Se um valor de tempo limite não tiver sido definido para o domínio de aplicativo, o valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impede que o método do tempo limite, é usado. O método estático recomendado para verificar uma correspondência de padrão é <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite que você defina o intervalo de tempo limite.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que fornece opções para correspondência.</param>
        <summary>Indica se a expressão regular especificada encontra uma correspondência na cadeia de caracteres de entrada especificada, usando as opções de correspondência especificadas.</summary>
        <returns>
          <see langword="true" /> se a expressão regular encontrar uma correspondência; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> método normalmente é usado para validar uma cadeia de caracteres ou para garantir que uma cadeia de caracteres está de acordo com um padrão específico sem recuperar essa cadeia de caracteres para manipulação subsequente. Se você quiser determinar se um ou mais cadeias de caracteres correspondem a um padrão de expressão regular e, em seguida, recuperá-las para manipulação subsequente, chamada de <xref:System.Text.RegularExpressions.Regex.Match%2A> ou <xref:System.Text.RegularExpressions.Regex.Matches%2A> método.  
  
 Estático <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método é equivalente ao construir um <xref:System.Text.RegularExpressions.Regex> objeto com o padrão de expressão regular especificado por `pattern` e as opções de expressão regular especificadas pelo `options` e chamar o <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> método de instância. Esse padrão de expressão regular é armazenado em cache para fornecer recuperação rápida pelo mecanismo de expressão regular.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que maneira simbólica descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é gerada se o tempo de execução da operação de correspondência excede o intervalo de tempo limite especificado para o domínio de aplicativo no qual o método é chamado. Se nenhum tempo limite é definido nas propriedades do domínio de aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> método para determinar se uma cadeia de caracteres é um número de peça válido. A expressão regular presume que o número de peça tem um formato específico que consiste em três conjuntos de caracteres separados por hifens. O primeiro conjunto que contém quatro caracteres, deve conter um caractere alfanumérico seguido por dois caracteres numéricos, seguidos por um caractere alfanumérico. O segundo conjunto consiste em três caracteres, deve ser numérico. O terceiro conjunto consiste em quatro caracteres, deve ter três caracteres alfanuméricos, seguidos por um caractere alfanumérico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch4.vb#4)]  
  
 O padrão da expressão regular é:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 A tabela a seguir mostra como o padrão da expressão regular é interpretado.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`^`|Começar a correspondência no início da cadeia de caracteres.|  
|`[A-Z0-9]`|Corresponder qualquer caractere alfabético de `A` por meio de `Z`, ou qualquer caractere numérico.|  
|`\d{2}`|Corresponde a dois caracteres alfanuméricos.|  
|`[A-Z0-9]`|Corresponder qualquer caractere alfabético de `A` por meio de `Z`, ou qualquer caractere numérico.|  
|`-`|Corresponder a um hífen.|  
|`\d{3}`|Corresponde exatamente três caracteres alfanuméricos.|  
|`(-\d{3}){2}`|Localizar um hífen seguido de três caracteres alfanuméricos e corresponder a duas ocorrências desse padrão.|  
|`[A-Z0-9]`|Corresponder qualquer caractere alfabético de `A` por meio de `Z`, ou qualquer caractere numérico.|  
|`$`|Encerrar a correspondência ao final da cadeia de caracteres.|  
  
 Chamando o <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método com o `options` parâmetro definido como <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> é equivalente a definir a seguinte expressão regular:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Por comparação, consulte o exemplo para o <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="pattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> não é um valor <see cref="T:System.Text.RegularExpressions.RegexOptions" /> válido.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <block subset="none" type="usage">
          <para>Esse método expire após um intervalo que seja igual ao valor de tempo limite padrão do domínio do aplicativo no qual ele é chamado. Se um valor de tempo limite não tiver sido definido para o domínio de aplicativo, o valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impede que o método do tempo limite, é usado. O método estático recomendado para verificar uma correspondência de padrão é <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite que você defina o intervalo de tempo limite.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que fornece opções para correspondência.</param>
        <param name="matchTimeout">Um intervalo de tempo limite ou <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que o método não deve atingir o tempo limite.</param>
        <summary>Indica se a expressão regular especificada encontra uma correspondência na cadeia de caracteres de entrada especificada, usando as opções de correspondência e intervalo de tempo limite especificados.</summary>
        <returns>
          <see langword="true" /> se a expressão regular encontrar uma correspondência; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> método normalmente é usado para validar uma cadeia de caracteres ou para garantir que uma cadeia de caracteres está de acordo com um padrão específico sem recuperar essa cadeia de caracteres para manipulação subsequente. Se você quiser determinar se um ou mais cadeias de caracteres correspondem a um padrão de expressão regular e, em seguida, recuperá-las para manipulação subsequente, chamada de <xref:System.Text.RegularExpressions.Regex.Match%2A> ou <xref:System.Text.RegularExpressions.Regex.Matches%2A> método.  
  
 Estático <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método é equivalente ao construir um <xref:System.Text.RegularExpressions.Regex> objeto com o padrão de expressão regular especificado por `pattern` e as opções de expressão regular especificadas pelo `options` e chamar o <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> método de instância. Esse padrão de expressão regular é armazenado em cache para fornecer recuperação rápida pelo mecanismo de expressão regular.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que maneira simbólica descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O `matchTimeout` parâmetro especifica como o tempo padrão correspondente método deve tentar localizar uma correspondência antes de expirar. Definir um intervalo de tempo limite impede que as expressões regulares que dependem de retrocesso excessiva de parece parar de responder ao processar a entrada que contém a próxima correspondência. Para obter mais informações, consulte [práticas recomendadas para expressões regulares](~/docs/standard/base-types/best-practices.md) e [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Se nenhuma correspondência for encontrada desse intervalo de tempo, o método gera uma <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção. `matchTimeout` substitui qualquer valor de tempo limite padrão definido para o domínio de aplicativo no qual o método é executado.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método para determinar se uma cadeia de caracteres é um número de peça válido. A expressão regular presume que o número de peça tem um formato específico que consiste em três conjuntos de caracteres separados por hifens. O primeiro conjunto que contém quatro caracteres, deve conter um caractere alfanumérico seguido por dois caracteres numéricos, seguidos por um caractere alfanumérico. O segundo conjunto consiste em três caracteres, deve ser numérico. O terceiro conjunto consiste em quatro caracteres, deve ter três caracteres alfanuméricos, seguidos por um caractere alfanumérico. O padrão de expressão regular de correspondência deve envolver mínimo pesquisar a cadeia de caracteres de entrada, para que o método define um intervalo de tempo limite de 500 milissegundos.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch5.vb#5)]  
  
 O padrão da expressão regular é:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 A tabela a seguir mostra como o padrão da expressão regular é interpretado.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`^`|Começar a correspondência no início da cadeia de caracteres.|  
|`[A-Z0-9]`|Corresponder qualquer caractere alfabético de `A` por meio de `Z`, ou qualquer caractere numérico.|  
|`\d{2}`|Corresponde a dois caracteres alfanuméricos.|  
|`[A-Z0-9]`|Corresponder qualquer caractere alfabético de `A` por meio de `Z`, ou qualquer caractere numérico.|  
|`-`|Corresponder a um hífen.|  
|`\d{3}`|Corresponde exatamente três caracteres alfanuméricos.|  
|`(-\d{3}){2}`|Localizar um hífen seguido de três caracteres alfanuméricos e corresponder a duas ocorrências desse padrão.|  
|`[A-Z0-9]`|Corresponder qualquer caractere alfabético de `A` por meio de `Z`, ou qualquer caractere numérico.|  
|`$`|Encerrar a correspondência ao final da cadeia de caracteres.|  
  
 Chamando o <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método com o `options` parâmetro definido como <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> é equivalente a definir a seguinte expressão regular:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Por comparação, consulte o exemplo para o <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="pattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> não é um valor <see cref="T:System.Text.RegularExpressions.RegexOptions" /> válido.  
  
 - ou -  
  
 <paramref name="matchTimeout" /> é negativo, zero ou maior que aproximadamente 24 dias.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite.</exception>
        <block subset="none" type="usage">
          <para>Recomendamos que você defina o <paramref name="matchTimeout" /> parâmetro para um valor apropriado, como dois segundos. Se você desabilitar o tempo limite especificando <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, o mecanismo de expressão regular oferece um pouco melhor desempenho. No entanto, você deve desabilitar tempos limite apenas sob as seguintes condições:  
  
-   Quando a entrada processada por uma expressão regular é derivada de uma origem conhecida e confiável ou consiste em texto estático. Exclui o texto que tenha sido dinamicamente entrada pelos usuários.  
  
-   Quando o padrão de expressão regular tem foram testado para garantir que ele trata com eficiência corresponde não correspondências e próximo corresponde.  
  
-   Quando o padrão de expressão regular não contém linguagem elementos que causam retrocesso excessiva durante o processamento de uma correspondência near.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Match">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pesquisa em uma cadeia de caracteres de entrada uma subcadeia de caracteres que corresponde a um padrão de expressão regular e retorna a primeira ocorrência como um único objeto <see cref="T:System.Text.RegularExpressions.Match" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <summary>Pesquisa a primeira ocorrência da expressão regular especificada na cadeia de caracteres de entrada especificada no construtor <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Um objeto que contém informações sobre a correspondência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> método retorna a primeira subcadeia de caracteres que corresponde a um padrão de expressão regular em uma cadeia de caracteres de entrada. Para obter informações sobre os elementos de linguagem usados para criar um padrão de expressão regular, consulte [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Você pode determinar se o padrão de expressão regular foi encontrado na cadeia de caracteres de entrada, verificando o valor retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Group.Success%2A> propriedade. Se uma correspondência for encontrada, retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Capture.Value%2A> propriedade contém a subcadeia de caracteres `input` que corresponde ao padrão de expressão regular. Se nenhuma correspondência for encontrada, seu valor é <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Este método retorna a subcadeia de caracteres primeiro no `input` que corresponde ao padrão de expressão regular. Você pode recuperar correspondências subsequentes chamando repetidamente retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> método. Você também pode recuperar todas as correspondências em uma única chamada de método chamando o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> método.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é gerada se o tempo de execução da operação de correspondência excede o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um intervalo de tempo limite ao chamar o construtor, a exceção é gerada se a operação exceder qualquer valor de tempo limite estabelecida para o domínio de aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido no <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio de aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
   
  
## Examples  
 O exemplo a seguir localiza o padrão de expressão regular faz a correspondência em uma cadeia de caracteres, em seguida, lista o correspondentes grupos, capturas e posições de captura.  
  
 [!code-cpp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp#8)]
 [!code-csharp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs#8)]
 [!code-vb[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb#8)]  
  
 O padrão de expressão regular `(\w+)\s+(car)` corresponde ocorrências da palavra "carro" junto com a palavra que o precede. Ele será interpretado como mostrado na tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`(\w+)`|Corresponde a um ou mais caracteres de palavra. Este é o primeiro grupo de captura.|  
|`\s+`|Corresponde a um ou mais caracteres de espaço em branco.|  
|(car)|Corresponde a cadeia de caracteres literal "carro". Este é o segundo grupo de captura.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, startat As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="startat">A posição do caractere baseada em zero na qual iniciar a pesquisa.</param>
        <summary>Procura a cadeia de caracteres de entrada para a primeira ocorrência de uma expressão regular, começando na posição inicial especificada na cadeia de caracteres.</summary>
        <returns>Um objeto que contém informações sobre a correspondência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> método retorna a primeira substring que corresponde a um padrão de expressão regular, iniciando em ou após o `startat` caractere posição em uma cadeia de caracteres de entrada. Para obter informações sobre os elementos de linguagem usados para criar um padrão de expressão regular, consulte [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O padrão de expressão regular para o qual o <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> método pesquisa é definido pela chamada para uma da <xref:System.Text.RegularExpressions.Regex> construtores de classe. Para obter mais informações sobre os elementos que podem formar um padrão de expressão regular, consulte [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Opcionalmente, você pode especificar uma posição inicial na cadeia de caracteres usando o `startat` parâmetro. Quando o mecanismo de expressão regular analisa da esquerda para a direita (o padrão), a correspondência e a verificação movem rightward, começando no caractere especificado em `startat`. Quando o mecanismo de expressão regular analisa da direita para a esquerda (quando o padrão de expressão regular é construído com a <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> opção), a correspondência e a verificação mover na direção oposta e começar com o caractere no `startat` -1. Se você não especificar uma posição inicial, a pesquisa começará no padrão `startat` posição. Se a pesquisa da esquerda para a direita, o padrão de expressão regular `startat` posição está na extremidade esquerda da `input`; se ele procura da direita para a esquerda, o padrão `startat` posição está na extremidade direita da `input`.  
  
 Se você quiser restringir uma correspondência para que ele começa na posição na cadeia de caracteres em particular e o mecanismo de expressão regular não examina o restante da cadeia de caracteres para uma correspondência, a expressão regular de ancoragem um `\G` (à esquerda de um padrão da esquerda para a direita ou à direita de um padrão da direita para esquerda). Isso restringe a correspondência; portanto, ele deve iniciar exatamente em `startat`.  
  
 Você pode determinar se o padrão de expressão regular foi encontrado na cadeia de caracteres de entrada, verificando o valor retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Group.Success%2A> propriedade. Se uma correspondência for encontrada, retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Capture.Value%2A> propriedade contém a subcadeia de caracteres `input` que corresponde ao padrão de expressão regular. Se nenhuma correspondência for encontrada, seu valor é <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Este método retorna a subcadeia de caracteres primeiro encontrada em ou após o `startat` posição de caractere `input` que corresponde ao padrão de expressão regular. Você pode recuperar correspondências subsequentes chamando repetidamente retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> método. Você também pode recuperar todas as correspondências em uma única chamada de método chamando o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> método.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é gerada se o tempo de execução da operação de correspondência excede o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um intervalo de tempo limite ao chamar o construtor, a exceção é lançada se qualquer valor de tempo limite de ultrapassa a operação estabelecida para o domínio de aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido no <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio de aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> é menor que zero ou maior que o tamanho de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <summary>Pesquisa a primeira ocorrência da expressão regular especificada na cadeia de caracteres de entrada especificada.</summary>
        <returns>Um objeto que contém informações sobre a correspondência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> método retorna a primeira subcadeia de caracteres que corresponde a um padrão de expressão regular em uma cadeia de caracteres de entrada. Para obter informações sobre os elementos de linguagem usados para criar um padrão de expressão regular, consulte [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Estático <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> método é equivalente ao construir um <xref:System.Text.RegularExpressions.Regex> do objeto com o padrão de expressão regular especificada e a instância de chamada <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> método. Nesse caso, o mecanismo de expressão regular armazena em cache o padrão de expressão regular.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que maneira simbólica descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Você pode determinar se o padrão de expressão regular foi encontrado na cadeia de caracteres de entrada, verificando o valor retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Group.Success%2A> propriedade. Se uma correspondência for encontrada, retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Capture.Value%2A> propriedade contém a subcadeia de caracteres `input` que corresponde ao padrão de expressão regular. Se nenhuma correspondência for encontrada, seu valor é <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Este método retorna a subcadeia de caracteres primeiro no `input` que corresponde ao padrão de expressão regular. Você pode recuperar correspondências subsequentes chamando repetidamente retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> método. Você também pode recuperar todas as correspondências em uma única chamada de método chamando o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> método.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é gerada se o tempo de execução da operação de correspondência excede o intervalo de tempo limite especificado para o domínio de aplicativo no qual o método é chamado. Se nenhum tempo limite é definido nas propriedades do domínio de aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> método para localizar a primeira palavra que contém pelo menos um `z` caractere e, em seguida, chama o <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> método para localizar todas as correspondências adicionais.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match1.vb#1)]  
  
 O padrão da expressão regular `\b\w*z+\w*\b` é interpretado conforme mostrado na tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\b`|Começa a correspondência em um limite de palavra.|  
|`\w*`|Corresponde a zero, um ou mais caracteres de texto.|  
|`z+`|Corresponde a uma ou mais ocorrências da `z` caracteres.|  
|`\w*`|Corresponde a zero, um ou mais caracteres de texto.|  
|`\b`|Termina a correspondência em um limite de palavra.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="pattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <block subset="none" type="usage">
          <para>Esse método expire após um intervalo que seja igual ao valor de tempo limite padrão do domínio do aplicativo no qual ele é chamado. Se um valor de tempo limite não tiver sido definido para o domínio de aplicativo, o valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impede que o método do tempo limite, é usado. O método estático recomendado para recuperar uma correspondência de padrão é <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, que permite que você defina o intervalo de tempo limite.</para>
        </block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int beginning, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 beginning, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, beginning As Integer, length As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int beginning, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="beginning" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="beginning">A posição do caractere baseado em zero na cadeia de caracteres de entrada que define a posição mais à esquerda a ser pesquisada.</param>
        <param name="length">O número de caracteres na subcadeia de caracteres a ser incluído na pesquisa.</param>
        <summary>Pesquisa a primeira ocorrência de uma expressão regular na cadeia de entrada, começando na posição inicial especificada e pesquisando apenas o número especificado de caracteres.</summary>
        <returns>Um objeto que contém informações sobre a correspondência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> método retorna a primeira subcadeia de caracteres que corresponde a um padrão de expressão regular em uma parte de uma cadeia de caracteres de entrada. Para obter informações sobre os elementos de linguagem usados para criar um padrão de expressão regular, consulte [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O padrão de expressão regular para o qual o <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> método pesquisa é definido pela chamada para uma da <xref:System.Text.RegularExpressions.Regex> construtores de classe. Para obter mais informações sobre os elementos que podem formar um padrão de expressão regular, consulte [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> a parte da pesquisa do método `input` definido pelo `beginning` e `length` parâmetros para o padrão de expressão regular. `beginning` sempre define o índice do caractere mais à esquerda para incluir na pesquisa, e `length` define o número máximo de caracteres a procurar. Juntos, eles definem o intervalo de pesquisa. Se a pesquisa continua a partir da esquerda para a direita (o padrão), o mecanismo de expressão regular pesquisará do caractere no índice `beginning` como o caractere no índice `beginning`  +  `length` – 1. Se o mecanismo de expressão regular foi instanciado usando o <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> opção para que a pesquisa continua da direita para a esquerda, as mecanismo de expressão regular pesquisas de caractere no índice `beginning`  +  `length` – 1 para o caractere no índice `beginning`. Esse método retorna a primeira correspondência que ele encontra dentro desse intervalo. Você pode recuperar correspondências subsequentes chamando repetidamente retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> método.  
  
 Você pode determinar se o padrão de expressão regular foi encontrado na cadeia de caracteres de entrada, verificando o valor retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Group.Success%2A> propriedade. Se uma correspondência for encontrada, retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Capture.Value%2A> propriedade contém a subcadeia de caracteres `input` que corresponde ao padrão de expressão regular. Se nenhuma correspondência for encontrada, seu valor é <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é gerada se o tempo de execução da operação de correspondência excede o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um valor de tempo limite ao chamar o construtor, a exceção é gerada se a operação exceder qualquer valor de tempo limite estabelecida para o domínio de aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido no <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio de aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="beginning" /> é menor que zero ou maior que o tamanho de <paramref name="input" />.  
  
 - ou -  
  
 <paramref name="length" /> é menor que zero ou maior que o tamanho de <paramref name="input" />.  
  
 - ou -  
  
 <paramref name="beginning" /><see langword="+" /><paramref name="length" /><see langword="–1" /> identifica uma posição fora do intervalo de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que fornece opções para correspondência.</param>
        <summary>Procura a cadeia de caracteres de entrada para a primeira ocorrência da expressão regular especificada, usando as opções especificadas de correspondência.</summary>
        <returns>Um objeto que contém informações sobre a correspondência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método retorna a primeira subcadeia de caracteres que corresponde a um padrão de expressão regular em uma cadeia de caracteres de entrada. Para obter informações sobre os elementos de linguagem usados para criar um padrão de expressão regular, consulte [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Estático <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método é equivalente ao construir um <xref:System.Text.RegularExpressions.Regex> do objeto com o <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> construtor e a instância de chamada <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> método.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que maneira simbólica descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Você pode determinar se o padrão de expressão regular foi encontrado na cadeia de caracteres de entrada, verificando o valor retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Group.Success%2A> propriedade. Se uma correspondência for encontrada, retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Capture.Value%2A> propriedade contém a subcadeia de caracteres `input` que corresponde ao padrão de expressão regular. Se nenhuma correspondência for encontrada, seu valor é <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Este método retorna a subcadeia de caracteres primeiro encontrada no `input` que corresponde ao padrão de expressão regular. Você pode recuperar correspondências subsequentes chamando repetidamente retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Match.NextMatch%2A> método. Você também pode recuperar todas as correspondências em uma única chamada de método chamando o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> método.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é gerada se o tempo de execução da operação de correspondência excede o intervalo de tempo limite especificado para o domínio de aplicativo no qual o método é chamado. Se nenhum tempo limite é definido nas propriedades do domínio de aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
   
  
## Examples  
 O exemplo a seguir define uma expressão regular que corresponde palavras que começam com a letra "a". Ele usa o <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> opção para garantir que a expressão regular localiza palavras que começam com dois em letras maiusculas em minúsculas "a" e uma "a".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match2.vb#2)]  
  
 O padrão da expressão regular `\ba\w*\b` é interpretado conforme mostrado na tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\b`|Começa a correspondência em um limite de palavra.|  
|`a`|Associar o caractere "a".|  
|`\w*`|Corresponde a zero, um ou mais caracteres de texto.|  
|`\b`|Termina a correspondência em um limite de palavra.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="pattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> não é uma combinação bit a bit válida de valores de <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <block subset="none" type="usage">
          <para>Esse método expire após um intervalo que seja igual ao valor de tempo limite padrão do domínio do aplicativo no qual ele é chamado. Se um valor de tempo limite não tiver sido definido para o domínio de aplicativo, o valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impede que o método do tempo limite, é usado. O método estático recomendado para recuperar uma correspondência de padrão é <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, que permite que você defina o intervalo de tempo limite.</para>
        </block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que fornece opções para correspondência.</param>
        <param name="matchTimeout">Um intervalo de tempo limite ou <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que o método não deve atingir o tempo limite.</param>
        <summary>Pesquisa a cadeia de caracteres de entrada da primeira ocorrência da expressão regular especificada, usando as opções de correspondência e intervalo de tempo limite especificados.</summary>
        <returns>Um objeto que contém informações sobre a correspondência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método retorna a primeira subcadeia de caracteres que corresponde a um padrão de expressão regular em uma cadeia de caracteres de entrada. Para obter informações sobre os elementos de linguagem usados para criar um padrão de expressão regular, consulte [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Estático <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método é equivalente ao construir um <xref:System.Text.RegularExpressions.Regex> do objeto com o <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> construtor e a instância de chamada <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> método.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que maneira simbólica descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Você pode determinar se o padrão de expressão regular foi encontrado na cadeia de caracteres de entrada, verificando o valor retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Group.Success%2A> propriedade. Se uma correspondência for encontrada, retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Capture.Value%2A> propriedade contém a subcadeia de caracteres `input` que corresponde ao padrão de expressão regular. Se nenhuma correspondência for encontrada, seu valor é <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Este método retorna a subcadeia de caracteres primeiro encontrada no `input` que corresponde ao padrão de expressão regular. Você pode recuperar correspondências subsequentes chamando repetidamente retornado <xref:System.Text.RegularExpressions.Match> do objeto <xref:System.Text.RegularExpressions.Match.NextMatch%2A> método. Você também pode recuperar todas as correspondências em uma única chamada de método chamando o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> método.  
  
 O `matchTimeout` parâmetro especifica como o tempo padrão correspondente método deve tentar localizar uma correspondência antes de expirar. Definir um intervalo de tempo limite impede que as expressões regulares que dependem de retrocesso excessiva de parece parar de responder ao processar a entrada que contém a próxima correspondência. Para obter mais informações, consulte [práticas recomendadas para expressões regulares](~/docs/standard/base-types/best-practices.md) e [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Se nenhuma correspondência for encontrada desse intervalo de tempo, o método gera uma <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção. `matchTimeout` substitui qualquer valor de tempo limite padrão definido para o domínio de aplicativo no qual o método é executado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="pattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> não é uma combinação bit a bit válida de valores de <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
 - ou -  
  
 <paramref name="matchTimeout" /> é negativo, zero ou maior que aproximadamente 24 dias.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <block subset="none" type="usage">
          <para>Recomendamos que você defina o <paramref name="matchTimeout" /> parâmetro para um valor apropriado, como dois segundos. Se você desabilitar o tempo limite especificando <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, o mecanismo de expressão regular oferece um pouco melhor desempenho. No entanto, você deve desabilitar tempos limite apenas sob as seguintes condições:  
  
-   Quando a entrada processada por uma expressão regular é derivada de uma origem conhecida e confiável ou consiste em texto estático. Exclui o texto que tenha sido dinamicamente entrada pelos usuários.  
  
-   Quando o padrão de expressão regular tem foram testado para garantir que ele trata com eficiência corresponde não correspondências e próximo corresponde.  
  
-   Quando o padrão de expressão regular não contém linguagem elementos que causam retrocesso excessiva durante o processamento de uma correspondência near.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Matches">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pesquisa em uma cadeia de caracteres de entrada todas as ocorrências de uma expressão regular e retorna todas as correspondências.</summary>
        <block subset="none" type="usage">
          <para>Quando uma tentativa de correspondência é repetida ao chamar o <see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /> método, o mecanismo de expressão regular fornece correspondências vazias tratamento especial. Geralmente, o mecanismo de expressão regular começa a procurar a próxima correspondência exatamente onde a correspondência anterior parou. No entanto, após uma correspondência vazia, o mecanismo de expressões regulares avança por um caractere antes de tentar a próxima correspondência. Esse comportamento garante que o mecanismo de expressão regular pode avançar a cadeia de caracteres. Caso contrário, como uma correspondência vazia não resulta em nenhum movimento para frente, a próxima correspondência iniciaria exatamente no mesmo local que a correspondência anterior, e ela corresponderia repetidamente com a mesma cadeia de caracteres vazia.  
  
 No exemplo a seguir, o padrão de expressão regular <c>um *</c> procura por zero ou mais ocorrências da letra "a" na cadeia de caracteres "abaabb". Como a saída de exemplo mostra, resultante <see cref="T:System.Text.RegularExpressions.MatchCollection" /> objeto contém seis <see cref="T:System.Text.RegularExpressions.Match" /> objetos. A primeira tentativa de correspondência localiza o primeiro "a". O segunda inicia correspondência exatamente onde a primeira correspondem termina antes do primeiro b; ele localiza zero ocorrências de "a" e retorna uma cadeia de caracteres vazia. A terceira correspondência não começa exatamente onde a segunda correspondência finalizou, pois a segunda correspondência retornou uma cadeia de caracteres vazia. Em vez disso, ele começa um caractere mais tarde, após o primeiro "b". A terceira correspondência localiza duas ocorrências de "a" e retorna "aa". A tentativa de correspondência quarta começa onde a terceira correspondência finalizou, antes do segundo "b" e retorna uma cadeia de caracteres vazia. A tentativa de correspondência quinto novamente avança um caractere para que ele começa antes do terceiro "b" e retorna uma cadeia de caracteres vazia. A sexta correspondência começa após o último "b" e retorna uma cadeia de caracteres vazia novamente.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/emptymatches1.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/emptymatches1.vb#9)]</para>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <summary>Pesquisa todas as ocorrências de uma expressão regular na cadeia de caracteres de entrada especificada.</summary>
        <returns>Uma coleção dos objetos <see cref="T:System.Text.RegularExpressions.Match" /> encontrados pela pesquisa. Se nenhuma correspondência for encontrada, o método retornará um objeto de coleção vazio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> método é semelhante de <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> método, exceto que ele retorna informações sobre todas as correspondências encontradas na cadeia de entrada, em vez de uma única correspondência. É equivalente ao seguinte código:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#5)]  
  
 A coleção inclui apenas as correspondências e termina na primeiro não correspondência.  
  
 O padrão de expressão regular para o qual o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> método pesquisa é definido pela chamada para uma da <xref:System.Text.RegularExpressions.Regex> construtores de classe. Para obter mais informações sobre os elementos que podem formar um padrão de expressão regular, consulte [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O <xref:System.Text.RegularExpressions.Regex.Matches%2A> método usa avaliação lenta para preencher retornado <xref:System.Text.RegularExpressions.MatchCollection> objeto. Acessando membros dessa coleção como <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> e <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> faz com que a coleção a ser preenchido imediatamente. Para tirar proveito de avaliação lenta, você deve iterar a coleção usando uma construção, tais como `foreach` em c# e `For Each`...`Next` no Visual Basic.  
  
 Devido a sua avaliação lenta, chamando o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> método não lançará um <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção. No entanto, a exceção é lançada quando uma operação é executada no <xref:System.Text.RegularExpressions.MatchCollection> objeto retornado por esse método, se o <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> propriedade não é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> e a operação de correspondência excede o intervalo de tempo limite.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> método para identificar quaisquer palavras em uma frase que terminam em "es".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches1.vb#1)]  
  
 O padrão de expressão regular `\b\w+es\b` é definido conforme mostrado na tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\b`|Começa a correspondência em um limite de palavra.|  
|`\w+`|Corresponde a um ou mais caracteres de palavra.|  
|`es`|Corresponde a cadeia de caracteres literal "es".|  
|`\b`|Termina a correspondência em um limite de palavra.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String, startat As Integer) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="startat">A posição do caractere na cadeia de caracteres de entrada na qual a pesquisa será iniciada.</param>
        <summary>Pesquisa a cadeia de caracteres de entrada especificada para todas as ocorrências de uma expressão regular, começando na posição inicial especificada na cadeia de caracteres.</summary>
        <returns>Uma coleção dos objetos <see cref="T:System.Text.RegularExpressions.Match" /> encontrados pela pesquisa. Se nenhuma correspondência for encontrada, o método retornará um objeto de coleção vazio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> método é semelhante de <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> método, exceto que ele retorna informações sobre todas as correspondências encontradas na cadeia de entrada, em vez de uma única correspondência. É equivalente ao seguinte código:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#6)]  
  
 O padrão de expressão regular para o qual o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> método pesquisa é definido pela chamada para uma da <xref:System.Text.RegularExpressions.Regex> construtores de classe. Para obter mais informações sobre os elementos que podem formar um padrão de expressão regular, consulte [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O <xref:System.Text.RegularExpressions.Regex.Matches%2A> método usa avaliação lenta para preencher retornado <xref:System.Text.RegularExpressions.MatchCollection> objeto. Acessando membros dessa coleção como <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> e <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> faz com que a coleção a ser preenchido imediatamente. Para tirar proveito de avaliação lenta, você deve iterar a coleção usando uma construção, tais como `foreach` em c# e `For Each`...`Next` no Visual Basic.  
  
 Devido a sua avaliação lenta, chamando o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> método não lançará um <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção. No entanto, a exceção é lançada quando uma operação é executada no <xref:System.Text.RegularExpressions.MatchCollection> objeto retornado por esse método, se o <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> propriedade não é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> e a operação de correspondência excede o intervalo de tempo limite.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> método para localizar a primeira palavra em uma frase que termina em "es" e, em seguida, chama o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> método para identificar quaisquer palavras adicionais que terminam em "es".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches3.vb#3)]  
  
 O padrão de expressão regular `\b\w+es\b` é definido conforme mostrado na tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\b`|Começa a correspondência em um limite de palavra.|  
|`\w+`|Corresponde a um ou mais caracteres de palavra.|  
|`es`|Corresponde a cadeia de caracteres literal "es".|  
|`\b`|Termina a correspondência em um limite de palavra.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> é menor que zero ou maior que o tamanho de <paramref name="input" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <summary>Pesquisa todas as ocorrências de uma expressão regular especificada na cadeia de entrada especificada.</summary>
        <returns>Uma coleção dos objetos <see cref="T:System.Text.RegularExpressions.Match" /> encontrados pela pesquisa. Se nenhuma correspondência for encontrada, o método retornará um objeto de coleção vazio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> método é semelhante de <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> método, exceto que ele retorna informações sobre todas as correspondências encontradas na cadeia de entrada, em vez de uma única correspondência. É equivalente ao seguinte código:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#7)]  
  
 Estático `Matches` métodos são equivalentes a construir um <xref:System.Text.RegularExpressions.Regex> do objeto com o padrão de expressão regular especificada e chamar o método de instância `Matches`.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que maneira simbólica descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O <xref:System.Text.RegularExpressions.Regex.Matches%2A> método usa avaliação lenta para preencher retornado <xref:System.Text.RegularExpressions.MatchCollection> objeto. Acessando membros dessa coleção como <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> e <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> faz com que a coleção a ser preenchido imediatamente. Para tirar proveito de avaliação lenta, você deve iterar a coleção usando uma construção, tais como `foreach` em c# e `For Each`...`Next` no Visual Basic.  
  
 Devido a sua avaliação lenta, chamando o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> método não lançará um <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção. No entanto, a exceção é lançada quando uma operação é executada no <xref:System.Text.RegularExpressions.MatchCollection> objeto retornado por esse método, se um intervalo de tempo limite é definido pela propriedade "REGEX_DEFAULT_MATCH_TIMEOUT" do domínio do aplicativo atual e a operação de correspondência excede esse intervalo de tempo limite.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> método para identificar qualquer palavra em uma frase que termina em "es".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches2.vb#2)]  
  
 O padrão de expressão regular `\b\w+es\b` é definido conforme mostrado na tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\b`|Começa a correspondência em um limite de palavra.|  
|`\w+`|Corresponde a um ou mais caracteres de palavra.|  
|`es`|Corresponde a cadeia de caracteres literal "es".|  
|`\b`|Termina a correspondência em um limite de palavra.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="pattern" /> é <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Esse método expire após um intervalo que seja igual ao valor de tempo limite padrão do domínio do aplicativo no qual ele é chamado. Se um valor de tempo limite não tiver sido definido para o domínio de aplicativo, o valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impede que o método do tempo limite, é usado. O método estático recomendado para recuperar vários padrão corresponde é <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite que você especifique o intervalo de tempo limite.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que especifica opções para correspondência.</param>
        <summary>Pesquisa todas as ocorrências de uma expressão regular especificada na cadeia de caracteres de entrada especificada, usando as opções de correspondência especificadas.</summary>
        <returns>Uma coleção dos objetos <see cref="T:System.Text.RegularExpressions.Match" /> encontrados pela pesquisa. Se nenhuma correspondência for encontrada, o método retornará um objeto de coleção vazio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método é semelhante de <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método, exceto que ele retorna informações sobre todas as correspondências encontradas na cadeia de entrada, em vez de uma única correspondência. É equivalente ao seguinte código:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#8)]  
  
 Estático `Matches` métodos são equivalentes a construir um <xref:System.Text.RegularExpressions.Regex> do objeto com o padrão de expressão regular especificada e chamar o método de instância `Matches`.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que maneira simbólica descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O <xref:System.Text.RegularExpressions.Regex.Matches%2A> método usa avaliação lenta para preencher retornado <xref:System.Text.RegularExpressions.MatchCollection> objeto. Acessando membros dessa coleção como <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> e <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> faz com que a coleção a ser preenchido imediatamente. Para tirar proveito de avaliação lenta, você deve iterar a coleção usando uma construção, tais como `foreach` em c# e `For Each`...`Next` no Visual Basic.  
  
 Devido a sua avaliação lenta, chamando o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> método não lançará um <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção. No entanto, a exceção é lançada quando uma operação é executada no <xref:System.Text.RegularExpressions.MatchCollection> objeto retornado por esse método, se um intervalo de tempo limite é definido pela propriedade "REGEX_DEFAULT_MATCH_TIMEOUT" do domínio do aplicativo atual e a operação de correspondência excede esse intervalo de tempo limite.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> método para identificar qualquer palavra em uma frase que termina em "es" e, em seguida, chama o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método para executar uma comparação de maiusculas e minúsculas do padrão com a cadeia de caracteres de entrada. Como mostra a saída, os dois métodos retornam resultados diferentes.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches4.vb#4)]  
  
 O padrão de expressão regular `\b\w+es\b` é definido conforme mostrado na tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\b`|Começa a correspondência em um limite de palavra.|  
|`\w+`|Corresponde a um ou mais caracteres de palavra.|  
|`es`|Corresponde a cadeia de caracteres literal "es".|  
|`\b`|Termina a correspondência em um limite de palavra.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="pattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> não é uma combinação bit a bit válida de valores de <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <block subset="none" type="usage">
          <para>Esse método expire após um intervalo que seja igual ao valor de tempo limite padrão do domínio do aplicativo no qual ele é chamado. Se um valor de tempo limite não tiver sido definido para o domínio de aplicativo, o valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impede que o método do tempo limite, é usado. O método estático recomendado para recuperar vários padrão corresponde é <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite que você defina o intervalo de tempo limite.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que especifica opções para correspondência.</param>
        <param name="matchTimeout">Um intervalo de tempo limite ou <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que o método não deve atingir o tempo limite.</param>
        <summary>Pesquisa todas as ocorrências de uma expressão regular especificada na cadeia de caracteres de entrada especificada, usando as opções de correspondência especificadas e o intervalo de tempo limite.</summary>
        <returns>Uma coleção dos objetos <see cref="T:System.Text.RegularExpressions.Match" /> encontrados pela pesquisa. Se nenhuma correspondência for encontrada, o método retornará um objeto de coleção vazio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método é semelhante de <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método, exceto que ele retorna informações sobre todas as correspondências encontradas na cadeia de entrada, em vez de uma única correspondência. É equivalente ao seguinte código:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#10)]  
  
 Estático `Matches` métodos são equivalentes a construir um <xref:System.Text.RegularExpressions.Regex> do objeto com o padrão de expressão regular especificada e chamar o método de instância `Matches`.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que maneira simbólica descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O <xref:System.Text.RegularExpressions.Regex.Matches%2A> método usa avaliação lenta para preencher retornado <xref:System.Text.RegularExpressions.MatchCollection> objeto. Acessando membros dessa coleção como <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> e <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> faz com que a coleção a ser preenchido imediatamente. Para tirar proveito de avaliação lenta, você deve iterar a coleção usando uma construção, tais como `foreach` em c# e `For Each`...`Next` no Visual Basic.  
  
 Devido a sua avaliação lenta, chamando o <xref:System.Text.RegularExpressions.Regex.Matches%2A> método não lançará um <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção. No entanto, uma exceção é lançada quando uma operação é executada no <xref:System.Text.RegularExpressions.MatchCollection> objeto retornado por esse método, se uma operação de correspondência exceder esse intervalo de tempo limite especificado pelo`matchTimeout` parâmetro.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método para executar uma comparação diferencia maiusculas e minúsculas que corresponde a qualquer palavra em uma frase que termina em "es". Depois, ele chama o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método para executar uma comparação de maiusculas e minúsculas do padrão com a cadeia de caracteres de entrada. Em ambos os casos, o intervalo de tempo limite é definido como um segundo. Como mostra a saída, os dois métodos retornam resultados diferentes.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches5.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches5.vb#11)]  
  
 O padrão de expressão regular `\b\w+es\b` é definido conforme mostrado na tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\b`|Começa a correspondência em um limite de palavra.|  
|`\w+`|Corresponde a um ou mais caracteres de palavra.|  
|`es`|Corresponde a cadeia de caracteres literal "es".|  
|`\b`|Termina a correspondência em um limite de palavra.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="pattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> não é uma combinação bit a bit válida de valores de <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
 - ou -  
  
 <paramref name="matchTimeout" /> é negativo, zero ou maior que aproximadamente 24 dias.</exception>
        <block subset="none" type="usage">
          <para>Recomendamos que você defina o <paramref name="matchTimeout" /> parâmetro para um valor apropriado, como dois segundos. Se você desabilitar o tempo limite especificando <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, o mecanismo de expressão regular oferece um pouco melhor desempenho. No entanto, você deve desabilitar tempos limite apenas sob as seguintes condições:  
  
-   Quando a entrada processada por uma expressão regular é derivada de uma origem conhecida e confiável ou consiste em texto estático. Exclui o texto que tenha sido dinamicamente entrada pelos usuários.  
  
-   Quando o padrão de expressão regular tem foram testado para garantir que ele trata com eficiência corresponde não correspondências e próximo corresponde.  
  
-   Quando o padrão de expressão regular não contém linguagem elementos que causam retrocesso excessiva durante o processamento de uma correspondência near.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="MatchTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan MatchTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MatchTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MatchTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MatchTimeout { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o intervalo de tempo limite da instância atual.</summary>
        <value>O intervalo de tempo máximo que pode decorrer em uma operação de correspondência de padrão antes que uma <see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" /> seja lançada ou <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> se os tempos limite estão desabilitados.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> propriedade define o intervalo de tempo máximo aproximado para um <xref:System.Text.RegularExpressions.Regex> instância para executar uma única operação de correspondência antes da operação de tempo limite. O mecanismo de expressão regular gera um <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção durante sua próxima verificação de tempo após o intervalo de tempo limite. Isso impede que o mecanismo de expressão regular do processamento de cadeias de caracteres de entrada que exigem acompanhamento inverso excessivo. Para obter mais informações, consulte [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md) e [práticas recomendadas para expressões regulares](~/docs/standard/base-types/best-practices.md).  
  
 Esta propriedade é somente para leitura. Você pode definir explicitamente o valor de um indivíduo <xref:System.Text.RegularExpressions.Regex> objeto chamando o <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor; e você pode definir seu valor para todas as <xref:System.Text.RegularExpressions.Regex> correspondência operações em um domínio de aplicativo ao chamar o <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> método e fornecendo um <xref:System.TimeSpan> valor para a propriedade "REGEX_DEFAULT_MATCH_TIMEOUT", como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/cs/regexmatchtimeout1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/vb/regexmatchtimeout1.vb#1)]  
  
 Se você não definir explicitamente um intervalo de tempo limite, o valor padrão <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> é usadas e correspondência operações não têm tempo limite.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.RegexOptions Options { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.RegularExpressions.RegexOptions Options" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Options" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Options As RegexOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::RegularExpressions::RegexOptions Options { System::Text::RegularExpressions::RegexOptions get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém as opções que foram passadas para o construtor <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <value>Um ou mais membros da enumeração <see cref="T:System.Text.RegularExpressions.RegexOptions" /> que representa as opções que foram passadas para o construtor <see cref="T:System.Text.RegularExpressions.Regex" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor da <xref:System.Text.RegularExpressions.Regex.Options%2A> propriedade consiste em um ou mais membros a <xref:System.Text.RegularExpressions.RegexOptions> enumeração. Se nenhuma das opções foram definida no <xref:System.Text.RegularExpressions.Regex> construtor de classe, seu valor é <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>. As opções disponíveis são discutidas detalhadamente o [opções de expressão Regular](~/docs/standard/base-types/regular-expression-options.md) tópico.  
  
 Observe que o <xref:System.Text.RegularExpressions.Regex.Options%2A> propriedade não reflete embutido opções definidas na expressão regular padrão em si.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> é a classe base de expressões regulares criado pelo <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> método. Essas expressões regulares compiladas usam a implementação da classe base a <see cref="P:System.Text.RegularExpressions.Regex.Options" /> propriedade. Se chamado de uma classe derivada, o <see cref="P:System.Text.RegularExpressions.Regex.Options" /> propriedade retorna as opções que foram passadas para o <paramref name="options" /> parâmetro o <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> construtor da classe que foi usado para definir a expressão regular.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="pattern">
      <MemberSignature Language="C#" Value="protected internal string pattern;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string pattern" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.pattern" />
      <MemberSignature Language="VB.NET" Value="Protected Friend pattern As String " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::String ^ pattern;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Usado por um objeto <see cref="T:System.Text.RegularExpressions.Regex" /> gerado pelo método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Em uma cadeia de caracteres de entrada especificada, substitui as cadeias de caracteres que correspondem a um padrão de expressão regular por uma cadeia de caracteres de substituição especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="replacement">A cadeia de caracteres substituta.</param>
        <summary>Em uma cadeia de caracteres de entrada especificada, substitui todas as cadeias de caracteres que correspondem a um padrão de expressão regular por uma cadeia de caracteres de substituição especificada.</summary>
        <returns>Uma nova cadeia de caracteres idêntica à cadeia de caracteres de entrada, com exceção de que a cadeia de caracteres de substituição substitui cada cadeia de caracteres correspondente. Se o padrão de expressão regular não tiver uma correspondência na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pesquisa para correspondência começa no início do `input` cadeia de caracteres. A expressão regular é um padrão definido pelo construtor atual <xref:System.Text.RegularExpressions.Regex> objeto.  
  
 O `replacement` parâmetro especifica a cadeia de caracteres que substitui cada correspondência no `input`. `replacement` pode consistir em qualquer combinação de texto literal e [substituições](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Por exemplo, o padrão de substituição `a*${test}b` insere a cadeia de caracteres "um *" seguido de subcadeia de caracteres que corresponde do `test` grupo de captura, se houver, seguido pela cadeia de caracteres "b". O * caractere não é reconhecido como um metacaractere em um padrão de substituição.  
  
> [!NOTE]
>  As substituições são os elementos de linguagem de expressão regular só serão reconhecidos em um padrão de substituição. Todos os outros elementos de linguagem de expressão regular, incluindo [escapes de caracteres](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), são permitidos em padrões de expressão regular apenas e não são reconhecidos em padrões de substituição.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é gerada se o tempo de execução da operação de substituição excede o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um intervalo de tempo limite ao chamar o construtor, a exceção é gerada se a operação exceder qualquer valor de tempo limite estabelecida para o domínio de aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido no <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio de aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada  
  
 Como o método retorna `input` inalterado se não houver nenhuma correspondência, você pode usar o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar se o método foi feita qualquer substituição para a cadeia de caracteres de entrada.  
  
   
  
## Examples  
 O exemplo a seguir define uma expressão regular, `\s+`, que corresponde a um ou mais caracteres de espaço em branco. A cadeia de caracteres de substituição, "", substitui-los com um único caractere de espaço.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample5.vb#5)]  
  
 O exemplo a seguir define uma expressão regular, `(\p{Sc}\s?)?(\d+\.?((?<=\.)\d+)?)(?(1)|\s?\p{Sc})?`e um padrão de substituição, `$2`, que remove um prefixo ou um símbolo de moeda à direita de um valor numérico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample7.vb#7)]  
  
 A expressão regular é interpretada conforme mostrado na tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\p{Sc}`|Corresponde a um símbolo de moeda. `{Sc}` indica que qualquer caractere que é membro do símbolo Unicode, categoria de moeda.|  
|`\s?`|Corresponder a zero ou a um caractere de espaço em branco.|  
|`(\p{Sc}\s?)?`|Corresponde a zero ou uma ocorrência da combinação de um símbolo de moeda, seguido por zero ou um caractere de espaço em branco. Este é o primeiro grupo de captura.|  
|`\d+`|Corresponde a um ou mais dígitos decimais.|  
|`\.?`|Corresponde a zero ou uma ocorrência de um período (usada como um caractere do separador decimal).|  
|`((?<=\.)\d+)?`|Se um ponto é o caractere anterior, corresponde a um ou mais dígitos decimais. Esse padrão pode corresponder a zero ou um tempo.|  
|`(\d+\.?((?<=\.)\d+)?)`|Corresponde ao padrão de um ou mais dígitos decimais, seguido por um período opcional e dígito decimal. Este é o segundo grupo de captura. A chamada para o <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29> método substitui a correspondência de inteira com o valor desse grupo capturado.|  
|`(?(1)&#124;\s?\p{Sc})?`|Se o primeiro grupo capturado existir, corresponde uma cadeia de caracteres vazia. Caso contrário, corresponde a zero ou um caractere de espaço em branco seguido por um símbolo de moeda.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="replacement" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="evaluator">Um método personalizado que examina cada correspondência e retorna a cadeia de caracteres correspondida original ou uma cadeia de caracteres de substituição.</param>
        <summary>Em uma cadeia de caracteres de entrada especificada, substitui todas as cadeias de caracteres que correspondem a uma expressão regular especificada por uma cadeia de caracteres retornada por um delegado <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Uma nova cadeia de caracteres é idêntica à cadeia de entrada, com exceção de que a cadeia de substituição substitui cada cadeia de caracteres correspondente. Se o padrão de expressão regular não tiver uma correspondência na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> método é útil para substituir uma correspondência da expressão regular, se qualquer uma das seguintes condições for verdadeira:  
  
-   A cadeia de caracteres de substituição prontamente não pode ser especificada por um padrão de substituição de expressão regular.  
  
-   Os resultados da cadeia de caracteres de substituição de algum processamento feito na cadeia de caracteres correspondente.  
  
-   Os resultados da cadeia de caracteres de substituição de processamento condicional.  
  
 O método é equivalente a chamar o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> método e passando cada <xref:System.Text.RegularExpressions.Match> objeto retornado <xref:System.Text.RegularExpressions.MatchCollection> coleção para o `evaluator` delegar.  
  
 A expressão regular é um padrão definido pelo construtor atual <xref:System.Text.RegularExpressions.Regex> objeto.  
  
 O `evaluator` parâmetro é o delegate para um método personalizado que você define e que examina cada correspondência. O método personalizado deve ter a seguinte assinatura para coincidir com o <xref:System.Text.RegularExpressions.MatchEvaluator> delegate.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 O método personalizado retorna uma cadeia de caracteres que substitui a entrada correspondente.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é gerada se o tempo de execução da operação de substituição excede o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um intervalo de tempo limite ao chamar o construtor, a exceção é gerada se a operação exceder qualquer valor de tempo limite estabelecida para o domínio de aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido no <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio de aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada  
  
 Como o método retorna `input` inalterado se não houver nenhuma correspondência, você pode usar o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar se o método foi feita qualquer substituição para a cadeia de caracteres de entrada.  
  
   
  
## Examples  
 O exemplo de código a seguir exibe uma cadeia de caracteres original, faz a correspondência de cada palavra na cadeia de caracteres original, converte o primeiro caractere de cada correspondência em maiuscula, em seguida, exibe a cadeia de caracteres convertida.  
  
 [!code-csharp[Regex.Replace-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Regex.Replace-Instance/cs/sample.cs#1)]
 [!code-vb[Regex.Replace-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex.Replace-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="evaluator" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="replacement">A cadeia de caracteres substituta.</param>
        <param name="count">O número máximo de vezes que a substituição pode ocorrer.</param>
        <summary>Em uma cadeia de caracteres de entrada especificada, substitui um número máximo especificado de cadeias de caracteres que correspondem a um padrão de expressão regular com uma cadeia de caracteres substituta especificada.</summary>
        <returns>Uma nova cadeia de caracteres idêntica à cadeia de caracteres de entrada, com exceção de que a cadeia de caracteres de substituição substitui cada cadeia de caracteres correspondente. Se o padrão de expressão regular não tiver uma correspondência na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pesquisa para correspondência começa no início do `input` cadeia de caracteres. A expressão regular é o padrão que é definido pelo construtor atual <xref:System.Text.RegularExpressions.Regex> objeto. Se `count` for negativo, substituições continuam até o final da cadeia de caracteres. Se `count` excede o número de correspondências, todas as correspondências são substituídas.  
  
 O `replacement` parâmetro especifica a cadeia de caracteres que substitui a primeira `count` faz a correspondência em `input`. `replacement` pode consistir em qualquer combinação de texto literal e [substituições](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Por exemplo, o padrão de substituição `a*${test}b` insere a cadeia de caracteres "um *" seguido de subcadeia de caracteres que corresponde do `test` grupo de captura, se houver, seguido pela cadeia de caracteres "b". O * caractere não é reconhecido como um metacaractere em um padrão de substituição.  
  
> [!NOTE]
>  As substituições são os elementos de linguagem de expressão regular só serão reconhecidos em um padrão de substituição. Todos os outros elementos de linguagem de expressão regular, incluindo [escapes de caracteres](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), são permitidos em padrões de expressão regular apenas e não são reconhecidos em padrões de substituição.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é gerada se o tempo de execução da operação de substituição excede o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um intervalo de tempo limite ao chamar o construtor, a exceção é gerada se a operação exceder qualquer valor de tempo limite estabelecida para o domínio de aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido no <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio de aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada  
  
 Como o método retorna `input` inalterado se não houver nenhuma correspondência, você pode usar o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar se o método foi feita qualquer substituição para a cadeia de caracteres de entrada.  
  
   
  
## Examples  
 O exemplo a seguir substitui as cinco primeiras ocorrências de caracteres duplicadas com um único caractere. O padrão de expressão regular `(\w)\1` corresponde ocorrências consecutivas de um único caractere e atribui a primeira ocorrência do primeiro grupo de captura. O padrão de substituição `$1` substitui a correspondência de inteira com o primeiro grupo capturado.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample8.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="replacement" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="replacement">A cadeia de caracteres substituta.</param>
        <summary>Em uma cadeia de caracteres de entrada especificada, substitui todas as cadeias de caracteres que correspondem a uma expressão regular especificada por uma cadeia de caracteres de substituição especificada.</summary>
        <returns>Uma nova cadeia de caracteres idêntica à cadeia de caracteres de entrada, com exceção de que a cadeia de caracteres de substituição substitui cada cadeia de caracteres correspondente. Se <paramref name="pattern" /> não tiver uma correspondência na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estático `Replace` métodos são equivalentes a construir um <xref:System.Text.RegularExpressions.Regex> do objeto com o padrão de expressão regular especificada e chamar o método de instância `Replace`.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que maneira simbólica descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md). A pesquisa para correspondência começa no início do `input` cadeia de caracteres.  
  
 O `replacement` parâmetro especifica a cadeia de caracteres que substitui cada correspondência no `input`. `replacement` pode consistir em qualquer combinação de texto literal e [substituições](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Por exemplo, o padrão de substituição `a*${test}b` insere a cadeia de caracteres "um *" seguido de subcadeia de caracteres que corresponde do `test` grupo de captura, se houver, seguido pela cadeia de caracteres "b". O * caractere não é reconhecido como um metacaractere em um padrão de substituição.  
  
> [!NOTE]
>  As substituições são os elementos de linguagem de expressão regular só serão reconhecidos em um padrão de substituição. Todos os outros elementos de linguagem de expressão regular, incluindo [escapes de caracteres](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), são permitidos em padrões de expressão regular apenas e não são reconhecidos em padrões de substituição.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é gerada se o tempo de execução da operação de substituição excede o intervalo de tempo limite especificado para o domínio de aplicativo no qual o método é chamado. Se nenhum tempo limite é definido nas propriedades do domínio de aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
 Como o método retorna `input` inalterado se não houver nenhuma correspondência, você pode usar o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar se o método foi feita qualquer substituição para a cadeia de caracteres de entrada.  
  
   
  
## Examples  
 O exemplo a seguir define uma expressão regular, `\s+`, que corresponde a um ou mais caracteres de espaço em branco. A cadeia de caracteres de substituição, "", substitui-los com um único caractere de espaço.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample6.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample6.vb#6)]  
  
 O exemplo a seguir usa o <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> método para substituir os nomes de computador e a unidade locais em um caminho UNC com um caminho de arquivo local. A expressão regular usa o <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propriedade para incluir o nome do computador local e o <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> método para incluir os nomes das unidades lógicas. Para executar o exemplo com êxito, você deve substituir a cadeia de caracteres literal "MinhaMaquina" com o nome do computador local.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace3.vb#3)]  
  
 O padrão de expressão regular é definido pela seguinte expressão:  
  
 `"\\\\(?i:" + Environment.MachineName + ")(?:\.\w+)*\\((?i:[" + driveNames + "]))\$"`  
  
 A tabela a seguir mostra como o padrão da expressão regular é interpretado.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\\\\`|Barra invertida consecutiva de correspondência dois (`\`) caracteres. Como o caractere de barra invertida é interpretado como o caractere de escape, cada barra invertida deve ser substituída com outra barra invertida.|  
|`(?i:" + Environment.MachineName + ")`|Executar uma correspondência de maiusculas e minúsculas da cadeia de caracteres que é retornada pelo <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propriedade.|  
|`(?:\.\w+)*`|Corresponde o período (`.`) seguido por um ou mais caracteres de texto. Essa correspondência pode ocorrer zero ou mais vezes. A subexpressão correspondente não é capturada.|  
|`\\`|Corresponde a uma barra invertida (`\`) caracteres.|  
|`((?i:[" + driveNames + "]))`|Execute uma correspondência de maiusculas e minúsculas da classe de caracteres que consiste de letras de unidade individuais. Esse correspondente é a primeira subexpressão capturada.|  
|`\$`|Corresponde o sinal de cifrão literal (`$`) caracteres.|  
  
 O padrão de substituição `$1` substitui toda correspondência com a primeira subexpressão capturada. Ou seja, ele substitui o nome UNC de máquina e a unidade com a letra da unidade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> ou <paramref name="replacement" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <block subset="none" type="usage">
          <para>Esse método expire após um intervalo que seja igual ao valor de tempo limite padrão do domínio do aplicativo no qual ele é chamado. Se um valor de tempo limite não tiver sido definido para o domínio de aplicativo, o valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impede que o método do tempo limite, é usado. O método recomendado estático para uma correspondência de padrões de substituição é <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite que você defina o intervalo de tempo limite.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="evaluator">Um método personalizado que examina cada correspondência e retorna a cadeia de caracteres correspondida original ou uma cadeia de caracteres de substituição.</param>
        <summary>Em uma cadeia de caracteres de entrada especificada, substitui todas as cadeias de caracteres que correspondem a uma expressão regular especificada por uma cadeia de caracteres retornada por um delegado <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Uma nova cadeia de caracteres é idêntica à cadeia de entrada, com exceção de que a cadeia de substituição substitui cada cadeia de caracteres correspondente. Se <paramref name="pattern" /> não tiver uma correspondência na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> método é útil para substituir uma correspondência da expressão regular, se qualquer uma das seguintes condições for verdadeira:  
  
-   A cadeia de caracteres de substituição prontamente não pode ser especificada por um padrão de substituição de expressão regular.  
  
-   Os resultados da cadeia de caracteres de substituição de algum processamento feito na cadeia de caracteres correspondente.  
  
-   Os resultados da cadeia de caracteres de substituição de processamento condicional.  
  
 O método é equivalente a chamar o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> método e passando cada <xref:System.Text.RegularExpressions.Match> objeto retornado <xref:System.Text.RegularExpressions.MatchCollection> coleção para o `evaluator` delegar.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que maneira simbólica descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O `evaluator` parâmetro é o delegate para um método personalizado que você define e que examina cada correspondência. O método personalizado deve ter a seguinte assinatura para coincidir com o <xref:System.Text.RegularExpressions.MatchEvaluator> delegate.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 O método personalizado retorna uma cadeia de caracteres que substitui a entrada correspondente.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é gerada se o tempo de execução da operação de substituição excede o intervalo de tempo limite especificado para o domínio de aplicativo no qual o método é chamado. Se nenhum tempo limite é definido nas propriedades do domínio de aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
 Como o método retorna `input` inalterado se não houver nenhuma correspondência, você pode usar o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar se o método foi feita qualquer substituição para a cadeia de caracteres de entrada.  
  
   
  
## Examples  
 O exemplo a seguir usa uma expressão regular para extrair as palavras individuais de uma cadeia de caracteres e, em seguida, usa um <xref:System.Text.RegularExpressions.MatchEvaluator> delegado para chamar um método chamado `WordScramble` que codifica as letras individuais na palavra. Para fazer isso, o `WordScramble` método cria uma matriz que contém os caracteres na correspondência. Ele também cria uma matriz paralela que é preenchida com números de ponto flutuante aleatórios. As matrizes são classificadas por chamar o <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> método e a matriz classificada é fornecido como um argumento para um <xref:System.String> construtor de classe. Essa cadeia de caracteres recém-criado é retornada pelo `WordScramble` método. O padrão de expressão regular `\w+` corresponde a um ou mais caracteres de palavra; o mecanismo de expressão regular continuará a adicionar caracteres para a correspondência até encontrar um caractere de palavra, como um caractere de espaço em branco.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace5.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace5.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> ou <paramref name="evaluator" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <block subset="none" type="usage">
          <para>Esse método expire após um intervalo que seja igual ao valor de tempo limite padrão do domínio do aplicativo no qual ele é chamado. Se um valor de tempo limite não tiver sido definido para o domínio de aplicativo, o valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impede que o método do tempo limite, é usado. O método estático recomendado para avaliar e substituindo uma correspondência de padrão é <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite que você defina o intervalo de tempo limite.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="evaluator">Um método personalizado que examina cada correspondência e retorna a cadeia de caracteres correspondida original ou uma cadeia de caracteres de substituição.</param>
        <param name="count">O número máximo de vezes que a substituição ocorrerá.</param>
        <summary>Em uma cadeia de caracteres de entrada especificada, substitui um número máximo especificado de cadeias de caracteres que correspondem a um padrão de expressão regular por uma cadeia de caracteres retornada por um delegado <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Uma nova cadeia de caracteres é idêntica à cadeia de entrada, com exceção de que a cadeia de substituição substitui cada cadeia de caracteres correspondente. Se o padrão de expressão regular não tiver uma correspondência na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType> método é útil para substituir uma correspondência da expressão regular, se qualquer uma das seguintes condições for verdadeira:  
  
-   A cadeia de caracteres de substituição prontamente não pode ser especificada por um padrão de substituição de expressão regular.  
  
-   Os resultados da cadeia de caracteres de substituição de algum processamento feito na cadeia de caracteres correspondente.  
  
-   Os resultados da cadeia de caracteres de substituição de processamento condicional.  
  
 O método é equivalente a chamar o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> método e passar o primeiro `count` <xref:System.Text.RegularExpressions.Match> objetos retornado <xref:System.Text.RegularExpressions.MatchCollection> coleção para o `evaluator` delegate.  
  
 A expressão regular é um padrão definido pelo construtor atual <xref:System.Text.RegularExpressions.Regex> objeto.  
  
 O `evaluator` parâmetro é o delegate para um método personalizado que você define e que examina cada correspondência. O método personalizado deve ter a seguinte assinatura para coincidir com o <xref:System.Text.RegularExpressions.MatchEvaluator> delegate.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 O método personalizado retorna uma cadeia de caracteres que substitui a entrada correspondente.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é gerada se o tempo de execução da operação de substituição excede o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um intervalo de tempo limite ao chamar o construtor, a exceção é gerada se a operação exceder qualquer valor de tempo limite estabelecida para o domínio de aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido no <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio de aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada  
  
 Como o método retorna `input` inalterado se não houver nenhuma correspondência, você pode usar o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar se o método foi feita qualquer substituição para a cadeia de caracteres de entrada.  
  
   
  
## Examples  
 O exemplo a seguir usa uma expressão regular para deliberadamente errar metade das palavras em uma lista. Ele usa a expressão regular `\w*(ie|ei)\w*` para fazer a correspondência de palavras que incluem os caracteres "ie" ou "ei". Ele passa a primeira metade das palavras correspondentes para o `ReverseLetter` método, que, por sua vez, usa o <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método para reverter "i" e "e" na cadeia de caracteres correspondente. As palavras restantes permanecem inalteradas.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace7.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace7.vb#11)]  
  
 A expressão regular `\w*(ie|ei)\w*` é definida conforme mostrado na tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\w*`|Corresponder a zero ou mais caracteres de palavra.|  
|`(ie&#124;ei)`|Corresponde a "ie" ou "ei".|  
|`\w*`|Corresponder a zero ou mais caracteres de palavra.|  
  
 O padrão de expressão regular `([ie])([ie])` no `ReverseLetter` método coincide com o primeiro "i" ou "e" em diphthong "ie" ou "ei" e atribui a letra para o primeiro grupo de capturando. Ele corresponde ao segundo "i" ou "e" e atribui a letra para o segundo grupo de capturando. Os dois caracteres, em seguida, são revertidos chamando o <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> método com o padrão de substituição `$2$1`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="evaluator" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="replacement">A cadeia de caracteres substituta.</param>
        <param name="count">Número máximo de vezes que a substituição pode ocorrer.</param>
        <param name="startat">A posição do caractere na cadeia de caracteres de entrada na qual a pesquisa começa.</param>
        <summary>Em uma subcadeia de caracteres de entrada especificada, substitui um número máximo especificado de cadeias de caracteres que correspondem a um padrão de expressão regular com uma cadeia de caracteres substituta especificada.</summary>
        <returns>Uma nova cadeia de caracteres idêntica à cadeia de caracteres de entrada, com exceção de que a cadeia de caracteres de substituição substitui cada cadeia de caracteres correspondente. Se o padrão de expressão regular não tiver uma correspondência na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Inicia a pesquisa para correspondência no `input` cadeia de caracteres na posição especificada o `startat` parâmetro. A expressão regular é um padrão definido pelo construtor atual <xref:System.Text.RegularExpressions.Regex> objeto. Se `count` for negativo, substituições continuam até o final da cadeia de caracteres. Se `count` excede o número de correspondências, todas as correspondências são substituídas.  
  
 O `replacement` parâmetro especifica a cadeia de caracteres que substitui cada correspondência no `input`. `replacement` pode consistir em qualquer combinação de texto literal e [substituições](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Por exemplo, o padrão de substituição `a*${test}b` insere a cadeia de caracteres "um *" seguido de subcadeia de caracteres que corresponde do `test` grupo de captura, se houver, seguido pela cadeia de caracteres "b". O * caractere não é reconhecido como um metacaractere em um padrão de substituição.  
  
> [!NOTE]
>  As substituições são os elementos de linguagem de expressão regular só serão reconhecidos em um padrão de substituição. Todos os outros elementos de linguagem de expressão regular, incluindo [escapes de caracteres](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), são permitidos em padrões de expressão regular apenas e não são reconhecidos em padrões de substituição.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é gerada se o tempo de execução da operação de substituição excede o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um intervalo de tempo limite ao chamar o construtor, a exceção é gerada se a operação exceder qualquer valor de tempo limite estabelecida para o domínio de aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido no <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio de aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada  
  
 Como o método retorna `input` inalterado se não houver nenhuma correspondência, você pode usar o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar se o método foi feita qualquer substituição para a cadeia de caracteres de entrada.  
  
   
  
## Examples  
 O exemplo a seguir usa espaçamento duplo nos todos, exceto a primeira linha de uma cadeia de caracteres. Define um padrão de expressão regular, `^.*$`, que corresponde a uma linha de texto, chamadas de <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> método para que correspondam a primeira linha da cadeia de caracteres e usa o `Match.Index` e `Match.Count` propriedades para determinar a posição inicial da segunda linha.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample9.vb#9)]  
  
 O padrão de expressão regular `^.*$` é definido conforme mostrado na tabela a seguir.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`^`|Corresponde ao início de uma linha. (Observe que o <xref:System.Text.RegularExpressions.Regex> objeto foi instanciado usando o <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> opção; caso contrário, essa classe de caractere corresponderia somente o início da cadeia de entrada.)|  
|`.*`|Corresponde qualquer caractere zero ou mais vezes.|  
|`$`|Corresponde o fim de uma linha. (Observe que o <xref:System.Text.RegularExpressions.Regex> objeto foi instanciado usando o <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> opção; caso contrário, essa classe de caractere corresponderia somente o início da cadeia de entrada.)|  
  
 A cadeia de caracteres de substituição (`vbCrLf + "$&"` no Visual Basic, `"\n$&"` em c#) adiciona uma nova linha antes da cadeia de caracteres correspondente. Observe que `\n` em c# exemplo é interpretado como o caractere de nova linha pelo compilador c#; ele não representa um caractere de escape de expressão regular.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="replacement" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> é menor que zero ou maior que o tamanho de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="replacement">A cadeia de caracteres substituta.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que fornece opções para correspondência.</param>
        <summary>Em uma cadeia de caracteres de entrada especificada, substitui todas as cadeias de caracteres que correspondem a uma expressão regular especificada por uma cadeia de caracteres de substituição especificada. As opções especificadas modificam a operação de correspondência.</summary>
        <returns>Uma nova cadeia de caracteres idêntica à cadeia de caracteres de entrada, com exceção de que a cadeia de caracteres de substituição substitui cada cadeia de caracteres correspondente. Se <paramref name="pattern" /> não tiver uma correspondência na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estático `Replace` métodos são equivalentes a construir um <xref:System.Text.RegularExpressions.Regex> do objeto com o padrão de expressão regular especificada e chamar o método de instância `Replace`.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que maneira simbólica descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Se você especificar <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> para o `options` parâmetro, a pesquisa de correspondências começa no final da cadeia de caracteres de entrada e move para a esquerda; caso contrário, a pesquisa começará no início da cadeia de caracteres de entrada e movido para a direita.  
  
 O `replacement` parâmetro especifica a cadeia de caracteres que substitui cada correspondência no `input`. `replacement` pode consistir em qualquer combinação de texto literal e [substituições](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Por exemplo, o padrão de substituição `a*${test}b` insere a cadeia de caracteres "um *" seguido de subcadeia de caracteres que corresponde do `test` grupo de captura, se houver, seguido pela cadeia de caracteres "b". O * caractere não é reconhecido como um metacaractere em um padrão de substituição.  
  
> [!NOTE]
>  As substituições são os elementos de linguagem de expressão regular só serão reconhecidos em um padrão de substituição. Todos os outros elementos de linguagem de expressão regular, incluindo [escapes de caracteres](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), são permitidos em padrões de expressão regular apenas e não são reconhecidos em padrões de substituição.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é gerada se o tempo de execução da operação de substituição excede o intervalo de tempo limite especificado para o domínio de aplicativo no qual o método é chamado. Se nenhum tempo limite é definido nas propriedades do domínio de aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
 Como o método retorna `input` inalterado se não houver nenhuma correspondência, você pode usar o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar se o método foi feita qualquer substituição para a cadeia de caracteres de entrada.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> método para substituir os nomes de computador e a unidade locais em um caminho UNC com um caminho de arquivo local. A expressão regular usa o <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propriedade para incluir o nome do computador local e o <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> método para incluir os nomes das unidades lógicas. Todas as comparações de cadeia de caracteres de expressão regular diferenciam maiusculas de minúsculas. Para executar o exemplo com êxito, você deve substituir a cadeia de caracteres literal "MinhaMaquina" com o nome do computador local.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace4.vb#4)]  
  
 O padrão de expressão regular é definido pela seguinte expressão:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 A tabela a seguir mostra como o padrão da expressão regular é interpretado.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\\\\`|Barra invertida consecutiva de correspondência dois (`\`) caracteres. Como o caractere de barra invertida é interpretado como o caractere de escape, cada barra invertida deve ser substituída com outra barra invertida.|  
|`+ Environment.MachineName +`|Corresponde a cadeia de caracteres que é retornada pelo <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propriedade.|  
|`(?:\.\w+)*`|Corresponde o período (`.`) seguido por um ou mais caracteres de texto. Essa correspondência pode ocorrer zero ou mais vezes. A subexpressão correspondente não é capturada.|  
|`\\`|Corresponde a uma barra invertida (`\`) caracteres.|  
|`([" + driveNames + "])`|Corresponde à classe de caracteres que consiste nas letras de unidade individuais. Esse correspondente é a primeira subexpressão capturada.|  
|`\$`|Corresponde o sinal de cifrão literal (`$`) caracteres.|  
  
 O padrão de substituição `$1` substitui toda correspondência com a primeira subexpressão capturada. Ou seja, ele substitui o nome UNC de máquina e a unidade com a letra da unidade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> ou <paramref name="replacement" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> não é uma combinação bit a bit válida de valores de <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <block subset="none" type="usage">
          <para>Esse método expire após um intervalo que seja igual ao valor de tempo limite padrão do domínio do aplicativo no qual ele é chamado. Se um valor de tempo limite não tiver sido definido para o domínio de aplicativo, o valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impede que o método do tempo limite, é usado. O método recomendado estático para uma correspondência de padrões de substituição é <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite que você defina o intervalo de tempo limite.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="evaluator">Um método personalizado que examina cada correspondência e retorna a cadeia de caracteres correspondida original ou uma cadeia de caracteres de substituição.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que fornece opções para correspondência.</param>
        <summary>Em uma cadeia de caracteres de entrada especificada, substitui todas as cadeias de caracteres que correspondem a uma expressão regular especificada por uma cadeia de caracteres retornada por um delegado <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />. As opções especificadas modificam a operação de correspondência.</summary>
        <returns>Uma nova cadeia de caracteres é idêntica à cadeia de entrada, com exceção de que a cadeia de substituição substitui cada cadeia de caracteres correspondente. Se <paramref name="pattern" /> não tiver uma correspondência na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> método é útil para substituir uma correspondência da expressão regular no se qualquer uma das seguintes condições for verdadeira:  
  
-   A cadeia de caracteres de substituição prontamente não pode ser especificada por um padrão de substituição de expressão regular.  
  
-   Os resultados da cadeia de caracteres de substituição de algum processamento feito na cadeia de caracteres correspondente.  
  
-   Os resultados da cadeia de caracteres de substituição de processamento condicional.  
  
 O método é equivalente a chamar o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> método e passando cada <xref:System.Text.RegularExpressions.Match> objeto retornado <xref:System.Text.RegularExpressions.MatchCollection> coleção para o `evaluator` delegar.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que maneira simbólica descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O `evaluator` parâmetro é o delegate para um método personalizado que você define e que examina cada correspondência. O método personalizado deve ter a seguinte assinatura para coincidir com o <xref:System.Text.RegularExpressions.MatchEvaluator> delegate.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 O método personalizado retorna uma cadeia de caracteres que substitui a entrada correspondente.  
  
 Se você especificar <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> para o `options` parâmetro, a pesquisa de correspondências começa no final da cadeia de caracteres de entrada e move para a esquerda; caso contrário, a pesquisa começará no início da cadeia de caracteres de entrada e movido para a direita.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é gerada se o tempo de execução da operação de substituição excede o intervalo de tempo limite especificado para o domínio de aplicativo no qual o método é chamado. Se nenhum tempo limite é definido nas propriedades do domínio de aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
 Como o método retorna `input` inalterado se não houver nenhuma correspondência, você pode usar o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar se o método foi feita qualquer substituição para a cadeia de caracteres de entrada.  
  
   
  
## Examples  
 O exemplo a seguir usa uma expressão regular para extrair as palavras individuais de uma cadeia de caracteres e, em seguida, usa um <xref:System.Text.RegularExpressions.MatchEvaluator> delegado para chamar um método chamado `WordScramble` que codifica as letras individuais na palavra. Para fazer isso, o `WordScramble` método cria uma matriz que contém os caracteres na correspondência. Ele também cria uma matriz paralela que é preenchida com números de ponto flutuante aleatórios. As matrizes são classificadas por chamar o <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> método e a matriz classificada é fornecido como um argumento para um <xref:System.String> construtor de classe. Essa cadeia de caracteres recém-criado é retornada pelo `WordScramble` método. O padrão de expressão regular `\w+` corresponde a um ou mais caracteres de palavra; o mecanismo de expressão regular continuará a adicionar caracteres para a correspondência até encontrar um caractere de palavra, como um caractere de espaço em branco. A chamada para o <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> método inclui o <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> opção para que o comentário no padrão de expressão regular `\w+  # Matches all the characters in a word.` é ignorado pelo mecanismo de expressão regular.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace6.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace6.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> ou <paramref name="evaluator" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> não é uma combinação bit a bit válida de valores de <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="evaluator">Um método personalizado que examina cada correspondência e retorna a cadeia de caracteres correspondida original ou uma cadeia de caracteres de substituição.</param>
        <param name="count">O número máximo de vezes que a substituição ocorrerá.</param>
        <param name="startat">A posição do caractere na cadeia de caracteres de entrada na qual a pesquisa começa.</param>
        <summary>Em uma subcadeia de caracteres de entrada especificada, substitui um número máximo especificado de cadeias de caracteres que correspondem a um padrão de expressão regular por uma cadeia de caracteres retornada por um delegado <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Uma nova cadeia de caracteres é idêntica à cadeia de entrada, com exceção de que a cadeia de substituição substitui cada cadeia de caracteres correspondente. Se o padrão de expressão regular não tiver uma correspondência na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método é útil para substituir uma correspondência da expressão regular, se qualquer uma das seguintes condições for verdadeira:  
  
-   A cadeia de caracteres de substituição prontamente não pode ser especificada por um padrão de substituição de expressão regular.  
  
-   Os resultados da cadeia de caracteres de substituição de algum processamento feito na cadeia de caracteres correspondente.  
  
-   Os resultados da cadeia de caracteres de substituição de processamento condicional.  
  
 O método é equivalente a chamar o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> método e passar o primeiro `count` <xref:System.Text.RegularExpressions.Match> objetos retornado <xref:System.Text.RegularExpressions.MatchCollection> coleção para o `evaluator` delegate.  
  
 A expressão regular é um padrão definido pelo construtor atual <xref:System.Text.RegularExpressions.Regex> objeto.  
  
 O `evaluator` parâmetro é o delegate para um método personalizado que você define e que examina cada correspondência. O método personalizado deve ter a seguinte assinatura para coincidir com o <xref:System.Text.RegularExpressions.MatchEvaluator> delegate.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 O método personalizado retorna uma cadeia de caracteres que substitui a entrada correspondente.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é gerada se o tempo de execução da operação de substituição excede o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um intervalo de tempo limite ao chamar o construtor, a exceção é gerada se a operação exceder qualquer valor de tempo limite estabelecida para o domínio de aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido no <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio de aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada  
  
 Como o método retorna `input` inalterado se não houver nenhuma correspondência, você pode usar o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar se o método foi feita qualquer substituição para a cadeia de caracteres de entrada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="evaluator" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> é menor que zero ou maior que o tamanho de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="replacement">A cadeia de caracteres substituta.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que fornece opções para correspondência.</param>
        <param name="matchTimeout">Um intervalo de tempo limite ou <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que o método não deve atingir o tempo limite.</param>
        <summary>Em uma cadeia de caracteres de entrada especificada, substitui todas as cadeias de caracteres que correspondem a uma expressão regular especificada por uma cadeia de caracteres de substituição especificada. Os parâmetros adicionais especificam opções que modificam a operação de correspondência e um intervalo de tempo limite se nenhuma correspondência é encontrada.</summary>
        <returns>Uma nova cadeia de caracteres idêntica à cadeia de caracteres de entrada, com exceção de que a cadeia de caracteres de substituição substitui cada cadeia de caracteres correspondente. Se <paramref name="pattern" /> não tiver uma correspondência na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estático `Replace` métodos são equivalentes a construir um <xref:System.Text.RegularExpressions.Regex> do objeto com o padrão de expressão regular especificada e chamar o método de instância `Replace`.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que maneira simbólica descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Se você especificar <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> para o `options` parâmetro, a pesquisa de correspondências começa no final da cadeia de caracteres de entrada e move para a esquerda; caso contrário, a pesquisa começará no início da cadeia de caracteres de entrada e movido para a direita.  
  
 O `replacement` parâmetro especifica a cadeia de caracteres que substitui cada correspondência no `input`. `replacement` pode consistir em qualquer combinação de texto literal e [substituições](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Por exemplo, o padrão de substituição `a*${test}b` insere a cadeia de caracteres "um *" seguido de subcadeia de caracteres que corresponde do `test` grupo de captura, se houver, seguido pela cadeia de caracteres "b". O * caractere não é reconhecido como um metacaractere em um padrão de substituição.  
  
> [!NOTE]
>  As substituições são os elementos de linguagem de expressão regular só serão reconhecidos em um padrão de substituição. Todos os outros elementos de linguagem de expressão regular, incluindo [escapes de caracteres](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), são permitidos em padrões de expressão regular apenas e não são reconhecidos em padrões de substituição.  
  
 O `matchTimeout` parâmetro especifica como o tempo padrão correspondente método deve tentar localizar uma correspondência antes de expirar. Definir um intervalo de tempo limite impede que as expressões regulares que dependem de retrocesso excessiva de parece parar de responder ao processar a entrada que contém a próxima correspondência. Para obter mais informações, consulte [práticas recomendadas para expressões regulares](~/docs/standard/base-types/best-practices.md) e [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Se nenhuma correspondência for encontrada desse intervalo de tempo, o método gera uma <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção. `matchTimeout` substitui qualquer valor de tempo limite padrão definido para o domínio de aplicativo no qual o método é executado.  
  
 Como o método retorna `input` inalterado se não houver nenhuma correspondência, você pode usar o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar se o método foi feita qualquer substituição para a cadeia de caracteres de entrada.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> método para substituir os nomes de computador e a unidade locais em um caminho UNC com um caminho de arquivo local. A expressão regular usa o <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propriedade para incluir o nome do computador local e o <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> método para incluir os nomes das unidades lógicas. Todas as comparações de cadeia de caracteres de expressão regular diferenciam maiusculas de minúsculas e qualquer operação única substituição expira se não for encontrada uma correspondência em 0,5 segundo. Para executar o exemplo com êxito, você deve substituir a cadeia de caracteres literal "MinhaMaquina" com o nome do computador local.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace12.cs#12)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace12.vb#12)]  
  
 O padrão de expressão regular é definido pela seguinte expressão:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 A tabela a seguir mostra como o padrão da expressão regular é interpretado.  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\\\\`|Barra invertida consecutiva de correspondência dois (`\`) caracteres. Como o caractere de barra invertida é interpretado como o caractere de escape, cada barra invertida deve ser substituída com outra barra invertida.|  
|`+ Environment.MachineName +`|Corresponde a cadeia de caracteres que é retornada pelo <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propriedade.|  
|`(?:\.\w+)*`|Corresponde o período (`.`) seguido por um ou mais caracteres de texto. Essa correspondência pode ocorrer zero ou mais vezes. A subexpressão correspondente não é capturada.|  
|`\\`|Corresponde a uma barra invertida (`\`) caracteres.|  
|`([" + driveNames + "])`|Corresponde à classe de caracteres que consiste nas letras de unidade individuais. Esse correspondente é a primeira subexpressão capturada.|  
|`\$`|Corresponde o sinal de cifrão literal (`$`) caracteres.|  
  
 O padrão de substituição `$1` substitui toda correspondência com a primeira subexpressão capturada. Ou seja, ele substitui o nome UNC de máquina e a unidade com a letra da unidade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> ou <paramref name="replacement" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> não é uma combinação bit a bit válida de valores de <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
 - ou -  
  
 <paramref name="matchTimeout" /> é negativo, zero ou maior que aproximadamente 24 dias.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <block subset="none" type="usage">
          <para>Recomendamos que você defina o <paramref name="matchTimeout" /> parâmetro para um valor apropriado, como dois segundos. Se você desabilitar o tempo limite especificando <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, o mecanismo de expressão regular oferece um pouco melhor desempenho. No entanto, você deve desabilitar tempos limite apenas sob as seguintes condições:  
  
-   Quando a entrada processada por uma expressão regular é derivada de uma origem conhecida e confiável ou consiste em texto estático. Exclui o texto que tenha sido dinamicamente entrada pelos usuários.  
  
-   Quando o padrão de expressão regular tem foram testado para garantir que ele trata com eficiência corresponde não correspondências e próximo corresponde.  
  
-   Quando o padrão de expressão regular não contém linguagem elementos que causam retrocesso excessiva durante o processamento de uma correspondência near.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres na qual será pesquisada uma correspondência.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="evaluator">Um método personalizado que examina cada correspondência e retorna a cadeia de caracteres correspondida original ou uma cadeia de caracteres de substituição.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que fornecem opções para correspondência.</param>
        <param name="matchTimeout">Um intervalo de tempo limite ou <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que o método não deve atingir o tempo limite.</param>
        <summary>Em uma cadeia de caracteres de entrada especificada, substitui todas as subcadeias de caracteres que correspondem a uma expressão regular especificada por uma cadeia de caracteres retornada por um delegado <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />. Os parâmetros adicionais especificam opções que modificam a operação de correspondência e um intervalo de tempo limite se nenhuma correspondência é encontrada.</summary>
        <returns>Uma nova cadeia de caracteres idêntica à cadeia de caracteres de entrada, com exceção de que a cadeia de caracteres de substituição substitui cada cadeia de caracteres correspondente. Se <paramref name="pattern" /> não tiver uma correspondência na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> método é útil para substituir uma correspondência da expressão regular, se qualquer uma das seguintes condições for verdadeira:  
  
-   Se a cadeia de caracteres de substituição prontamente não pode ser especificada por um padrão de substituição de expressão regular.  
  
-   Se os resultados de cadeia de caracteres de substituição de algum processamento executado na cadeia de caracteres correspondente.  
  
-   Se a cadeia de caracteres de substituição os resultados de processamento condicional.  
  
 O método é equivalente a chamar o <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> método e passando cada <xref:System.Text.RegularExpressions.Match> objeto retornado <xref:System.Text.RegularExpressions.MatchCollection> coleção para o `evaluator` delegar.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que maneira simbólica descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 O `evaluator` parâmetro é o delegate para um método personalizado que você define e que examina cada correspondência. O método personalizado deve ter a seguinte assinatura para coincidir com o <xref:System.Text.RegularExpressions.MatchEvaluator> delegate.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 O método personalizado retorna uma cadeia de caracteres que substitui a entrada correspondente.  
  
 Se você especificar <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> para o `options` parâmetro, a pesquisa de correspondências começa no final da cadeia de caracteres de entrada e move para a esquerda; caso contrário, a pesquisa começará no início da cadeia de caracteres de entrada e movido para a direita.  
  
 O `matchTimeout` parâmetro especifica como o tempo padrão correspondente método deve tentar localizar uma correspondência antes de expirar. Definir um intervalo de tempo limite impede que as expressões regulares que dependem de retrocesso excessiva de parece "parar de responder ao processar a entrada que contém a próxima correspondência. Para obter mais informações, consulte [práticas recomendadas para expressões regulares](~/docs/standard/base-types/best-practices.md) e [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Se nenhuma correspondência for encontrada desse intervalo de tempo, o método gera uma <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção. `matchTimeout` substitui qualquer valor de tempo limite padrão definido para o domínio de aplicativo no qual o método é executado.  
  
 Como o método retorna `input` inalterado se não houver nenhuma correspondência, você pode usar o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para determinar se o método foi feita qualquer substituição para a cadeia de caracteres de entrada.  
  
   
  
## Examples  
 O exemplo a seguir usa uma expressão regular para extrair as palavras individuais de uma cadeia de caracteres e, em seguida, usa um <xref:System.Text.RegularExpressions.MatchEvaluator> delegado para chamar um método chamado `WordScramble` que codifica as letras individuais na palavra. Para fazer isso, o `WordScramble` método cria uma matriz que contém os caracteres na correspondência. Ele também cria uma matriz paralela que é preenchida com números de ponto flutuante aleatórios. As matrizes são classificadas por chamar o <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> método e a matriz classificada é fornecido como um argumento para um <xref:System.String> construtor de classe. Essa cadeia de caracteres recém-criado é retornada pelo `WordScramble` método. O padrão de expressão regular `\w+` corresponde a um ou mais caracteres de palavra; o mecanismo de expressão regular continuará a adicionar caracteres para a correspondência até encontrar um caractere de palavra, como um caractere de espaço em branco. A chamada para o <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> método inclui o <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> opção para que o comentário no padrão de expressão regular `\w+  # Matches all the characters in a word.` é ignorado pelo mecanismo de expressão regular.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace13.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> ou <paramref name="evaluator" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> não é uma combinação bit a bit válida de valores de <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
 - ou -  
  
 <paramref name="matchTimeout" /> é negativo, zero ou maior que aproximadamente 24 dias.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <block subset="none" type="usage">
          <para>Recomendamos que você defina o <paramref name="matchTimeout" /> parâmetro para um valor apropriado, como dois segundos. Se você desabilitar o tempo limite especificando <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, o mecanismo de expressão regular oferece um pouco melhor desempenho. No entanto, você deve desabilitar tempos limite apenas sob as seguintes condições:  
  
-   Quando a entrada processada por uma expressão regular é derivada de uma origem conhecida e confiável ou consiste em texto estático. Exclui o texto que tenha sido dinamicamente entrada pelos usuários.  
  
-   Quando o padrão de expressão regular tem foram testado para garantir que ele trata com eficiência corresponde não correspondências e próximo corresponde.  
  
-   Quando o padrão de expressão regular não contém linguagem elementos que causam retrocesso excessiva durante o processamento de uma correspondência near.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a expressão regular pesquisa da direita para a esquerda.</summary>
        <value>
          <see langword="true" /> Se a expressão regular pesquisas da direita para a esquerda; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.RightToLeft%2A> é `true` se o <xref:System.Text.RegularExpressions.Regex> instância foi criada com o <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> opção.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="roptions">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexOptions roptions;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.Text.RegularExpressions.RegexOptions roptions" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.roptions" />
      <MemberSignature Language="VB.NET" Value="Protected Friend roptions As RegexOptions " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexOptions roptions;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Usado por um objeto <see cref="T:System.Text.RegularExpressions.Regex" /> gerado pelo método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Divide uma cadeia de caracteres de entrada em uma matriz de subcadeias de caracteres nas posições definidas por uma correspondência de expressão regular.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres a ser dividida.</param>
        <summary>Divide uma cadeia de caracteres de entrada em uma matriz de subcadeias de caracteres nas posições definidas por um padrão de expressão regular especificado no construtor <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Uma matriz de cadeias de caracteres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> métodos são semelhantes a <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> método, exceto que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> divide a cadeia de caracteres em um determinado por uma expressão regular, em vez de um conjunto de caracteres de delimitador. A cadeia de caracteres é dividida quantas vezes forem possíveis. Se nenhum delimitador for encontrado, o valor de retorno contém um elemento cujo valor é a cadeia de caracteres de entrada original.  
  
 Se várias correspondências são adjacentes uns aos outros, uma cadeia de caracteres vazia será inserida na matriz. Por exemplo, dividir uma cadeia de caracteres em um hífen faz com que a matriz retornada incluir uma cadeia de caracteres vazia na posição onde dois hifens adjacentes são encontrados, como mostra o seguinte código.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split1.vb#1)]  
  
 Se uma correspondência for encontrada no início ou no final da cadeia de caracteres de entrada, uma cadeia de caracteres vazia é incluída no início ou no final da matriz retornada. O exemplo a seguir usa o padrão de expressão regular `\d+` para dividir uma cadeia de caracteres de entrada em caracteres numéricos. Como a cadeia de caracteres começa e termina com a correspondência de caracteres numéricos, o valor do primeiro e o último elemento da matriz retornada é <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split21.cs#21)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split21.vb#21)]  
  
 Se parênteses de captura são usados em um <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> expressão, qualquer capturada texto está incluído na matriz de cadeia de caracteres resultante. Por exemplo, se você dividir a cadeia de caracteres "Black-pera" em um hífen colocado dentro de parênteses de captura, a matriz retornada inclui um elemento de cadeia de caracteres que contém o hífen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split2.vb#2)]  
  
 No entanto, quando o padrão de expressão regular inclui vários conjuntos de parênteses de captura, o comportamento desse método depende da versão do .NET Framework. No .NET Framework 1.0 e 1.1, se não for encontrada uma correspondência dentro do primeiro conjunto de parênteses, a captura o texto capturado de parênteses adicionais de captura não está incluído na matriz retornada. Começando com o .NET Framework 2.0, todo o texto capturado também é adicionado à matriz retornada. Por exemplo, o código a seguir usa dois conjuntos de captura parênteses para extrair os elementos de uma data, incluindo os delimitadores de data, de uma cadeia de caracteres de data. O primeiro conjunto de parênteses de captura captura o hífen e o segundo conjunto de captura a barra invertida. Se o código de exemplo é compilado e executado no .NET Framework 1.0 ou 1.1, ele exclui os caracteres de barra; Se ele for compilado e executado no .NET Framework 2.0 ou versões posteriores, inclui-los.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split3.vb#3)]  
  
 Se a expressão regular pode corresponder a cadeia de caracteres vazia, <xref:System.Text.RegularExpressions.Regex.Split%28System.String%29> dividirá a cadeia de caracteres em uma matriz de cadeias de caracteres único porque o delimitador de cadeia de caracteres vazia pode ser encontrado em cada local. Por exemplo:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split11.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split11.vb#11)]  
  
 Observe que a matriz retornada também inclui uma cadeia de caracteres vazia no início e no final da matriz.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é gerada se o tempo de execução da operação de divisão excede o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um intervalo de tempo limite ao chamar o construtor, a exceção é gerada se a operação exceder qualquer valor de tempo limite estabelecida para o domínio de aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido no <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio de aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres a ser dividida.</param>
        <param name="count">O número máximo de vezes que a divisão pode ocorrer.</param>
        <summary>Divide uma cadeia de entrada no número de vezes máximo especificado em uma matriz de subcadeias de caracteres, nas posições definidas por uma expressão regular especificada no construtor <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Uma matriz de cadeias de caracteres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> métodos são semelhantes a <xref:System.String.Split%2A?displayProperty=nameWithType> método, exceto que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> divide a cadeia de caracteres em um determinado por uma expressão regular, em vez de um conjunto de caracteres de delimitador. O `count` parâmetro especifica o número máximo de subcadeias de caracteres na qual o `input` cadeia de caracteres pode ser dividida; a última cadeia de caracteres contém o dividido restante da cadeia de caracteres. Um `count` valor zero fornece o comportamento padrão de divisão de quantas vezes forem possíveis.  
  
 Se várias correspondências são adjacentes uns aos outros ou se uma correspondência for encontrada no início ou no final da `input`, e o número de correspondências encontradas é pelo menos dois menor `count`, uma cadeia de caracteres vazia é inserida na matriz. Isto é, cadeias de caracteres vazias que resultam de correspondências adjacentes ou de correspondências no início ou no final da cadeia de caracteres de entrada são contadas para determinar se o número de correspondência subcadeias de caracteres é igual a `count`. No exemplo a seguir, a expressão regular `/d+` é usado para dividir uma cadeia de caracteres de entrada que inclui um ou mais dígitos decimais em um máximo de três subcadeias de caracteres. Como o início da cadeia de entrada corresponde ao padrão de expressão regular, o primeiro elemento da matriz contém <xref:System.String.Empty?displayProperty=nameWithType>, o segundo contém o primeiro conjunto de caracteres alfabéticos na cadeia de caracteres de entrada e a terceira contém o restante da cadeia de caracteres que segue a correspondência de terceira.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split25.cs#25)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split25.vb#25)]  
  
 Se parênteses de captura são usados em uma expressão regular, qualquer texto capturado está incluído na matriz de cadeias de caracteres de divisão. No entanto, os elementos de matriz que contêm texto capturado não são contados para determinar se o número de correspondências atingiu `count`. Por exemplo, dividir a cadeia de caracteres "apple-damasco-Black-pera-banana" em um máximo de quatro resultados de subcadeias de caracteres em uma matriz de elementos de sete, como o código a seguir mostra.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split4.vb#4)]  
  
 No entanto, quando o padrão de expressão regular inclui vários conjuntos de parênteses de captura, o comportamento desse método depende da versão do .NET Framework. No .NET Framework 1.0 e 1.1, somente texto capturado do primeiro conjunto de parênteses de captura está incluído na matriz retornada. Começando com o .NET Framework 2.0, todo o texto capturado é adicionado à matriz retornada. No entanto, os elementos na matriz retornada que contêm texto capturado não são contados para determinar se o número de correspondência subcadeias de caracteres é igual a `count`. Por exemplo, no código a seguir, uma expressão regular usa dois conjuntos de captura parênteses para extrair os elementos de uma data de uma cadeia de caracteres de data. O primeiro conjunto de parênteses de captura captura o hífen e o segundo conjunto de captura a barra invertida. A chamada para o <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> método Especifica, em seguida, um máximo de dois elementos na matriz retornada. Se o código de exemplo é compilado e executado no .NET Framework 1.0 ou 1.1, o método retorna uma matriz de cadeia de caracteres de dois elementos. Se ele for compilado e executado no .NET Framework 2.0 ou versões posteriores, o método retorna uma matriz de cadeia de caracteres de três elementos.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split5.vb#5)]  
  
 Se a expressão regular pode corresponder a cadeia de caracteres vazia, <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> dividirá a cadeia de caracteres em uma matriz de cadeias de caracteres único porque o delimitador de cadeia de caracteres vazia pode ser encontrado em cada local. O exemplo a seguir divide a cadeia de "caracteres" em que como há muitos elementos na cadeia de caracteres de entrada. Porque a cadeia de caracteres nula corresponde ao início da cadeia de caracteres de entrada, uma cadeia de caracteres nulo é inserida no início da matriz retornada. Isso faz com que o elemento décimo consistem em dois caracteres do final da cadeia de caracteres de entrada.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split12.vb#12)]  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é gerada se o tempo de execução da operação de divisão excede o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um intervalo de tempo limite ao chamar o construtor, a exceção é gerada se a operação exceder qualquer valor de tempo limite estabelecida para o domínio de aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido no <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio de aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres a ser dividida.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <summary>Divide uma cadeia de caracteres de entrada em uma matriz de subcadeias de caracteres nas posições definidas por um padrão de expressão regular.</summary>
        <returns>Uma matriz de cadeias de caracteres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> métodos são semelhantes a <xref:System.String.Split%2A?displayProperty=nameWithType> método, exceto que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> divide a cadeia de caracteres em um determinado por uma expressão regular, em vez de um conjunto de caracteres de delimitador. O `input` cadeia de caracteres é dividida quantas vezes forem possíveis. Se `pattern` não foi encontrado no `input` cadeia de caracteres, o valor de retorno contém um elemento cujo valor é o original `input` cadeia de caracteres.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que maneira simbólica descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Compilado expressões regulares usadas em chamadas para estático <xref:System.Text.RegularExpressions.Regex.Split%2A> métodos são armazenados em cache automaticamente. Para gerenciar o tempo de vida de expressões regulares compiladas, use a instância <xref:System.Text.RegularExpressions.Regex.Split%2A> métodos.  
  
 Se várias correspondências são adjacentes uns aos outros, uma cadeia de caracteres vazia será inserida na matriz. Por exemplo, dividir uma cadeia de caracteres em um hífen faz com que a matriz retornada incluir uma cadeia de caracteres vazia na posição onde dois hifens adjacentes são encontrados, como mostra o seguinte código.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split8.vb#8)]  
  
 Se uma correspondência for encontrada no início ou no final da cadeia de caracteres de entrada, uma cadeia de caracteres vazia é incluída no início ou no final da matriz retornada. O exemplo a seguir usa o padrão de expressão regular `\d+` para dividir uma cadeia de caracteres de entrada em caracteres numéricos. Como a cadeia de caracteres começa e termina com a correspondência de caracteres numéricos, o valor do primeiro e o último elemento da matriz retornada é <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split22.cs#22)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split22.vb#22)]  
  
 Se parênteses de captura são usados em um <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> expressão, qualquer capturada texto está incluído na matriz de cadeia de caracteres resultante. Por exemplo, se você dividir a cadeia de caracteres "Black-pera" em um hífen colocado dentro de parênteses de captura, a matriz retornada inclui um elemento de cadeia de caracteres que contém o hífen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 No entanto, quando o padrão de expressão regular inclui vários conjuntos de parênteses de captura, o comportamento desse método depende da versão do .NET Framework. No .NET Framework 1.0 e 1.1, se não for encontrada uma correspondência dentro do primeiro conjunto de parênteses, a captura o texto capturado de parênteses adicionais de captura não está incluído na matriz retornada. Começando com o .NET Framework 2.0, todo o texto capturado também é adicionado à matriz retornada. Por exemplo, o código a seguir usa dois conjuntos de captura parênteses para extrair os elementos de uma data, incluindo os delimitadores de data, de uma cadeia de caracteres de data. O primeiro conjunto de parênteses de captura captura o hífen e o segundo conjunto de captura a barra invertida. Se o código de exemplo é compilado e executado no .NET Framework 1.0 ou 1.1, ele exclui os caracteres de barra; Se ele for compilado e executado no .NET Framework 2.0 ou versões posteriores, inclui-los.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Se a expressão regular pode corresponder a cadeia de caracteres vazia, <xref:System.Text.RegularExpressions.Regex.Split%2A> dividirá a cadeia de caracteres em uma matriz de cadeias de caracteres único porque o delimitador de cadeia de caracteres vazia pode ser encontrado em cada local. Por exemplo:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split13.vb#13)]  
  
 Observe que a matriz retornada também inclui uma cadeia de caracteres vazia no início e no final da matriz.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é gerada se o tempo de execução da operação de divisão excede o intervalo de tempo limite especificado para o domínio de aplicativo no qual o método é chamado. Se nenhum tempo limite é definido nas propriedades do domínio de aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="pattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <block subset="none" type="usage">
          <para>Esse método expire após um intervalo que seja igual ao valor de tempo limite padrão do domínio do aplicativo no qual o método é chamado. Se um valor de tempo limite não tiver sido definido para o domínio de aplicativo, o valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impede que o método do tempo limite, é usado. O método estático recomendado para dividir o texto em uma correspondência de padrão é <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite que você defina o intervalo de tempo limite.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer, startat As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres a ser dividida.</param>
        <param name="count">O número máximo de vezes que a divisão pode ocorrer.</param>
        <param name="startat">A posição do caractere na cadeia de caracteres de entrada em que a pesquisa será iniciada.</param>
        <summary>Divide uma cadeia de entrada no número de vezes máximo especificado em uma matriz de subcadeias de caracteres, nas posições definidas por uma expressão regular especificada no construtor <see cref="T:System.Text.RegularExpressions.Regex" />. A pesquisa do padrão de expressão regular é iniciada em uma posição de caractere especificada na cadeia de entrada.</summary>
        <returns>Uma matriz de cadeias de caracteres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> métodos são semelhantes a <xref:System.String.Split%2A?displayProperty=nameWithType> método, exceto que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> divide a cadeia de caracteres em um determinado por uma expressão regular, em vez de um conjunto de caracteres de delimitador. O `count` parâmetro especifica o número máximo de subcadeias de caracteres na qual o `input` é dividir a cadeia de caracteres; a última cadeia de caracteres contém o dividido restante da cadeia de caracteres. Um `count` valor zero fornece o comportamento padrão de divisão de quantas vezes forem possíveis. O `startat` parâmetro define o ponto no qual começa a pesquisa para o primeiro delimitador (Isso pode ser usado para ignorar espaço em branco à esquerda).  
  
 Se nenhuma correspondência for encontrada no `count`+ 1 posição na cadeia de caracteres, o método retorna uma matriz de um elemento que contém o `input` cadeia de caracteres. Se uma ou mais correspondências forem encontradas, o primeiro elemento da matriz retornada contém a primeira parte da cadeia de caracteres do primeiro caractere até um caractere antes da correspondência.  
  
 Se várias correspondências são adjacentes um ao outro e o número de correspondências encontradas é pelo menos dois menor `count`, uma cadeia de caracteres vazia é inserida na matriz. Da mesma forma, se uma correspondência for encontrada em `startat`, que é o primeiro caractere na cadeia de caracteres, o primeiro elemento da matriz retornada é uma cadeia de caracteres vazia. Isto é, cadeias de caracteres vazias que resultam de correspondências adjacentes são contadas para determinar se o número de correspondência subcadeias de caracteres é igual a `count`. No exemplo a seguir, a expressão regular `\d+` é usado para localizar a posição inicial da primeira subcadeia de caracteres de caracteres numéricos em uma cadeia de caracteres e, em seguida, dividir a cadeia de caracteres no máximo três vezes inicial da posição. Como o padrão de expressão regular corresponde ao início da cadeia de caracteres de entrada, a matriz de cadeia de caracteres retornada consiste em uma cadeia de caracteres vazia, uma cadeia de caracteres alfabética cinco caracteres e o restante da cadeia de caracteres  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split26.cs#26)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split26.vb#26)]  
  
 Se parênteses de captura são usados em uma expressão regular, qualquer texto capturado está incluído na matriz de cadeias de caracteres de divisão. No entanto, os elementos de matriz que contêm texto capturado não são contados para determinar se o número de correspondências atingiu `count`. Por exemplo, dividir a cadeia de caracteres ' "apple-apricot-plum-pear-pomegranate-pineapple-peach" em um máximo de quatro subcadeias começando no caractere 15 nos resultados da cadeia de caracteres em uma matriz de sete elementos, como mostra o código a seguir.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split6.vb#6)]  
  
 No entanto, quando o padrão de expressão regular inclui vários conjuntos de parênteses de captura, o comportamento desse método depende da versão do .NET Framework. No .NET Framework 1.0 e 1.1, se não for encontrada uma correspondência dentro do primeiro conjunto de parênteses, a captura o texto capturado de parênteses adicionais de captura não está incluído na matriz retornada. Começando com o .NET Framework 2.0, todo o texto capturado também é adicionado à matriz retornada. Por exemplo, o código a seguir usa dois conjuntos de captura parênteses para extrair as palavras individuais em uma cadeia de caracteres. O primeiro conjunto de parênteses de captura captura o hífen e o segundo conjunto de captura a barra vertical. Se o código de exemplo é compilado e executado no .NET Framework 1.0 ou 1.1, ele exclui vertical barra caracteres; Se ele for compilado e executado no .NET Framework 2.0 ou versões posteriores, inclui-los.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split7.vb#7)]  
  
 Se a expressão regular pode corresponder a cadeia de caracteres vazia, <xref:System.Text.RegularExpressions.Regex.Split%2A> dividirá a cadeia de caracteres em uma matriz de cadeias de caracteres único porque o delimitador de cadeia de caracteres vazia pode ser encontrado em cada local. O exemplo a seguir divide os caracteres"cadeia de caracteres" em tantos elementos que contém a cadeia de caracteres de entrada, começando com o caractere "a". Porque a cadeia de caracteres nula corresponde ao fim da cadeia de caracteres de entrada, uma cadeia de caracteres nulo é inserida no final da matriz retornada.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split14.cs#14)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split14.vb#14)]  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é gerada se o tempo de execução da operação de divisão excede o intervalo de tempo limite especificado pelo <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> construtor. Se você não definir um intervalo de tempo limite ao chamar o construtor, a exceção é gerada se a operação exceder qualquer valor de tempo limite estabelecida para o domínio de aplicativo no qual o <xref:System.Text.RegularExpressions.Regex> objeto é criado. Se nenhum tempo limite é definido no <xref:System.Text.RegularExpressions.Regex> chamada de construtor ou nas propriedades do domínio de aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> é menor que zero ou maior que o tamanho de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres a ser dividida.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que fornece opções para correspondência.</param>
        <summary>Divide uma cadeia de caracteres de entrada em uma matriz de subcadeias de caracteres nas posições definidas por um padrão de expressão regular especificado. As opções especificadas modificam a operação de correspondência.</summary>
        <returns>Uma matriz de cadeias de caracteres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> métodos são semelhantes a <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> método, exceto que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> divide a cadeia de caracteres em um determinado por uma expressão regular, em vez de um conjunto de caracteres de delimitador. A cadeia de caracteres é dividida quantas vezes forem possíveis. Se nenhum delimitador for encontrado, o valor de retorno contém um elemento cujo valor é o original `input` cadeia de caracteres.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que maneira simbólica descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Compilado expressões regulares usadas em chamadas para estático <xref:System.Text.RegularExpressions.Regex.Split%2A> métodos são armazenados em cache automaticamente. Para gerenciar o tempo de vida de expressões regulares compiladas, use a instância <xref:System.Text.RegularExpressions.Regex.Split%2A> métodos.  
  
 Se várias correspondências são adjacentes uns aos outros, uma cadeia de caracteres vazia será inserida na matriz. Por exemplo, dividir uma cadeia de caracteres em um hífen faz com que a matriz retornada incluir uma cadeia de caracteres vazia na posição onde dois hifens adjacentes são encontradas.  
  
 Se uma correspondência for encontrada no início ou no final da cadeia de caracteres de entrada, uma cadeia de caracteres vazia é incluída no início ou no final da matriz retornada. O exemplo a seguir usa o padrão de expressão regular `[a-z]+` para dividir uma cadeia de caracteres de entrada em qualquer caractere alfabético em maiuscula ou minúscula. Como a cadeia de caracteres começa e termina com a correspondência de caracteres alfabéticos, o valor do primeiro e o último elemento da matriz retornada é <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split24.cs#24)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split24.vb#24)]  
  
 Se parênteses de captura são usados em um <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> expressão, qualquer capturada texto está incluído na matriz de cadeia de caracteres resultante. Por exemplo, se você dividir a cadeia de caracteres "Black-pera" em um hífen colocado dentro de parênteses de captura, a matriz retornada inclui um elemento de cadeia de caracteres que contém o hífen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 No entanto, quando o padrão de expressão regular inclui vários conjuntos de parênteses de captura, o comportamento desse método depende da versão do .NET Framework. No .NET Framework 1.0 e 1.1, se não for encontrada uma correspondência dentro do primeiro conjunto de parênteses, a captura o texto capturado de parênteses adicionais de captura não está incluído na matriz retornada. Começando com o .NET Framework 2.0, todo o texto capturado também é adicionado à matriz retornada. Por exemplo, o código a seguir usa dois conjuntos de captura parênteses para extrair os elementos de uma data, incluindo os delimitadores de data, de uma cadeia de caracteres de data. O primeiro conjunto de parênteses de captura captura o hífen e o segundo conjunto de captura a barra invertida. Se o código de exemplo é compilado e executado no .NET Framework 1.0 ou 1.1, ele exclui os caracteres de barra; Se ele for compilado e executado no .NET Framework 2.0 ou versões posteriores, inclui-los.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Se a expressão regular pode corresponder a cadeia de caracteres vazia, <xref:System.Text.RegularExpressions.Regex.Split%2A> dividirá a cadeia de caracteres em uma matriz de cadeias de caracteres único porque o delimitador de cadeia de caracteres vazia pode ser encontrado em cada local.  
  
 O <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção é gerada se o tempo de execução da operação de divisão excede o intervalo de tempo limite especificado para o domínio de aplicativo no qual o método é chamado. Se nenhum tempo limite é definido nas propriedades do domínio de aplicativo, ou se o valor de tempo limite é <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nenhuma exceção é lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="pattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> não é uma combinação bit a bit válida de valores de <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <block subset="none" type="usage">
          <para>Esse método expire após um intervalo que seja igual ao valor de tempo limite padrão do domínio do aplicativo no qual o método é chamado. Se um valor de tempo limite não tiver sido definido para o domínio de aplicativo, o valor <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, que impede que o método do tempo limite, é usado. O método estático recomendado para dividir o texto em uma correspondência de padrão é <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, que permite que você defina o intervalo de tempo limite.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">A cadeia de caracteres a ser dividida.</param>
        <param name="pattern">O padrão de expressão regular para correspondência.</param>
        <param name="options">Uma combinação bit a bit dos valores de enumeração que fornece opções para correspondência.</param>
        <param name="matchTimeout">Um intervalo de tempo limite ou <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> para indicar que o método não deve atingir o tempo limite.</param>
        <summary>Divide uma cadeia de caracteres de entrada em uma matriz de subcadeias de caracteres nas posições definidas por um padrão de expressão regular especificado. Os parâmetros adicionais especificam opções que modificam a operação de correspondência e um intervalo de tempo limite se nenhuma correspondência é encontrada.</summary>
        <returns>Uma matriz de cadeia de caracteres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> métodos são semelhantes a <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> método, exceto que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> divide a cadeia de caracteres em um determinado por uma expressão regular, em vez de um conjunto de caracteres de delimitador. A cadeia de caracteres é dividida quantas vezes forem possíveis. Se nenhum delimitador for encontrado, o valor de retorno contém um elemento cujo valor é o original `input` cadeia de caracteres.  
  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que maneira simbólica descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Compilado expressões regulares usadas em chamadas para estático <xref:System.Text.RegularExpressions.Regex.Split%2A> métodos são armazenados em cache automaticamente. Para gerenciar o tempo de vida de expressões regulares compiladas, use a instância <xref:System.Text.RegularExpressions.Regex.Split%2A> métodos.  
  
 Se várias correspondências são adjacentes uns aos outros, uma cadeia de caracteres vazia será inserida na matriz. Por exemplo, dividir uma cadeia de caracteres em um hífen faz com que a matriz retornada incluir uma cadeia de caracteres vazia na posição onde dois hifens adjacentes são encontradas.  
  
 Se uma correspondência for encontrada no início ou no final da cadeia de caracteres de entrada, uma cadeia de caracteres vazia é incluída no início ou no final da matriz retornada. O exemplo a seguir usa o padrão de expressão regular `[a-z]+` para dividir uma cadeia de caracteres de entrada em qualquer caractere alfabético em maiuscula ou minúscula. Como a cadeia de caracteres começa e termina com a correspondência de caracteres alfabéticos, o valor do primeiro e o último elemento da matriz retornada é <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split23.cs#23)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split23.vb#23)]  
  
 Se parênteses de captura são usados em um <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> expressão, qualquer capturada texto está incluído na matriz de cadeia de caracteres resultante. Por exemplo, se você dividir a cadeia de caracteres "Black-pera" em um hífen colocado dentro de parênteses de captura, a matriz retornada inclui um elemento de cadeia de caracteres que contém o hífen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 No entanto, quando o padrão de expressão regular inclui vários conjuntos de parênteses de captura, o comportamento desse método depende da versão do .NET Framework. No .NET Framework 1.0 e 1.1, se não for encontrada uma correspondência dentro do primeiro conjunto de parênteses, a captura o texto capturado de parênteses adicionais de captura não está incluído na matriz retornada. Começando com o .NET Framework 2.0, todo o texto capturado também é adicionado à matriz retornada. Por exemplo, o código a seguir usa dois conjuntos de captura parênteses para extrair os elementos de uma data, incluindo os delimitadores de data, de uma cadeia de caracteres de data. O primeiro conjunto de parênteses de captura captura o hífen e o segundo conjunto de captura a barra invertida. Se o código de exemplo é compilado e executado no .NET Framework 1.0 ou 1.1, ele exclui os caracteres de barra; Se ele for compilado e executado no .NET Framework 2.0 ou versões posteriores, inclui-los.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Se a expressão regular pode corresponder a cadeia de caracteres vazia, <xref:System.Text.RegularExpressions.Regex.Split%2A> dividirá a cadeia de caracteres em uma matriz de cadeias de caracteres único porque o delimitador de cadeia de caracteres vazia pode ser encontrado em cada local.  
  
 O `matchTimeout` parâmetro especifica como o tempo padrão correspondente método deve tentar localizar uma correspondência antes de expirar. Definir um intervalo de tempo limite impede que as expressões regulares que dependem de retrocesso excessiva de parece parar de responder ao processar a entrada que contém a próxima correspondência. Para obter mais informações, consulte [práticas recomendadas para expressões regulares](~/docs/standard/base-types/best-practices.md) e [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Se nenhuma correspondência for encontrada desse intervalo de tempo, o método gera uma <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exceção. `matchTimeout` substitui qualquer valor de tempo limite padrão definido para o domínio de aplicativo no qual o método é executado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de análise da expressão regular.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ou <paramref name="pattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> não é uma combinação bit a bit válida de valores de <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
 - ou -  
  
 <paramref name="matchTimeout" /> é negativo, zero ou maior que aproximadamente 24 dias.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Ocorreu um tempo limite. Para obter mais informações sobre tempos limite, consulte a seção Comentários.</exception>
        <block subset="none" type="usage">
          <para>Recomendamos que você defina o <paramref name="matchTimeout" /> parâmetro para um valor apropriado, como dois segundos. Se você desabilitar o tempo limite especificando <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, o mecanismo de expressão regular oferece um pouco melhor desempenho. No entanto, você deve desabilitar tempos limite apenas sob as seguintes condições:  
  
-   Quando a entrada processada por uma expressão regular é derivada de uma origem conhecida e confiável ou consiste em texto estático. Exclui o texto que tenha sido dinamicamente entrada pelos usuários.  
  
-   Quando o padrão de expressão regular tem foram testado para garantir que ele trata com eficiência corresponde não correspondências e próximo corresponde.  
  
-   Quando o padrão de expressão regular não contém linguagem elementos que causam retrocesso excessiva durante o processamento de uma correspondência near.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="si">O objeto a ser preenchido com informações de serialização.</param>
        <param name="context">O local para armazenar e recuperar dados serializados. Esse parâmetro está reservado para uso futuro.</param>
        <summary>Popula um objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> com os dados necessários para desserializar o objeto <see cref="T:System.Text.RegularExpressions.Regex" /> atual.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o padrão de expressão regular que foi passado para o construtor <see langword="Regex" />.</summary>
        <returns>O parâmetro <paramref name="pattern" /> passado para o construtor <see langword="Regex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `pattern` parâmetro consiste em elementos de linguagem de expressão regular que maneira simbólica descrevem a cadeia de caracteres para corresponder. Para obter mais informações sobre expressões regulares, consulte [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguagem de expressões regulares - referência rápida](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> é a classe base de expressões regulares criado pelo <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> método. Esses compilado o uso de expressões regulares de <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> implementação da classe base. Se chamado de uma classe derivada, o <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> método retorna a cadeia de caracteres que foi passada para o <paramref name="pattern" /> parâmetro o <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> construtor da classe que foi usado para definir a expressão regular.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="public static string Unescape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Unescape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unescape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Unescape(System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">A cadeia de caracteres de entrada que contém o texto a ser convertido.</param>
        <summary>Converte qualquer caractere de escape na cadeia de caracteres de entrada.</summary>
        <returns>Uma cadeia de caracteres com qualquer caractere de escape convertido em sua forma sem escape.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.RegularExpressions.Regex.Unescape%2A> método executa uma das duas transformações a seguir:  
  
-   Ele reverte a transformação executada pelo <xref:System.Text.RegularExpressions.Regex.Escape%2A> método removendo o caractere de escape ("\\") de cada caractere de escape pelo método. Isso inclui o \\, *, +,?, &#124;, {, [, (,), ^, $,., # e espaço em branco. Além disso, o <xref:System.Text.RegularExpressions.Regex.Unescape%2A> método unescapes o colchete de fechamento (]) e fechamento caracteres de colchete (}).  
  
> [!NOTE]
>  <xref:System.Text.RegularExpressions.Regex.Unescape%2A> não é possível reverter uma cadeia de caracteres de escape perfeitamente porque ele não é possível deduzir exatamente quais caracteres foram substituídos,  
  
-   Ele substitui a representação de caracteres não imprimíveis com os próprios caracteres. Por exemplo, ele substitui \a com \x07. As representações de caractere que substitui são \a, \b, \e, \n, \r, \f, \t e \v.  
  
 Se o <xref:System.Text.RegularExpressions.Regex.Unescape%2A> método encontrar outras sequências de escape não é possível converter, como \w ou \s, ele lança um <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="str" /> inclui uma sequência de escape não reconhecida.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="UseOptionC">
      <MemberSignature Language="C#" Value="protected bool UseOptionC ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionC() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionC" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionC () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionC();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usado por um objeto <see cref="T:System.Text.RegularExpressions.Regex" /> gerado pelo método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <returns>
          <see langword="true" /> se a propriedade <see cref="P:System.Text.RegularExpressions.Regex.Options" /> contiver a opção <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseOptionR">
      <MemberSignature Language="C#" Value="protected bool UseOptionR ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionR() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionR" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionR () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionR();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usado por um objeto <see cref="T:System.Text.RegularExpressions.Regex" /> gerado pelo método <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <returns>
          <see langword="true" /> se a propriedade <see cref="P:System.Text.RegularExpressions.Regex.Options" /> contiver a opção <see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" />; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal static void ValidateMatchTimeout (TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig void ValidateMatchTimeout(valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Sub ValidateMatchTimeout (matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static void ValidateMatchTimeout(TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="matchTimeout">O intervalo de tempo limite a ser verificado.</param>
        <summary>Verifique se o intervalo de tempo limite está dentro de um intervalo aceitável.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>