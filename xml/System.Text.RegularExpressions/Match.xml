<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Match.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5fb63372e2192302c84aaf2b9879a89ead4000664.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fb63372e2192302c84aaf2b9879a89ead4000664</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Match">
          <source>Represents the results from a single regular expression match.</source>
          <target state="translated">Representa os resultados de correspondência de uma única expressão regular.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object is immutable and has no public constructor.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objeto é imutável e não tem construtor público.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> class is returned by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType&gt;</ph> method and represents the first pattern match in a string.</source>
          <target state="translated">Uma instância do <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> retornada pela classe o <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType&gt;</ph> método e representa o primeiro padrão correspondem em uma cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>Subsequent matches are represented by <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objects returned by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Correspondências subsequentes são representadas por <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objetos retornados pelo <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>In addition, a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object that consists of zero, one, or more <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objects is returned by the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Além disso, um <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objeto que consiste em zero, um ou mais <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objetos retornado pelo <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>If the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType&gt;</ph> method fails to match a regular expression pattern in an input string, it returns an empty <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated">Se o <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType&gt;</ph> método não corresponde a um padrão de expressão regular em uma cadeia de caracteres de entrada, ele retornará um elemento <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>You can then use a <ph id="ph1">`foreach`</ph> construct in C# or a <ph id="ph2">`For Each`</ph> construct in Visual Basic to iterate the collection.</source>
          <target state="translated">Você pode usar um <ph id="ph1">`foreach`</ph> construir em c# ou um <ph id="ph2">`For Each`</ph> construir no Visual Basic para iterar a coleção.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>If the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType&gt;</ph> method fails to match the regular expression pattern, it returns a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object that is equal to <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match.Empty%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se o <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType&gt;</ph> método não corresponde ao padrão de expressão regular, ele retorna um <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> que é igual ao objeto <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match.Empty%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>You can use the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property to determine whether the match was successful.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> para determinar se a correspondência foi bem-sucedida.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>The following example provides an illustration.</source>
          <target state="translated">O exemplo a seguir fornece uma ilustração.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>If a pattern match is successful, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the matched substring, the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Index%2A&gt;</ph> property indicates the zero-based starting position of the matched substring in the input string, and the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Capture.Length%2A&gt;</ph> property indicates the length of matched substring in the input string.</source>
          <target state="translated">Se uma correspondência de padrão for bem-sucedida, o <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> propriedade contém a subcadeia de caracteres correspondida, a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Index%2A&gt;</ph> propriedade indica a posição inicial com base em zero da subcadeia de caracteres correspondente na cadeia de entrada e o <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Capture.Length%2A&gt;</ph> propriedade indica o comprimento da subcadeia de caracteres correspondida na cadeia de caracteres de entrada.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>Because a single match can involve multiple capturing groups, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> has a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> property that returns the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph>.</source>
          <target state="translated">Como uma única correspondência pode envolver vários grupos de capturas, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> tem um <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> propriedade retorna o <ph id="ph3">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> instance itself is equivalent to the first object in the collection, at <ph id="ph2">`Match.Groups[0]`</ph> (<ph id="ph3">`Match.Groups(0)`</ph> in Visual Basic), which represents the entire match.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> própria instância é equivalente ao primeiro objeto na coleção, em <ph id="ph2">`Match.Groups[0]`</ph> (<ph id="ph3">`Match.Groups(0)`</ph> no Visual Basic), que representa o inteiro correspondente.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>You can access the captured groups in a match in the following ways:</source>
          <target state="translated">Você pode acessar de grupos capturados em uma correspondência das seguintes maneiras:</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>You can iterate the members of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> object  by using a <ph id="ph2">`foreach`</ph> (C#) or <ph id="ph3">`For Each`</ph> (Visual Basic) construct.</source>
          <target state="translated">Você pode iterar os membros a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> objeto usando um <ph id="ph2">`foreach`</ph> (c#) ou <ph id="ph3">`For Each`</ph> construção (Visual Basic).</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>You can use the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection.Item%28System.Int32%29?displayProperty=nameWithType&gt;</ph> property to retrieve groups by the number of the capturing group.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection.Item%28System.Int32%29?displayProperty=nameWithType&gt;</ph> propriedade para recuperar grupos pelo número de grupo de captura.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>Note that you can determine which numbered groups are present in a regular expression by calling the instance <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Observe que você pode determinar quais grupos numerados estão presentes em uma expressão regular chamando-se a instância <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>You can use the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection.Item%28System.String%29?displayProperty=nameWithType&gt;</ph> property to retrieve groups by the name of the capturing group.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection.Item%28System.String%29?displayProperty=nameWithType&gt;</ph> propriedade para recuperar grupos com o nome do grupo de captura.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>Note that you can determine which named groups are present in a regular expression by calling the instance <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GetGroupNames?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Observe que você pode determinar quais grupos nomeados estão presentes em uma expressão regular chamando-se a instância <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GetGroupNames?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>The following examples use the regular expression <ph id="ph1">`Console\.Write(Line)?`</ph>.</source>
          <target state="translated">Os exemplos a seguir usam a expressão regular <ph id="ph1">`Console\.Write(Line)?`</ph>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>The regular expression is interpreted as follows:</source>
          <target state="translated">A expressão regular é interpretada da seguinte forma:</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>Console<ph id="ph1">\\</ph>.Write</source>
          <target state="translated">Console<ph id="ph1">\\</ph>. Gravação</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>Match the string "Console.Write".</source>
          <target state="translated">Corresponder à cadeia de caracteres “Console.Write”.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>Note that the "." character is escaped so that it is interpreted as a literal period rather than as a wildcard that matches any character.</source>
          <target state="translated">Observe que o "." caracteres são ignorados para que ele será interpretado como um período de literal em vez de como um caractere curinga que corresponde a qualquer caractere.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>(Line)?</source>
          <target state="translated">(Linha)?</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>Match zero or one occurrence of the string "Line".</source>
          <target state="translated">Corresponde a zero ou uma ocorrência da cadeia de caracteres “Line”.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source><bpt id="p1">**</bpt>Example 1<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Exemplo 1<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method to retrieve all pattern matches in an input string.</source>
          <target state="translated">A exemplo a seguir chama o <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> método para recuperar todas as correspondências de padrão em uma cadeia de caracteres de entrada.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>It then iterates the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objects in the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object to display information about each match.</source>
          <target state="translated">Ele itera o <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objetos retornado <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> objeto para exibir informações sobre cada correspondência.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source><bpt id="p1">**</bpt>Example 2<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Exemplo 2<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> methods to retrieve one match at a time.</source>
          <target state="translated">A exemplo a seguir chama o <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> métodos para recuperar uma correspondência de cada vez.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Match.Empty">
          <source>Gets the empty group.</source>
          <target state="translated">Obtém o grupo vazio.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Match.Empty">
          <source>All failed matches return this empty match.</source>
          <target state="translated">Todas as correspondências com falha retornam essa correspondência vazia.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Empty">
          <source>An empty match.</source>
          <target state="translated">Uma correspondência vazia.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Empty">
          <source>This property should not be used to determine if a match is successful.</source>
          <target state="translated">Essa propriedade não deve ser usada para determinar se uma correspondência for bem-sucedida.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Empty">
          <source>Instead, use the <ph id="ph1">`Match.Success`</ph> property (which is inherited from <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">Em vez disso, use o <ph id="ph1">`Match.Success`</ph> propriedade (que é herdado da <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A?displayProperty=nameWithType&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>Gets a collection of groups matched by the regular expression.</source>
          <target state="translated">Obtém uma coleção de grupos correspondentes à expressão regular.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>The character groups matched by the pattern.</source>
          <target state="translated">Os grupos de caracteres que correspondem ao padrão.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>A regular expression pattern can include subexpressions, which are defined by enclosing a portion of the regular expression pattern in parentheses.</source>
          <target state="translated">Um padrão de expressão regular pode incluir subexpressões, que são definidas, colocando uma parte do padrão de expressão regular entre parênteses.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>Every such subexpression forms a group.</source>
          <target state="translated">Essa subexpressão cada forma um grupo.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> property provides access to information about those subexpression matches.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> propriedade fornece acesso às informações sobre as correspondências de subexpressão.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>For example, the regular expression pattern <ph id="ph1">`(\d{3})-(\d{3}-\d{4})`</ph>, which matches North American telephone numbers, has two subexpressions.</source>
          <target state="translated">Por exemplo, o padrão de expressão regular <ph id="ph1">`(\d{3})-(\d{3}-\d{4})`</ph>, que corresponde a números de telefone na América do Norte, tem duas subexpressões.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>The first consists of the area code, which composes the first three digits of the telephone number.</source>
          <target state="translated">O primeiro consiste o código de área, o que compõe os primeiros três dígitos do número de telefone.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>This group is captured by the first portion of the regular expression, <ph id="ph1">`(\d{3})`</ph>.The second consists of the individual telephone number, which composes the last seven digits of the telephone number.</source>
          <target state="translated">Esse grupo é capturado pela primeira parte da expressão regular, <ph id="ph1">`(\d{3})`</ph>. O segundo consiste o número de telefone individuais, que compõe os última de sete dígitos do número de telefone.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>This group is captured by the second portion of the regular expression, <ph id="ph1">`(\d{3}-\d{4})`</ph>.</source>
          <target state="translated">Esse grupo é capturado pela segunda parte da expressão regular, <ph id="ph1">`(\d{3}-\d{4})`</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>These two groups can then be retrieved from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> object that is returned by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> property, as the following example shows.</source>
          <target state="translated">Esses dois grupos, em seguida, podem ser recuperados do <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> objeto que é retornado pelo <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> propriedade, como mostra o exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> object returned by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType&gt;</ph> property is a zero-based collection object that always has at least one member.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> objeto retornado pelo <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType&gt;</ph> propriedade é um objeto de coleção com base zero que sempre tenha pelo menos um membro.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>If the regular expression engine cannot find any matches in a particular input string, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group.Success%2A?displayProperty=nameWithType&gt;</ph> property of the single <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> object in the collection (the object at index 0) is set to <ph id="ph3">`false`</ph> and the <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> object's <ph id="ph5">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property is set to <ph id="ph6">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se o mecanismo de expressão regular não pode localizar nenhuma correspondência em uma cadeia de caracteres de entrada específica, o <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group.Success%2A?displayProperty=nameWithType&gt;</ph> propriedade do único <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> objeto da coleção (o objeto no índice 0) é definido como <ph id="ph3">`false`</ph> e <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> do objeto <ph id="ph5">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> está definida como <ph id="ph6">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>If the regular expression engine can find a match, the first element of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> object (the element at index 0) returned by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> property contains a string that matches the entire regular expression pattern.</source>
          <target state="translated">Se o mecanismo de expressão regular pode encontrar uma correspondência, o primeiro elemento do <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> objeto (o elemento no índice 0) retornado pelo <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> propriedade contém uma cadeia de caracteres que corresponde ao padrão de toda a expressão regular.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>Each subsequent element, from index one upward, represents a captured group, if the regular expression includes capturing groups.</source>
          <target state="translated">Cada elemento subsequente, do índice, uma para cima, representa um grupo capturado, se a expressão regular inclui grupos de captura.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>For more information, see the "Grouping Constructs and Regular Expression Objects" section of the <bpt id="p1">[</bpt>Grouping Constructs<ept id="p1">](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept> article.</source>
          <target state="translated">Para obter mais informações, consulte a seção "Agrupamento constrói e Regular Expression objetos" a <bpt id="p1">[</bpt>construções de agrupamento<ept id="p1">](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept> artigo.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>The following example attempts to match a regular expression pattern against a sample string.</source>
          <target state="translated">O exemplo a seguir tenta corresponder a um padrão de expressão regular em uma cadeia de caracteres de exemplo.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> property to store information that is retrieved by the match for display to the console.</source>
          <target state="translated">O exemplo usa o <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> propriedade para armazenar as informações recuperadas pelo correspondem para exibição no console.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>Returns a new <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> object with the results for the next match, starting at the position at which the last match ended (at the character after the last matched character).</source>
          <target state="translated">Retorna um novo objeto <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> com os resultados para a próxima correspondência, começando na posição em que a última correspondência terminou (no caractere após o último caractere correspondente).</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The next regular expression match.</source>
          <target state="translated">A próxima expressão regular de correspondência.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>This method is similar to calling <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> again and passing (<ph id="ph2">`Index+Length`</ph>) as the new starting position.</source>
          <target state="translated">Esse método é semelhante a chamar <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> novamente e passando (<ph id="ph2">`Index+Length`</ph>) como a nova posição inicial.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>This method does not modify the current instance.</source>
          <target state="translated">Esse método não modifica a instância atual.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>Instead, it returns a new <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object that contains information about the next match.</source>
          <target state="translated">Em vez disso, ele retorna um novo <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objeto que contém informações sobre a próxima correspondência.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>Attempting to retrieve the next match may throw a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> if a time-out value for matching operations is in effect and the attempt to find the next match exceeds that time-out interval.</source>
          <target state="translated">Tentativa de recuperar a próxima correspondência pode gerar um <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> se um valor de tempo limite para correspondência de operações está em vigor e a tentativa de localizar a próxima correspondência excede esse intervalo de tempo limite.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> method to capture regular expression matches beyond the first match.</source>
          <target state="translated">O exemplo a seguir usa o <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> método para capturar a expressão regular corresponde além da primeira correspondência.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>A time-out occurred.</source>
          <target state="translated">Ocorreu um tempo limite.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>When a match attempt is repeated by calling the <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Match.NextMatch" /&gt;</ph> method, the regular expression engine gives empty matches special treatment.</source>
          <target state="translated">Quando uma tentativa de correspondência é repetida ao chamar o <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Match.NextMatch" /&gt;</ph> método, o mecanismo de expressão regular fornece correspondências vazias tratamento especial.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>Usually, <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Match.NextMatch" /&gt;</ph> begins the search for the next match exactly where the previous match left off.</source>
          <target state="translated">Normalmente, <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Match.NextMatch" /&gt;</ph> inicia a pesquisa para a próxima correspondência exatamente onde a correspondência anterior parou.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>However, after an empty match, the <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Match.NextMatch" /&gt;</ph> method advances by one character before trying the next match.</source>
          <target state="translated">No entanto, após uma correspondência vazia, o <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Match.NextMatch" /&gt;</ph> método avança um caractere antes de tentar a próxima correspondência.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>This behavior guarantees that the regular expression engine will progress through the string.</source>
          <target state="translated">Esse comportamento garante que o mecanismo de expressão regular pode avançar a cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>Otherwise, because an empty match does not result in any forward movement, the next match would start in exactly the same place as the previous match, and it would match the same empty string repeatedly.</source>
          <target state="translated">Caso contrário, como uma correspondência vazia não resulta em nenhum movimento para frente, a próxima correspondência iniciaria exatamente no mesmo local que a correspondência anterior, e ela corresponderia repetidamente com a mesma cadeia de caracteres vazia.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The following example provides an illustration.</source>
          <target state="translated">O exemplo a seguir fornece uma ilustração.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The regular expression pattern <bpt id="p1">&lt;c&gt;</bpt>a*<ept id="p1">&lt;/c&gt;</ept> searches for zero or more occurrences of the letter "a" in the string "abaabb".</source>
          <target state="translated">O padrão de expressão regular <bpt id="p1">&lt;c&gt;</bpt>um *<ept id="p1">&lt;/c&gt;</ept> procura por zero ou mais ocorrências da letra "a" na cadeia de caracteres "abaabb".</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>As the output from the example shows, the search finds six matches.</source>
          <target state="translated">Como mostra a saída do exemplo, a pesquisa localizará seis correspondências.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The first match attempt finds the first "a".</source>
          <target state="translated">A primeira tentativa de correspondência localiza o primeiro "a".</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The second match starts exactly where the first match ends, before the first b; it finds zero occurrences of "a" and returns an empty string.</source>
          <target state="translated">O segunda inicia correspondência exatamente onde a primeira correspondem termina antes do primeiro b; ele localiza zero ocorrências de "a" e retorna uma cadeia de caracteres vazia.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The third match does not begin exactly where the second match ended, because the second match returned an empty string.</source>
          <target state="translated">A terceira correspondência não começa exatamente onde a segunda correspondência finalizou, pois a segunda correspondência retornou uma cadeia de caracteres vazia.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>Instead, it begins one character later, after the first "b".</source>
          <target state="translated">Em vez disso, ele começa um caractere mais tarde, após o primeiro "b".</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The third match finds two occurrences of "a" and returns "aa".</source>
          <target state="translated">A terceira correspondência localiza duas ocorrências de "a" e retorna "aa".</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The fourth match attempt begins where the third match ended, before the second "b", and returns an empty string.</source>
          <target state="translated">A tentativa de correspondência quarta começa onde a terceira correspondência finalizou, antes do segundo "b" e retorna uma cadeia de caracteres vazia.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The fifth match attempt again advances one character so that it begins before the third "b" and returns an empty string.</source>
          <target state="translated">A tentativa de correspondência quinto novamente avança um caractere para que ele começa antes do terceiro "b" e retorna uma cadeia de caracteres vazia.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The sixth match begins after the last "b" and returns an empty string again.</source>
          <target state="translated">A sexta correspondência começa após o último "b" e retorna uma cadeia de caracteres vazia novamente.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>The replacement pattern to use.</source>
          <target state="translated">O padrão de substituição a ser usado.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Returns the expansion of the specified replacement pattern.</source>
          <target state="translated">Retorna a expansão do padrão de substituição especificado.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>The expanded version of the <ph id="ph1">&lt;paramref name="replacement" /&gt;</ph> parameter.</source>
          <target state="translated">A versão expandida do parâmetro <ph id="ph1">&lt;paramref name="replacement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Whereas the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType&gt;</ph> method replaces all matches in an input string with a specified replacement pattern, the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Result%2A&gt;</ph> method replaces a single match with a specified replacement pattern.</source>
          <target state="translated">Enquanto o <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType&gt;</ph> método substitui todas as correspondências em uma cadeia de caracteres de entrada com um padrão de substituição especificada, o <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Result%2A&gt;</ph> método substitui um única correspondência com um padrão de substituição especificado.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Because it operates on an individual match, it is also possible to perform processing on the matched string before you call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Result%2A&gt;</ph> method.</source>
          <target state="translated">Porque ela opera em uma correspondência individual, também é possível executar o processamento na cadeia de caracteres correspondente antes de chamar o <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Result%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>The <ph id="ph1">`replacement`</ph> parameter is a standard regular expression replacement pattern.</source>
          <target state="translated">O <ph id="ph1">`replacement`</ph> parâmetro é um padrão de substituição padrão de expressão regular.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>It can consist of literal characters and regular expression substitutions.</source>
          <target state="translated">Ele pode consistir de caracteres literais e substituições de expressão regular.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>For more information, see <bpt id="p1">[</bpt>Substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Para saber mais, confira <bpt id="p1">[</bpt>Substituições<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>The following example replaces the hyphens that begin and end a parenthetical expression with parentheses.</source>
          <target state="translated">O exemplo a seguir substitui os hifens que começam e terminam uma expressão entre parênteses com parênteses.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>The regular expression pattern <ph id="ph1">`--(.+?)--`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">O padrão da expressão regular <ph id="ph1">`--(.+?)--`</ph> é interpretado conforme mostrado na tabela a seguir.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Pattern</source>
          <target state="translated">Padrão</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Match two hyphens.</source>
          <target state="translated">Corresponde a dois hifens.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Match any character one or more times, but as few times as possible.</source>
          <target state="translated">Corresponde qualquer caractere uma ou mais vezes, mas como algumas vezes possível.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>This is the first capturing group.</source>
          <target state="translated">Este é o primeiro grupo de captura.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Match two hyphens.</source>
          <target state="translated">Corresponde a dois hifens.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Note that the regular expression pattern <ph id="ph1">`--(.+?)--`</ph> uses the lazy quantifier <ph id="ph2">`+?`</ph>.</source>
          <target state="translated">Observe que o padrão de expressão regular <ph id="ph1">`--(.+?)--`</ph> usa o quantificador lazy <ph id="ph2">`+?`</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>If the greedy quantifier <ph id="ph1">`+`</ph> were used instead, the regular expression engine would find only a single match in the input string.</source>
          <target state="translated">Se o quantificador greedy <ph id="ph1">`+`</ph> foram usadas em vez disso, o mecanismo de expressão regular encontraria somente uma única correspondência na cadeia de caracteres de entrada.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>The replacement string <ph id="ph1">`($1)`</ph> replaces the match with the first captured group, which is enclosed in parentheses.</source>
          <target state="translated">A cadeia de caracteres de substituição <ph id="ph1">`($1)`</ph> substitui a correspondência com o primeiro grupo capturado, que é colocado entre parênteses.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source><ph id="ph1">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="replacement" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Expansion is not allowed for this pattern.</source>
          <target state="translated">A expansão não é permitida para este padrão.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.Synchronized(System.Text.RegularExpressions.Match)">
          <source>A regular expression match equivalent to the one expected.</source>
          <target state="translated">Uma expressão regular corresponde ao equivalente da esperada.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.Synchronized(System.Text.RegularExpressions.Match)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> instance equivalent to the one supplied that is suitable to share between multiple threads.</source>
          <target state="translated">Retorna um instância <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> equivalente a uma fornecida que é adequada para compartilhar entre vários threads.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.Synchronized(System.Text.RegularExpressions.Match)">
          <source>A regular expression match that is suitable to share between multiple threads.</source>
          <target state="translated">Uma correspondência da expressão regular que é adequada para compartilhar entre vários threads.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.Synchronized(System.Text.RegularExpressions.Match)">
          <source><ph id="ph1">&lt;paramref name="inner" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="inner" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>