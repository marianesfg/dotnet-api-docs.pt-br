<Type Name="OracleLob" FullName="System.Data.OracleClient.OracleLob">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f752621e9496b0bd55f13fe4c3cb60aecdfbea99" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30391030" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class OracleLob : System.IO.Stream, ICloneable, System.Data.SqlTypes.INullable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit OracleLob extends System.IO.Stream implements class System.Data.SqlTypes.INullable, class System.ICloneable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.OracleClient.OracleLob" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class OracleLob&#xA;Inherits Stream&#xA;Implements ICloneable, INullable" />
  <TypeSignature Language="C++ CLI" Value="public ref class OracleLob sealed : System::IO::Stream, ICloneable, System::Data::SqlTypes::INullable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.OracleClient</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Data.SqlTypes.INullable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa um tipo de dados (<see langword="LOB" />) binário de objeto grande armazenado em um servidor Oracle. Essa classe não pode ser herdada.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Data.OracleClient.OracleLob> difere de um <xref:System.Data.OracleClient.OracleBFile> em que os dados são armazenados no servidor, em vez de em um arquivo físico no sistema operacional. Ele também pode ser um objeto de leitura / gravação, ao contrário de um <xref:System.Data.OracleClient.OracleBFile>, que é sempre somente leitura.  
  
 Um <xref:System.Data.OracleClient.OracleLob> pode ser um destes <xref:System.Data.OracleClient.OracleType> tipos de dados.  
  
|Tipo de dados de OracleType|Descrição|  
|--------------------------|-----------------|  
|`Blob`|Um Oracle `BLOB` tipo de dados que contém dados binários com um tamanho máximo de 4 gigabytes (GB). Isso é mapeado para um <xref:System.Array> do tipo <xref:System.Byte>.|  
|`Clob`|Um Oracle `CLOB` tipo de dados que contém dados de caracteres, com base no caractere padrão definido no servidor, com um tamanho máximo de 4 GB. Isso é mapeado para <xref:System.String>.|  
|`NClob`|Um Oracle `NCLOB` tipo de dados que contém dados de caracteres, com base em conjunto no servidor com um tamanho máximo de 4 GB de caracteres nacional. Isso é mapeado para <xref:System.String>.|  
  
 Um desenvolvedor de aplicativos .NET pode recuperar o Oracle `LOB` valores em tipos de dados .NET básicos, como <xref:System.Array> do tipo <xref:System.Byte> e <xref:System.String>, ou o especializado <xref:System.Data.OracleClient.OracleLob> tipo de dados. O <xref:System.Data.OracleClient.OracleLob> classe oferece suporte a dados de leitura e gravação para o Oracle `LOB` no banco de dados Oracle.  
  
 A seguir estão as principais características de um <xref:System.Data.OracleClient.OracleLob> tipo de dados que distingui-lo de tipos de dados básicos do .NET:  
  
-   Depois de recuperar o Oracle `LOB` valor do banco de dados Oracle para o <xref:System.Data.OracleClient.OracleLob> classe, você pode alterar o `LOB` dados em uma transação aberta e as alterações são refletidos diretamente no banco de dados. Se você recuperar o Oracle `LOB` valor em uma <xref:System.Array> do tipo <xref:System.Byte> ou <xref:System.String> e atualizar essas matrizes, suas alterações não serão refletidas no banco de dados.  
  
-   Quando você usa o <xref:System.Data.OracleClient.OracleLob> classe para acessar uma parte de uma `LOB` valor, somente o fragmento é passado do banco de dados Oracle para o cliente. Quando você usa o <xref:System.Data.OracleClient.OracleDataReader.GetChars%2A> método para acessar uma parte de uma `LOB` valor, todo o conteúdo do valor é passado do banco de dados Oracle para o cliente.  
  
 Para obter um <xref:System.Data.OracleClient.OracleLob> de objeto, chame o <xref:System.Data.OracleClient.OracleDataReader.GetOracleLob%2A> método.  
  
 Você pode construir um <xref:System.Data.OracleClient.OracleLob> que é NULL usando este formato:  
  
```  
OracleLob myLob = OracleLob.Null;  
```  
  
 Essa técnica é usada principalmente para testar se um `LOB` retornado do servidor for NULL, como mostra este exemplo:  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 Um valor nulo `LOB` se comporta da mesma forma para zero bytes `LOB` que <xref:System.Data.OracleClient.OracleLob.Read%2A> terá êxito e sempre retorna zero bytes.  
  
 Selecionando um `LOB` coluna que contém um valor nulo retornará <xref:System.Data.OracleClient.OracleLob.Null>.  
  
 Você deve iniciar uma transação antes de obter um temporário `LOB`. Caso contrário, o <xref:System.Data.OracleClient.OracleDataReader> pode falhar ao obter dados mais tarde.  
  
 Você também pode abrir um temporário `LOB` no Oracle chamando o DBMS_LOB. Sistema CREATETEMPORARY procedimento armazenado e associação de um `LOB` parâmetro de saída. No lado do cliente, um temporário `LOB` se comporta como uma tabela com base em `LOB`. Por exemplo, para atualizar temporárias `LOB`, ele deve ser incluído em uma transação.  
  
 O exemplo c# a seguir demonstra como abrir um temporário `LOB`.  
  
```  
OracleConnection connection = new OracleConnection("server=MyServer; integrated security=yes;");  
connection.Open();  
OracleTransaction transaction = connection.BeginTransaction();  
OracleCommand command = connection.CreateCommand();  
command.Transaction = transaction;  
command.CommandText = "declare xx blob; begin dbms_lob.createtemporary(xx, false, 0); :tempblob := xx; end;";  
command.Parameters.Add(new OracleParameter("tempblob", OracleType.Blob)).Direction = ParameterDirection.Output;  
command.ExecuteNonQuery();  
OracleLob tempLob = (OracleLob)command.Parameters[0].Value;  
byte[] tempbuff = new byte[10000];  
tempLob.BeginBatch(OracleLobOpenMode.ReadWrite);  
tempLob.Write(tempbuff,0,tempbuff.Length);  
tempLob.EndBatch();  
command.Parameters.Clear();  
command.CommandText = "MyTable.MyProc";  
command.CommandType = CommandType.StoredProcedure;    
command.Parameters.Add(new OracleParameter("ImportDoc", OracleType.Blob)).Value = tempLob;  
command.ExecuteNonQuery();  
transaction.Commit();  
connection.Close  
```  
  
> [!NOTE]
>  O herdadas <xref:System.IO.Stream.WriteByte%2A> método falhará se usado com dados de caracteres e um <xref:System.InvalidOperationException> é gerada. Use o método <xref:System.Data.OracleClient.OracleLob.Write%2A> em seu lugar.  
>   
>  Temporário `LOB`estão apenas fechados quando a conexão é fechada, mas com o pool e sob carga, temporária `LOB`s não fechar. Isso pode ser resolvido removendo temporárias `LOB`, invocando `tempLob.Dispose()`.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Data.OracleClient.OracleLob source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Data.OracleClient.OracleLob source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Append(System.Data.OracleClient.OracleLob)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (source As OracleLob)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Data::OracleClient::OracleLob ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.OracleClient.OracleLob" />
      </Parameters>
      <Docs>
        <param name="source">O <see langword="LOB" /> do qual os dados serão acrescentados.</param>
        <summary>Acrescenta dados do <see langword="LOB" /> especificado no <see langword="LOB" /> atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para gravar o `LOB`, você deve recuperar o `LOB` usando a cláusula FOR UPDATE na instrução SQL SELECT e você deve ter uma transação local iniciada.  
  
 Todos os dados da fonte de `LOB` é acrescentado ao final da atual `LOB`. A posição de nenhuma `LOB` for avaliada ou alterada durante esse processo.  
  
 Os tipos de dados subjacente devem ser sempre a mesma. Por exemplo, se você está anexando de um <xref:System.Data.OracleClient.OracleType.NClob>, o destino <xref:System.Data.OracleClient.OracleLob> também deve ser um <xref:System.Data.OracleClient.OracleType.NClob>.  
  
> [!NOTE]
>  Nesta versão, uma operação de gravação para somente leitura `LOB` pode ter êxito, mas não atualiza o `LOB` no servidor. Nesse caso, no entanto, a cópia local do `LOB` é atualizado. Portanto, mais tarde operações de leitura no <xref:System.Data.OracleClient.OracleLob> objeto pode retornar os resultados da operação de gravação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A origem <see cref="T:System.Data.OracleClient.OracleLob" /> é nula.</exception>
        <exception cref="T:System.InvalidOperationException">A origem <see cref="T:System.Data.OracleClient.OracleLob" /> é nula ou a conexão está fechada.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto da origem <see cref="T:System.Data.OracleClient.OracleLob" /> foi fechado ou descartado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Ocorreu um erro do Oracle.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginBatch">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Impede que gatilhos do lado do servidor disparem ao executar várias operações de gravação.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginBatch">
      <MemberSignature Language="C#" Value="public void BeginBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.BeginBatch" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginBatch ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginBatch();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Impede que gatilhos do lado do servidor disparem ao executar várias operações de leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abre o `LOB` na <xref:System.Data.OracleClient.OracleLobOpenMode.ReadOnly> modo; portanto, o `LOB` só podem ser lidos, não gravada, até a chamada correspondente para <xref:System.Data.OracleClient.OracleLob.EndBatch%2A>. Para realizar gravações em lotes para o `LOB`, chame <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> com <xref:System.Data.OracleClient.OracleLobOpenMode.ReadWrite>.  
  
 Chamando <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> mais de uma vez na mesma transação atualmente lança Oracle "ORA-22293: LOB já aberto na mesma transação" erro. Além disso, se você obtiver o `LOB` usando outro <xref:System.Data.OracleClient.OracleDataReader>, e o chamador original não chamou o <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> método, o mesmo erro é gerado. Portanto, você deve chamar o <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> método quando tiver terminado de usar o <xref:System.Data.OracleClient.OracleLob>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A conexão está fechada.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto foi fechado ou descartado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Ocorreu um erro do Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginBatch">
      <MemberSignature Language="C#" Value="public void BeginBatch (System.Data.OracleClient.OracleLobOpenMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginBatch(valuetype System.Data.OracleClient.OracleLobOpenMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.BeginBatch(System.Data.OracleClient.OracleLobOpenMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginBatch (mode As OracleLobOpenMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginBatch(System::Data::OracleClient::OracleLobOpenMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.OracleClient.OracleLobOpenMode" />
      </Parameters>
      <Docs>
        <param name="mode">Modo (um dos valores <see cref="T:System.Data.OracleClient.OracleLobOpenMode" />) em que o <see langword="LOB" /> pode ser acessado entre essa chamada <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch(System.Data.OracleClient.OracleLobOpenMode)" /> e a chamada <see cref="M:System.Data.OracleClient.OracleLob.EndBatch" /> correspondente.</param>
        <summary>Impede que gatilhos do lado do servidor disparem ao executar várias operações de leitura e gravação no modo de acesso especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para gravar o `LOB`, você deve recuperar o `LOB` usando a cláusula FOR UPDATE na instrução SQL SELECT e você deve ter uma transação local iniciada.  
  
 Chamando <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> mais de uma vez na mesma transação atualmente lança Oracle "ORA-22293: LOB já aberto na mesma transação" erro. Além disso, se você obtiver o `LOB` usando outro <xref:System.Data.OracleClient.OracleDataReader>, e o chamador original não chamou o <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> método, o mesmo erro é gerado. Portanto, você deve chamar o <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> método quando tiver terminado de usar o <xref:System.Data.OracleClient.OracleLob>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A conexão está fechada.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto foi fechado ou descartado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Ocorreu um erro do Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o fluxo <see langword="LOB" /> pode ser lido.</summary>
        <value>
          <see langword="true" /> Se o <see langword="LOB" /> fluxo suporte leitura, caso contrário, <see langword="false" /> se um <see langword="LOB" /> foi fechado ou descartado.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se as operações de busca progressiva ou regressiva podem ser executadas.</summary>
        <value>
          <see langword="false" /> Se um <see langword="LOB" /> foi fechado ou descartado, caso contrário, <see langword="true" />. Sempre <see langword="true" /> para <see cref="F:System.Data.OracleClient.OracleLob.Null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sempre retorna true, independentemente se o <see langword="LOB" /> oferece suporte à criação ou não.</summary>
        <value>Sempre retorna <see langword="true" />, independentemente de um aberto ou não descartado <see langword="LOB" /> oferece suporte à criação ou não, <see langword="false" /> se um <see langword="LOB" /> foi fechado ou descartado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para gravar o `LOB`, você deve recuperar o `LOB` usando a cláusula FOR UPDATE na instrução SQL SELECT e você deve ter iniciado uma transação local.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChunkSize">
      <MemberSignature Language="C#" Value="public int ChunkSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ChunkSize" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.ChunkSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChunkSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ChunkSize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica o número mínimo de bytes a serem recuperados ou enviados ao servidor durante uma operação de leitura/gravação.</summary>
        <value>O número mínimo de bytes para recuperar ou enviar.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado pelo <xref:System.Data.OracleClient.OracleLob.ChunkSize%2A> propriedade não é uma configuração do .NET Framework Data Provider for Oracle. Em vez disso, ele é o valor que o Oracle Call Interface (OCI) usa ao se comunicar com o servidor. Use <xref:System.Data.OracleClient.OracleLob.ChunkSize%2A> para garantir que partes do lado do cliente são do mesmo tamanho. Ler ou gravar em partes menores não armazena em cache dados e faz com que um processamento otimizado menor para o servidor, como um pacote completo não é recebido ou enviado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A conexão está fechada.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto foi fechado ou descartado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Ocorreu um erro do Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um novo objeto <see cref="T:System.Data.OracleClient.OracleLob" /> que faz referência ao mesmo Oracle <see langword="LOB" /> que o objeto <see cref="T:System.Data.OracleClient.OracleLob" /> original.</summary>
        <returns>Um novo objeto <see cref="T:System.Data.OracleClient.OracleLob" /> que faz referência ao mesmo Oracle <see langword="LOB" /> que o objeto <see cref="T:System.Data.OracleClient.OracleLob" /> original.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As propriedades do novo <xref:System.Data.OracleClient.OracleLob> objeto inicialmente ter os mesmos valores do objeto original. No entanto, após o <xref:System.Data.OracleClient.OracleLob.Clone%2A> estiver concluído, cada <xref:System.Data.OracleClient.OracleLob> objeto é independente dos outros. Por exemplo, alterar o valor da <xref:System.Data.OracleClient.OracleLob.Position%2A> propriedade original <xref:System.Data.OracleClient.OracleLob> não altera o valor de <xref:System.Data.OracleClient.OracleLob.Position%2A> na cópia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A conexão está fechada.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto foi fechado ou descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.OracleClient.OracleConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.OracleClient.OracleConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As OracleConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::OracleClient::OracleConnection ^ Connection { System::Data::OracleClient::OracleConnection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Data.OracleClient.OracleConnection" /> usado por essa instância do <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <value>A conexão com uma fonte de dados.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">O objeto foi fechado ou descartado.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia deste <see cref="T:System.Data.OracleClient.OracleLob" /> para um destino <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (System.Data.OracleClient.OracleLob destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(class System.Data.OracleClient.OracleLob destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destination As OracleLob) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(System::Data::OracleClient::OracleLob ^ destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
      </Parameters>
      <Docs>
        <param name="destination">O <see cref="T:System.Data.OracleClient.OracleLob" /> de destino.</param>
        <summary>Copia deste <see cref="T:System.Data.OracleClient.OracleLob" /> para um destino <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>O número de bytes copiados. Isso exclui todos os bytes preenchidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os tipos de dados subjacente devem ser sempre a mesma. Por exemplo, se você estiver copiando de um <xref:System.Data.OracleClient.OracleType.NClob>, o destino <xref:System.Data.OracleClient.OracleLob> também deve ser um <xref:System.Data.OracleClient.OracleType.NClob>.  
  
 Se o deslocamento de destino está além do fim do destino `LOB`, o `LOB` é estendido para o qual os dados estão sendo copiados. O espaço entre o fim do `LOB` e o deslocamento de destino após o final será preenchido com zeros para `BLOB` tipos de dados e espaços para `CLOB` e `NCLOB` tipos de dados.  
  
 Para gravar o `LOB`, você deve recuperar o `LOB` usando a cláusula FOR UPDATE na instrução SQL SELECT e você deve ter uma transação local iniciada.  
  
> [!NOTE]
>  Nesta versão, uma operação de gravação para somente leitura `LOB` pode ter êxito, mas não atualizar o `LOB` no servidor. Nesse caso, no entanto, a cópia local do `LOB` será atualizado. Portanto, mais tarde operações de leitura no <xref:System.Data.OracleClient.OracleLob> objeto pode retornar os resultados da operação de gravação.  
>   
>  O `CopyTo` método não limpa o conteúdo do destino `OracleLob` antes de executar a operação de cópia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O <see cref="T:System.Data.OracleClient.OracleLob" /> especificado no parâmetro <paramref name="destination" /> é nulo.</exception>
        <exception cref="T:System.InvalidOperationException">A operação não está em uma transação, o objeto <see cref="T:System.Data.OracleClient.OracleLob" /> é nulo ou a conexão é fechada.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Ocorreu um erro do Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (System.Data.OracleClient.OracleLob destination, long destinationOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(class System.Data.OracleClient.OracleLob destination, int64 destinationOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destination As OracleLob, destinationOffset As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(System::Data::OracleClient::OracleLob ^ destination, long destinationOffset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
        <Parameter Name="destinationOffset" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="destination">O destino <see cref="T:System.Data.OracleClient.OracleLob" /></param>
        <param name="destinationOffset">O deslocamento para o qual copiar. Para os tipos de dados <see langword="CLOB" /> e <see langword="NCLOB" />, isso deve ser um número par de bytes.</param>
        <summary>Copia deste <see cref="T:System.Data.OracleClient.OracleLob" /> para um destino <see cref="T:System.Data.OracleClient.OracleLob" /> com a quantidade de dados especificada.</summary>
        <returns>O número de bytes copiados. Isso exclui todos os bytes preenchidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os tipos de dados subjacente devem ser sempre a mesma. Por exemplo, se você estiver copiando de um <xref:System.Data.OracleClient.OracleType.NClob>, o destino <xref:System.Data.OracleClient.OracleLob> também deve ser um <xref:System.Data.OracleClient.OracleType.NClob>.  
  
 Se o deslocamento de destino está além do fim do destino `LOB`, o `LOB` é estendido para o qual os dados estão sendo copiados. O espaço entre o fim do `LOB` e deslocamento além do fim de destino é preenchido com zeros para `BLOB` tipos de dados e espaços para `CLOB` e `NCLOB` tipos de dados.  
  
 Para gravar o `LOB`, você deve recuperar o `LOB` usando a cláusula FOR UPDATE na instrução SQL SELECT e você deve ter uma transação local iniciada.  
  
> [!NOTE]
>  Nesta versão, uma operação de gravação para somente leitura `LOB` pode ter êxito, mas não atualiza o `LOB` no servidor. Nesse caso, no entanto, a cópia local do `LOB` é atualizado. Portanto, mais tarde operações de leitura no <xref:System.Data.OracleClient.OracleLob> objeto pode retornar os resultados da operação de gravação.  
>   
>  O `CopyTo` método não limpa o conteúdo do destino `OracleLob` antes de executar a operação de cópia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O <see cref="T:System.Data.OracleClient.OracleLob" /> especificado no parâmetro <paramref name="destination" /> é está cheio.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Um valor especificado no parâmetro <paramref name="destinationOffset" /> é menor que zero ou maior que 4 gigabytes.  
  
 - ou -  
  
 Um valor especificado no parâmetro <paramref name="destinationOffset" /> para um tipo de dados <see langword="CLOB" /> ou <see langword="NCLOB" /> não é par.  
  
 - ou -  
  
 Você deve especificar os tipos de dados <see langword="CLOB" /> e <see langword="NCLOB" /> como um número par de bytes.</exception>
        <exception cref="T:System.InvalidOperationException">A operação não está em uma transação, o objeto <see cref="T:System.Data.OracleClient.OracleLob" /> é nulo ou a conexão é fechada.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Ocorreu um erro do Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (long sourceOffset, System.Data.OracleClient.OracleLob destination, long destinationOffset, long amount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(int64 sourceOffset, class System.Data.OracleClient.OracleLob destination, int64 destinationOffset, int64 amount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Int64,System.Data.OracleClient.OracleLob,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (sourceOffset As Long, destination As OracleLob, destinationOffset As Long, amount As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(long sourceOffset, System::Data::OracleClient::OracleLob ^ destination, long destinationOffset, long amount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceOffset" Type="System.Int64" />
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
        <Parameter Name="destinationOffset" Type="System.Int64" />
        <Parameter Name="amount" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceOffset">O deslocamento do qual copiar. Para os tipos de dados <see langword="CLOB" /> e <see langword="NCLOB" />, isso deve ser um número par.</param>
        <param name="destination">O <see langword="OracleLob" /><see cref="N:System.Data.OracleClient" /> de destino.</param>
        <param name="destinationOffset">O deslocamento de destino a ser copiado. Para os tipos de dados <see langword="CLOB" /> e <see langword="NCLOB" />, isso deve ser um número par.</param>
        <param name="amount">A quantidade de dados, em bytes, a serem copiados. Para os tipos de dados <see langword="CLOB" /> e <see langword="NCLOB" />, isso deve ser um número par.</param>
        <summary>Copia deste <see cref="T:System.Data.OracleClient.OracleLob" /> para um destino <see cref="T:System.Data.OracleClient.OracleLob" /> com a quantidade especificada de dados e o deslocamento de origem.</summary>
        <returns>O número de bytes copiados. Isso exclui todos os bytes preenchidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os tipos de dados subjacente devem ser sempre a mesma. Por exemplo, se você estiver copiando de um <xref:System.Data.OracleClient.OracleType.NClob>, o destino <xref:System.Data.OracleClient.OracleLob> também deve ser um <xref:System.Data.OracleClient.OracleType.NClob>.  
  
 Se o deslocamento de destino está além do fim do destino `LOB`, o `LOB` é estendido para o qual os dados estão sendo copiados. O espaço entre o fim do `LOB` e deslocamento além do fim de destino é preenchido com zeros para `BLOB` tipos de dados e espaços para `CLOB` e `NCLOB` tipos de dados.  
  
 Para gravar o `LOB`, você deve recuperar o `LOB` usando a cláusula FOR UPDATE na instrução SQL SELECT e você deve ter uma transação local iniciada.  
  
> [!NOTE]
>  Nesta versão, uma operação de gravação para somente leitura `LOB` pode ter êxito, mas não atualiza o `LOB` no servidor. Nesse caso, no entanto, a cópia local do `LOB` é atualizado. Portanto, mais tarde operações de leitura no <xref:System.Data.OracleClient.OracleLob> objeto pode retornar os resultados da operação de gravação.  
>   
>  O `CopyTo` método não limpa o conteúdo do destino `OracleLob` antes de executar a operação de cópia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O <see cref="T:System.Data.OracleClient.OracleLob" /> especificado no parâmetro <paramref name="destination" /> é está cheio.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Um valor especificado no parâmetro <paramref name="amount" />, <paramref name="sourceOffset" /> ou <paramref name="destinationOffset" /> é menor que zero ou maior que 4 gigabytes.  
  
 - ou -  
  
 Um valor especificado no parâmetro <paramref name="amount" />, <paramref name="sourceOffset" /> ou <paramref name="destinationOffset" /> para um tipo de dados <see langword="CLOB" /> ou <see langword="NCLOB" /> não é par.</exception>
        <exception cref="T:System.InvalidOperationException">A operação não está em uma transação, o objeto <see cref="T:System.Data.OracleClient.OracleLob" /> é nulo ou a conexão é fechada.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Ocorreu um erro do Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndBatch">
      <MemberSignature Language="C#" Value="public void EndBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.EndBatch" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndBatch ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndBatch();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permite que gatilhos do lado do servidor continuem a disparar depois de executar várias operações de gravação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar o <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> método antes de começar a executar operações de gravação no <xref:System.Data.OracleClient.OracleLob>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A conexão está fechada.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto foi fechado ou descartado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Ocorreu um erro do Oracle.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Erase">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Apaga dados deste <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Erase">
      <MemberSignature Language="C#" Value="public long Erase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Erase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Erase" />
      <MemberSignature Language="VB.NET" Value="Public Function Erase () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Erase();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Apaga todos os dados deste <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>O número de bytes apagados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.OracleClient.OracleLob.Erase%2A> não truncar os dados. O `LOB` comprimento permanece o mesmo para um `BLOB` tipo de dados, e os dados apagados são substituídos por 0x00. `CLOB` e `NCLOB` tipos de dados são substituídos por espaços.  
  
 Para gravar o `LOB`, você deve recuperar o `LOB` usando a cláusula FOR UPDATE na instrução SQL SELECT e você deve ter uma transação local iniciada.  
  
> [!NOTE]
>  Nesta versão, uma operação de gravação para somente leitura `LOB` pode ter êxito, mas não atualiza o `LOB` no servidor. Nesse caso, no entanto, a cópia local do `LOB` é atualizado. Portanto, mais tarde operações de leitura no <xref:System.Data.OracleClient.OracleLob> objeto pode retornar os resultados da operação de gravação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A operação não está em uma transação, o objeto <see cref="T:System.Data.OracleClient.OracleLob" /> é nulo ou a conexão é fechada.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto foi fechado ou descartado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Ocorreu um erro do Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Erase">
      <MemberSignature Language="C#" Value="public long Erase (long offset, long amount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Erase(int64 offset, int64 amount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Erase(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Erase (offset As Long, amount As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Erase(long offset, long amount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="amount" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="offset">O deslocamento do qual apagar. Para os tipos de dados <see langword="CLOB" /> e <see langword="NCLOB" />, isso deve ser um número par.</param>
        <param name="amount">A quantidade de dados, em bytes, a serem apagados. Para os tipos de dados <see langword="CLOB" /> e <see langword="NCLOB" />, isso deve ser um número par.</param>
        <summary>Apaga a quantidade especificada de dados neste <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>O número de bytes apagados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A soma dos valores de `offset` e `amount` parâmetros podem ser maiores do que o tamanho do <xref:System.Data.OracleClient.OracleLob>. Portanto, especificando um valor maior do que o retornado pelo <xref:System.Data.OracleClient.OracleLob.Length%2A> propriedade for bem-sucedida; no entanto <xref:System.Data.OracleClient.OracleLob.Erase%2A> apaga apenas ao final do <xref:System.Data.OracleClient.OracleLob>. (Da mesma forma, se um valor negativo for passado para `offset`, <xref:System.Data.OracleClient.OracleLob.Erase%2A> seja bem-sucedida, mas apenas apagar a partir do início do <xref:System.Data.OracleClient.OracleLob>.) Esse comportamento é diferente de <xref:System.Data.OracleClient.OracleLob.Read%2A> e <xref:System.Data.OracleClient.OracleLob.Write%2A> métodos e oferece a vantagem de poder apagar todos os dados do valor especificada pelo `offset` sem fazer uma ida e volta adicional para o servidor para verificar o tamanho real.  
  
 <xref:System.Data.OracleClient.OracleLob.Erase%2A> não truncar os dados. O `LOB` comprimento permanece o mesmo para um `BLOB` tipo de dados, e os dados apagados são substituídos por 0x00. `CLOB` e `NCLOB` tipos de dados são substituídos por espaços.  
  
 Para gravar o `LOB`, você deve recuperar o `LOB` usando a cláusula FOR UPDATE na instrução SQL SELECT e você deve ter uma transação local iniciada.  
  
> [!NOTE]
>  Nesta versão, uma operação de gravação para somente leitura `LOB` pode ter êxito, mas não atualiza o `LOB` no servidor. Nesse caso, no entanto, a cópia local do `LOB` é atualizado. Portanto, mais tarde operações de leitura no <xref:System.Data.OracleClient.OracleLob> objeto pode retornar os resultados da operação de gravação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A operação não está em uma transação, o objeto <see cref="T:System.Data.OracleClient.OracleLob" /> é nulo ou a conexão é fechada.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto foi fechado ou descartado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Ocorreu um erro do Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Não há suporte no momento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nesta versão, este método não está funcionando.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBatched">
      <MemberSignature Language="C#" Value="public bool IsBatched { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBatched" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsBatched" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBatched As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBatched { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se um aplicativo chamou o método <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch" />.</summary>
        <value>
          <see langword="true" /> Se o aplicativo chamado de <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch" /> método, caso contrário <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ao usar um servidor Oracle 8.0.5, um Oracle "ORA-00600: código de erro interno" exceção será lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OracleClient.OracleException">Ocorreu um erro do Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNull">
      <MemberSignature Language="C#" Value="public bool IsNull { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNull" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsNull" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNull As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNull { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.SqlTypes.INullable.IsNull</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Data.OracleClient.OracleLob" /> é um fluxo <see cref="F:System.Data.OracleClient.OracleBFile.Null" />.</summary>
        <value>
          <see langword="true" /> Se o <see cref="T:System.Data.OracleClient.OracleLob" /> é um <see cref="F:System.Data.OracleClient.OracleBFile.Null" /> fluxo, caso contrário <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTemporary">
      <MemberSignature Language="C#" Value="public bool IsTemporary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTemporary" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsTemporary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsTemporary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTemporary { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Data.OracleClient.OracleLob" /> é um <see langword="LOB" /> temporário.</summary>
        <value>
          <see langword="true" /> Se o <see cref="T:System.Data.OracleClient.OracleLob" /> é um temporário <see langword="LOB" />, caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O exemplo a seguir demonstra como criar um temporário `LOB`.  
  
```  
OracleConnection connection = new OracleConnection("server=MyServer; integrated security=yes;");  
connection.Open();  
OracleTransaction transaction = connection.BeginTransaction();  
OracleCommand command = connection.CreateCommand();  
command.Transaction = transaction;  
command.CommandText = "declare xx blob; begin dbms_lob.createtemporary(xx, false, 0); :tempblob := xx; end;";  
command.Parameters.Add(new OracleParameter("tempblob", OracleType.Blob)).Direction = ParameterDirection.Output;  
command.ExecuteNonQuery();  
OracleLob tempLob = (OracleLob)command.Parameters[0].Value;  
tempLob.BeginBatch(OracleLobOpenMode.ReadWrite);  
tempLob.Write(tempbuff,0,tempbuff.Length);  
tempLob.EndBatch();  
command.Parameters.Clear();  
command.CommandText = "MyTable.MyProc";  
command.CommandType = CommandType.StoredProcedure;    
command.Parameters.Add(new OracleParameter("ImportDoc", OracleType.Blob)).Value = tempLob;  
command.ExecuteNonQuery();  
transaction.Commit();  
connection.Close  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A conexão está fechada.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto foi fechado ou descartado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Ocorreu um erro do Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que retorna o tamanho do <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <value>O tamanho do <see cref="T:System.Data.OracleClient.OracleLob" /> em bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tamanho do <xref:System.Data.OracleClient.OracleLob> sempre é retornado em bytes para todos os tipos de dados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A conexão está fechada.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto foi fechado ou descartado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Ocorreu um erro do Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="LobType">
      <MemberSignature Language="C#" Value="public System.Data.OracleClient.OracleType LobType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.OracleClient.OracleType LobType" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.LobType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LobType As OracleType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::OracleClient::OracleType LobType { System::Data::OracleClient::OracleType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que retorna o tipo de dados do <see langword="LOB" />.</summary>
        <value>Uma da <see cref="T:System.Data.OracleClient.OracleType" /><see langword="LOB" /> tipos de dados.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Data.OracleClient.OracleLob> pode ser um dos seguintes <xref:System.Data.OracleClient.OracleType> tipos de dados.  
  
|Tipo de dados de OracleType|Descrição|  
|--------------------------|-----------------|  
|`Blob`|Um tipo de dados `BLOB` do Oracle que contém dados binários com um tamanho máximo de 4 gigabytes. Isso é mapeado para um <xref:System.Array> do tipo <xref:System.Byte>.|  
|`Clob`|Um tipo de dados `CLOB` do Oracle que contém dados de caractere, baseados no conjunto de caracteres padrão do servidor, com um tamanho máximo de 4 gigabytes. Isso é mapeado para <xref:System.String>.|  
|`NClob`|Um Oracle `NCLOB` tipo de dados que contém dados de caracteres, com base em conjunto no servidor com um tamanho máximo de 4 gigabytes de caracteres nacional. Isso é mapeado para <xref:System.String>.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.Data.OracleClient.OracleLob Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Data.OracleClient.OracleLob Null" />
      <MemberSignature Language="DocId" Value="F:System.Data.OracleClient.OracleLob.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As OracleLob " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Data::OracleClient::OracleLob ^ Null;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleLob</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa um objeto <see cref="T:System.Data.OracleClient.OracleLob" /> nulo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode construir um <xref:System.Data.OracleClient.OracleLob> que é NULL usando este formato:  
  
```  
OracleLob myLob = OracleLOB.Null;  
```  
  
 Essa técnica é usada principalmente para testar se um `LOB` retornado do servidor for NULL, como mostra este exemplo:  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 Um valor nulo `LOB` se comporta da mesma forma para um byte zero `LOB` que <xref:System.Data.OracleClient.OracleLob.Read%2A> terá êxito e sempre retorna zero bytes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a posição de leitura atual no fluxo <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <value>A posição atual dentro de <see cref="T:System.Data.OracleClient.OracleLob" /> fluxo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O fluxo deve oferecer suporte a busca obter ou definir a posição. Use o <xref:System.Data.OracleClient.OracleLob.CanSeek%2A> propriedade para determinar se o fluxo oferece suporte à busca.  
  
 Há suporte para busca em qualquer local além do comprimento do fluxo. Buscando uma posição ímpar para `CLOB` e `NCLOB` também há suporte para tipos de dados. Para obter mais informações, consulte a seção comentários a <xref:System.Data.OracleClient.OracleLob.Read%2A> propriedade.  
  
 O <xref:System.Data.OracleClient.OracleLob.Position%2A> propriedade não manter o controle do número de bytes do fluxo que tiverem sido consumidos, ignorado, ou ambos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A conexão está fechada.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto foi fechado ou descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz de bytes. Quando esse método é retornado, o buffer conterá a matriz de bytes especificada com os valores entre <c>deslocamento</c> e (<c>deslocamento</c> + <c>contagem</c>) substituídos pelos bytes lidos da origem atual.</param>
        <param name="offset">O deslocamento de bytes baseado em zero no <c>buffer</c> em que se começa a armazenar os dados lidos do fluxo atual. Para os tipos de dados <see langword="CLOB" /> e <see langword="NCLOB" />, isso deve ser um número par.</param>
        <param name="count">O número máximo de bytes a serem lidos no fluxo atual. Para os tipos de dados <see langword="CLOB" /> e <see langword="NCLOB" />, isso deve ser um número par.</param>
        <summary>Lê uma sequência de bytes do fluxo <see cref="T:System.Data.OracleClient.OracleLob" /> atual de forma assíncrona e avança a posição no fluxo até o número de bytes lidos.</summary>
        <returns>O número total de bytes lidos do buffer. Isso poderá ser menor que o número de bytes solicitado se esses muitos bytes não estiverem disponíveis no momento ou zero (0) se o final do fluxo tiver sido atingido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.OracleClient.OracleLob.Read%2A> método lê um máximo de `count` de fluxo de bytes do atual e armazena-os em `buffer` começando no `offset`. A posição atual dentro do fluxo for avançada pelo número de bytes lido; No entanto, se ocorrer uma exceção, a posição atual dentro do fluxo permanece inalterada. <xref:System.Data.OracleClient.OracleLob.Read%2A> Retorna o número de bytes lidos. O valor de retorno é zero apenas se a posição do final do fluxo. <xref:System.Data.OracleClient.OracleLob.Read%2A> será bloqueada até que pelo menos um byte de dados podem ser lidos, que não há dados disponíveis.<xref:System.Data.OracleClient.OracleLob.Read%2A> Retorna 0 se você tentar ler de um `LOB` quando a posição atual está no final da `LOB`. <xref:System.Data.OracleClient.OracleLob.Read%2A> pode retornar menos bytes que solicitado, mesmo se não foi atingido o fim do fluxo.  
  
 O provedor de dados .NET Framework para Oracle trata todos os `CLOB` e `NCLOB` dados como Unicode. Portanto, ao acessar `CLOB` e `NCLOB` tipos de dados, você sempre está lidando com o número de bytes, onde cada caractere é de 2 bytes. Por exemplo, se uma cadeia de caracteres de texto que contém três caracteres é salvo como um `NCLOB` em um servidor Oracle onde o conjunto de caracteres é de 4 bytes por caractere, e você executar uma `Read` operação, especifique o comprimento da cadeia de caracteres como 6 bytes, embora ele é armazenado como 12 bytes no servidor.  
  
 O exemplo c# a seguir demonstra como ler <xref:System.Data.OracleClient.OracleLob> objetos.  
  
```  
public static void ReadLobExample(OracleCommand command)  
{  
   int actual = 0;  
  
   //Select some data.  
   // Table Schema:  
   //  "CREATE TABLE TableWithLobs (a int, b BLOB, c CLOB, d NCLOB)";  
   //  "INSERT INTO TableWithLobs values (1, 'AA', 'AAA', N'AAAA')";  
   command.CommandText = "SELECT * FROM TableWithLobs";  
   OracleDataReader reader = command.ExecuteReader();  
   using(reader)  
   {  
      //Obtain the first row of data.  
      reader.Read();  
      //Obtain the LOBs (all 3 varieties).  
      OracleLob BLOB = reader.GetOracleLob(1);  
      OracleLob CLOB  = reader.GetOracleLob(2);  
      OracleLob NCLOB = reader.GetOracleLob(3);  
  
      //Example - Reading binary data (in chunks).  
      byte[] buffer = new byte[100];  
      while((actual = BLOB.Read(buffer, 0, buffer.Length)) >0)  
         Console.WriteLine(BLOB.LobType + ".Read(" + buffer + ", " + buffer.Length + ") => " + actual);  
  
      //Example - Reading CLOB/NCLOB data (in chunks).  
      //Note: You can read character data as raw Unicode bytes (using OracleLob.Read as in the above example).  
      //However, because the OracleLob object inherits directly from the.NET stream object,   
      //all the existing classes that manipluate streams can also be used. For example, the   
      //.NET StreamReader makes converting the raw bytes into actual characters easier.  
      StreamReader streamreader = new StreamReader(CLOB, Encoding.Unicode);  
      char[] cbuffer = new char[100];  
      while((actual = streamreader.Read(cbuffer, 0, cbuffer.Length)) >0)  
         Console.WriteLine(CLOB.LobType + ".Read(" + new string(cbuffer, 0, actual) + ", " + cbuffer.Length + ") => " + actual);  
  
      //Example - Reading data (all at once).  
      //You could use StreamReader.ReadToEnd to obtain all the string data,or simply  
      //call OracleLob.Value to obtain a contiguous allocation of all the data.  
      Console.WriteLine(NCLOB.LobType + ".Value => " + NCLOB.Value);  
   }  
}  
```  
  
 Você pode construir um <xref:System.Data.OracleClient.OracleLob> que é NULL usando este formato:  
  
```  
OracleLob myLob = OracleLob.Null;  
```  
  
 Essa técnica é usada principalmente para testar se um `LOB` retornado do servidor for NULL, como mostra o exemplo a seguir.  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 Um valor nulo `LOB` se comporta da mesma forma para um byte zero `LOB` que <xref:System.Data.OracleClient.OracleLob.Read%2A> terá êxito e sempre retorna zero bytes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O <see langword="Nothing" /> é uma referência nula (<paramref name="buffer" /> no Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Um valor de parâmetro <paramref name="offset" /> ou <paramref name="count" /> não é positivo.  
  
 - ou -  
  
 A soma dos parâmetros de deslocamento e contagem é maior do que o tamanho do buffer.  
  
 - ou -  
  
 Um valor especificado no parâmetro <paramref name="amount" /> ou <paramref name="offset" /> é menor que zero ou maior que 4 gigabytes.</exception>
        <exception cref="T:System.InvalidOperationException">A operação não está em uma transação, o objeto <see cref="T:System.Data.OracleClient.OracleLob" /> é nulo ou a conexão é fechada.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto foi fechado ou descartado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Ocorreu um erro do Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Um deslocamento de bytes relativo à origem. Se <c>deslocamento</c> for negativo, a nova posição precederá a posição especificada pela <c>origem</c> pelo número de bytes especificado por <c>deslocamento</c>. Se <c>deslocamento</c> for zero, a nova posição será a posição especificada pela <c>origem</c>. Se <c>deslocamento</c> for positivo, a nova posição seguirá a posição especificada pela <c>origem</c> pelo número de bytes especificado por <c>deslocamento</c>.</param>
        <param name="origin">Um valor do tipo <see cref="T:System.IO.SeekOrigin" /> indicando o ponto de referência usado para obter a nova posição.</param>
        <summary>Define a posição no fluxo <see cref="T:System.Data.OracleClient.OracleLob" /> atual.</summary>
        <returns>A nova posição dentro do fluxo atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `offset` é negativo, a nova posição deve preceder a posição especificada pelo `origin` pelo número de bytes especificado por `offset`. Se `offset` for zero, a nova posição deve ser a posição especificada pelo `origin`. Se `offset` for positivo, a nova posição deve seguir a posição especificada pelo `origin` pelo número de bytes especificado por `offset`.  
  
 Há suporte para busca em qualquer local além do comprimento do fluxo. Buscando uma posição ímpar para `CLOB` e `NCLOB` também há suporte para tipos de dados. Para obter mais informações, consulte a seção comentários a <xref:System.Data.OracleClient.OracleLob.Read%2A> propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="origin" /> não contém um valor válido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A posição resultante está além do comprimento do valor.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Data.OracleClient.OracleLob" /> foi fechado ou descartado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Ocorreu um erro do Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O tamanho desejado do fluxo <see cref="T:System.Data.OracleClient.OracleLob" /> atual em bytes. Para os tipos de dados <see langword="CLOB" /> e <see langword="NCLOB" />, isso deve ser um número par.</param>
        <summary>Define o tamanho do fluxo <see cref="T:System.Data.OracleClient.OracleLob" /> para um valor menor que o tamanho atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma tentativa de aumentar o tamanho do <xref:System.Data.OracleClient.OracleLob> fluxo falhará e retornará "mensagem: ORA-22926: especificado trim comprimento é maior que o comprimento do valor de LOB atual" do servidor Oracle.  
  
 Um fluxo deve dão suporte a gravação e busca de <xref:System.Data.OracleClient.OracleLob.SetLength%2A> à função.  
  
 O provedor de dados .NET Framework para Oracle trata todos os `CLOB` e `NCLOB` dados como Unicode. Portanto, ao acessar `CLOB` e `NCLOB` tipos de dados, você sempre está lidando com o número de bytes, onde cada caractere é de 2 bytes. Por exemplo, se uma cadeia de caracteres de texto que contém três caracteres é salvo como um `NCLOB` em um servidor Oracle onde o conjunto de caracteres é de 4 bytes por caractere, e você executar uma `SetLength` operação, especifique o comprimento da cadeia de caracteres como 6 bytes, embora ele é armazenado como 12 bytes no servidor.  
  
 Para gravar o `LOB`, você deve recuperar o `LOB` usando a cláusula FOR UPDATE na instrução SQL SELECT e você deve ter uma transação local iniciada.  
  
> [!NOTE]
>  A operação de gravação para somente leitura `LOB` pode ter êxito, mas não atualiza o `LOB` no servidor. Nesse caso, no entanto, a cópia local do `LOB` é atualizado. Portanto, mais tarde operações de leitura no <xref:System.Data.OracleClient.OracleLob> objeto pode retornar os resultados da operação de gravação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Um valor especificado no parâmetro <paramref name="value" /> para um tipo de dados <see langword="CLOB" /> ou <see langword="NCLOB" /> não é par.  
  
 - ou -  
  
 Um valor especificado no parâmetro <paramref name="value" /> é menor que zero ou maior que 4 gigabytes.</exception>
        <exception cref="T:System.InvalidOperationException">A operação não está em uma transação, o objeto <see cref="T:System.Data.OracleClient.OracleLob" /> é nulo ou a conexão é fechada.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto foi fechado ou descartado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Ocorreu um erro do Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public object Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Value" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Value { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o valor do fluxo de Common Language Runtime equivalente do valor subjacente.</summary>
        <value>Para <see cref="F:System.Data.OracleClient.OracleType.Blob" />, uma matriz do tipo <see langword="Byte[]" />. Para <see cref="F:System.Data.OracleClient.OracleType.Clob" /> e <see cref="F:System.Data.OracleClient.OracleType.NClob" />, um <see langword="String" />. Para dados nulos, <see cref="T:System.DBNull" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para <xref:System.Data.OracleClient.OracleType.Blob> tipos de dados, <xref:System.Data.OracleClient.OracleLob.Value%2A> retorna todos os dados subjacentes como uma matriz do tipo de contígua `Byte[]`. Para <xref:System.Data.OracleClient.OracleType.Clob> e <xref:System.Data.OracleClient.OracleType.NClob> tipos de dados, <xref:System.Data.OracleClient.OracleLob.Value%2A> retorna todos os dados como um `String` tipo de dados. Para dados nulos, <xref:System.Data.OracleClient.OracleLob.Value%2A> retorna <xref:System.DBNull>. Comparando os valores retornados, você pode distinguir entre os dados vazios, nulo dados e dados.  
  
> [!NOTE]
>  Uma vantagem de usar `LOB` tipos de dados é a capacidade de recuperar grandes quantidades de dados em partes no cliente. No entanto, quando você usa <xref:System.Data.OracleClient.OracleLob.Value%2A>, obter todos os dados para o `LOB` coluna como uma parte de contígua, que pode aumentar significativamente a sobrecarga de aplicativo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O objeto foi fechado ou descartado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Ocorreu um erro do Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz de bytes. Este método copia o número de bytes especificado em <c>contagem</c> de <c>buffer</c> para o fluxo atual.</param>
        <param name="offset">O deslocamento de bytes baseado em zero no <c>buffer</c> no qual será iniciada a cópia de bytes para o fluxo atual. Para os tipos de dados <see langword="CLOB" /> e <see langword="NCLOB" />, isso deve ser um número par.</param>
        <param name="count">O número de bytes a serem gravados no fluxo atual. Para os tipos de dados <see langword="CLOB" /> e <see langword="NCLOB" />, isso deve ser um número par.</param>
        <summary>Grava assincronamente uma sequência de bytes no fluxo <see cref="T:System.Data.OracleClient.OracleLob" /> atual e avança a posição atual dentro desse fluxo no número de bytes gravados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a operação de gravação for bem-sucedida, a posição dentro do fluxo avança pelo número de bytes gravados. Se ocorrer uma exceção, a posição dentro do fluxo permanecerá inalterada.  
  
 Gravando além do fim de `LOB` é permitida e amplia o `LOB` pelo número de bytes gravados.  
  
 O provedor de dados .NET Framework para Oracle trata todos os `CLOB` e `NCLOB` dados como Unicode. Portanto, ao acessar `CLOB` e `NCLOB` tipos de dados, você sempre está lidando com o número de bytes, onde cada caractere é de 2 bytes. Por exemplo, se uma cadeia de caracteres de texto que contém três caracteres é salvo como um `NCLOB` em um servidor Oracle onde o conjunto de caracteres é de 4 bytes por caractere, e você executar uma `Write` operação, especifique o comprimento da cadeia de caracteres como 6 bytes, embora ele é armazenado como 12 bytes no servidor.  
  
 Para gravar o `LOB`, você deve recuperar o `LOB` usando a cláusula FOR UPDATE na instrução SQL SELECT e você deve ter uma transação local iniciada.  
  
 O exemplo c# a seguir demonstra como gravar <xref:System.Data.OracleClient.OracleLob> objetos.  
  
```  
public static void WriteLobExample(OracleCommand command)  
{  
   //Note: Updating LOB data requires a transaction.  
   command.Transaction = command.Connection.BeginTransaction();  
   //Select some data.  
   //    Table Schema:  
   //        "CREATE TABLE tablewithlobs (a int, b BLOB, c BLOB)";  
   //        "INSERT INTO tablewithlobs values (1, 'AA', 'AAA')";  
   command.CommandText = "SELECT * FROM TableWithLobs FOR UPDATE";  
   OracleDataReader reader = command.ExecuteReader();  
   using(reader)  
   {  
      //Obtain the first row of data.  
      reader.Read();  
      //Obtain both LOBs.  
      OracleLob BLOB1    = reader.GetOracleLob(1);  
      OracleLob BLOB2    = reader.GetOracleLob(2);  
      //Perform any desired operations on the LOB, (read, position, and so on).  
      //...  
      //Example - Writing binary data (directly to the backend).  
      //To write, you can use any of the stream classes, or write raw binary data using   
      //the OracleLob write method. Writing character vs. binary is the same;  
      //however note that character is always in terms of Unicode byte counts  
      //(for example: even number of bytes - 2 bytes for every Unicode character).  
      byte[] buffer = new byte[100];  
      buffer[0] = 0xCC;  
      buffer[1] = 0xDD;  
      BLOB1.Write(buffer, 0, 2);  
      BLOB1.Position = 0;  
      Console.WriteLine(BLOB1.LobType + ".Write(" + buffer + ", 0, 2) => " + BLOB1.Value);  
  
      //Example - Copying data into another LOB.  
      long actual = BLOB1.CopyTo(BLOB2);  
      Console.WriteLine(BLOB1.LobType + ".CopyTo(" + BLOB2.Value + ") => " + actual);  
  
      //Commit the transaction now that everything succeeded.  
      //Note: On error, Transaction.Dispose is called (from the using statement)  
      //and will automatically roll-back the pending transaction.  
      command.Transaction.Commit();  
   }  
}  
```  
  
> [!NOTE]
>  A operação de gravação para somente leitura `LOB` pode ter êxito, mas não atualiza o `LOB` no servidor. Nesse caso, no entanto, a cópia local do `LOB` é atualizado. Portanto, mais tarde operações de leitura no <xref:System.Data.OracleClient.OracleLob> objeto pode retornar os resultados da operação de gravação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <see langword="Nothing" /> é uma referência nula (<paramref name="buffer" /> no Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Um valor de parâmetro <paramref name="offset" /> ou <paramref name="count" /> não é positivo.  
  
 - ou -  
  
 A soma dos parâmetros <paramref name="offset" /> e <paramref name="count" /> é maior do que o tamanho <paramref name="buffer" />.  
  
 - ou -  
  
 Um valor especificado no parâmetro <paramref name="count" /> ou <paramref name="offset" /> é menor que zero ou maior que 4 gigabytes.  
  
 - ou -  
  
 Você deve especificar os tipos de dados <see langword="CLOB" /> e <see langword="NCLOB" /> como um número par de bytes.</exception>
        <exception cref="T:System.InvalidOperationException">A operação não está em uma transação, o objeto <see cref="T:System.Data.OracleClient.OracleLob" /> é nulo ou a conexão é fechada.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto foi fechado ou descartado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Ocorreu um erro do Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">O byte a ser gravado no fluxo.</param>
        <summary>Grava um byte na posição atual no fluxo <see cref="T:System.Data.OracleClient.OracleLob" /> e avança a posição dentro no fluxo em um byte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a operação de gravação for bem-sucedida, a posição dentro do fluxo avança por um byte. Se ocorrer uma exceção, a posição dentro do fluxo permanecerá inalterada.  
  
 Gravando além do fim do `LOB` é permitida e amplia o `LOB` por um byte.  
  
 Para gravar o `LOB`, você deve recuperar o `LOB` usando a cláusula FOR UPDATE na instrução SQL SELECT e você deve ter uma transação local iniciada.  
  
> [!NOTE]
>  A operação de gravação para somente leitura `LOB` pode ter êxito, mas não atualiza o `LOB` no servidor. Nesse caso, no entanto, a cópia local do `LOB` é atualizado. Portanto, mais tarde operações de leitura no <xref:System.Data.OracleClient.OracleLob> objeto pode retornar os resultados da operação de gravação.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>