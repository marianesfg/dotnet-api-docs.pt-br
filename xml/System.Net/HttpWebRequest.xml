<Type Name="HttpWebRequest" FullName="System.Net.HttpWebRequest">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f88a39f4d4dab5cf50f5b402455902e510a069b3" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57951637" /></Metadata><TypeSignature Language="C#" Value="public class HttpWebRequest : System.Net.WebRequest, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable HttpWebRequest extends System.Net.WebRequest implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpWebRequest" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpWebRequest&#xA;Inherits WebRequest&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpWebRequest : System::Net::WebRequest, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type HttpWebRequest = class&#xA;    inherit WebRequest&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Requests</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.WebRequest</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.CompilerServices.FriendAccessAllowed</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece uma implementação específica de HTTP da classe <see cref="T:System.Net.WebRequest" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
>  Não é recomendável que você use `HttpWebRequest` para novo desenvolvimento. Em vez disso, use o <xref:System.Net.Http.HttpClient?displayProperty=nameWithType> classe.

 O <xref:System.Net.HttpWebRequest> classe oferece suporte para as propriedades e métodos definidos no <xref:System.Net.WebRequest> e para propriedades e métodos que permitem ao usuário interagir diretamente com os servidores usando HTTP adicionais.  
  
 Não use o <xref:System.Net.HttpWebRequest.%23ctor%2A> construtor. Use o <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType> método para inicializar novos <xref:System.Net.HttpWebRequest> objetos. Se o esquema para o identificador de URI (Uniform Resource) é `http://` ou `https://`, <xref:System.Net.WebRequest.Create%2A> retorna um <xref:System.Net.HttpWebRequest> objeto.  
  
 O <xref:System.Net.HttpWebRequest.GetResponse%2A> método faz uma solicitação síncrona para o recurso especificado na <xref:System.Net.HttpWebRequest.RequestUri%2A> propriedade e retorna um <xref:System.Net.HttpWebResponse> que contém o objeto de resposta. Os dados de resposta podem ser recebidos usando o fluxo retornado por <xref:System.Net.HttpWebResponse.GetResponseStream%2A>. Se o objeto de resposta ou o fluxo de resposta estiver fechado, dados restantes serão perdidos. Os dados restantes serão descarregados e o soquete será reutilizado em solicitações subsequentes ao fechar o objeto de resposta ou o fluxo se mantenha as seguintes condições: é uma solicitação de keep-alive ou pipeline, apenas uma pequena quantidade de dados precisa ser recebida, ou o dados restantes é recebido em um pequeno intervalo. Se nenhuma das condições mencionadas mantenha ou a hora de dreno for excedida, o soquete será fechado. Para conexões keep-alive ou pipeline, é altamente recomendável que o aplicativo lê os fluxos de até o EOF. Isso garante que o soquete será reutilizado em solicitações subsequentes, resultando em um melhor desempenho e menos recursos usados.  
  
 Quando você deseja enviar dados para o recurso, o <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método retorna um <xref:System.IO.Stream> objeto a ser usado para enviar dados. O <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> e <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> métodos fornecem acesso assíncrono ao fluxo de dados de envio.  
  
 Para autenticação de cliente com <xref:System.Net.HttpWebRequest>, o certificado do cliente deve ser instalado no meu repositório de certificados do usuário atual.  
  
 O <xref:System.Net.HttpWebRequest> classe gera uma <xref:System.Net.WebException> quando ocorrem erros ao acessar um recurso. O <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> propriedade contém um <xref:System.Net.WebExceptionStatus> valor que indica a origem do erro. Quando <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> está <xref:System.Net.WebExceptionStatus.ProtocolError?displayProperty=nameWithType>, o <xref:System.Net.WebException.Response%2A> propriedade contém o <xref:System.Net.HttpWebResponse> recebida do recurso.  
  
 <xref:System.Net.HttpWebRequest> expõe os valores de cabeçalho HTTP comuns enviados para o recurso de Internet como propriedades, definidos pelos métodos, ou definida pelo sistema; a tabela a seguir contém uma lista completa. Você pode definir outros cabeçalhos no <xref:System.Net.HttpWebRequest.Headers%2A> a propriedade como pares nome/valor. Observe que servidores e os caches podem alterar ou adicionar cabeçalhos durante a solicitação.  
  
 A tabela a seguir lista os cabeçalhos HTTP que são definidos por propriedades ou métodos ou o sistema.  
  
|Cabeçalho|Definido por|  
|------------|------------|  
|Aceitar|Definido pelo <xref:System.Net.HttpWebRequest.Accept%2A> propriedade.|  
|Conexão|Definido pela <xref:System.Net.HttpWebRequest.Connection%2A> propriedade, <xref:System.Net.HttpWebRequest.KeepAlive%2A> propriedade.|  
|Tamanho do conteúdo|Definido pelo <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade.|  
|Tipo de conteúdo|Definido pelo <xref:System.Net.HttpWebRequest.ContentType%2A> propriedade.|  
|Esperar|Definido pelo <xref:System.Net.HttpWebRequest.Expect%2A> propriedade.|  
|Date|Definido pelo sistema como a data atual.|  
|Host|Definido pelo sistema de informações do host atual.|  
|If-Modified-Since|Definido pelo <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriedade.|  
|Intervalo|Definido pelo <xref:System.Net.HttpWebRequest.AddRange%2A> método.|  
|Referer|Definido pelo <xref:System.Net.HttpWebRequest.Referer%2A> propriedade.|  
|Codificação de transferência|Definido pela <xref:System.Net.HttpWebRequest.TransferEncoding%2A> propriedade (o <xref:System.Net.HttpWebRequest.SendChunked%2A> propriedade deve ser `true`).|  
|Agente do usuário|Definido pelo <xref:System.Net.HttpWebRequest.UserAgent%2A> propriedade.|  
  
> [!NOTE]
>  <xref:System.Net.HttpWebRequest> é registrado automaticamente. Você não precisará chamar o <xref:System.Net.WebRequest.RegisterPrefix%2A> método para registrar <xref:System.Net.HttpWebRequest?displayProperty=nameWithType> antes de usar URIs começando com `http://` ou `https://`.  
  
 O computador local ou o arquivo de configuração de aplicativo pode especificar que um proxy padrão usado. Se o <xref:System.Net.HttpWebRequest.Proxy%2A> propriedade for especificada, em seguida, as configurações de proxy do <xref:System.Net.HttpWebRequest.Proxy%2A> substituição de propriedade, o computador local ou o arquivo de configuração de aplicativo e o <xref:System.Net.HttpWebRequest> instância usará as configurações de proxy especificadas. Se nenhum proxy for especificado em um arquivo de configuração e o <xref:System.Net.HttpWebRequest.Proxy%2A> propriedade não for especificada, o <xref:System.Net.HttpWebRequest> classe usa as configurações de proxy herdadas do Internet Explorer no computador local. Se não houver nenhuma configuração de proxy no Internet Explorer, a solicitação é enviada diretamente para o servidor.  
  
 O <xref:System.Net.HttpWebRequest> classe analisa uma lista de bypass de proxy com caracteres curinga herdadas do Internet Explorer de modo diferente do que a lista de ignoráveis é analisada diretamente pelo Internet Explorer. Por exemplo, o <xref:System.Net.HttpWebRequest> classe analisa uma lista de bypass de "nt *" do Internet Explorer como uma expressão regular de "nt. $". Isso é diferente do comportamento nativo do Internet Explorer. Portanto, uma URL de "`http://intxxxxx`" ignoram o proxy usando o <xref:System.Net.HttpWebRequest> de classe, mas não ignoram o proxy usando o Internet Explorer.  
  
> [!NOTE]
>  O Framework armazena em cache as sessões de SSL conforme eles são criados e tenta reutilizar uma sessão em cache para uma nova solicitação, se possível. Ao tentar reutilizar uma sessão SSL, a estrutura usa o primeiro elemento da <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (se houver um), ou tenta reutilizar um sessões anônimas se <xref:System.Net.HttpWebRequest.ClientCertificates%2A> está vazio.  
  
> [!NOTE]
>  Por motivos de segurança, os cookies estão desabilitados por padrão. Se você quiser usar cookies, use o <xref:System.Net.HttpWebRequest.CookieContainer%2A> propriedade para habilitar cookies.  
  
 O .NET Framework 4.6 inclui um novo recurso de segurança que impede algoritmos para conexões de hash e criptografia insegura. Por padrão, os aplicativos usando TLS/SSL por meio de APIs, como HttpClient, HttpWebRequest, FTPClient, SmtpClient, SslStream, etc. e direcionamento do .NET Framework 4.6 obter o comportamento mais seguras.  
  
 Os desenvolvedores podem querer recusar esse comportamento para manter a interoperabilidade com seus serviços existentes SSL3 ou TLS com os serviços de RC4. [Este artigo](https://support.microsoft.com/kb/3069494) explica como modificar seu código para que o novo comportamento está desabilitado.  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma <xref:System.Net.HttpWebRequest> para o URI http://www.contoso.com/.  
  
 [!code-cpp[Classic HttpWebRequest Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.WebPermission">para acessar o URI solicitado ou qualquer URI que a solicitação é redirecionada. Enumeração associada: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
    <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Elemento DefaultProxy (configurações de rede)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/8bf0b428-5a21-4299-8d6e-bf8251fd978a">Alterações para a autenticação NTLM para HTTPWebRequest na versão 3.5 SP1</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Net.HttpWebRequest" />. Esses construtores são obsoletos; consulte a seção Comentários para obter detalhes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Ambos <xref:System.Net.HttpWebRequest> construtores são obsoletos e não deve ser usados. Chame o <xref:System.Net.WebRequest.CreateHttp%2A?displayProperty=nameWithType> método para inicializar novos <xref:System.Net.HttpWebRequest> objetos.     
  
      ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Net.HttpWebRequest" />. Esse construtor é obsoleto.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : Uri -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest uri" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      </Parameters>
      <Docs>
        <param name="uri">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HttpWebRequest (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HttpWebRequest(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Um objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contém as informações necessárias para serializar o objeto <see cref="T:System.Net.HttpWebRequest" />.</param>
        <param name="streamingContext">Um objeto <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contém a origem e o destino do fluxo serializado associado ao novo objeto <see cref="T:System.Net.HttpWebRequest" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Net.HttpWebRequest" /> das instâncias especificadas das classes <see cref="T:System.Runtime.Serialization.SerializationInfo" /> e <see cref="T:System.Runtime.Serialization.StreamingContext" />. Esse construtor é obsoleto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um aplicativo deve ser executado no modo de confiança total ao usar a serialização.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Para obter acesso irrestrito aos recursos da rede. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">Serialização XML e SOAP</related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public override void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Abort();" />
      <MemberSignature Language="F#" Value="override this.Abort : unit -&gt; unit" Usage="httpWebRequest.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancela uma solicitação para um recurso de Internet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.Abort%2A> método cancela uma solicitação para um recurso. Depois que uma solicitação for cancelada, chamando o <xref:System.Net.HttpWebRequest.GetResponse%2A>, <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.EndGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, ou <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> método faz com que uma <xref:System.Net.WebException> com o <xref:System.Net.WebException.Status%2A> propriedade definida como <xref:System.Net.WebExceptionStatus.RequestCanceled>.  
  
 O <xref:System.Net.HttpWebRequest.Abort%2A> método de forma síncrona executará o retorno de chamada especificado para o <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> ou <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> métodos se o <xref:System.Net.HttpWebRequest.Abort%2A> método é chamado enquanto qualquer uma dessas operações estão pendente. Isso pode levar a problemas potenciais de deadlock.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede](https://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 No caso de solicitações assíncronas, é responsabilidade do aplicativo cliente para implementar seu próprio mecanismo de tempo limite. O exemplo de código a seguir mostra como fazer isso.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public string Accept { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Accept" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Property Accept As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Accept { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Accept : string with get, set" Usage="System.Net.HttpWebRequest.Accept" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor do cabeçalho HTTP <see langword="Accept" />.</summary>
        <value>O valor do cabeçalho HTTP <see langword="Accept" />. O valor padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para limpar os `Accept` cabeçalho HTTP, defina o <xref:System.Net.HttpWebRequest.Accept%2A> propriedade `null`.  
  
> [!NOTE]
>  O valor dessa propriedade é armazenado em <xref:System.Net.WebHeaderCollection>. Se WebHeaderCollection for definido, o valor da propriedade será perdido.  
  
   
  
## Examples  
 O seguinte exemplo de código define o <xref:System.Net.HttpWebRequest.Accept%2A> propriedade.  
  
 [!code-cpp[HttpWebRequest_Accept#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Accept/CPP/httpwebrequest_accept.cpp#1)]
 [!code-csharp[HttpWebRequest_Accept#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Accept/CS/httpwebrequest_accept.cs#1)]
 [!code-vb[HttpWebRequest_Accept#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Accept/VB/httpwebrequest_accept.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRange">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adiciona um cabeçalho de intervalo à solicitação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma vez que todas as entidades HTTP são representadas em mensagens HTTP como sequências de bytes, o conceito de um intervalo de bytes é significativo para qualquer entidade HTTP. No entanto, nem todos os clientes e servidores precisam dar suporte a operações de intervalo de bytes.  
  
 O cabeçalho de intervalo em uma solicitação permite que um cliente solicitar que ele só quer receber alguma parte do intervalo especificado de bytes em uma entidade HTTP. Servidores não são necessários para dar suporte a solicitações de cabeçalho de intervalo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="range">O ponto inicial ou final do intervalo.</param>
        <summary>Adiciona um cabeçalho de intervalo de bytes a uma solicitação de um intervalo específico, do início ou do fim dos dados solicitados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método adiciona um cabeçalho de intervalo de bytes para a solicitação.  
  
 Se `range` for positivo, o `range` parâmetro especifica o ponto inicial do intervalo. O servidor deve começar a enviar dados a partir de `range` parâmetro especificado ao final dos dados na entidade HTTP.  
  
 Se `range` for negativo, o `range` parâmetro especifica o ponto final do intervalo. O servidor deve começar a enviar dados desde o início dos dados na entidade HTTP para o `range` parâmetro especificado.  
  
 Uma vez que todas as entidades HTTP são representadas em mensagens HTTP como sequências de bytes, o conceito de um intervalo de bytes é significativo para qualquer entidade HTTP. No entanto, nem todos os clientes e servidores precisam dar suporte a operações de intervalo de bytes.  
  
 O cabeçalho de intervalo em uma solicitação permite que um cliente solicitar que ele só quer receber alguma parte do intervalo especificado de bytes em uma entidade HTTP. Servidores não são necessários para dar suporte a solicitações de cabeçalho de intervalo.  
  
 Um exemplo de um cabeçalho de intervalo em uma solicitação de protocolo HTTP que solicita que o servidor de enviar os primeiros 100 bytes (desde o início para a posição do byte 99) seria o seguinte:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Neste exemplo, o `range` parâmetro seria -99.  
  
 Um servidor HTTP indica suporte para cabeçalhos de intervalo com o cabeçalho Accept-Ranges. Um exemplo do cabeçalho Accept-Ranges de um servidor que oferece suporte a intervalos de bytes seria da seguinte maneira:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Se um cabeçalho Accept-Ranges não for recebido no cabeçalho da resposta do servidor, o servidor não oferece suporte a cabeçalhos de intervalo. Um exemplo do cabeçalho Accept-Ranges de um servidor que não oferece suporte a intervalos, mas reconhece o cabeçalho Accept-Ranges, seria da seguinte maneira:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Ao receber a resposta de uma solicitação de intervalo, somente os cabeçalhos HTTP associados com a solicitação inteira são analisados e disponibilizados por meio de propriedades no <xref:System.Net.HttpWebResponse> classe. Cabeçalhos associados a cada intervalo são retornados na resposta.  
  
   
  
## Examples  
 O exemplo de código a seguir adiciona um cabeçalho de intervalo para a solicitação.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> é inválido.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível adicionar o cabeçalho de intervalo.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="range">O ponto inicial ou final do intervalo.</param>
        <summary>Adiciona um cabeçalho de intervalo de bytes a uma solicitação de um intervalo específico, do início ou do fim dos dados solicitados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método adiciona um cabeçalho de intervalo de bytes para a solicitação.  
  
 Se `range` for positivo, o `range` parâmetro especifica o ponto inicial do intervalo. O servidor deve começar a enviar dados a partir de `range` parâmetro especificado ao final dos dados na entidade HTTP.  
  
 Se `range` for negativo, o `range` parâmetro especifica o ponto final do intervalo. O servidor deve começar a enviar dados desde o início dos dados na entidade HTTP para o `range` parâmetro especificado.  
  
 Uma vez que todas as entidades HTTP são representadas em mensagens HTTP como sequências de bytes, o conceito de um intervalo de bytes é significativo para qualquer entidade HTTP. No entanto, nem todos os clientes e servidores precisam dar suporte a operações de intervalo de bytes.  
  
 O cabeçalho de intervalo em uma solicitação permite que um cliente solicitar que ele só quer receber alguma parte do intervalo especificado de bytes em uma entidade HTTP. Servidores não são necessários para dar suporte a solicitações de cabeçalho de intervalo.  
  
 Um exemplo de um cabeçalho de intervalo em uma solicitação de protocolo HTTP que solicita que o servidor de enviar os primeiros 100 bytes (desde o início para a posição do byte 99) seria o seguinte:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Neste exemplo, o `range` parâmetro seria -99.  
  
 Um servidor HTTP indica suporte para cabeçalhos de intervalo com o cabeçalho Accept-Ranges. Um exemplo do cabeçalho Accept-Ranges de um servidor que oferece suporte a intervalos de bytes seria da seguinte maneira:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Se um cabeçalho Accept-Ranges não for recebido no cabeçalho da resposta do servidor, o servidor não oferece suporte a cabeçalhos de intervalo. Um exemplo do cabeçalho Accept-Ranges de um servidor que não oferece suporte a intervalos, mas reconhece o cabeçalho Accept-Ranges, seria da seguinte maneira:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Ao receber a resposta de uma solicitação de intervalo, somente os cabeçalhos HTTP associados com a solicitação inteira são analisados e disponibilizados por meio de propriedades no <xref:System.Net.HttpWebResponse> classe. Cabeçalhos associados a cada intervalo são retornados na resposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> é inválido.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível adicionar o cabeçalho de intervalo.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int * int -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="to" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="from">A posição na qual iniciar o envio de dados.</param>
        <param name="to">A posição na qual interromper o envio de dados.</param>
        <summary>Adiciona um cabeçalho de intervalo de byte à solicitação de um intervalo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método adiciona um cabeçalho de intervalo de bytes para a solicitação.  
  
 Uma vez que todas as entidades HTTP são representadas em mensagens HTTP como sequências de bytes, o conceito de um intervalo de bytes é significativo para qualquer entidade HTTP. No entanto, nem todos os clientes e servidores precisam dar suporte a operações de intervalo de bytes.  
  
 O cabeçalho de intervalo em uma solicitação permite que um cliente solicitar que ele só quer receber alguma parte do intervalo especificado de bytes em uma entidade HTTP. Servidores não são necessários para dar suporte a solicitações de cabeçalho de intervalo.  
  
 Um exemplo de um cabeçalho de intervalo em uma solicitação do protocolo HTTP que seriam solicitações os primeiros 100 bytes seria o seguinte:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Neste exemplo, o `from` parâmetro deve ser especificado como 0 e o `to` parâmetro deve ser especificado como 99. O especificador de intervalo é definido automaticamente como "bytes" por esse método.  
  
 Um servidor HTTP indica suporte para cabeçalhos de intervalo com o cabeçalho Accept-Ranges. Um exemplo do cabeçalho Accept-Ranges de um servidor que oferece suporte a intervalos de bytes seria da seguinte maneira:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Se um cabeçalho Accept-Ranges não for recebido no cabeçalho da resposta do servidor, o servidor não oferece suporte a cabeçalhos de intervalo. Um exemplo do cabeçalho Accept-Ranges de um servidor que não oferece suporte a intervalos, mas reconhece o cabeçalho Accept-Ranges, seria da seguinte maneira:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Ao receber a resposta de uma solicitação de intervalo, somente os cabeçalhos HTTP associados com a solicitação inteira são analisados e disponibilizados por meio de propriedades no <xref:System.Net.HttpWebResponse> classe. Cabeçalhos associados a cada intervalo são retornados na resposta.  
  
   
  
## Examples  
 O exemplo de código a seguir adiciona um cabeçalho de intervalo para a solicitação.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> é inválido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> é maior que <paramref name="to" />  
  
- ou - 
 <paramref name="from" /> ou <paramref name="to" /> é menor que 0.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível adicionar o cabeçalho de intervalo.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="to" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="from">A posição na qual iniciar o envio de dados.</param>
        <param name="to">A posição na qual interromper o envio de dados.</param>
        <summary>Adiciona um cabeçalho de intervalo de byte à solicitação de um intervalo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método adiciona um cabeçalho de intervalo de bytes para a solicitação.  
  
 Uma vez que todas as entidades HTTP são representadas em mensagens HTTP como sequências de bytes, o conceito de um intervalo de bytes é significativo para qualquer entidade HTTP. No entanto, nem todos os clientes e servidores precisam dar suporte a operações de intervalo de bytes.  
  
 O cabeçalho de intervalo em uma solicitação permite que um cliente solicitar que ele só quer receber alguma parte do intervalo especificado de bytes em uma entidade HTTP. Servidores não são necessários para dar suporte a solicitações de cabeçalho de intervalo.  
  
 Um exemplo de um cabeçalho de intervalo em uma solicitação do protocolo HTTP que seriam solicitações os primeiros 100 bytes seria o seguinte:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Neste exemplo, o `from` parâmetro deve ser especificado como 0 e o `to` parâmetro deve ser especificado como 99. O especificador de intervalo é definido automaticamente como "bytes" por esse método.  
  
 Um servidor HTTP indica suporte para cabeçalhos de intervalo com o cabeçalho Accept-Ranges. Um exemplo do cabeçalho Accept-Ranges de um servidor que oferece suporte a intervalos de bytes seria da seguinte maneira:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Se um cabeçalho Accept-Ranges não for recebido no cabeçalho da resposta do servidor, o servidor não oferece suporte a cabeçalhos de intervalo. Um exemplo do cabeçalho Accept-Ranges de um servidor que não oferece suporte a intervalos, mas reconhece o cabeçalho Accept-Ranges, seria da seguinte maneira:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Ao receber a resposta de uma solicitação de intervalo, somente os cabeçalhos HTTP associados com a solicitação inteira são analisados e disponibilizados por meio de propriedades no <xref:System.Net.HttpWebResponse> classe. Cabeçalhos associados a cada intervalo são retornados na resposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> é inválido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> é maior que <paramref name="to" />  
  
- ou - 
 <paramref name="from" /> ou <paramref name="to" /> é menor que 0.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível adicionar o cabeçalho de intervalo.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="range" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">A descrição do intervalo.</param>
        <param name="range">O ponto inicial ou final do intervalo.</param>
        <summary>Adiciona um cabeçalho de intervalo a uma solicitação de um intervalo específico, do início ou do fim dos dados solicitados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método adiciona um cabeçalho de intervalo para a solicitação.  
  
 Se `range` for positivo, o `range` parâmetro especifica o ponto inicial do intervalo. O servidor deve começar a enviar dados a partir de `range` parâmetro especificado ao final dos dados na entidade HTTP.  
  
 Se `range` for negativo, o `range` parâmetro especifica o ponto final do intervalo. O servidor deve começar a enviar dados desde o início dos dados na entidade HTTP para o `range` parâmetro especificado.  
  
 Uma vez que todas as entidades HTTP são representadas em mensagens HTTP como sequências de bytes, o conceito de um intervalo de bytes é significativo para qualquer entidade HTTP. No entanto, nem todos os clientes e servidores precisam dar suporte a operações de intervalo de bytes.  
  
 O cabeçalho de intervalo em uma solicitação permite que um cliente solicitar que ele só quer receber alguma parte do intervalo especificado de bytes em uma entidade HTTP. Servidores não são necessários para dar suporte a solicitações de cabeçalho de intervalo.  
  
 O `rangeSpecifier` parâmetro normalmente seria especificado como "bytes", já que este é o especificador de intervalo único reconhecido pela maioria dos servidores HTTP. Definindo o `rangeSpecifier` parâmetro para alguma outra cadeia de caracteres permite que o suporte para especificadores de intervalo personalizado que não sejam de bytes (o especificador de intervalo de bytes definido na RFC 2616 pela IETF).  
  
 Um exemplo de um cabeçalho de intervalo em uma solicitação do protocolo HTTP que seriam solicitações os primeiros 100 bytes seria o seguinte:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 Neste exemplo, o `rangeSpecifier` parâmetro deve ser especificado como "bytes" e o `range` parâmetro seria -99.  
  
 Um servidor HTTP indica suporte para cabeçalhos de intervalo com o cabeçalho Accept-Ranges na resposta. Um exemplo do cabeçalho Accept-Ranges de um servidor que oferece suporte a intervalos de bytes seria da seguinte maneira:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Se um cabeçalho Accept-Ranges não for recebido no cabeçalho da resposta do servidor, o servidor não oferece suporte a cabeçalhos de intervalo. Um exemplo do cabeçalho Accept-Ranges de um servidor que não oferece suporte a intervalos, mas reconhece o cabeçalho Accept-Ranges, seria da seguinte maneira:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Ao receber a resposta de uma solicitação de intervalo, somente os cabeçalhos HTTP associados com a solicitação inteira são analisados e disponibilizados por meio de propriedades no <xref:System.Net.HttpWebResponse> classe. Cabeçalhos associados a cada intervalo são retornados na resposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> é inválido.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível adicionar o cabeçalho de intervalo.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="range" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">A descrição do intervalo.</param>
        <param name="range">O ponto inicial ou final do intervalo.</param>
        <summary>Adiciona um cabeçalho de intervalo a uma solicitação de um intervalo específico, do início ou do fim dos dados solicitados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método adiciona um cabeçalho de intervalo para a solicitação.  
  
 Se `range` for positivo, o `range` parâmetro especifica o ponto inicial do intervalo. O servidor deve começar a enviar dados a partir de `range` parâmetro especificado ao final dos dados na entidade HTTP.  
  
 Se `range` for negativo, o `range` parâmetro especifica o ponto final do intervalo. O servidor deve começar a enviar dados desde o início dos dados na entidade HTTP para o `range` parâmetro especificado.  
  
 Uma vez que todas as entidades HTTP são representadas em mensagens HTTP como sequências de bytes, o conceito de um intervalo de bytes é significativo para qualquer entidade HTTP. No entanto, nem todos os clientes e servidores precisam dar suporte a operações de intervalo de bytes.  
  
 O cabeçalho de intervalo em uma solicitação permite que um cliente solicitar que ele só quer receber alguma parte do intervalo especificado de bytes em uma entidade HTTP. Servidores não são necessários para dar suporte a solicitações de cabeçalho de intervalo.  
  
 O `rangeSpecifier` parâmetro normalmente seria especificado como "bytes", já que este é o especificador de intervalo único reconhecido pela maioria dos servidores HTTP. Definindo o `rangeSpecifier` parâmetro para alguma outra cadeia de caracteres permite que o suporte para especificadores de intervalo personalizado que não sejam de bytes (o especificador de intervalo de bytes definido na RFC 2616 pela IETF).  
  
 Um exemplo de um cabeçalho de intervalo em uma solicitação do protocolo HTTP que seriam solicitações os primeiros 100 bytes seria o seguinte:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 Neste exemplo, o `rangeSpecifier` parâmetro deve ser especificado como "bytes" e o `range` parâmetro seria -99.  
  
 Um servidor HTTP indica suporte para cabeçalhos de intervalo com o cabeçalho Accept-Ranges na resposta. Um exemplo do cabeçalho Accept-Ranges de um servidor que oferece suporte a intervalos de bytes seria da seguinte maneira:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Se um cabeçalho Accept-Ranges não for recebido no cabeçalho da resposta do servidor, o servidor não oferece suporte a cabeçalhos de intervalo. Um exemplo do cabeçalho Accept-Ranges de um servidor que não oferece suporte a intervalos, mas reconhece o cabeçalho Accept-Ranges, seria da seguinte maneira:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Ao receber a resposta de uma solicitação de intervalo, somente os cabeçalhos HTTP associados com a solicitação inteira são analisados e disponibilizados por meio de propriedades no <xref:System.Net.HttpWebResponse> classe. Cabeçalhos associados a cada intervalo são retornados na resposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> é inválido.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível adicionar o cabeçalho de intervalo.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="from" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="to" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">A descrição do intervalo.</param>
        <param name="from">A posição na qual iniciar o envio de dados.</param>
        <param name="to">A posição na qual interromper o envio de dados.</param>
        <summary>Adiciona um cabeçalho de intervalo a uma solicitação para um intervalo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método adiciona um cabeçalho de intervalo para a solicitação.  
  
 Uma vez que todas as entidades HTTP são representadas em mensagens HTTP como sequências de bytes, o conceito de um intervalo de bytes é significativo para qualquer entidade HTTP. No entanto, nem todos os clientes e servidores precisam dar suporte a operações de intervalo de bytes.  
  
 O cabeçalho de intervalo em uma solicitação permite que um cliente solicitar que ele só quer receber alguma parte do intervalo especificado de bytes em uma entidade HTTP. Servidores não são necessários para dar suporte a solicitações de cabeçalho de intervalo.  
  
 O `rangeSpecifier` parâmetro normalmente seria especificado como "bytes", já que este é o especificador de intervalo único reconhecido pela maioria dos servidores HTTP. Definindo o `rangeSpecifier` parâmetro para alguma outra cadeia de caracteres permite que o suporte para especificadores de intervalo personalizado que não sejam de bytes (o especificador de intervalo de bytes definido na RFC 2616 pela IETF).  
  
 Um exemplo de um cabeçalho de intervalo em uma solicitação do protocolo HTTP que seriam solicitações os primeiros 100 bytes seria o seguinte:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Neste exemplo, o `rangeSpecifier` parâmetro deve ser especificado como "bytes", o `from` parâmetro seria 0 e o `to` parâmetro seria 99.  
  
 Um servidor HTTP indica suporte para cabeçalhos de intervalo com o cabeçalho Accept-Ranges na resposta. Um exemplo do cabeçalho Accept-Ranges de um servidor que oferece suporte a intervalos de bytes seria da seguinte maneira:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 A cadeia de caracteres especificada no cabeçalho Accept-Ranges é o especificador de intervalo que seria especificado no `rangeSpecifier` parâmetro desse método.  
  
 Se um cabeçalho Accept-Ranges não for recebido no cabeçalho da resposta do servidor, o servidor não oferece suporte a cabeçalhos de intervalo. Um exemplo do cabeçalho Accept-Ranges de um servidor que não oferece suporte a intervalos, mas reconhece o cabeçalho Accept-Ranges, seria da seguinte maneira:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Ao receber a resposta de uma solicitação de intervalo, somente os cabeçalhos HTTP associados com a solicitação inteira são analisados e disponibilizados por meio de propriedades no <xref:System.Net.HttpWebResponse> classe. Cabeçalhos associados a cada intervalo são retornados na resposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> é maior que <paramref name="to" />  
  
- ou - 
 <paramref name="from" /> ou <paramref name="to" /> é menor que 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> é inválido.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível adicionar o cabeçalho de intervalo.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="from" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="to" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">A descrição do intervalo.</param>
        <param name="from">A posição na qual iniciar o envio de dados.</param>
        <param name="to">A posição na qual interromper o envio de dados.</param>
        <summary>Adiciona um cabeçalho de intervalo a uma solicitação para um intervalo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método adiciona um cabeçalho de intervalo para a solicitação.  
  
 Uma vez que todas as entidades HTTP são representadas em mensagens HTTP como sequências de bytes, o conceito de um intervalo de bytes é significativo para qualquer entidade HTTP. No entanto, nem todos os clientes e servidores precisam dar suporte a operações de intervalo de bytes.  
  
 O cabeçalho de intervalo em uma solicitação permite que um cliente solicitar que ele só quer receber alguma parte do intervalo especificado de bytes em uma entidade HTTP. Servidores não são necessários para dar suporte a solicitações de cabeçalho de intervalo.  
  
 O `rangeSpecifier` parâmetro normalmente seria especificado como "bytes", já que este é o especificador de intervalo único reconhecido pela maioria dos servidores HTTP. Definindo o `rangeSpecifier` parâmetro para alguma outra cadeia de caracteres permite que o suporte para especificadores de intervalo personalizado que não sejam de bytes (o especificador de intervalo de bytes definido na RFC 2616 pela IETF).  
  
 Um exemplo de um cabeçalho de intervalo em uma solicitação do protocolo HTTP que seriam solicitações os primeiros 100 bytes seria o seguinte:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Neste exemplo, o `rangeSpecifier` parâmetro deve ser especificado como "bytes", o `from` parâmetro seria 0 e o `to` parâmetro seria 99.  
  
 Um servidor HTTP indica suporte para cabeçalhos de intervalo com o cabeçalho Accept-Ranges na resposta. Um exemplo do cabeçalho Accept-Ranges de um servidor que oferece suporte a intervalos de bytes seria da seguinte maneira:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 A cadeia de caracteres especificada no cabeçalho Accept-Ranges é o especificador de intervalo que seria especificado no `rangeSpecifier` parâmetro desse método.  
  
 Se um cabeçalho Accept-Ranges não for recebido no cabeçalho da resposta do servidor, o servidor não oferece suporte a cabeçalhos de intervalo. Um exemplo do cabeçalho Accept-Ranges de um servidor que não oferece suporte a intervalos, mas reconhece o cabeçalho Accept-Ranges, seria da seguinte maneira:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Ao receber a resposta de uma solicitação de intervalo, somente os cabeçalhos HTTP associados com a solicitação inteira são analisados e disponibilizados por meio de propriedades no <xref:System.Net.HttpWebResponse> classe. Cabeçalhos associados a cada intervalo são retornados na resposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> é maior que <paramref name="to" />  
  
- ou - 
 <paramref name="from" /> ou <paramref name="to" /> é menor que 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> é inválido.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível adicionar o cabeçalho de intervalo.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public Uri Address { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Address" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Address As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Address { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Address : Uri" Usage="System.Net.HttpWebRequest.Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o URI (Uniform Resource Identifier) do recurso de Internet que realmente responde à solicitação.</summary>
        <value>Um <see cref="T:System.Uri" /> que identifica o recurso de Internet que realmente responde à solicitação. O padrão é o URI usado pelo método <see cref="M:System.Net.WebRequest.Create(System.String)" /> para inicializar a solicitação.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.Address%2A> propriedade é definida como o URI depois de concluir qualquer redirecionamento que ocorrem durante a solicitação.  
  
 O URI da solicitação original é mantido no <xref:System.Net.HttpWebRequest.RequestUri%2A> propriedade.  
  
   
  
## Examples  
 O seguinte código de exemplo verifica se o <xref:System.Net.HttpWebRequest> objeto `req` foi redirecionado para outro local para atender à solicitação e define o valor da `hasChanged` variável para `true` se a solicitação foi redirecionada; caso contrário `hasChanged`é definido como `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAutoRedirect">
      <MemberSignature Language="C#" Value="public virtual bool AllowAutoRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAutoRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowAutoRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowAutoRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAutoRedirect : bool with get, set" Usage="System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a solicitação deve seguir as respostas de redirecionamento.</summary>
        <value><see langword="true" /> se a solicitação precisar seguir automaticamente as respostas de redirecionamento do recurso da Internet; caso contrário, <see langword="false" />. O valor padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definir <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> para `true` se você quiser que a solicitação para seguir automaticamente os cabeçalhos de redirecionamento de HTTP para o novo local do recurso. O número máximo de redirecionamentos a seguir é definido <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> propriedade.  
  
 Se <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> é definido como `false`, todas as respostas com um código de status HTTP de 300 a 399 é retornado ao aplicativo.  
  
 O cabeçalho de autorização está desmarcado na redirecionamentos automáticos e <xref:System.Net.HttpWebRequest> automaticamente tenta autenticar novamente para o local de redirecionamento. Na prática, isso significa que um aplicativo não é possível colocar informações de autenticação personalizada no cabeçalho de autorização, se for possível encontrar o redirecionamento. Em vez disso, o aplicativo deve implementar e registrar um módulo de autenticação personalizada. O <xref:System.Net.AuthenticationManager?displayProperty=nameWithType> e a classe relacionada são usados para implementar um módulo de autenticação personalizada. O <xref:System.Net.AuthenticationManager.Register%2A?displayProperty=nameWithType> método registra um módulo de autenticação personalizada.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> propriedade para permitir que a solicitação a seguir respostas de redirecionamento.  
  
 [!code-cpp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CPP/httpwebrequest_allowautoredirect.cpp#2)]
 [!code-csharp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CS/httpwebrequest_allowautoredirect.cs#2)]
 [!code-vb[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/VB/httpwebrequest_allowautoredirect.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowReadStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowReadStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowReadStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowReadStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowReadStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowReadStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o recebido do recurso da Internet deve ser armazenado em buffer.</summary>
        <value><see langword="true" /> para habilitar o armazenamento em buffer dos dados recebidos do recurso da Internet; <see langword="false" /> para desabilitar o armazenamento em buffer. O padrão é <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowWriteStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowWriteStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowWriteStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowWriteStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowWriteStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowWriteStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se os dados enviados para o recurso de Internet devem ser armazenados em buffer.</summary>
        <value><see langword="true" /> para habilitar o armazenamento em buffer dos dados enviados para o recurso da Internet, <see langword="false" /> para desabilitar o armazenamento em buffer. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> é `true`, os dados são armazenados em buffer na memória para que ele está pronto para ser reenviados no caso de redirecionamentos ou autenticação de solicitações.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> propriedade para desabilitar o buffer de dados.  
  
 [!code-cpp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CPP/httpwebrequest_allowwritestreambuffering.cpp#1)]
 [!code-csharp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CS/httpwebrequest_allowwritestreambuffering.cs#1)]
 [!code-vb[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/VB/httpwebrequest_allowwritestreambuffering.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Definindo <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> para <see langword="true" /> pode causar problemas de desempenho ao carregar grandes conjuntos de dados porque o buffer de dados poderia usar toda a memória disponível.</para></block>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDecompression">
      <MemberSignature Language="C#" Value="public System.Net.DecompressionMethods AutomaticDecompression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.DecompressionMethods AutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticDecompression As DecompressionMethods" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::DecompressionMethods AutomaticDecompression { System::Net::DecompressionMethods get(); void set(System::Net::DecompressionMethods value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticDecompression : System.Net.DecompressionMethods with get, set" Usage="System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.DecompressionMethods</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tipo de descompactação usada.</summary>
        <value>Um <see cref="T:System.Net.DecompressionMethods" /> objeto que indica o tipo de descompactação usado.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Estado atual do objeto não permite que esse tipo de propriedade seja definido.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetRequestStream">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetRequestStream (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetRequestStream(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetRequestStream (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetRequestStream(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetRequestStream : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetRequestStream (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="callback">O delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">O objeto de estado dessa solicitação.</param>
        <summary>Inicia uma solicitação assíncrona para um objeto <see cref="T:System.IO.Stream" /> a ser usado para gravar dados.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que faz referência à solicitação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método inicia uma solicitação assíncrona para um fluxo usado para enviar dados o <xref:System.Net.HttpWebRequest>. O método de retorno de chamada assíncrono usa a <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> método para retornar o fluxo real.  
  
 O <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método exige algumas tarefas de instalação síncrona para concluir (resolução de DNS, a detecção de proxy e conexão de soquete TCP, por exemplo) antes desse método se torna assíncrono. Como resultado, esse método nunca deve ser chamado em um thread de interface do usuário do usuário porque ele pode demorar um tempo considerável (até vários minutos dependendo das configurações de rede) para concluir as tarefas de configuração inicial de síncrona antes de uma exceção para um erro será gerado ou o método for bem-sucedido.  
  
 Para saber mais sobre o pool de threads, consulte [pool de threads gerenciados](~/docs/standard/threading/the-managed-thread-pool.md).  
  
> [!NOTE]
>  Seu aplicativo não pode combinar métodos síncronos e assíncronos para uma determinada solicitação. Se você chamar o <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método, você deve usar o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método para recuperar a resposta.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método para fazer uma solicitação assíncrona para uma instância de fluxo.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">A propriedade <see cref="P:System.Net.HttpWebRequest.Method" /> é GET ou HEAD.  
  
- ou - 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> é <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> é <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> é -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> é <see langword="false" /> e <see cref="P:System.Net.HttpWebRequest.Method" /> é POST ou PUT.</exception>
        <exception cref="T:System.InvalidOperationException">O fluxo está sendo usado por uma chamada anterior a <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />  
  
- ou - 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> é definido como um valor e <see cref="P:System.Net.HttpWebRequest.SendChunked" /> é <see langword="false" />.  
  
- ou - 
O pool de threads está ficando sem threads.</exception>
        <exception cref="T:System.NotSupportedException">O validador de cache de solicitações indicou que a resposta para essa solicitação pode ser atendida no cache; no entanto, as solicitações que gravam dados não devem usar o cache. Essa exceção poderá ocorrer se você estiver usando um validador de cache personalizado implementado incorretamente.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> foi chamado anteriormente.</exception>
        <exception cref="T:System.ObjectDisposedException">Em um aplicativo .NET Compact Framework, um fluxo de solicitação com tamanho de conteúdo zero não foi obtido e fechado corretamente. Para obter mais informações sobre como tratar solicitações de tamanho de conteúdo zero, consulte [Programação de rede no .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Elemento DefaultProxy (configurações de rede)</related>
      </Docs>
    </Member>
    <Member MemberName="BeginGetResponse">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetResponse (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetResponse(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetResponse (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetResponse(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetResponse : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetResponse (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="callback">O delegado <see cref="T:System.AsyncCallback" /></param>
        <param name="state">O objeto de estado dessa solicitação.</param>
        <summary>Inicia uma solicitação assíncrona para um recurso da Internet.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que faz referência à solicitação assíncrona de uma resposta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método inicia uma solicitação assíncrona para uma resposta do recurso da Internet. O método de retorno de chamada assíncrono usa a <xref:System.Net.HttpWebRequest.EndGetResponse%2A> método para retornar o valor real <xref:System.Net.WebResponse>.  
  
 Um <xref:System.Net.ProtocolViolationException> é gerada em vários casos, quando as propriedades definidas no <xref:System.Net.HttpWebRequest> classe estão em conflito. Essa exceção ocorre se um aplicativo define a <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade e o <xref:System.Net.HttpWebRequest.SendChunked%2A> propriedade `true`e, em seguida, envia uma solicitação HTTP GET. Essa exceção ocorre se um aplicativo tentar enviar em partes para um servidor que só dá suporte ao protocolo HTTP 1.0, em que isso não é suportado. Essa exceção ocorre se um aplicativo tentar enviar dados sem definir a <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade ou o <xref:System.Net.HttpWebRequest.SendChunked%2A> é `false` quando o buffer está desativado e em uma conexão de keepalive (o <xref:System.Net.HttpWebRequest.KeepAlive%2A> é de propriedade `true`)`.`  
  
 Se um <xref:System.Net.WebException> é gerada, use o <xref:System.Net.WebException.Response%2A> e <xref:System.Net.WebException.Status%2A> propriedades da exceção para determinar a resposta do servidor.  
  
 O <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método exige algumas tarefas de instalação síncrona para concluir (resolução de DNS, a detecção de proxy e conexão de soquete TCP, por exemplo) antes desse método se torna assíncrono. Como resultado, esse método nunca deve ser chamado em um thread de interface do usuário do usuário porque ele pode demorar um tempo considerável (até vários minutos dependendo das configurações de rede) para concluir as tarefas de configuração inicial de síncrona antes de uma exceção para um erro será gerado ou o método for bem-sucedido.  
  
 Para saber mais sobre o pool de threads, consulte [pool de threads gerenciados](~/docs/standard/threading/the-managed-thread-pool.md).  
  
> [!NOTE]
>  Seu aplicativo não pode combinar métodos síncronos e assíncronos para uma determinada solicitação. Se você chamar o <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método, você deve usar o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método para recuperar a resposta.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método para fazer uma solicitação assíncrona para um recurso da Internet.  
  
> [!NOTE]
>  No caso de solicitações assíncronas, é responsabilidade do aplicativo cliente para implementar seu próprio mecanismo de tempo limite. O exemplo de código a seguir mostra como fazer isso.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O fluxo já está sendo usado por uma chamada anterior a <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />  
  
- ou - 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> é definido como um valor e <see cref="P:System.Net.HttpWebRequest.SendChunked" /> é <see langword="false" />.  
  
- ou - 
O pool de threads está ficando sem threads.</exception>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.HttpWebRequest.Method" /> é GET ou HEAD e <see cref="P:System.Net.HttpWebRequest.ContentLength" /> é maior que zero ou <see cref="P:System.Net.HttpWebRequest.SendChunked" /> é <see langword="true" />.  
  
- ou - 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> é <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> é <see langword="false" />, e <see cref="P:System.Net.HttpWebRequest.ContentLength" /> é -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> é <see langword="false" /> e <see cref="P:System.Net.HttpWebRequest.Method" /> é POST ou PUT.  
  
- ou - 
O <see cref="T:System.Net.HttpWebRequest" /> tem um corpo de entidade, mas o método <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> é chamado sem chamar o método <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.  
  
- ou - 
O <see cref="P:System.Net.HttpWebRequest.ContentLength" /> é maior que zero, mas o aplicativo não grava todos os dados prometidos.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> foi chamado anteriormente.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Elemento DefaultProxy (configurações de rede)</related>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); void set(System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection with get, set" Usage="System.Net.HttpWebRequest.ClientCertificates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a coleção de certificados de segurança que estão associadas essa solicitação.</summary>
        <value>Um <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> que contém os certificados de segurança associados a essa solicitação.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um aplicativo pode adicionar um certificado a uma coleção, mas pode não ter direitos de acesso a ele. Para usar um certificado contido na coleção, o aplicativo deve ter os mesmos direitos de acesso que a entidade que emitiu o certificado.  
  
> [!NOTE]
>  O Framework armazena em cache as sessões de SSL conforme eles são criados e tenta reutilizar uma sessão em cache para uma nova solicitação, se possível. Ao tentar reutilizar uma sessão SSL, a estrutura usa o primeiro elemento da <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (se houver um), ou tenta reutilizar um sessões anônimas se <xref:System.Net.HttpWebRequest.ClientCertificates%2A> está vazio.  
  
> [!NOTE]
>  Por motivos de desempenho, você não deve adicionar um certificado de cliente para um <xref:System.Net.HttpWebRequest> , a menos que você sabe que o servidor será pedi-lo.  
>   
>  Para obter um exemplo de código que ilustram como enumerar os certificados no repositório de certificados de cliente, consulte o <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor especificado para uma operação de definição é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public string Connection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Connection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Connection" />
      <MemberSignature Language="VB.NET" Value="Public Property Connection As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Connection { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Connection : string with get, set" Usage="System.Net.HttpWebRequest.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor do cabeçalho HTTP <see langword="Connection" />.</summary>
        <value>O valor do cabeçalho HTTP <see langword="Connection" />. O valor padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Envia a solicitação a <xref:System.Net.HttpWebRequest.Connection%2A> propriedade para o recurso de Internet como o `Connection` cabeçalho HTTP. Se o valor da <xref:System.Net.HttpWebRequest.KeepAlive%2A> é de propriedade `true`, o valor de "Keep-alive" é acrescentado ao final do `Connection` cabeçalho.  
  
 Para limpar os `Connection` cabeçalho HTTP, defina o <xref:System.Net.HttpWebRequest.Connection%2A> propriedade `null`.  
  
 Alterando a <xref:System.Net.HttpWebRequest.Connection%2A> propriedade depois que a solicitação foi iniciada chamando o <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, ou <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método lança um <xref:System.InvalidOperationException>.  
  
> [!NOTE]
>  O valor dessa propriedade é armazenado em <xref:System.Net.WebHeaderCollection>. Se WebHeaderCollection for definido, o valor da propriedade será perdido.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Net.HttpWebRequest.Connection%2A> propriedade para definir o valor do cabeçalho de HTTP de Conexão.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor de <see cref="P:System.Net.HttpWebRequest.Connection" /> é definido como Keep-alive ou Fechar.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionGroupName">
      <MemberSignature Language="C#" Value="public override string ConnectionGroupName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionGroupName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionGroupName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionGroupName : string with get, set" Usage="System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nome do grupo de conexões para a solicitação.</summary>
        <value>O nome do grupo de conexão para essa solicitação. O valor padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> propriedade permite que você associe uma solicitação um grupo de conexão. Isso é útil quando seu aplicativo fizer solicitações para um servidor para usuários diferentes, como um site da Web que recupera informações do cliente de um servidor de banco de dados.  
  
   
  
## Examples  
 O exemplo de código a seguir mostram como usar informações do usuário para formar um grupo de conexão, supondo que as variáveis `username`, `password`, e `domain` são definidas pelo aplicativo antes que esse código é chamado.  
  
 [!code-cpp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Cada grupo de conexão cria conexões adicionais para um servidor. Isso pode resultar em exceder o número de conexões definida <see cref="P:System.Net.ServicePoint.ConnectionLimit" /> propriedade para o servidor.</para></block>
        <altmember cref="P:System.Net.Configuration.ConnectionManagementElement.MaxConnection" />
        <altmember cref="P:System.Net.WebRequest.ConnectionGroupName" />
        <related type="Article" href="~/docs/framework/network-programming/connection-grouping.md">Agrupamento de conexão</related>
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public override long ContentLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long ContentLength { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength : int64 with get, set" Usage="System.Net.HttpWebRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o cabeçalho HTTP <see langword="Content-length" />.</summary>
        <value>O número de bytes de dados a serem enviados ao recurso de Internet. O padrão é -1, que indica que a propriedade não foi definida e que não há dados de solicitação para enviar.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade contém o valor para enviar como o `Content-length` cabeçalho HTTP com a solicitação.  
  
 Qualquer valor diferente de -1 na <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade indica que a solicitação carrega dados e que somente os métodos que carregam dados podem ser definidas no <xref:System.Net.HttpWebRequest.Method%2A> propriedade.  
  
 Após o <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade é definida como um valor, esse número de bytes deve ser gravado no fluxo de solicitação que é retornado ao chamar o <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método ou ambos os <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> e o <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> métodos.  
  
> [!NOTE]
>  O valor dessa propriedade é armazenado em <xref:System.Net.WebHeaderCollection>. Se WebHeaderCollection for definido, o valor da propriedade será perdido.  
  
   
  
## Examples  
 O seguinte exemplo de código define o <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade para o comprimento da cadeia de caracteres que está sendo lançada.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A solicitação foi iniciada chamando o método <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> ou <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O novo valor <see cref="P:System.Net.HttpWebRequest.ContentLength" /> é menor que 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public override string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Net.HttpWebRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor do cabeçalho HTTP <see langword="Content-type" />.</summary>
        <value>O valor do cabeçalho HTTP <see langword="Content-type" />. O valor padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.ContentType%2A> propriedade contém o tipo de mídia da solicitação. Valores atribuídos para o <xref:System.Net.HttpWebRequest.ContentType%2A> propriedade substituir qualquer conteúdo existente quando a solicitação envia o `Content-type` cabeçalho HTTP.  
  
 Para limpar os `Content-type` cabeçalho HTTP, defina o <xref:System.Net.HttpWebRequest.ContentType%2A> propriedade `null`.  
  
> [!NOTE]
>  O valor dessa propriedade é armazenado em <xref:System.Net.WebHeaderCollection> . Se <xref:System.Net.WebHeaderCollection> for definido, o valor da propriedade será perdido.  
  
   
  
## Examples  
 O seguinte exemplo de código define o <xref:System.Net.HttpWebRequest.ContentType%2A> propriedade.  
  
 [!code-cpp[HttpWebRequest_ContentLength#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#1)]
 [!code-csharp[HttpWebRequest_ContentLength#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#1)]
 [!code-vb[HttpWebRequest_ContentLength#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpContinueDelegate ContinueDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpContinueDelegate ContinueDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueDelegate As HttpContinueDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpContinueDelegate ^ ContinueDelegate { System::Net::HttpContinueDelegate ^ get(); void set(System::Net::HttpContinueDelegate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueDelegate : System.Net.HttpContinueDelegate with get, set" Usage="System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpContinueDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o método delegado chamado quando uma resposta 100-continue HTTP é recebida do recurso da Internet.</summary>
        <value>Um delegado que implementa o método de retorno de chamada que é executado quando uma resposta HTTP continuar é retornada do recurso da Internet. O valor padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> propriedade especifica o método de retorno de chamada para chamar quando o cliente recebe um 100-Continue a resposta.  
  
 Quando o <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> propriedade for definida, o cliente chama o delegado sempre que as respostas do tipo de protocolo <xref:System.Net.HttpStatusCode.Continue?displayProperty=nameWithType> (100) são recebidas. Isso é útil se você quiser que o cliente para exibir o status dos dados que estão sendo recebidos do recurso da Internet.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public int ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContinueTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um tempo limite, em milissegundos, para aguardar até que o 100-Continue seja recebido do servidor.</summary>
        <value>O tempo limite, em milissegundos, para aguardar até que o 100-Continue seja recebido.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o 100-Continue a resposta for recebida antes que o tempo limite expirar, o corpo da entidade pode ser enviado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieContainer">
      <MemberSignature Language="C#" Value="public virtual System.Net.CookieContainer CookieContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieContainer CookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.CookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CookieContainer As CookieContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::CookieContainer ^ CookieContainer { System::Net::CookieContainer ^ get(); void set(System::Net::CookieContainer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CookieContainer : System.Net.CookieContainer with get, set" Usage="System.Net.HttpWebRequest.CookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CookieContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define os cookies associados à solicitação.</summary>
        <value>Um <see cref="T:System.Net.CookieContainer" /> que contém os cookies associados a essa solicitação.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.CookieContainer%2A> propriedade fornece uma instância da <xref:System.Net.CookieContainer> classe que contém os cookies associados a esta solicitação.  
  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A> é `null` por padrão. Você deve atribuir um <xref:System.Net.CookieContainer> objeto para a propriedade para que cookies retornada na <xref:System.Net.HttpWebResponse.Cookies%2A> propriedade da <xref:System.Net.HttpWebResponse> retornado pelo <xref:System.Net.HttpWebRequest.GetResponse%2A> método.  
  
> [!NOTE]
>  Por motivos de segurança, os cookies estão desabilitados por padrão. Se você quiser usar cookies, use o <xref:System.Net.HttpWebRequest.CookieContainer%2A> propriedade para habilitar cookies.  
  
   
  
## Examples  
 O exemplo de código a seguir envia uma solicitação para uma URL e exibe os cookies retornados na resposta.  
  
 [!code-cpp[NCLCookies#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLCookies/CPP/cookiessnippets.cpp#1)]
 [!code-csharp[NCLCookies#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLCookies/CS/cookiessnippets.cs#1)]
 [!code-vb[NCLCookies#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLCookies/VB/cookiessnippets.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.CookieContainer" />
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Net.ICredentials with get, set" Usage="System.Net.HttpWebRequest.Credentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define informações de autenticação para a solicitação.</summary>
        <value>Um <see cref="T:System.Net.ICredentials" /> que contém as credenciais de autenticação associadas à solicitação. O padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.Credentials%2A> propriedade contém informações de autenticação para identificar o criador da solicitação. O <xref:System.Net.HttpWebRequest.Credentials%2A> propriedade pode ser um <xref:System.Net.NetworkCredential>, no qual caso o usuário, senha e informações de domínio contidas na <xref:System.Net.NetworkCredential> objeto é usado para autenticar a solicitação, ou pode ser um <xref:System.Net.CredentialCache>, caso em que o Uniform Resource Identificador (URI) da solicitação é usado para determinar o usuário, senha e informações de domínio para usar para autenticar a solicitação.  
  
 Na maioria dos cenários de cliente, você deve usar o <xref:System.Net.CredentialCache.DefaultCredentials%2A> propriedade, que contém as credenciais do usuário conectado no momento. Para fazer isso, defina as <xref:System.Net.WebClient.UseDefaultCredentials%2A> propriedade para `true` em vez de definir essa propriedade.  
  
 Se o <xref:System.Net.HttpWebRequest> classe está sendo usado em um aplicativo de camada intermediária, como um aplicativo ASP.NET, as credenciais no <xref:System.Net.CredentialCache.DefaultCredentials%2A> propriedade pertence à conta de execução da página ASP (as credenciais do lado do servidor). Normalmente, você deve definir essa propriedade para as credenciais do cliente em cujo nome a solicitação é feita.  
  
> [!NOTE]
>  O esquema de autenticação NTLM não pode ser usado para representar outro usuário. Kerberos deve ser configurado especialmente para dar suporte a representação.  
  
 Para restringir HttpWebRequest para um ou mais métodos de autenticação, use o <xref:System.Net.CredentialCache> de classe e associar suas credenciais para um ou mais esquemas de autenticação  
  
 Esquemas de autenticação com suporte incluem Digest, Negotiate, Kerberos, NTLM e Basic.  
  
 Por motivos de segurança, quando segue automaticamente redirecionamentos, armazenar as credenciais que você deseja incluir no redirecionamento em um <xref:System.Net.CredentialCache> e atribuí-la a essa propriedade. Essa propriedade será definida automaticamente `null` após o redirecionamento se ele contiver qualquer coisa, exceto um <xref:System.Net.CredentialCache>. Ter esse valor da propriedade ser definida automaticamente como `null` sob essas condições impede que as credenciais que estão sendo enviados para qualquer destino não intencional.
  
## Examples  
 O exemplo de código a seguir define as credenciais para uma solicitação.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Date" />
      <MemberSignature Language="VB.NET" Value="Public Property Date As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Date { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.Date : DateTime with get, set" Usage="System.Net.HttpWebRequest.Date" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor do cabeçalho HTTP <see langword="Date" /> a ser usado em uma solicitação HTTP.</summary>
        <value>O valor do cabeçalho de Data na solicitação HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o cabeçalho de data estiver `null`, em seguida, o valor retornado será definido como <xref:System.DateTime.MinValue?displayProperty=nameWithType>.  
  
 O <xref:System.Net.HttpWebRequest.Date%2A> propriedade é um padrão <xref:System.DateTime?displayProperty=nameWithType> do objeto e pode conter um <xref:System.DateTimeKind?displayProperty=nameWithType> campo <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, ou <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Qualquer tipo de tempo pode ser definido ao usar o <xref:System.Net.HttpWebRequest.Date%2A> propriedade. Se <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> é definido ou recuperado, o <xref:System.Net.HttpWebRequest.Date%2A> propriedade será considerada como <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (hora local).  
  
 As classes de <xref:System.Net> namespace sempre gravá-los a <xref:System.Net.HttpWebRequest.Date%2A> propriedade durante a transmissão durante a transmissão na forma padrão usando o formato GMT (Utc).  
  
 Se o <xref:System.Net.HttpWebRequest.Date%2A> estiver definida como <xref:System.DateTime.MinValue?displayProperty=nameWithType>, em seguida, a `Date` cabeçalho HTTP é removido do <xref:System.Net.HttpWebRequest.Headers%2A> propriedade e o <xref:System.Net.WebHeaderCollection>.  
  
 Se o <xref:System.Net.HttpWebRequest.Date%2A> é de propriedade <xref:System.DateTime.MinValue?displayProperty=nameWithType>, isso indica que o `Date` cabeçalho HTTP não está incluído no <xref:System.Net.HttpWebRequest.Headers%2A> propriedade e o <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  O valor dessa propriedade é armazenado em <xref:System.Net.WebHeaderCollection>. Se WebHeaderCollection for definido, o valor da propriedade será perdido.  
  
 Se o <xref:System.Net.HttpWebRequest.Date%2A> é definido e é feita uma tentativa de enviar uma <xref:System.Net.HttpWebRequest> sem corpo, em seguida, um <xref:System.Net.ProtocolViolationException?displayProperty=nameWithType> serão geradas pela <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, e <xref:System.Net.HttpWebRequest.EndGetResponse%2A> métodos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCachePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Cache.RequestCachePolicy DefaultCachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Cache.RequestCachePolicy DefaultCachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultCachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Cache::RequestCachePolicy ^ DefaultCachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCachePolicy : System.Net.Cache.RequestCachePolicy with get, set" Usage="System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a política de cache padrão para essa solicitação.</summary>
        <value>Um <see cref="T:System.Net.Cache.HttpRequestCachePolicy" /> que especifica a política de cache em vigor para essa solicitação quando nenhuma outra política é aplicável.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A definição dessa propriedade registra a política especificada para os esquemas de HTTP e HTTPS. Essa política é usada para essa solicitação se:  
  
 Não há nenhum <xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType> propriedade especificada para esta solicitação.  
  
- ou -
  
 A configuração de máquina e do aplicativo que arquivos não especificar uma política de cache que é aplicável para o identificador de URI (Uniform Resource) usado para criar essa solicitação.  
  
 A política de cache determina se o recurso solicitado pode ser obtido de um cache em vez de enviar a solicitação para o computador de host do recurso.  
  
 Uma cópia de um recurso somente é adicionada ao cache se o fluxo de resposta para o recurso é recuperado e ler até o final do fluxo. Portanto, outra solicitação para o mesmo recurso pode usar uma cópia armazenada em cache, dependendo do nível de política de cache para esta solicitação.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Para obter acesso irrestrito aos recursos da rede. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.Cache.RequestCachePolicy" />
        <altmember cref="T:System.Net.Cache.HttpRequestCacheLevel" />
        <altmember cref="T:System.Net.Cache.RequestCacheLevel" />
        <altmember cref="P:System.Net.WebRequest.CachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumErrorResponseLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumErrorResponseLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumErrorResponseLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumErrorResponseLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumErrorResponseLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tamanho máximo padrão de uma resposta de erro HTTP.</summary>
        <value>O tamanho máximo padrão de uma resposta de erro HTTP.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor é menor que 0 e não é igual a -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor padrão para a propriedade <see cref="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />.</summary>
        <value>O comprimento, em quilobytes (1024 bytes), do padrão máximo para cabeçalhos de resposta recebidos. O arquivo de configuração padrão define esse valor como 64 quilobytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O comprimento do cabeçalho da resposta recebida a linha de status de resposta e quaisquer caracteres de controle extra que são recebidos como parte do protocolo HTTP. Um valor de-1 significa que sem limite é imposto nos cabeçalhos de resposta recebidos; um valor de 0 significa que todas as solicitações falham.  
  
 Esse valor também pode ser alterado no arquivo de configuração. O impacto dessa propriedade pode ser substituído pela configuração de <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> propriedade em uma instância da <xref:System.Net.HttpWebRequest> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor não é igual a -1 e é menor que zero.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndGetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Encerra uma solicitação assíncrona para um objeto <see cref="T:System.IO.Stream" /> a ser usado para gravar dados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetRequestStream (asyncResult As IAsyncResult) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">A solicitação pendente de um fluxo.</param>
        <summary>Encerra uma solicitação assíncrona para um objeto <see cref="T:System.IO.Stream" /> a ser usado para gravar dados.</summary>
        <returns>Um <see cref="T:System.IO.Stream" /> a ser usado para gravar dados de solicitação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> uma solicitação assíncrona para um fluxo que foi iniciada pela conclusão do método a <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método. Após o <xref:System.IO.Stream> objeto foi retornado, você pode enviar dados com o <xref:System.Net.HttpWebRequest> usando o <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> método.  
  
> [!NOTE]
>  Você deve definir o valor da <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade antes de gravar dados no fluxo.  
  
> [!CAUTION]
>  Você deve chamar o <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> método para fechar o fluxo e liberar a conexão para reutilização. Falha ao fechar o fluxo faz com que seu aplicativo seja executado sem conexões.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> método para encerrar uma solicitação assíncrona para uma instância de fluxo.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">A solicitação não foi concluída e nenhum fluxo está disponível.</exception>
        <exception cref="T:System.ArgumentException">O <paramref name="asyncResult" /> não foi retornado pela instância atual de uma chamada a <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Esse método foi chamado anteriormente usando <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> foi chamado anteriormente.  
  
- ou - 
Ocorreu um erro ao processar a solicitação.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; context) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef context As TransportContext) As Stream" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; transportContext) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef transportContext As TransportContext) As Stream" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult *  -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream (asyncResult, transportContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="context" Type="System.Net.TransportContext" RefType="out" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="transportContext" Type="System.Net.TransportContext" RefType="out" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">A solicitação pendente de um fluxo.</param>
        <param name="context">O <see cref="T:System.Net.TransportContext" /> para o <see cref="T:System.IO.Stream" />.</param>
        <param name="transportContext">O <see cref="T:System.Net.TransportContext" /> para o <see cref="T:System.IO.Stream" />.</param>
        <summary>Encerra uma solicitação assíncrona para um objeto <see cref="T:System.IO.Stream" /> a ser usado para gravar os dados e produz como saída o <see cref="T:System.Net.TransportContext" /> associado ao fluxo.</summary>
        <returns>Um <see cref="T:System.IO.Stream" /> a ser usado para gravar dados de solicitação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> uma solicitação assíncrona para um fluxo que foi iniciada pela conclusão do método a <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método e as saídas a <xref:System.Net.TransportContext> associado ao fluxo. Após o <xref:System.IO.Stream> objeto foi retornado, você pode enviar dados com o <xref:System.Net.HttpWebRequest> usando o <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> método.  
  
 Talvez seja necessário consultar a camada de transporte usada por alguns aplicativos que usam autenticação integrada do Windows com proteção estendida <xref:System.Net.HttpWebRequest> para recuperar o token de associação de canal (CBT) de canal TLS subjacente. O <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método fornece acesso a essas informações para os métodos HTTP que têm um corpo de solicitação (`POST` e `PUT` solicitações). Isso é necessário apenas se o aplicativo é implementar sua própria autenticação e precisa acessar o CBT.  
  
> [!NOTE]
>  Se um aplicativo precisar definir o valor da <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade, em seguida, isso deve ser feito antes de recuperar o fluxo e gravando dados nela.  
  
> [!CAUTION]
>  Você deve chamar o <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> método para fechar o fluxo e liberar a conexão para reutilização. Falha ao fechar o fluxo faz com que seu aplicativo seja executado sem conexões.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> não foi retornado pela instância atual de uma chamada para <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Esse método foi chamado anteriormente usando <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.IO.IOException">A solicitação não foi concluída e nenhum fluxo está disponível.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> foi chamado anteriormente.  
  
- ou - 
Ocorreu um erro ao processar a solicitação.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Autenticação Integrada do Windows com proteção estendida</related>
      </Docs>
    </Member>
    <Member MemberName="EndGetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse EndGetResponse (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse EndGetResponse(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetResponse(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetResponse (asyncResult As IAsyncResult) As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ EndGetResponse(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetResponse : IAsyncResult -&gt; System.Net.WebResponse" Usage="httpWebRequest.EndGetResponse asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">A solicitação pendente para uma resposta.</param>
        <summary>Encerra uma solicitação assíncrona para um recurso da Internet.</summary>
        <returns>Um <see cref="T:System.Net.WebResponse" /> que contém a resposta do recurso da Internet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.EndGetResponse%2A> método conclui uma solicitação assíncrona para um recurso de Internet que foi iniciada chamando o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método.  
  
> [!CAUTION]
>  Você deve chamar o <xref:System.Net.HttpWebResponse.Close%2A> método para fechar o fluxo e liberar a conexão. Falha ao fazer isso pode causar o aplicativo seja executado sem conexões.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Net.HttpWebRequest.EndGetResponse%2A> método para encerrar uma solicitação assíncrona para um recurso da Internet.  
  
 [!code-cpp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CPP/httpwebrequest_begingetresponse.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CS/httpwebrequest_begingetresponse.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/VB/httpwebrequest_begingetresponse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Esse método foi chamado anteriormente usando <paramref name="asyncResult." />  
  
- ou - 
A propriedade <see cref="P:System.Net.HttpWebRequest.ContentLength" /> é maior que 0, mas os dados não foram gravados no fluxo de solicitação.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> foi chamado anteriormente.  
  
- ou - 
Ocorreu um erro ao processar a solicitação.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> não foi retornado pela instância atual de uma chamada para <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expect">
      <MemberSignature Language="C#" Value="public string Expect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Expect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Expect" />
      <MemberSignature Language="VB.NET" Value="Public Property Expect As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Expect { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Expect : string with get, set" Usage="System.Net.HttpWebRequest.Expect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor do cabeçalho HTTP <see langword="Expect" />.</summary>
        <value>O conteúdo do cabeçalho HTTP <see langword="Expect" />. O valor padrão é <see langword="null" />.  
  
 <block subset="none" type="note"><para>  
 O valor dessa propriedade é armazenado em <see cref="T:System.Net.WebHeaderCollection" />. Se WebHeaderCollection for definido, o valor da propriedade será perdido.  
  
</para></block></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><see langword="Expect" /> é definido como uma cadeia de caracteres que contém "100-continue" como uma subcadeia de caracteres.</exception>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Elemento DefaultProxy (configurações de rede)</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="httpWebRequest.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor de hash para uma instância de <see cref="T:System.Net.WebRequest" />.</summary>
        <returns>Um valor de hash inteiro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
O método GetHashCode retorna um código hash da solicitação da web. Esse valor pode ser usado como uma chave em tabelas de hash.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected override void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="httpWebRequest.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">O <see cref="T:System.Runtime.Serialization.SerializationInfo" /> a ser preenchido com dados.</param>
        <param name="streamingContext">Um <see cref="T:System.Runtime.Serialization.StreamingContext" /> que especifica o destino dessa serialização.</param>
        <summary>Popula um <see cref="T:System.Runtime.Serialization.SerializationInfo" /> com os dados necessários para serializar o objeto de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos os objetos incluídos no <xref:System.Runtime.Serialization.SerializationInfo> são automaticamente rastreadas e serializado pelo formatador.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém um objeto <see cref="T:System.IO.Stream" /> a ser usado para gravar dados de solicitação.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetRequestStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetRequestStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetRequestStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ GetRequestStream();" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream : unit -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém um objeto <see cref="T:System.IO.Stream" /> a ser usado para gravar dados de solicitação.</summary>
        <returns>Um <see cref="T:System.IO.Stream" /> a ser usado para gravar dados de solicitação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método retorna um fluxo a ser usado para enviar dados o <xref:System.Net.HttpWebRequest>. Após o <xref:System.IO.Stream> objeto foi retornado, você pode enviar dados com o <xref:System.Net.HttpWebRequest> usando o <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> método.  
  
 Se um aplicativo precisar definir o valor da <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade, em seguida, isso deve ser feito antes de recuperar o fluxo.  
  
 Você deve chamar o <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> método para fechar o fluxo e liberar a conexão para reutilização. Falha ao fechar o fluxo faz com que seu aplicativo seja executado sem conexões.  
  
> [!NOTE]
>  Seu aplicativo não pode combinar métodos síncronos e assíncronos para uma determinada solicitação. Se você chamar o <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método, você deve usar o <xref:System.Net.HttpWebRequest.GetResponse%2A> método para recuperar a resposta.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método para retornar uma instância de fluxo.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">A propriedade <see cref="P:System.Net.HttpWebRequest.Method" /> é GET ou HEAD.  
  
- ou - 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> é <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> é <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> é -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> é <see langword="false" /> e <see cref="P:System.Net.HttpWebRequest.Method" /> é POST ou PUT.</exception>
        <exception cref="T:System.InvalidOperationException">O método <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> é chamado mais de uma vez.  
  
- ou - 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> é definido como um valor e <see cref="P:System.Net.HttpWebRequest.SendChunked" /> é <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">O validador de cache de solicitações indicou que a resposta para essa solicitação pode ser atendida no cache; no entanto, as solicitações que gravam dados não devem usar o cache. Essa exceção poderá ocorrer se você estiver usando um validador de cache personalizado implementado incorretamente.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> foi chamado anteriormente.  
  
- ou - 
O período de tempo limite da solicitação expirou.  
  
- ou - 
Ocorreu um erro ao processar a solicitação.</exception>
        <exception cref="T:System.ObjectDisposedException">Em um aplicativo .NET Compact Framework, um fluxo de solicitação com tamanho de conteúdo zero não foi obtido e fechado corretamente. Para obter mais informações sobre como tratar solicitações de tamanho de conteúdo zero, consulte [Programação de rede no .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Elemento DefaultProxy (configurações de rede)</related>
      </Docs>
    </Member>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetRequestStream (out System.Net.TransportContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetRequestStream([out] class System.Net.TransportContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream(System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRequestStream (ByRef context As TransportContext) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetRequestStream([Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream :  -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Net.TransportContext" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="context">O <see cref="T:System.Net.TransportContext" /> para o <see cref="T:System.IO.Stream" />.</param>
        <summary>Obtém um objeto <see cref="T:System.IO.Stream" /> a ser usado para gravar os dados de solicitação e gera o <see cref="T:System.Net.TransportContext" /> associado ao fluxo.</summary>
        <returns>Um <see cref="T:System.IO.Stream" /> a ser usado para gravar dados de solicitação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método retorna um fluxo a ser usado para enviar dados o <xref:System.Net.HttpWebRequest> e gera o <xref:System.Net.TransportContext> associado ao fluxo. Após o <xref:System.IO.Stream> objeto foi retornado, você pode enviar dados com o <xref:System.Net.HttpWebRequest> usando o <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> método.  
  
 Talvez seja necessário consultar a camada de transporte usada por alguns aplicativos que usam autenticação integrada do Windows com proteção estendida <xref:System.Net.HttpWebRequest> para recuperar o token de associação de canal (CBT) de canal TLS subjacente. O <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método fornece acesso a essas informações para os métodos HTTP que têm um corpo de solicitação (`POST` e `PUT` solicitações). Isso é necessário apenas se o aplicativo é implementar sua própria autenticação e precisa acessar o CBT.  
  
 Se um aplicativo precisar definir o valor da <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade, em seguida, isso deve ser feito antes de recuperar o fluxo.  
  
 Você deve chamar o <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> método para fechar o fluxo e liberar a conexão para reutilização. Falha ao fechar o fluxo faz com que seu aplicativo seja executado sem conexões.  
  
> [!NOTE]
>  Seu aplicativo não pode combinar métodos síncronos e assíncronos para uma determinada solicitação. Se você chamar o <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método, você deve usar o <xref:System.Net.HttpWebRequest.GetResponse%2A> método para recuperar a resposta.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">O método <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> não pôde obter o <see cref="T:System.IO.Stream" />.</exception>
        <exception cref="T:System.InvalidOperationException">O método <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> é chamado mais de uma vez.  
  
- ou - 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> é definido como um valor e <see cref="P:System.Net.HttpWebRequest.SendChunked" /> é <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">O validador de cache de solicitações indicou que a resposta para essa solicitação pode ser atendida no cache; no entanto, as solicitações que gravam dados não devem usar o cache. Essa exceção poderá ocorrer se você estiver usando um validador de cache personalizado implementado incorretamente.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">A propriedade <see cref="P:System.Net.HttpWebRequest.Method" /> é GET ou HEAD.  
  
- ou - 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> é <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> é <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> é -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> é <see langword="false" /> e <see cref="P:System.Net.HttpWebRequest.Method" /> é POST ou PUT.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> foi chamado anteriormente.  
  
- ou - 
O período de tempo limite da solicitação expirou.  
  
- ou - 
Ocorreu um erro ao processar a solicitação.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Autenticação Integrada do Windows com proteção estendida</related>
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse GetResponse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse GetResponse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetResponse () As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ GetResponse();" />
      <MemberSignature Language="F#" Value="override this.GetResponse : unit -&gt; System.Net.WebResponse" Usage="httpWebRequest.GetResponse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma resposta de um recurso da Internet.</summary>
        <returns>Um <see cref="T:System.Net.WebResponse" /> que contém a resposta do recurso da Internet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.GetResponse%2A> método retorna um <xref:System.Net.WebResponse> objeto que contém a resposta do recurso da Internet. A instância real retornada é um <xref:System.Net.HttpWebResponse>e pode ser estereotipado para essa classe para acessar propriedades específicas de HTTP.  
  
 Um <xref:System.Net.ProtocolViolationException> é gerada em vários casos, quando as propriedades definidas no <xref:System.Net.HttpWebRequest> classe estão em conflito. Essa exceção ocorre se um aplicativo define a <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade e o <xref:System.Net.HttpWebRequest.SendChunked%2A> propriedade `true`e, em seguida, envia uma solicitação HTTP GET. Essa exceção ocorre se um aplicativo tentar enviar em partes para um servidor que só dá suporte ao protocolo HTTP 1.0, em que isso não é suportado. Essa exceção ocorre se um aplicativo tentar enviar dados sem definir a <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade ou o <xref:System.Net.HttpWebRequest.SendChunked%2A> é `false` quando o buffer está desativado e em uma conexão de keepalive (o <xref:System.Net.HttpWebRequest.KeepAlive%2A> é de propriedade `true`)`.`  
  
> [!CAUTION]
>  Você deve chamar o <xref:System.Net.HttpWebResponse.Close%2A> método para fechar o fluxo e liberar a conexão. Falha ao fazer isso pode causar o aplicativo seja executado sem conexões.  
  
 Ao usar o método POST, obtenha o fluxo da solicitação, gravar os dados a ser postada e feche o fluxo. Esse método é bloqueada aguardando conteúdo para postagem. Se não houver nenhum conjunto de tempo limite e não fornecer conteúdo, os blocos de thread chamando indefinidamente.  
  
> [!NOTE]
>  Diversas chamadas para <xref:System.Net.HttpWebRequest.GetResponse%2A> retornar o mesmo objeto de resposta; a solicitação não seja enviado novamente.  
  
> [!NOTE]
>  Seu aplicativo não pode combinar métodos síncronos e assíncronos para uma determinada solicitação. Se você chamar o <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método, você deve usar o <xref:System.Net.HttpWebRequest.GetResponse%2A> método para recuperar a resposta.  
  
> [!NOTE]
>  Se um <xref:System.Net.WebException> é gerada, use o <xref:System.Net.WebException.Response%2A> e <xref:System.Net.WebException.Status%2A> propriedades da exceção para determinar a resposta do servidor.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Por motivos de segurança, os cookies estão desabilitados por padrão. Se você quiser usar cookies, use o <xref:System.Net.HttpWebRequest.CookieContainer%2A> propriedade para habilitar cookies.  
  
   
  
## Examples  
 O exemplo de código a seguir obtém a resposta para uma solicitação.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O fluxo já está sendo usado por uma chamada anterior para <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.  
  
- ou - 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> é definido como um valor e <see cref="P:System.Net.HttpWebRequest.SendChunked" /> é <see langword="false" />.</exception>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.HttpWebRequest.Method" /> é GET ou HEAD e <see cref="P:System.Net.HttpWebRequest.ContentLength" /> é maior ou igual a zero ou <see cref="P:System.Net.HttpWebRequest.SendChunked" /> é <see langword="true" />.  
  
- ou - 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> é <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> é <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> é -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> é <see langword="false" /> e <see cref="P:System.Net.HttpWebRequest.Method" /> é POST ou PUT.  
  
- ou - 
O <see cref="T:System.Net.HttpWebRequest" /> tem um corpo de entidade, mas o método <see cref="M:System.Net.HttpWebRequest.GetResponse" /> é chamado sem chamar o método <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />.  
  
- ou - 
O <see cref="P:System.Net.HttpWebRequest.ContentLength" /> é maior que zero, mas o aplicativo não grava todos os dados prometidos.</exception>
        <exception cref="T:System.NotSupportedException">O validador de cache de solicitações indicou que a resposta para essa solicitação pode ser atendida no cache; no entanto, essa solicitação inclui dados a serem enviados ao servidor. Solicitações que enviam dados não devem usar o cache. Essa exceção poderá ocorrer se você estiver usando um validador de cache personalizado implementado incorretamente.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> foi chamado anteriormente.  
  
- ou - 
O período de tempo limite da solicitação expirou.  
  
- ou - 
Ocorreu um erro ao processar a solicitação.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Elemento DefaultProxy (configurações de rede)</related>
      </Docs>
    </Member>
    <Member MemberName="HaveResponse">
      <MemberSignature Language="C#" Value="public virtual bool HaveResponse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HaveResponse" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.HaveResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HaveResponse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HaveResponse { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HaveResponse : bool" Usage="System.Net.HttpWebRequest.HaveResponse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se uma resposta foi recebida de um recurso da Internet.</summary>
        <value><see langword="true" /> se uma resposta foi recebida; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O seguinte código de exemplo verifica o <xref:System.Net.HttpWebRequest.HaveResponse%2A> propriedade para determinar se uma resposta foi recebida de um recurso da Internet.  
  
 [!code-cpp[Httpwebrequest_HaveResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CPP/httpwebrequest_haveresponse.cpp#1)]
 [!code-csharp[Httpwebrequest_HaveResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CS/httpwebrequest_haveresponse.cs#1)]
 [!code-vb[Httpwebrequest_HaveResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/VB/httpwebrequest_haveresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public override System.Net.WebHeaderCollection Headers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.WebHeaderCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Headers As WebHeaderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::WebHeaderCollection ^ Headers { System::Net::WebHeaderCollection ^ get(); void set(System::Net::WebHeaderCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Net.WebHeaderCollection with get, set" Usage="System.Net.HttpWebRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.WebHeaderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica uma coleção de pares nome/valor que compõem os cabeçalhos HTTP.</summary>
        <value>Um <see cref="T:System.Net.WebHeaderCollection" /> que contém os pares nome/valor que compõem os cabeçalhos da solicitação HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.Headers%2A> coleção contém os cabeçalhos de protocolo associados à solicitação. A tabela a seguir lista os cabeçalhos HTTP que não são armazenados em do <xref:System.Net.HttpWebRequest.Headers%2A> coleção, mas que são definidos pelo sistema ou definido por propriedades ou métodos.  
  
|Cabeçalho|Definido por|  
|------------|------------|  
|Aceitar|Definido pelo <xref:System.Net.HttpWebRequest.Accept%2A> propriedade.|  
|Conexão|Definido pela <xref:System.Net.HttpWebRequest.Connection%2A> propriedade e <xref:System.Net.HttpWebRequest.KeepAlive%2A> propriedade.|  
|Tamanho do conteúdo|Definido pelo <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade.|  
|Tipo de conteúdo|Definido pelo <xref:System.Net.HttpWebRequest.ContentType%2A> propriedade.|  
|Esperar|Definido pelo <xref:System.Net.HttpWebRequest.Expect%2A> propriedade.|  
|Date|Definido pelo <xref:System.Net.HttpWebRequest.Date%2A> propriedade.|  
|Host|Definido pelo <xref:System.Net.HttpWebRequest.Host%2A> propriedade.|  
|If-Modified-Since|Definido pelo <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriedade.|  
|Intervalo|Definido pelo <xref:System.Net.HttpWebRequest.AddRange%2A> método.|  
|Referer|Definido pelo <xref:System.Net.HttpWebRequest.Referer%2A> propriedade.|  
|Codificação de transferência|Definido pela <xref:System.Net.HttpWebRequest.TransferEncoding%2A> propriedade (o <xref:System.Net.HttpWebRequest.SendChunked%2A> propriedade deve ser true).|  
|Agente do usuário|Definido pelo <xref:System.Net.HttpWebRequest.UserAgent%2A> propriedade.|  
  
 O <xref:System.Net.WebHeaderCollection.Add%2A> método lança um <xref:System.ArgumentException> se você tentar definir um desses cabeçalhos protegidos.  
  
 Alterando a <xref:System.Net.HttpWebRequest.Headers%2A> propriedade depois que a solicitação foi iniciada chamando <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, ou <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método lança um <xref:System.InvalidOperationException>.  
  
 Você não deve presumir que os valores de cabeçalho permanecerá inalterados, porque os caches e servidores Web podem alterar ou adicionar cabeçalhos de uma solicitação da Web.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Net.HttpWebRequest.Headers%2A> propriedade para imprimir os pares de nome/valor do cabeçalho HTTP para o console.  
  
 [!code-cpp[HttpWebRequest_Headers#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Headers/CPP/httpwebrequest_headers.cpp#1)]
 [!code-csharp[HttpWebRequest_Headers#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Headers/CS/httpwebrequest_headers.cs#1)]
 [!code-vb[HttpWebRequest_Headers#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Headers/VB/httpwebrequest_headers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A solicitação foi iniciada chamando o método <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> ou <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Host" />
      <MemberSignature Language="VB.NET" Value="Public Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : string with get, set" Usage="System.Net.HttpWebRequest.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor de cabeçalho do Host a ser usado em uma solicitação HTTP, independente do URI de solicitação.</summary>
        <value>O valor do cabeçalho de Host na solicitação HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.Host%2A> propriedade pode ser usada para definir o Host do valor de cabeçalho a ser usado em uma solicitação HTTP, independente do URI da solicitação. O <xref:System.Net.HttpWebRequest.Host%2A> propriedade pode consistir em um nome de host e um número de porta opcional. Um cabeçalho de Host sem informações de porta implica a porta padrão para o serviço solicitado (porta 80 para uma URL HTTP, por exemplo).  
  
 O formato para especificar um host e porta deve seguir as regras na seção 14.23 RFC2616 publicado pela IETF. Um exemplo de estar em conformidade com esses requisitos que especifica uma porta 8080 seria o seguinte valor para o <xref:System.Net.HttpWebRequest.Host%2A> propriedade:  
  
 `www.contoso.com:8080`  
  
 Usando o <xref:System.Net.HttpWebRequest.Host%2A> propriedade para especificar explicitamente um valor de cabeçalho de Host personalizado também afeta a áreas de armazenamento em cache, cookies e autenticação. Quando um aplicativo fornece credenciais para um prefixo URI específico, os aplicativos precisa certificar-se de usar o URI que contém o valor do cabeçalho de Host, não no servidor de destino no URI. A chave usada ao armazenar em cache os recursos, usa o valor do cabeçalho de Host em vez de URI de solicitação. Os cookies são armazenados em um <xref:System.Net.CookieContainer> e logicamente agrupados pelo nome de domínio do servidor. Se o aplicativo especificar um cabeçalho de Host, em seguida, esse valor será usado como domínio.  
  
 Se o <xref:System.Net.HttpWebRequest.Host%2A> não está definida e, em seguida, o valor do cabeçalho de Host para usar em uma solicitação HTTP é com base no URI da solicitação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O cabeçalho do Host não pode ser definido como <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O cabeçalho do Host não pode ser definido com um valor inválido.</exception>
        <exception cref="T:System.InvalidOperationException">O cabeçalho do Host não pode ser definido após o <see cref="T:System.Net.HttpWebRequest" /> já ter começado o envio.</exception>
      </Docs>
    </Member>
    <Member MemberName="IfModifiedSince">
      <MemberSignature Language="C#" Value="public DateTime IfModifiedSince { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime IfModifiedSince" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberSignature Language="VB.NET" Value="Public Property IfModifiedSince As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime IfModifiedSince { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.IfModifiedSince : DateTime with get, set" Usage="System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor do cabeçalho HTTP <see langword="If-Modified-Since" />.</summary>
        <value>Um <see cref="T:System.DateTime" /> que contém o conteúdo do cabeçalho HTTP <see langword="If-Modified-Since" />. O valor padrão é a data e hora atuais.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriedade é um padrão <xref:System.DateTime?displayProperty=nameWithType> do objeto e pode conter um <xref:System.DateTimeKind?displayProperty=nameWithType> campo <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, ou <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Qualquer tipo de tempo pode ser definido ao usar o <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriedade. Se <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> é definido ou recuperado, o <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriedade será considerada como <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (hora local).  
  
 As classes de <xref:System.Net> namespace sempre gravá-los a <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriedade durante a transmissão durante a transmissão na forma padrão usando o formato GMT (Utc).  
  
 Se o <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> estiver definida como <xref:System.DateTime.MinValue?displayProperty=nameWithType>, em seguida, a `If-Modified-Since` cabeçalho HTTP é removido do <xref:System.Net.HttpWebRequest.Headers%2A> propriedade e o <xref:System.Net.WebHeaderCollection>.  
  
 Se o <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> é de propriedade <xref:System.DateTime.MinValue?displayProperty=nameWithType>, isso indica que o `If-Modified-Since` cabeçalho HTTP não está incluído no <xref:System.Net.HttpWebRequest.Headers%2A> propriedade e o <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  O valor dessa propriedade é armazenado em <xref:System.Net.WebHeaderCollection>. Se WebHeaderCollection for definido, o valor da propriedade será perdido.  
  
   
  
## Examples  
 O seguinte código de exemplo verifica o <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriedade.  
  
 [!code-cpp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CPP/httpwebrequest_ifmodifiedsince.cpp#1)]
 [!code-csharp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CS/httpwebrequest_ifmodifiedsince.cs#1)]
 [!code-vb[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/VB/httpwebrequest_ifmodifiedsince.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlive : bool with get, set" Usage="System.Net.HttpWebRequest.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se é necessário fazer uma conexão persistente com o recurso da Internet.</summary>
        <value><see langword="true" /> se a solicitação para o recurso de Internet deve conter um cabeçalho HTTP <see langword="Connection" /> com o valor keep-alive; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Defina essa propriedade como `true` para enviar um `Connection` cabeçalho HTTP com o valor Keep-alive. Um aplicativo usa <xref:System.Net.HttpWebRequest.KeepAlive%2A> para indicar uma preferência para conexões persistentes. Quando o <xref:System.Net.HttpWebRequest.KeepAlive%2A> é de propriedade `true`, o aplicativo faz conexões persistentes aos servidores que dão suporte a eles.  
  
> [!NOTE]
>  Ao usar o HTTP/1.1, Keep-Alive é em por padrão. Definindo <xref:System.Net.HttpWebRequest.KeepAlive%2A> à `false` pode resultar no envio de um `Connection: Close` cabeçalho para o servidor.  
  
   
  
## Examples  
 O seguinte exemplo de código define a <xref:System.Net.HttpWebRequest.KeepAlive%2A> propriedade para `false` para evitar o estabelecimento de uma conexão persistente com o recurso da Internet.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumAutomaticRedirections">
      <MemberSignature Language="C#" Value="public int MaximumAutomaticRedirections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumAutomaticRedirections" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumAutomaticRedirections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumAutomaticRedirections { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumAutomaticRedirections : int with get, set" Usage="System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o número máximo de redirecionamentos que a solicitação segue.</summary>
        <value>O número máximo de respostas de redirecionamento que a solicitação segue. O valor padrão é 50.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> propriedade define o número máximo de redirecionamentos para a solicitação a seguir se o <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> é de propriedade `true`.  
  
   
  
## Examples  
 O exemplo de código a seguir define o valor dessa propriedade.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor é definido como 0 ou menos.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o comprimento máximo permitido dos cabeçalhos de resposta.</summary>
        <value>O comprimento, em quilobytes (1024 bytes), dos cabeçalhos de resposta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O comprimento do cabeçalho de resposta inclui a linha de status de resposta e quaisquer caracteres de controle extra que são recebidos como parte do protocolo HTTP. Um valor de-1 significa que sem limite é imposto nos cabeçalhos de resposta; um valor de 0 significa que todas as solicitações falham.  
  
 Se o <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> propriedade não está definida explicitamente, ela será padronizada como o valor da <xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A> propriedade.  
  
 Se o comprimento do cabeçalho da resposta recebido excede o valor da <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> propriedade, o <xref:System.Net.HttpWebRequest.EndGetResponse%2A> ou <xref:System.Net.HttpWebRequest.GetResponse%2A> métodos lançará uma <xref:System.Net.WebException> com o <xref:System.Net.WebException.Status%2A> propriedade definida como <xref:System.Net.WebExceptionStatus.MessageLengthLimitExceeded>.  
  
   
  
## Examples  
 O exemplo de código a seguir define o valor dessa propriedade.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade é definida depois que a solicitação já foi enviada.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor é menor que 0 e não é igual a -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="MediaType">
      <MemberSignature Language="C#" Value="public string MediaType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MediaType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MediaType" />
      <MemberSignature Language="VB.NET" Value="Public Property MediaType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MediaType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MediaType : string with get, set" Usage="System.Net.HttpWebRequest.MediaType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tipo de mídia da solicitação.</summary>
        <value>O tipo de mídia da solicitação. O valor padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de <xref:System.Net.HttpWebRequest.MediaType%2A> propriedade afeta a <xref:System.Net.HttpWebResponse.CharacterSet%2A> propriedade. Quando você define o <xref:System.Net.HttpWebRequest.MediaType%2A> na solicitação, o tipo de mídia correspondente é escolhido na lista de conjuntos de caracteres retornados na resposta `Content-type` cabeçalho HTTP.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public override string Method { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Method" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Method" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Method As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Method { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Method : string with get, set" Usage="System.Net.HttpWebRequest.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o método para a solicitação.</summary>
        <value>O método de solicitação a ser usado para contatar o recurso de Internet. O valor padrão é GET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.Method%2A> propriedade pode ser definida para qualquer um dos verbos de protocolo HTTP 1.1: GET, HEAD, POST, PUT, excluir, rastreamento ou opções.  
  
 Se o <xref:System.Net.HttpWebRequest.ContentLength%2A> estiver definida como qualquer valor diferente de -1, o <xref:System.Net.HttpWebRequest.Method%2A> propriedade deve ser definida como uma propriedade de protocolo que carrega dados.  
  
   
  
## Examples  
 O seguinte exemplo de código define o <xref:System.Net.HttpWebRequest.Method%2A> propriedade à POSTAGEM.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nenhum método é fornecido.  
  
- ou - 
A cadeia de caracteres de método contém caracteres inválidos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pipelined">
      <MemberSignature Language="C#" Value="public bool Pipelined { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Pipelined" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Pipelined" />
      <MemberSignature Language="VB.NET" Value="Public Property Pipelined As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Pipelined { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Pipelined : bool with get, set" Usage="System.Net.HttpWebRequest.Pipelined" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se deve-se fazer pipeline da solicitação ao recurso de Internet.</summary>
        <value><see langword="true" /> se a solicitação deve ser por pipeline; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um aplicativo usa o <xref:System.Net.HttpWebRequest.Pipelined%2A> propriedade para indicar uma preferência para conexões por pipeline. Quando <xref:System.Net.HttpWebRequest.Pipelined%2A> é `true`, um aplicativo faz conexões por pipeline para os servidores que oferecem suporte a eles.  
  
 Conexões por pipeline são feitas somente quando o <xref:System.Net.HttpWebRequest.KeepAlive%2A> propriedade também é `true`.  
  
   
  
## Examples  
 O exemplo de código a seguir imprime o valor da <xref:System.Net.HttpWebRequest.Pipelined%2A> propriedade no console.  
  
 [!code-cpp[HttpWebRequest_PipeLined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CPP/httpwebrequest_pipelined.cpp#1)]
 [!code-csharp[HttpWebRequest_PipeLined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CS/httpwebrequest_pipelined.cs#1)]
 [!code-vb[HttpWebRequest_PipeLined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_PipeLined/VB/httpwebrequest_pipelined.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public override bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreAuthenticate : bool with get, set" Usage="System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se é necessário enviar um cabeçalho de autorização com a solicitação.</summary>
        <value><see langword="true" /> para enviar um cabeçalho de autorização HTTP com solicitações após a autenticação ser realizada; Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Depois de uma solicitação de cliente para um determinado <xref:System.Uri> é autenticado com êxito, se <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> é `true` e as credenciais são fornecidas, o cabeçalho de autorização é enviado com cada solicitação para qualquer <xref:System.Uri> que corresponde ao específico <xref:System.Uri>até a última barra invertida. Portanto, se a solicitação do cliente é autenticado com êxito para um determinado <xref:System.Uri> que contém o seguinte:  
  
 `http://www.contoso.com/firstpath/`  
  
 Em seguida, o cabeçalho de autorização para pré-autenticação é enviado com cada solicitação para qualquer um dos seguintes <xref:System.Uri> instâncias:  
  
 `http://www.contoso.com/firstpath/`  
  
 `http://www.contoso.com/firstpath/default`  
  
 `http://www.contoso.com/firstpath/default.html`  
  
 `http://www.contoso.com/firstpath/sample.html`  
  
 No entanto, o cabeçalho de autorização não é enviado com solicitações para qualquer um dos seguintes <xref:System.Uri> instâncias:  
  
 `http://www.contoso.com/`  
  
 `http://www.contoso.com/firstpath`  
  
 `http://www.contoso.com/secondpath/`  
  
 Se o cliente solicitar para um determinado <xref:System.Uri> é autenticado não com êxito, a solicitação usa procedimentos de autenticação padrão.  
  
 Com exceção da primeira solicitação, o <xref:System.Net.WebRequest.PreAuthenticate%2A> propriedade indica se deseja enviar informações de autenticação com solicitações subsequentes para uma <xref:System.Uri> que corresponde ao específico <xref:System.Uri> até a última barra invertida sem aguardando para serem o desafio pelo servidor.  
  
 A seguinte caixa de diálogo entre cliente e servidor ilustra o efeito dessa propriedade. A caixa de diálogo pressupõe que a autenticação básica está em uso.  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> é `false`:  
  
 Cliente: OBTER someUrl  
  
 Servidor: 401 WWW-Authenticate Basic  
  
 Cliente: OBTER com cabeçalhos de autorização  
  
 Servidor: 200 OK  
  
 Cliente: OBTER someUrl  
  
 Servidor: 401 WWW-Authenticate Basic  
  
 Cliente: OBTER com cabeçalhos de autorização  
  
 Servidor: 200 OK  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> é `true`:  
  
 Cliente: OBTER someUrl  
  
 Servidor: 401 WWW-Authenticate Basic  
  
 Cliente: OBTER com cabeçalhos de autorização  
  
 Servidor: 200 OK  
  
 Cliente: OBTER someUrl com cabeçalhos de autorização  
  
 Se o esquema de autenticação não oferece suporte a pré-autenticação, o valor dessa propriedade é ignorado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); void set(Version ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolVersion : Version with get, set" Usage="System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a versão do HTTP a ser usada para a solicitação.</summary>
        <value>A versão do HTTP a ser usada para a solicitação. O padrão é <see cref="F:System.Net.HttpVersion.Version11" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest> classe dá suporte a apenas as versões 1.0 e 1.1 do HTTP. Definindo <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> para uma versão diferente, gera uma exceção.  
  
> [!NOTE]
>  Para definir a versão HTTP da solicitação atual, use o <xref:System.Net.HttpVersion.Version10> e <xref:System.Net.HttpVersion.Version11> campos do <xref:System.Net.HttpVersion> classe.  
  
   
  
## Examples  
 O seguinte exemplo de código define o <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> propriedade.  
  
 [!code-cpp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CPP/httpwebrequest_protocolversion.cpp#1)]
 [!code-csharp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CS/httpwebrequest_protocolversion.cs#1)]
 [!code-vb[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/VB/httpwebrequest_protocolversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A versão do HTTP é definida como um valor diferente de 1.0 ou 1.1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public override System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Proxy : System.Net.IWebProxy with get, set" Usage="System.Net.HttpWebRequest.Proxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define informações de proxy da solicitação.</summary>
        <value>O objeto <see cref="T:System.Net.IWebProxy" /> a ser usado para o proxy da solicitação. O valor padrão é definido com a chamada à propriedade <see cref="P:System.Net.GlobalProxySelection.Select" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.Proxy%2A> propriedade identifica o <xref:System.Net.WebProxy> objeto a ser usado para processar solicitações aos recursos da Internet. Para especificar que nenhum proxy deve ser usado, defina as <xref:System.Net.HttpWebRequest.Proxy%2A> propriedade para a instância do proxy retornada pelo <xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A?displayProperty=nameWithType> método.  
  
 O computador local ou o arquivo de configuração de aplicativo pode especificar que um proxy padrão usado. Se o <xref:System.Net.HttpWebRequest.Proxy%2A> propriedade for especificada, em seguida, as configurações de proxy do <xref:System.Net.HttpWebRequest.Proxy%2A> substituição de propriedade, o computador local ou o arquivo de configuração de aplicativo e o <xref:System.Net.HttpWebRequest> instância usará as configurações de proxy especificadas. Se nenhum proxy for especificado em um arquivo de configuração e o <xref:System.Net.HttpWebRequest.Proxy%2A> propriedade não for especificada, o <xref:System.Net.HttpWebRequest> classe usa as configurações de proxy herdadas do Internet Explorer no computador local. Se não houver nenhuma configuração de proxy no Internet Explorer, a solicitação é enviada diretamente para o servidor.  
  
 O <xref:System.Net.HttpWebRequest> classe analisa uma lista de bypass de proxy com caracteres curinga herdadas do Internet Explorer a mesma conforme a lista de ignoráveis é analisada diretamente pelo Internet Explorer. Por exemplo, o <xref:System.Net.HttpWebRequest> classe analisa uma lista de bypass de "nt *" do Internet Explorer como uma expressão regular de "nt.\*". Portanto, uma URL de "`http://nt.com`" ignoram o proxy usando o <xref:System.Net.HttpWebRequest> classe e usando o Internet Explorer.  
  
 O <xref:System.Net.HttpWebRequest> classe dá suporte a bypass de proxy local. A classe considera um destino ser local se qualquer uma das seguintes condições forem atendidas:  
  
-   O destino contém um nome simples (sem pontos na URL).  
  
-   O destino contém um endereço de loopback (<xref:System.Net.IPAddress.Loopback> ou <xref:System.Net.IPAddress.IPv6Loopback>) ou o destino contém um <xref:System.Net.IPAddress> atribuído ao computador local.  
  
-   O sufixo do domínio de destino corresponde ao sufixo de domínio do computador local (<xref:System.Net.NetworkInformation.IPGlobalProperties.DomainName%2A>).  
  
 Alterando a <xref:System.Net.HttpWebRequest.Proxy%2A> propriedade depois que a solicitação foi iniciada chamando o <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, ou <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método lança um <xref:System.InvalidOperationException>. Para obter informações sobre o elemento de proxy, consulte [ \&lt; defaultProxy\&gt; (Configurações de rede)](~/docs/framework/configure-apps/file-schema/network/defaultproxy-element-network-settings.md).  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Net.HttpWebRequest.Proxy%2A> método para obter as informações de proxy para a solicitação.  
  
 [!code-cpp[Httpwebrequest_proxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_proxy/CPP/httpwebrequest_proxy.cpp#1)]
 [!code-csharp[Httpwebrequest_proxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_proxy/CS/httpwebrequest_proxy.cs#1)]
 [!code-vb[Httpwebrequest_proxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_proxy/VB/httpwebrequest_proxy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.HttpWebRequest.Proxy" /> é definido como <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">A solicitação foi iniciada com a chamada a <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> ou <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem permissão para a operação solicitada.</exception>
        <permission cref="T:System.Net.WebPermission">Para obter ou definir o <see cref="P:System.Net.HttpWebRequest.Proxy" /> propriedade. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Elemento DefaultProxy (configurações de rede)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/bb707c72-eed2-4a82-8800-c9e68df2fd4f">Configurando aplicativos da Internet</related>
        <related type="Article" href="https://msdn.microsoft.com/library/353c0a8b-4cee-44f6-8e65-60e286743df9">Configuração de proxy</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fcd9c3bd-93de-4c92-8ff3-837327ad18de">Detecção automática de proxy</related>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadWriteTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um tempo limite em milissegundos ao gravar ou ler de um fluxo.</summary>
        <value>O número de milissegundos antes da gravação ou leitura expirar. O valor padrão é 300.000 milissegundos (5 minutos).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> propriedade é usada ao gravar no fluxo retornado pelo <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método ou a leitura do fluxo retornado pelo <xref:System.Net.HttpWebResponse.GetResponseStream%2A> método.  
  
 Especificamente, o <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> propriedade controla o tempo limite para o <xref:System.IO.Stream.Read%2A> método, que é usado para ler o fluxo retornado pela <xref:System.Net.HttpWebResponse.GetResponseStream%2A> método e para o <xref:System.IO.Stream.Write%2A> método, que é usado para gravar no fluxo retornado pelo <xref:System.Net.HttpWebRequest.GetRequestStream%2A>método.  
  
 Para especificar a quantidade de tempo de espera para a solicitação ser concluída, use o <xref:System.Net.HttpWebRequest.Timeout%2A> propriedade.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como definir o <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> propriedade.  
  
 [!code-csharp[Classic HttpWebRequest Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A solicitação já foi enviada.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor especificado para uma operação de definição é menor ou igual a zero e é diferente de <see cref="F:System.Threading.Timeout.Infinite" /></exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="Referer">
      <MemberSignature Language="C#" Value="public string Referer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Referer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Referer" />
      <MemberSignature Language="VB.NET" Value="Public Property Referer As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Referer { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Referer : string with get, set" Usage="System.Net.HttpWebRequest.Referer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor do cabeçalho HTTP <see langword="Referer" />.</summary>
        <value>O valor do cabeçalho HTTP <see langword="Referer" />. O valor padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> é de propriedade `true`, o <xref:System.Net.HttpWebRequest.Referer%2A> propriedade é definida automaticamente quando a solicitação é redirecionada para outro site.  
  
 Para limpar os `Referer` cabeçalho HTTP, defina o <xref:System.Net.HttpWebRequest.Referer%2A> propriedade `null`.  
  
> [!NOTE]
>  O valor dessa propriedade é armazenado em <xref:System.Net.WebHeaderCollection>. Se WebHeaderCollection for definido, o valor da propriedade será perdido.  
  
   
  
## Examples  
 O seguinte exemplo de código define o <xref:System.Net.HttpWebRequest.Referer%2A> propriedade.  
  
 [!code-cpp[HttpWebRequest_Referer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Referer/CPP/httpwebrequest_referer.cpp#1)]
 [!code-csharp[HttpWebRequest_Referer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Referer/CS/httpwebrequest_referer.cs#1)]
 [!code-vb[HttpWebRequest_Referer#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Referer/VB/httpwebrequest_referer.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestUri">
      <MemberSignature Language="C#" Value="public override Uri RequestUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri RequestUri" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.RequestUri" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RequestUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Uri ^ RequestUri { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestUri : Uri" Usage="System.Net.HttpWebRequest.RequestUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o URI (Uniform Resource Identifier) original da solicitação.</summary>
        <value>Um <see cref="T:System.Uri" /> que contém o URI do recurso da Internet passado para o método <see cref="M:System.Net.WebRequest.Create(System.String)" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri> objeto passado para <xref:System.Net.HttpWebRequest> pela chamada para <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>.  
  
 Após um redirecionamento de cabeçalho não altera o <xref:System.Net.HttpWebRequest.RequestUri%2A> propriedade. Para obter o URI real que respondeu à solicitação, examine o <xref:System.Net.HttpWebRequest.Address%2A> propriedade.  
  
   
  
## Examples  
 O seguinte código de exemplo verifica se o <xref:System.Net.HttpWebRequest> objeto `req` foi redirecionado para outro local para atender à solicitação e define o valor da `hasChanged` variável para `true` se a solicitação tiver sido redirecionada; caso contrário, `hasChanged` é definido como `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendChunked">
      <MemberSignature Language="C#" Value="public bool SendChunked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SendChunked" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SendChunked" />
      <MemberSignature Language="VB.NET" Value="Public Property SendChunked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SendChunked { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SendChunked : bool with get, set" Usage="System.Net.HttpWebRequest.SendChunked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se é necessário enviar os dados em segmentos para o recurso da Internet.</summary>
        <value><see langword="true" /> para enviar dados para o recurso da Internet em segmentos; caso contrário, <see langword="false" />. O valor padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Net.HttpWebRequest.SendChunked%2A> é `true`, a solicitação envia dados para o recurso de Internet em segmentos. O recurso de Internet deve dar suporte a recebimento de dados em partes.  
  
 Alterando a <xref:System.Net.HttpWebRequest.SendChunked%2A> propriedade depois que a solicitação foi iniciada chamando o <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, ou <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método lança um <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 O seguinte exemplo de código define a <xref:System.Net.HttpWebRequest.SendChunked%2A> propriedade para `true` para que os dados podem ser enviados em segmentos para o recurso da Internet.  
  
 [!code-cpp[HttpWebRequest_SendChunked#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CPP/httpwebrequest_sendchunked.cpp#2)]
 [!code-csharp[HttpWebRequest_SendChunked#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CS/httpwebrequest_sendchunked.cs#2)]
 [!code-vb[HttpWebRequest_SendChunked#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_SendChunked/VB/httpwebrequest_sendchunked.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A solicitação foi iniciada chamando o método <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> ou <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define uma função de retorno de chamada para validar o certificado do servidor.</summary>
        <value>Uma função de retorno de chamada para validar o certificado do servidor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O padrão é que nenhuma função de retorno de chamada é definida e o <xref:System.Net.HttpWebRequest.ServerCertificateValidationCallback%2A> é de propriedade `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServicePoint">
      <MemberSignature Language="C#" Value="public System.Net.ServicePoint ServicePoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ServicePoint ServicePoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServicePoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServicePoint As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ServicePoint ^ ServicePoint { System::Net::ServicePoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServicePoint : System.Net.ServicePoint" Usage="System.Net.HttpWebRequest.ServicePoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o ponto de serviço a ser usado para a solicitação.</summary>
        <value>Um <see cref="T:System.Net.ServicePoint" /> que representa a conexão de rede para o recurso de Internet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.ServicePoint.Address%2A?displayProperty=nameWithType> propriedade pode ser diferente do <xref:System.Net.HttpWebRequest.Address%2A?displayProperty=nameWithType> se a solicitação é redirecionada.  
  
   
  
## Examples  
 [!code-cpp[System.Net.ServicePoint#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#6)]
 [!code-csharp[System.Net.ServicePoint#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#6)]
 [!code-vb[System.Net.ServicePoint#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsCookieContainer">
      <MemberSignature Language="C#" Value="public virtual bool SupportsCookieContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsCookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsCookieContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsCookieContainer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsCookieContainer : bool" Usage="System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a solicitação dá suporte a um <see cref="T:System.Net.CookieContainer" />.</summary>
        <value><see langword="true" /> Se a solicitação fornece suporte para um <see cref="T:System.Net.CookieContainer" />; caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">O <see cref="T:System.Runtime.Serialization.SerializationInfo" /> a ser preenchido com dados.</param>
        <param name="streamingContext">Um <see cref="T:System.Runtime.Serialization.StreamingContext" /> que especifica o destino dessa serialização.</param>
        <summary>Popula um <see cref="T:System.Runtime.Serialization.SerializationInfo" /> com os dados necessários para serializar o objeto de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos os objetos incluídos no <xref:System.Runtime.Serialization.SerializationInfo> são automaticamente rastreadas e serializado pelo formatador.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public override int Timeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Timeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Timeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Timeout : int with get, set" Usage="System.Net.HttpWebRequest.Timeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor de tempo limite em milissegundos para os métodos <see cref="M:System.Net.HttpWebRequest.GetResponse" /> e <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />.</summary>
        <value>O número de milissegundos de espera antes que a solicitação atinja o tempo limite. O valor padrão é 100.000 milissegundos (100 segundos).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Timeout%2A> é o número de milissegundos que uma solicitação síncrona subsequente feita com o <xref:System.Net.HttpWebRequest.GetResponse%2A> método aguarda uma resposta e o <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método aguarda um fluxo. O <xref:System.Net.HttpWebRequest.Timeout%2A> se aplica a toda solicitação e resposta, não individualmente para o <xref:System.Net.HttpWebRequest.GetRequestStream%2A> e <xref:System.Net.HttpWebRequest.GetResponse%2A> chamadas de método. Se o recurso não for retornado dentro do período de tempo limite, a solicitação gerará uma <xref:System.Net.WebException> com o <xref:System.Net.WebException.Status%2A> propriedade definida como <xref:System.Net.WebExceptionStatus.Timeout?displayProperty=nameWithType>.  
  
 O <xref:System.Net.HttpWebRequest.Timeout%2A> propriedade deve ser definida antes do <xref:System.Net.HttpWebRequest.GetRequestStream%2A> ou <xref:System.Net.HttpWebRequest.GetResponse%2A> método é chamado. Alterando a <xref:System.Net.HttpWebRequest.Timeout%2A> propriedade após a chamada a <xref:System.Net.HttpWebRequest.GetRequestStream%2A> ou <xref:System.Net.HttpWebRequest.GetResponse%2A> método não tem nenhum efeito  
  
 O <xref:System.Net.HttpWebRequest.Timeout%2A> propriedade não tem efeito sobre as solicitações assíncronas feitas com o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> ou <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método.  
  
> [!CAUTION]
>  No caso de solicitações assíncronas, o aplicativo cliente implementa seu próprio mecanismo de tempo limite. Consulte o exemplo no <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método.  
  
 Para especificar a quantidade de tempo a aguardar antes de uma leitura ou gravação operação atingirá o tempo limite, use o <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> propriedade.  
  
 Uma consulta de sistema de nome de domínio (DNS) pode levar até 15 segundos para retornar ou tempo limite. Se sua solicitação contém um nome de host que requer que a resolução e você definir <xref:System.Net.FileWebRequest.Timeout%2A> como um valor menor que 15 segundos, pode levar 15 segundos ou mais antes de um <xref:System.Net.WebException> é gerada para indicar um tempo limite para sua solicitação.  
  
   
  
## Examples  
 O seguinte exemplo de código define a <xref:System.Net.HttpWebRequest.Timeout%2A> propriedade do <xref:System.Net.HttpWebRequest> objeto.  
  
 [!code-cpp[HttpWebRequest_Timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CPP/httpwebrequest_timeout.cpp#1)]
 [!code-csharp[HttpWebRequest_Timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CS/httpwebrequest_timeout.cs#1)]
 [!code-vb[HttpWebRequest_Timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Timeout/VB/httpwebrequest_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor especificado é menor que zero e não é <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransferEncoding">
      <MemberSignature Language="C#" Value="public string TransferEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransferEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.TransferEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property TransferEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransferEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransferEncoding : string with get, set" Usage="System.Net.HttpWebRequest.TransferEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor do cabeçalho HTTP <see langword="Transfer-encoding" />.</summary>
        <value>O valor do cabeçalho HTTP <see langword="Transfer-encoding" />. O valor padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Antes de configurar o <xref:System.Net.HttpWebRequest.TransferEncoding%2A> propriedade, você deve primeiro definir o <xref:System.Net.HttpWebRequest.SendChunked%2A> propriedade `true`. Limpando <xref:System.Net.HttpWebRequest.TransferEncoding%2A> definindo-a como `null` não tem efeito sobre o valor de <xref:System.Net.HttpWebRequest.SendChunked%2A>.  
  
 Valores atribuídos ao <xref:System.Net.HttpWebRequest.TransferEncoding%2A> propriedade substituir qualquer conteúdo existente.  
  
> [!NOTE]
>  O valor dessa propriedade é armazenado em <xref:System.Net.WebHeaderCollection>. Se WebHeaderCollection for definido, o valor da propriedade será perdido.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> é definido quando <see cref="P:System.Net.HttpWebRequest.SendChunked" /> é <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> é definido como o valor "Em bloco".</exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeAuthenticatedConnectionSharing : bool with get, set" Usage="System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se deve ser permitido o compartilhamento de conexão de alta velocidade autenticado por NTLM.</summary>
        <value><see langword="true" /> para manter a conexão autenticada aberta, caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor padrão desta propriedade é `false`, que faz com que a conexão atual ser fechada depois que uma solicitação é concluída. Seu aplicativo deve passar pela sequência de autenticação toda vez que ele emite uma nova solicitação.  
  
 Se essa propriedade é definida como `true`, a conexão usada para recuperar a resposta permanece aberta depois que a autenticação ter sido executada. Nesse caso, outras solicitações que têm essa propriedade definida como `true` podem usar a conexão sem autenticar novamente. Em outras palavras, se uma conexão tiver sido autenticado para o usuário A, o usuário B pode reutilizar da conexão; solicitação do usuário B é atendida com base nas credenciais do usuário A.  
  
> [!CAUTION]
>  Como é possível que um aplicativo para usar a conexão sem ser autenticada, você precisa certificar-se de que não há nenhuma vulnerabilidade administrativa no seu sistema ao definir essa propriedade como `true`. Se seu aplicativo envia solicitações para vários usuários (representa várias contas de usuário) e se baseia na autenticação para proteger recursos, não defina essa propriedade como `true` , a menos que você use grupos de conexão, conforme descrito abaixo.  
  
 Você talvez queira considerar habilitar esse mecanismo se seu estiver tendo problemas de desempenho e seu aplicativo está em execução em um servidor Web com autenticação integrada do Windows.  
  
 Habilitar essa configuração, o sistema a riscos de segurança é aberta. Se você definir a <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> propriedade para `true` tome as seguintes precauções:  
  
-   Use o <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> propriedade para gerenciar as conexões para usuários diferentes. Isso evita o uso de potencial da conexão por aplicativos não-autenticados. Por exemplo, o usuário A deve ter um nome de grupo de conexão exclusivo que seja diferente do usuário B. Isso fornece uma camada de isolamento para cada conta de usuário.  
  
-   Execute seu aplicativo em um ambiente protegido para ajudar a evitar explorações de conexão possíveis.  
  
 Se você controlar o servidor de back-end, como alternativa você pode considerar a desativar a persistência de autenticação. Isso aumenta o desempenho em um grau menor, mas é mais seguro. Para obter mais detalhes, procure AuthPersistence na biblioteca MSDN em [ http://msdn.microsoft.com/library ](https://msdn.microsoft.com/library).  
  
> [!NOTE]
>  Se os dois <xref:System.Net.WebRequest.PreAuthenticate%2A> e <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> são definidos como `true`, cada solicitação é enviada usando uma conexão do pool não seguro, mas com um cabeçalho de autorização.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Permissão irrestrita de Web é necessário definir essa propriedade.</permission>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public override bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDefaultCredentials : bool with get, set" Usage="System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor <see cref="T:System.Boolean" /> que controla se as credenciais padrão são enviadas com solicitações.</summary>
        <value><see langword="true" /> se as credenciais padrão forem usadas; caso contrário, <see langword="false" />. O valor padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Defina essa propriedade como `true` quando as solicitações feitas por este <xref:System.Net.HttpWebRequest> objeto deve, se solicitado pelo servidor de ser autenticado usando as credenciais do usuário conectado no momento. Para aplicativos cliente, esse é o comportamento desejado na maioria dos cenários. Para aplicativos de camada intermediária, como aplicativos do ASP.NET, em vez de usar essa propriedade, você normalmente definiria o <xref:System.Net.HttpWebRequest.Credentials%2A> propriedade para as credenciais do cliente em cujo nome a solicitação é feita.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Você tentou definir essa propriedade depois que a solicitação foi enviada.</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UserAgent : string with get, set" Usage="System.Net.HttpWebRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor do cabeçalho HTTP <see langword="User-agent" />.</summary>
        <value>O valor do cabeçalho HTTP <see langword="User-agent" />. O valor padrão é <see langword="null" />.  
  
 <block subset="none" type="note"><para>  
 O valor dessa propriedade é armazenado em <see cref="T:System.Net.WebHeaderCollection" />. Se WebHeaderCollection for definido, o valor da propriedade será perdido.  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O seguinte exemplo de código define o <xref:System.Net.HttpWebRequest.UserAgent%2A> propriedade.  
  
 [!code-cpp[HttpWebRequest_UserAgent#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CPP/httpwebrequest_useragent.cpp#1)]
 [!code-csharp[HttpWebRequest_UserAgent#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CS/httpwebrequest_useragent.cs#1)]
 [!code-vb[HttpWebRequest_UserAgent#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_UserAgent/VB/httpwebrequest_useragent.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>