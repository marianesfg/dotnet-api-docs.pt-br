<Type Name="IPAddress" FullName="System.Net.IPAddress">
  <TypeSignature Language="C#" Value="public class IPAddress" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit IPAddress extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.IPAddress" />
  <TypeSignature Language="VB.NET" Value="Public Class IPAddress" />
  <TypeSignature Language="C++ CLI" Value="public ref class IPAddress" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Primitives</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="f2960-101">Fornece um endereço IP (Internet Protocol).</span><span class="sxs-lookup"><span data-stu-id="f2960-101">Provides an Internet Protocol (IP) address.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-102">O <xref:System.Net.IPAddress> classe contém o endereço de um computador em uma rede IP.</span><span class="sxs-lookup"><span data-stu-id="f2960-102">The <xref:System.Net.IPAddress> class contains the address of a computer on an IP network.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f2960-103">O exemplo de código a seguir mostra como consultar um servidor para obter os endereços de família e os endereços IP ele suporta.</span><span class="sxs-lookup"><span data-stu-id="f2960-103">The following code example shows how to query a server to obtain the family addresses and the IP addresses it supports.</span></span>  
  
 [!code-cpp[System.Net.IPAddress#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#1)]
 [!code-csharp[System.Net.IPAddress#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#1)]
 [!code-vb[System.Net.IPAddress#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f2960-104">Inicializa uma nova instância da classe <see cref="T:System.Net.IPAddress" />.</span><span class="sxs-lookup"><span data-stu-id="f2960-104">Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (byte[] address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(cli::array &lt;System::Byte&gt; ^ address);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="f2960-105">O valor da matriz de bytes do endereço IP.</span><span class="sxs-lookup"><span data-stu-id="f2960-105">The byte array value of the IP address.</span></span></param>
        <summary><span data-ttu-id="f2960-106">Inicializa uma nova instância da classe <see cref="T:System.Net.IPAddress" /> com o endereço especificado como uma matriz <see cref="T:System.Byte" />.</span><span class="sxs-lookup"><span data-stu-id="f2960-106">Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class with the address specified as a <see cref="T:System.Byte" /> array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-107">O <xref:System.Net.IPAddress> é criado com o <xref:System.Net.IPAddress.Address%2A> propriedade definida como `address`.</span><span class="sxs-lookup"><span data-stu-id="f2960-107">The <xref:System.Net.IPAddress> is created with the <xref:System.Net.IPAddress.Address%2A> property set to `address`.</span></span>  
  
 <span data-ttu-id="f2960-108">Se o comprimento de `address` é 4, <xref:System.Net.IPAddress.%23ctor%28System.Byte%5B%5D%29> constrói um endereço IPv4; caso contrário, um endereço IPv6 com um escopo de 0 é construído.</span><span class="sxs-lookup"><span data-stu-id="f2960-108">If the length of `address` is 4, <xref:System.Net.IPAddress.%23ctor%28System.Byte%5B%5D%29> constructs an IPv4 address; otherwise, an IPv6 address with a scope of 0 is constructed.</span></span>  
  
 <span data-ttu-id="f2960-109">O <xref:System.Byte> matriz devem para estar em ordem de bytes de rede com o byte mais significativo primeiro na posição de índice 0.</span><span class="sxs-lookup"><span data-stu-id="f2960-109">The <xref:System.Byte> array is assumed to be in network byte order with the most significant byte first in index position 0.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f2960-110"><paramref name="address" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f2960-110"><paramref name="address" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f2960-111"><paramref name="address" /> contém um endereço IP inválido.</span><span class="sxs-lookup"><span data-stu-id="f2960-111"><paramref name="address" /> contains a bad IP address.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (long newAddress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 newAddress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (newAddress As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(long newAddress);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="newAddress" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="newAddress"><span data-ttu-id="f2960-112">O valor longo do endereço IP.</span><span class="sxs-lookup"><span data-stu-id="f2960-112">The long value of the IP address.</span></span> <span data-ttu-id="f2960-113">Por exemplo, o valor 0x2414188f no formato big endian seria o endereço IP "143.24.20.36".</span><span class="sxs-lookup"><span data-stu-id="f2960-113">For example, the value 0x2414188f in big-endian format would be the IP address "143.24.20.36".</span></span></param>
        <summary><span data-ttu-id="f2960-114">Inicializa uma nova instância da classe <see cref="T:System.Net.IPAddress" /> com o endereço especificado como um <see cref="T:System.Int64" />.</span><span class="sxs-lookup"><span data-stu-id="f2960-114">Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class with the address specified as an <see cref="T:System.Int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-115">O <xref:System.Net.IPAddress> instância é criada com o <xref:System.Net.IPAddress.Address%2A> propriedade definida como `newAddress`.</span><span class="sxs-lookup"><span data-stu-id="f2960-115">The <xref:System.Net.IPAddress> instance is created with the <xref:System.Net.IPAddress.Address%2A> property set to `newAddress`.</span></span>  
  
 <span data-ttu-id="f2960-116">O <xref:System.Int64> valor devem para estar em ordem de bytes de rede.</span><span class="sxs-lookup"><span data-stu-id="f2960-116">The <xref:System.Int64> value is assumed to be in network byte order.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f2960-117"><paramref name="newAddress" /> &lt; 0 ou</span><span class="sxs-lookup"><span data-stu-id="f2960-117"><paramref name="newAddress" /> &lt; 0 or</span></span>  
  
 <span data-ttu-id="f2960-118"><paramref name="newAddress" /> &gt; 0x00000000FFFFFFFF</span><span class="sxs-lookup"><span data-stu-id="f2960-118"><paramref name="newAddress" /> &gt; 0x00000000FFFFFFFF</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (ReadOnlySpan&lt;byte&gt; address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(ReadOnlySpan&lt;System::Byte&gt; address);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="address">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (byte[] address, long scopeid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] address, int64 scopeid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.Byte[],System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As Byte(), scopeid As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(cli::array &lt;System::Byte&gt; ^ address, long scopeid);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.Byte[]" />
        <Parameter Name="scopeid" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="f2960-119">O valor da matriz de bytes do endereço IP.</span><span class="sxs-lookup"><span data-stu-id="f2960-119">The byte array value of the IP address.</span></span></param>
        <param name="scopeid"><span data-ttu-id="f2960-120">O valor longo do identificador de escopo.</span><span class="sxs-lookup"><span data-stu-id="f2960-120">The long value of the scope identifier.</span></span></param>
        <summary><span data-ttu-id="f2960-121">Inicializa uma nova instância da classe <see cref="T:System.Net.IPAddress" /> com o endereço especificado como uma matriz <see cref="T:System.Byte" /> e o identificador de escopo especificado.</span><span class="sxs-lookup"><span data-stu-id="f2960-121">Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class with the address specified as a <see cref="T:System.Byte" /> array and the specified scope identifier.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-122">Este construtor cria um endereço IPv6.</span><span class="sxs-lookup"><span data-stu-id="f2960-122">This constructor instantiates an IPv6 address.</span></span> <span data-ttu-id="f2960-123">O `scopeid` identifica uma interface de rede no caso de um endereço de conexão local.</span><span class="sxs-lookup"><span data-stu-id="f2960-123">The `scopeid` identifies a network interface in the case of a link-local address.</span></span> <span data-ttu-id="f2960-124">O escopo é válido somente para endereços locais de site e local de link.</span><span class="sxs-lookup"><span data-stu-id="f2960-124">The scope is valid only for link-local and site-local addresses.</span></span>  
  
 <span data-ttu-id="f2960-125">O <xref:System.Byte> matriz devem para estar em ordem de bytes de rede com o byte mais significativo primeiro na posição de índice 0.</span><span class="sxs-lookup"><span data-stu-id="f2960-125">The <xref:System.Byte> array is assumed to be in network byte order with the most significant byte first in index position 0.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f2960-126"><paramref name="address" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f2960-126"><paramref name="address" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f2960-127"><paramref name="address" /> contém um endereço IP inválido.</span><span class="sxs-lookup"><span data-stu-id="f2960-127"><paramref name="address" /> contains a bad IP address.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f2960-128"><paramref name="scopeid" /> &lt; 0 ou</span><span class="sxs-lookup"><span data-stu-id="f2960-128"><paramref name="scopeid" /> &lt; 0 or</span></span>  
  
 <span data-ttu-id="f2960-129"><paramref name="scopeid" /> &gt; 0x00000000FFFFFFFF</span><span class="sxs-lookup"><span data-stu-id="f2960-129"><paramref name="scopeid" /> &gt; 0x00000000FFFFFFFF</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (ReadOnlySpan&lt;byte&gt; address, long scopeid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; address, int64 scopeid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.ReadOnlySpan{System.Byte},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As ReadOnlySpan(Of Byte), scopeid As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(ReadOnlySpan&lt;System::Byte&gt; address, long scopeid);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="scopeid" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">To be added.</param>
        <param name="scopeid">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public long Address { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.Address" />
      <MemberSignature Language="VB.NET" Value="Public Property Address As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Address { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This property has been deprecated. It is address family dependent. Please use IPAddress.Equals method to perform comparisons. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f2960-130">Um endereço IP (Internet Protocol).</span><span class="sxs-lookup"><span data-stu-id="f2960-130">An Internet Protocol (IP) address.</span></span></summary>
        <value><span data-ttu-id="f2960-131">O valor longo do endereço IP.</span><span class="sxs-lookup"><span data-stu-id="f2960-131">The long value of the IP address.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-132">Esta propriedade está obsoleta.</span><span class="sxs-lookup"><span data-stu-id="f2960-132">This property is obsolete.</span></span> <span data-ttu-id="f2960-133">Use <xref:System.Net.IPAddress.GetAddressBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="f2960-133">Use <xref:System.Net.IPAddress.GetAddressBytes%2A>.</span></span>  
  
 <span data-ttu-id="f2960-134">Para converter <xref:System.Net.IPAddress.Address%2A> notação pontilhada quad, use o <xref:System.Net.IPAddress.ToString%2A> método.</span><span class="sxs-lookup"><span data-stu-id="f2960-134">To convert <xref:System.Net.IPAddress.Address%2A> to dotted-quad notation, use the <xref:System.Net.IPAddress.ToString%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f2960-135">O exemplo a seguir usa o <xref:System.Net.IPAddress.Address%2A> parâmetro para recuperar o endereço IP do <xref:System.Net.IPAddress> instância.</span><span class="sxs-lookup"><span data-stu-id="f2960-135">The following example uses the <xref:System.Net.IPAddress.Address%2A> parameter to retrieve the IP address of the <xref:System.Net.IPAddress> instance.</span></span>  
  
 [!code-cpp[IPAddress_Address_AddressFamily#2](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_Address_AddressFamily/CPP/ipaddress_address_addressfamily.cpp#2)]
 [!code-csharp[IPAddress_Address_AddressFamily#2](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_Address_AddressFamily/CS/ipaddress_address_addressfamily.cs#2)]
 [!code-vb[IPAddress_Address_AddressFamily#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_Address_AddressFamily/VB/ipaddress_address_addressfamily.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f2960-136">A família de endereços é <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span><span class="sxs-lookup"><span data-stu-id="f2960-136">The address family is <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f2960-137">Obtém a família de endereços do endereço IP.</span><span class="sxs-lookup"><span data-stu-id="f2960-137">Gets the address family of the IP address.</span></span></summary>
        <value><span data-ttu-id="f2960-138">Retorna <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> para IPv4 ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> para IPv6.</span><span class="sxs-lookup"><span data-stu-id="f2960-138">Returns <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> for IPv4 or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> for IPv6.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f2960-139">Consulte o exemplo de <xref:System.Net.IPAddress> tópico sobre a classe.</span><span class="sxs-lookup"><span data-stu-id="f2960-139">Refer to the example in the <xref:System.Net.IPAddress> class topic.</span></span>  
  
 [!code-cpp[System.Net.IPAddress#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#3)]
 [!code-csharp[System.Net.IPAddress#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#3)]
 [!code-vb[System.Net.IPAddress#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Any">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress Any" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Any As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ Any;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f2960-140">Fornece um endereço IP que indica que o servidor deve ouvir a atividade do cliente em todas as interfaces de rede.</span><span class="sxs-lookup"><span data-stu-id="f2960-140">Provides an IP address that indicates that the server must listen for client activity on all network interfaces.</span></span> <span data-ttu-id="f2960-141">Este campo é somente leitura.</span><span class="sxs-lookup"><span data-stu-id="f2960-141">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-142">O <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> método usa o <xref:System.Net.IPAddress.Any> campo para indicar que um <xref:System.Net.Sockets.Socket> instância deve escutar para a atividade de cliente em todas as interfaces de rede.</span><span class="sxs-lookup"><span data-stu-id="f2960-142">The <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> method uses the <xref:System.Net.IPAddress.Any> field to indicate that a <xref:System.Net.Sockets.Socket> instance must listen for client activity on all network interfaces.</span></span>  
  
 <span data-ttu-id="f2960-143">O <xref:System.Net.IPAddress.Any> campo é equivalente à 0.0.0.0 na notação pontilhada quad.</span><span class="sxs-lookup"><span data-stu-id="f2960-143">The <xref:System.Net.IPAddress.Any> field is equivalent to 0.0.0.0 in dotted-quad notation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Broadcast">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress Broadcast;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress Broadcast" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.Broadcast" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Broadcast As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ Broadcast;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f2960-144">Fornece o endereço IP de difusão.</span><span class="sxs-lookup"><span data-stu-id="f2960-144">Provides the IP broadcast address.</span></span> <span data-ttu-id="f2960-145">Este campo é somente leitura.</span><span class="sxs-lookup"><span data-stu-id="f2960-145">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-146">O <xref:System.Net.IPAddress.Broadcast> campo é equivalente à 255.255.255.255 na notação pontilhada quad.</span><span class="sxs-lookup"><span data-stu-id="f2960-146">The <xref:System.Net.IPAddress.Broadcast> field is equivalent to 255.255.255.255 in dotted-quad notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f2960-147">O exemplo a seguir imprime o <xref:System.Net.IPAddress.Broadcast> endereço para o console.</span><span class="sxs-lookup"><span data-stu-id="f2960-147">The following example prints the <xref:System.Net.IPAddress.Broadcast> address to the console.</span></span>  
  
 [!code-cpp[IPAddress_Broadcast_Loopback#2](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CPP/ipaddress_broadcast_loopback.cpp#2)]
 [!code-csharp[IPAddress_Broadcast_Loopback#2](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CS/ipaddress_broadcast_loopback.cs#2)]
 [!code-vb[IPAddress_Broadcast_Loopback#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/VB/ipaddress_broadcast_loopback.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (comparand As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ comparand);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="comparand"><span data-ttu-id="f2960-148">Uma instância do <see cref="T:System.Net.IPAddress" /> a ser comparada com a instância atual.</span><span class="sxs-lookup"><span data-stu-id="f2960-148">An <see cref="T:System.Net.IPAddress" /> instance to compare to the current instance.</span></span></param>
        <summary><span data-ttu-id="f2960-149">Compara dois endereços IP.</span><span class="sxs-lookup"><span data-stu-id="f2960-149">Compares two IP addresses.</span></span></summary>
        <returns>
          <span data-ttu-id="f2960-150"><see langword="true" /> se os dois endereços forem iguais; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f2960-150"><see langword="true" /> if the two addresses are equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-151">O <xref:System.Net.IPAddress.Equals%2A> método compara atual <xref:System.Net.IPAddress> instância com o `comparand` parâmetro e retorna `true` se as duas instâncias contêm o mesmo endereço IP.</span><span class="sxs-lookup"><span data-stu-id="f2960-151">The <xref:System.Net.IPAddress.Equals%2A> method compares the current <xref:System.Net.IPAddress> instance with the `comparand` parameter and returns `true` if the two instances contain the same IP address.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAddressBytes">
      <MemberSignature Language="C#" Value="public byte[] GetAddressBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetAddressBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.GetAddressBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAddressBytes () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetAddressBytes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f2960-152">Fornece uma cópia do <see cref="T:System.Net.IPAddress" /> como uma matriz de bytes.</span><span class="sxs-lookup"><span data-stu-id="f2960-152">Provides a copy of the <see cref="T:System.Net.IPAddress" /> as an array of bytes.</span></span></summary>
        <returns><span data-ttu-id="f2960-153">Uma matriz <see cref="T:System.Byte" />.</span><span class="sxs-lookup"><span data-stu-id="f2960-153">A <see cref="T:System.Byte" /> array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f2960-154">O exemplo de código a seguir mostra como obter um servidor de endereço IP no formato de byte.</span><span class="sxs-lookup"><span data-stu-id="f2960-154">The following code example shows how to get a server IP address in byte format.</span></span>  
  
 [!code-cpp[System.Net.IPAddress#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#2)]
 [!code-csharp[System.Net.IPAddress#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#2)]
 [!code-vb[System.Net.IPAddress#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f2960-155">Retorna um valor de hash para um endereço IP.</span><span class="sxs-lookup"><span data-stu-id="f2960-155">Returns a hash value for an IP address.</span></span></summary>
        <returns><span data-ttu-id="f2960-156">Um valor de hash inteiro.</span><span class="sxs-lookup"><span data-stu-id="f2960-156">An integer hash value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-157">O <xref:System.Net.IPAddress.GetHashCode%2A> método retorna um código hash do endereço IP.</span><span class="sxs-lookup"><span data-stu-id="f2960-157">The <xref:System.Net.IPAddress.GetHashCode%2A> method returns a hash code of the IP address.</span></span> <span data-ttu-id="f2960-158">Esse valor pode ser usado como uma chave em tabelas de hash.</span><span class="sxs-lookup"><span data-stu-id="f2960-158">This value can be used as a key in hash tables.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HostToNetworkOrder">
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f2960-159">Converte um valor de ordem de byte de host em ordem de byte de rede.</span><span class="sxs-lookup"><span data-stu-id="f2960-159">Converts a value from host byte order to network byte order.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HostToNetworkOrder">
      <MemberSignature Language="C#" Value="public static short HostToNetworkOrder (short host);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 HostToNetworkOrder(int16 host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.HostToNetworkOrder(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HostToNetworkOrder (host As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short HostToNetworkOrder(short host);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="host"><span data-ttu-id="f2960-160">O número a ser convertido, expresso em ordem de byte de host.</span><span class="sxs-lookup"><span data-stu-id="f2960-160">The number to convert, expressed in host byte order.</span></span></param>
        <summary><span data-ttu-id="f2960-161">Converte um valor resumido da ordem de byte de host em ordem de byte de rede.</span><span class="sxs-lookup"><span data-stu-id="f2960-161">Converts a short value from host byte order to network byte order.</span></span></summary>
        <returns><span data-ttu-id="f2960-162">Um valor resumido, expresso em ordem de byte de rede.</span><span class="sxs-lookup"><span data-stu-id="f2960-162">A short value, expressed in network byte order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-163">Computadores diferentes usam diferentes convenções para ordenar os bytes dentro de valores inteiros multibyte.</span><span class="sxs-lookup"><span data-stu-id="f2960-163">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="f2960-164">Alguns computadores colocados o byte mais significativo primeiro (conhecido como ordem big-endian) e outros colocar o byte menos significativo primeiro (conhecido como ordem de little endian).</span><span class="sxs-lookup"><span data-stu-id="f2960-164">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="f2960-165">Para trabalhar com computadores que usam a ordem de bytes diferentes, todos os valores de inteiro que são enviados pela rede são enviados na ordem de bytes de rede que tem o byte mais significativo primeiro.</span><span class="sxs-lookup"><span data-stu-id="f2960-165">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="f2960-166">O <xref:System.Net.IPAddress.HostToNetworkOrder%2A> método converte valores inteiros multibyte que são armazenados no sistema de host da ordem de bytes usado pelo host para a ordem de bytes usado pela rede.</span><span class="sxs-lookup"><span data-stu-id="f2960-166">The <xref:System.Net.IPAddress.HostToNetworkOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the host to the byte order used by the network.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="HostToNetworkOrder">
      <MemberSignature Language="C#" Value="public static int HostToNetworkOrder (int host);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 HostToNetworkOrder(int32 host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.HostToNetworkOrder(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HostToNetworkOrder (host As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int HostToNetworkOrder(int host);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host"><span data-ttu-id="f2960-167">O número a ser convertido, expresso em ordem de byte de host.</span><span class="sxs-lookup"><span data-stu-id="f2960-167">The number to convert, expressed in host byte order.</span></span></param>
        <summary><span data-ttu-id="f2960-168">Converte um valor inteiro da ordem de byte de host para a ordem de byte de rede.</span><span class="sxs-lookup"><span data-stu-id="f2960-168">Converts an integer value from host byte order to network byte order.</span></span></summary>
        <returns><span data-ttu-id="f2960-169">Um valor inteiro, expresso em ordem de byte de rede.</span><span class="sxs-lookup"><span data-stu-id="f2960-169">An integer value, expressed in network byte order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-170">Computadores diferentes usam diferentes convenções para ordenar os bytes dentro de valores inteiros multibyte.</span><span class="sxs-lookup"><span data-stu-id="f2960-170">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="f2960-171">Alguns computadores colocados o byte mais significativo primeiro (conhecido como ordem big-endian) e outros colocar o byte menos significativo primeiro (conhecido como ordem de little endian).</span><span class="sxs-lookup"><span data-stu-id="f2960-171">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="f2960-172">Para trabalhar com computadores que usam a ordem de bytes diferentes, todos os valores de inteiro que são enviados pela rede são enviados na ordem de bytes de rede que tem o byte mais significativo primeiro.</span><span class="sxs-lookup"><span data-stu-id="f2960-172">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="f2960-173">O <xref:System.Net.IPAddress.HostToNetworkOrder%2A> método converte valores inteiros multibyte que são armazenados no sistema de host da ordem de bytes usado pelo host para a ordem de bytes usado pela rede.</span><span class="sxs-lookup"><span data-stu-id="f2960-173">The <xref:System.Net.IPAddress.HostToNetworkOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the host to the byte order used by the network.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="HostToNetworkOrder">
      <MemberSignature Language="C#" Value="public static long HostToNetworkOrder (long host);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 HostToNetworkOrder(int64 host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HostToNetworkOrder (host As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long HostToNetworkOrder(long host);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="host"><span data-ttu-id="f2960-174">O número a ser convertido, expresso em ordem de byte de host.</span><span class="sxs-lookup"><span data-stu-id="f2960-174">The number to convert, expressed in host byte order.</span></span></param>
        <summary><span data-ttu-id="f2960-175">Converte um valor longo de ordem de byte de host em ordem de byte de rede.</span><span class="sxs-lookup"><span data-stu-id="f2960-175">Converts a long value from host byte order to network byte order.</span></span></summary>
        <returns><span data-ttu-id="f2960-176">Um valor longo, expresso em ordem de byte de rede.</span><span class="sxs-lookup"><span data-stu-id="f2960-176">A long value, expressed in network byte order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-177">Computadores diferentes usam diferentes convenções para ordenar os bytes dentro de valores inteiros multibyte.</span><span class="sxs-lookup"><span data-stu-id="f2960-177">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="f2960-178">Alguns computadores colocados o byte mais significativo primeiro (conhecido como ordem big-endian) e outros colocar o byte menos significativo primeiro (conhecido como ordem de little endian).</span><span class="sxs-lookup"><span data-stu-id="f2960-178">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="f2960-179">Para trabalhar com computadores que usam a ordem de bytes diferentes, todos os valores de inteiro que são enviados pela rede são enviados na ordem de bytes de rede que tem o byte mais significativo primeiro.</span><span class="sxs-lookup"><span data-stu-id="f2960-179">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="f2960-180">O <xref:System.Net.IPAddress.HostToNetworkOrder%2A> método converte valores inteiros multibyte que são armazenados no sistema de host da ordem de bytes usado pelo host para a ordem de bytes usado pela rede.</span><span class="sxs-lookup"><span data-stu-id="f2960-180">The <xref:System.Net.IPAddress.HostToNetworkOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the host to the byte order used by the network.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="IPv6Any">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress IPv6Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress IPv6Any" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.IPv6Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IPv6Any As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ IPv6Any;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f2960-181">O método <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> utiliza o campo <see cref="F:System.Net.IPAddress.IPv6Any" /> para indicar que um <see cref="T:System.Net.Sockets.Socket" /> deve escutar a atividade de cliente em todos os adaptadores de rede.</span><span class="sxs-lookup"><span data-stu-id="f2960-181">The <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method uses the <see cref="F:System.Net.IPAddress.IPv6Any" /> field to indicate that a <see cref="T:System.Net.Sockets.Socket" /> must listen for client activity on all network interfaces.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-182">O <xref:System.Net.IPAddress.IPv6Any> campo é equivalente à 0:0:0:0:0:0:0:0 em notação hexadecimal com dois-pontos ou:: na notação compact.</span><span class="sxs-lookup"><span data-stu-id="f2960-182">The <xref:System.Net.IPAddress.IPv6Any> field is equivalent to 0:0:0:0:0:0:0:0 in colon-hexadecimal notation, or to :: in compact notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f2960-183">O exemplo de código a seguir exibe o valor atual qualquer endereço do host em formato compactado padrão.</span><span class="sxs-lookup"><span data-stu-id="f2960-183">The following code example displays the value of the current host's Any address in standard compressed format.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.IPv6NoneAnyLoopback#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CPP/noneanyloopback.cpp#2)]
 [!code-csharp[System.Net.IPAddress.IPv6NoneAnyLoopback#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CS/noneanyloopback.cs#2)]
 [!code-vb[System.Net.IPAddress.IPv6NoneAnyLoopback#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/VB/noneanyloopback.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IPv6Loopback">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress IPv6Loopback;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress IPv6Loopback" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.IPv6Loopback" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IPv6Loopback As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ IPv6Loopback;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f2960-184">Fornece o endereço de loopback de IP.</span><span class="sxs-lookup"><span data-stu-id="f2960-184">Provides the IP loopback address.</span></span> <span data-ttu-id="f2960-185">Esta propriedade é somente para leitura.</span><span class="sxs-lookup"><span data-stu-id="f2960-185">This property is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-186">O <xref:System.Net.IPAddress.IPv6Loopback> campo é equivalente à 0:0:0:0:0:0:0:1 em notação hexadecimal com dois-pontos ou:: 1 na notação compact.</span><span class="sxs-lookup"><span data-stu-id="f2960-186">The <xref:System.Net.IPAddress.IPv6Loopback> field is equivalent to 0:0:0:0:0:0:0:1 in colon-hexadecimal notation, or to ::1 in compact notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f2960-187">O exemplo de código a seguir exibe o valor do endereço de loopback do host em formato compactado padrão.</span><span class="sxs-lookup"><span data-stu-id="f2960-187">The following code example displays the value of the current host's loopback address in standard compressed format.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.IPv6NoneAnyLoopback#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CPP/noneanyloopback.cpp#1)]
 [!code-csharp[System.Net.IPAddress.IPv6NoneAnyLoopback#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CS/noneanyloopback.cs#1)]
 [!code-vb[System.Net.IPAddress.IPv6NoneAnyLoopback#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/VB/noneanyloopback.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IPv6None">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress IPv6None;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress IPv6None" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.IPv6None" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IPv6None As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ IPv6None;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f2960-188">Fornece um endereço IP que indica que nenhum adaptador de rede deve ser usado.</span><span class="sxs-lookup"><span data-stu-id="f2960-188">Provides an IP address that indicates that no network interface should be used.</span></span> <span data-ttu-id="f2960-189">Esta propriedade é somente para leitura.</span><span class="sxs-lookup"><span data-stu-id="f2960-189">This property is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-190">O <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> método usa o <xref:System.Net.IPAddress.IPv6None> campo para indicar que um <xref:System.Net.Sockets.Socket> não deve escutar para a atividade do cliente.</span><span class="sxs-lookup"><span data-stu-id="f2960-190">The <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> method uses the <xref:System.Net.IPAddress.IPv6None> field to indicate that a <xref:System.Net.Sockets.Socket> must not listen for client activity.</span></span> <span data-ttu-id="f2960-191">O <xref:System.Net.IPAddress.IPv6None> campo é equivalente à 0:0:0:0:0:0:0:0 em notação hexadecimal com dois-pontos ou:: 0 na notação compact.</span><span class="sxs-lookup"><span data-stu-id="f2960-191">The <xref:System.Net.IPAddress.IPv6None> field is equivalent to 0:0:0:0:0:0:0:0 in colon-hexadecimal notation, or to ::0 in compact notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f2960-192">O exemplo de código a seguir exibe o valor atual do host que nenhum endereço no formato compactado padrão.</span><span class="sxs-lookup"><span data-stu-id="f2960-192">The following code example displays the value of the current host's None address in standard compressed format.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.IPv6NoneAnyLoopback#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CPP/noneanyloopback.cpp#3)]
 [!code-csharp[System.Net.IPAddress.IPv6NoneAnyLoopback#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CS/noneanyloopback.cs#3)]
 [!code-vb[System.Net.IPAddress.IPv6NoneAnyLoopback#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/VB/noneanyloopback.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv4MappedToIPv6">
      <MemberSignature Language="C#" Value="public bool IsIPv4MappedToIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv4MappedToIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv4MappedToIPv6" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv4MappedToIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv4MappedToIPv6 { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f2960-193">Determina se o endereço IP é um endereço IPv6 mapeado por IPv4.</span><span class="sxs-lookup"><span data-stu-id="f2960-193">Gets whether the IP address is an IPv4-mapped IPv6 address.</span></span></summary>
        <value><span data-ttu-id="f2960-194">Retorna <see cref="T:System.Boolean" />.</span><span class="sxs-lookup"><span data-stu-id="f2960-194">Returns <see cref="T:System.Boolean" />.</span></span>  
  
 <span data-ttu-id="f2960-195"><see langword="true" /> se o endereço IP for um endereço IPv6 mapeado por IPv4; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f2960-195"><see langword="true" /> if the IP address is an IPv4-mapped IPv6 address; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-196">Soquetes de pilha dupla sempre exigem endereços IPv6.</span><span class="sxs-lookup"><span data-stu-id="f2960-196">Dual-stack sockets always require IPv6 addresses.</span></span> <span data-ttu-id="f2960-197">A capacidade de interagir com um endereço IPv4 requer o uso do formato de endereço IPv6 mapeados para IPv4.</span><span class="sxs-lookup"><span data-stu-id="f2960-197">The ability to interact with an IPv4 address requires the use of the IPv4-mapped IPv6 address format.</span></span> <span data-ttu-id="f2960-198">Os endereços IPv4 devem ser representados no formato de endereço IPv6 mapeados para IPv4, que permite que um aplicativo somente IPv6 para se comunicar com um nó de IPv4.</span><span class="sxs-lookup"><span data-stu-id="f2960-198">Any IPv4 addresses must be represented in the IPv4-mapped IPv6 address format which enables an IPv6 only application to communicate with an IPv4 node.</span></span> <span data-ttu-id="f2960-199">O formato do endereço IPv6 mapeados para IPv4 permite que o endereço IPv4 de um nó de IPv4 a ser representado como um endereço IPv6.</span><span class="sxs-lookup"><span data-stu-id="f2960-199">The IPv4-mapped IPv6 address format allows the IPv4 address of an IPv4 node to be represented as an IPv6 address.</span></span> <span data-ttu-id="f2960-200">O endereço IPv4 é codificado nos 32 bits de ordem inferior do endereço IPv6 e os bits de ordem alta 96 mantenha 0:0:0:0:0:FFFF o prefixo fixa.</span><span class="sxs-lookup"><span data-stu-id="f2960-200">The IPv4 address is encoded into the low-order 32 bits of the IPv6 address, and the high-order 96 bits hold the fixed prefix 0:0:0:0:0:FFFF.</span></span> <span data-ttu-id="f2960-201">O formato do endereço IPv6 mapeados para IPv4 é especificado no RFC 4291.</span><span class="sxs-lookup"><span data-stu-id="f2960-201">The IPv4-mapped IPv6 address format is specified in RFC 4291.</span></span> <span data-ttu-id="f2960-202">Para obter mais informações, consulte [www.ietf.org/rfc/rfc4291.txt](http://go.microsoft.com/fwlink/?LinkID=92231).</span><span class="sxs-lookup"><span data-stu-id="f2960-202">For more information, see [www.ietf.org/rfc/rfc4291.txt](http://go.microsoft.com/fwlink/?LinkID=92231).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6LinkLocal">
      <MemberSignature Language="C#" Value="public bool IsIPv6LinkLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6LinkLocal" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6LinkLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6LinkLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6LinkLocal { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f2960-203">Determina se o endereço é um endereço local do link IPv6.</span><span class="sxs-lookup"><span data-stu-id="f2960-203">Gets whether the address is an IPv6 link local address.</span></span></summary>
        <value>
          <span data-ttu-id="f2960-204"><see langword="true" /> se o endereço IP for um endereço local do link IPv6; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f2960-204"><see langword="true" /> if the IP address is an IPv6 link local address; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6Multicast">
      <MemberSignature Language="C#" Value="public bool IsIPv6Multicast { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6Multicast" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6Multicast" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6Multicast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6Multicast { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f2960-205">Determina se o endereço é um endereço global multicast IPv6.</span><span class="sxs-lookup"><span data-stu-id="f2960-205">Gets whether the address is an IPv6 multicast global address.</span></span></summary>
        <value>
          <span data-ttu-id="f2960-206"><see langword="true" /> Se o endereço IP é um multicast IPv6 global address; Caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f2960-206"><see langword="true" /> if the IP address is an IPv6 multicast global address; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6SiteLocal">
      <MemberSignature Language="C#" Value="public bool IsIPv6SiteLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6SiteLocal" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6SiteLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6SiteLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6SiteLocal { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f2960-207">Determina se o endereço é um endereço local de site IPv6.</span><span class="sxs-lookup"><span data-stu-id="f2960-207">Gets whether the address is an IPv6 site local address.</span></span></summary>
        <value>
          <span data-ttu-id="f2960-208"><see langword="true" /> Se o endereço IP é um endereço de local do site do IPv6; Caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f2960-208"><see langword="true" /> if the IP address is an IPv6 site local address; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6Teredo">
      <MemberSignature Language="C#" Value="public bool IsIPv6Teredo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6Teredo" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6Teredo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6Teredo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6Teredo { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f2960-209">Determina se o endereço é um endereço IPv6 Teredo.</span><span class="sxs-lookup"><span data-stu-id="f2960-209">Gets whether the address is an IPv6 Teredo address.</span></span></summary>
        <value>
          <span data-ttu-id="f2960-210"><see langword="true" /> se o endereço IP for um endereço IPv6 Teredo; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f2960-210"><see langword="true" /> if the IP address is an IPv6 Teredo address; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-211">Um endereço de Teredo é um endereço IPv6 com o prefixo de 2001::/ / 32.</span><span class="sxs-lookup"><span data-stu-id="f2960-211">A Teredo address is an IPv6 address with the prefix of 2001::/32.</span></span> <span data-ttu-id="f2960-212">Endereços Teredo podem ser retornados por meio da resolução de nome DNS normal ou enumerados como um endereço de IPv6 atribuído a uma interface local.</span><span class="sxs-lookup"><span data-stu-id="f2960-212">Teredo addresses can be returned through normal DNS name resolution or enumerated as an IPv6 address assigned to a local interface.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.NetworkInformation.IPGlobalProperties.BeginGetUnicastAddresses(System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.NetworkInformation.IPGlobalProperties.EndGetUnicastAddresses(System.IAsyncResult)" />
        <altmember cref="M:System.Net.NetworkInformation.IPGlobalProperties.GetUnicastAddresses" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsLoopback">
      <MemberSignature Language="C#" Value="public static bool IsLoopback (System.Net.IPAddress address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLoopback(class System.Net.IPAddress address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.IsLoopback(System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLoopback (address As IPAddress) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLoopback(System::Net::IPAddress ^ address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="f2960-213">Um endereço IP.</span><span class="sxs-lookup"><span data-stu-id="f2960-213">An IP address.</span></span></param>
        <summary><span data-ttu-id="f2960-214">Indica se o endereço IP especificado é o endereço de loopback.</span><span class="sxs-lookup"><span data-stu-id="f2960-214">Indicates whether the specified IP address is the loopback address.</span></span></summary>
        <returns>
          <span data-ttu-id="f2960-215"><see langword="true" /> se <paramref name="address" /> é o endereço de loopback, caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f2960-215"><see langword="true" /> if <paramref name="address" /> is the loopback address; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-216">O <xref:System.Net.IPAddress.IsLoopback%2A> método compara `address` para <xref:System.Net.IPAddress.Loopback> e retorna `true` se os dois endereços IP forem iguais.</span><span class="sxs-lookup"><span data-stu-id="f2960-216">The <xref:System.Net.IPAddress.IsLoopback%2A> method compares `address` to <xref:System.Net.IPAddress.Loopback> and returns `true` if the two IP addresses are the same.</span></span>  
  
 <span data-ttu-id="f2960-217">No caso de IPv4, que o <xref:System.Net.IPAddress.IsLoopback%2A> método `true` para qualquer endereço IP do formulário 127.X.Y.Z (em que X, Y e Z estão no intervalo 0-255), não apenas <xref:System.Net.IPAddress.Loopback> (127.0.0.1).</span><span class="sxs-lookup"><span data-stu-id="f2960-217">In the case of IPv4, that the <xref:System.Net.IPAddress.IsLoopback%2A> method returns `true` for any IP address of the form 127.X.Y.Z (where X, Y, and Z are in the range 0-255), not just <xref:System.Net.IPAddress.Loopback> (127.0.0.1).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f2960-218">O seguinte exemplo de código usa o <xref:System.Net.IPAddress.IsLoopback%2A> método para determinar se o endereço especificado é um endereço de loopback.</span><span class="sxs-lookup"><span data-stu-id="f2960-218">The following code example uses the <xref:System.Net.IPAddress.IsLoopback%2A> method to determine whether the specified address is a loopback address.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.IsLoopback#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IsLoopback/CPP/isloopback.cpp#1)]
 [!code-csharp[System.Net.IPAddress.IsLoopback#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IsLoopback/CS/isloopback.cs#1)]
 [!code-vb[System.Net.IPAddress.IsLoopback#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IsLoopback/VB/isloopback.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Loopback">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress Loopback;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress Loopback" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.Loopback" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Loopback As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ Loopback;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f2960-219">Fornece o endereço de loopback de IP.</span><span class="sxs-lookup"><span data-stu-id="f2960-219">Provides the IP loopback address.</span></span> <span data-ttu-id="f2960-220">Este campo é somente leitura.</span><span class="sxs-lookup"><span data-stu-id="f2960-220">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-221">O <xref:System.Net.IPAddress.Loopback> campo é equivalente à 127.0.0.1 na notação pontilhada quad.</span><span class="sxs-lookup"><span data-stu-id="f2960-221">The <xref:System.Net.IPAddress.Loopback> field is equivalent to 127.0.0.1 in dotted-quad notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f2960-222">O exemplo a seguir imprime o <xref:System.Net.IPAddress.Loopback> endereço para o console.</span><span class="sxs-lookup"><span data-stu-id="f2960-222">The following example prints the <xref:System.Net.IPAddress.Loopback> address to the console.</span></span>  
  
 [!code-cpp[IPAddress_Broadcast_Loopback#1](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CPP/ipaddress_broadcast_loopback.cpp#1)]
 [!code-csharp[IPAddress_Broadcast_Loopback#1](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CS/ipaddress_broadcast_loopback.cs#1)]
 [!code-vb[IPAddress_Broadcast_Loopback#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/VB/ipaddress_broadcast_loopback.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapToIPv4">
      <MemberSignature Language="C#" Value="public System.Net.IPAddress MapToIPv4 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.IPAddress MapToIPv4() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.MapToIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Function MapToIPv4 () As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::IPAddress ^ MapToIPv4();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f2960-223">Mapeia o objeto <see cref="T:System.Net.IPAddress" /> para um endereço IPv4.</span><span class="sxs-lookup"><span data-stu-id="f2960-223">Maps the <see cref="T:System.Net.IPAddress" /> object to an IPv4 address.</span></span></summary>
        <returns><span data-ttu-id="f2960-224">Retorna <see cref="T:System.Net.IPAddress" />.</span><span class="sxs-lookup"><span data-stu-id="f2960-224">Returns <see cref="T:System.Net.IPAddress" />.</span></span>  
  
 <span data-ttu-id="f2960-225">Um endereço IPv4.</span><span class="sxs-lookup"><span data-stu-id="f2960-225">An IPv4 address.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-226">Soquetes de pilha dupla sempre exigem endereços IPv6.</span><span class="sxs-lookup"><span data-stu-id="f2960-226">Dual-stack sockets always require IPv6 addresses.</span></span> <span data-ttu-id="f2960-227">A capacidade de interagir com um endereço IPv4 requer o uso do formato de endereço IPv6 mapeados para IPv4.</span><span class="sxs-lookup"><span data-stu-id="f2960-227">The ability to interact with an IPv4 address requires the use of the IPv4-mapped IPv6 address format.</span></span> <span data-ttu-id="f2960-228">Os endereços IPv4 devem ser representados no formato de endereço IPv6 mapeados para IPv4, que permite que um aplicativo somente IPv6 para se comunicar com um nó de IPv4.</span><span class="sxs-lookup"><span data-stu-id="f2960-228">Any IPv4 addresses must be represented in the IPv4-mapped IPv6 address format which enables an IPv6 only application to communicate with an IPv4 node.</span></span> <span data-ttu-id="f2960-229">O formato do endereço IPv6 mapeados para IPv4 permite que o endereço IPv4 de um nó de IPv4 a ser representado como um endereço IPv6.</span><span class="sxs-lookup"><span data-stu-id="f2960-229">The IPv4-mapped IPv6 address format allows the IPv4 address of an IPv4 node to be represented as an IPv6 address.</span></span> <span data-ttu-id="f2960-230">O endereço IPv4 é codificado nos 32 bits de ordem inferior do endereço IPv6 e os bits de ordem alta 96 mantenha 0:0:0:0:0:FFFF o prefixo fixa.</span><span class="sxs-lookup"><span data-stu-id="f2960-230">The IPv4 address is encoded into the low-order 32 bits of the IPv6 address, and the high-order 96 bits hold the fixed prefix 0:0:0:0:0:FFFF.</span></span> <span data-ttu-id="f2960-231">O formato do endereço IPv6 mapeados para IPv4 é especificado no RFC 4291.</span><span class="sxs-lookup"><span data-stu-id="f2960-231">The IPv4-mapped IPv6 address format is specified in RFC 4291.</span></span> <span data-ttu-id="f2960-232">Para obter mais informações, consulte [www.ietf.org/rfc/rfc4291.txt](http://go.microsoft.com/fwlink/?LinkID=92231).</span><span class="sxs-lookup"><span data-stu-id="f2960-232">For more information, see [www.ietf.org/rfc/rfc4291.txt](http://go.microsoft.com/fwlink/?LinkID=92231).</span></span>  
  
 <span data-ttu-id="f2960-233">Se você quiser usar <xref:System.Net.IPAddress.MapToIPv4%2A> para converter um endereço IPv4 do formato de IPv6 no formato IPv4, primeiro você deve assegurar que você tem um endereço IPv4.</span><span class="sxs-lookup"><span data-stu-id="f2960-233">If you want to use <xref:System.Net.IPAddress.MapToIPv4%2A> to convert an IPv4 address from IPv6 format to IPv4 format, you must first ensure that you've got an IPv4 address.</span></span> <span data-ttu-id="f2960-234">Chamar <xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A>, que retornará `true` se o endereço IP é originalmente IPv4 gravados como IPv6, ou `false` caso contrário.</span><span class="sxs-lookup"><span data-stu-id="f2960-234">Call <xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A>, which will return `true` if the IP address is originally IPv4 written as IPv6, or `false` otherwise.</span></span> <span data-ttu-id="f2960-235">Se <xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A> retorna `true`, use <xref:System.Net.IPAddress.MapToIPv4%2A> para fazer a conversão.</span><span class="sxs-lookup"><span data-stu-id="f2960-235">If <xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A> returns `true`, use <xref:System.Net.IPAddress.MapToIPv4%2A> to make the conversion.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapToIPv6">
      <MemberSignature Language="C#" Value="public System.Net.IPAddress MapToIPv6 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.IPAddress MapToIPv6() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.MapToIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Function MapToIPv6 () As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::IPAddress ^ MapToIPv6();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f2960-236">Mapeia o objeto <see cref="T:System.Net.IPAddress" /> para um endereço IPv6.</span><span class="sxs-lookup"><span data-stu-id="f2960-236">Maps the <see cref="T:System.Net.IPAddress" /> object to an IPv6 address.</span></span></summary>
        <returns><span data-ttu-id="f2960-237">Retorna <see cref="T:System.Net.IPAddress" />.</span><span class="sxs-lookup"><span data-stu-id="f2960-237">Returns <see cref="T:System.Net.IPAddress" />.</span></span>  
  
 <span data-ttu-id="f2960-238">Um endereço IPv6.</span><span class="sxs-lookup"><span data-stu-id="f2960-238">An IPv6 address.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-239">Soquetes de pilha dupla sempre exigem endereços IPv6.</span><span class="sxs-lookup"><span data-stu-id="f2960-239">Dual-stack sockets always require IPv6 addresses.</span></span> <span data-ttu-id="f2960-240">A capacidade de interagir com um endereço IPv4 requer o uso do formato de endereço IPv6 mapeados para IPv4.</span><span class="sxs-lookup"><span data-stu-id="f2960-240">The ability to interact with an IPv4 address requires the use of the IPv4-mapped IPv6 address format.</span></span> <span data-ttu-id="f2960-241">Os endereços IPv4 devem ser representados no formato de endereço IPv6 mapeados para IPv4, que permite que um aplicativo somente IPv6 para se comunicar com um nó de IPv4.</span><span class="sxs-lookup"><span data-stu-id="f2960-241">Any IPv4 addresses must be represented in the IPv4-mapped IPv6 address format which enables an IPv6 only application to communicate with an IPv4 node.</span></span> <span data-ttu-id="f2960-242">O formato do endereço IPv6 mapeados para IPv4 permite que o endereço IPv4 de um nó de IPv4 a ser representado como um endereço IPv6.</span><span class="sxs-lookup"><span data-stu-id="f2960-242">The IPv4-mapped IPv6 address format allows the IPv4 address of an IPv4 node to be represented as an IPv6 address.</span></span> <span data-ttu-id="f2960-243">O endereço IPv4 é codificado nos 32 bits de ordem inferior do endereço IPv6 e os bits de ordem alta 96 mantenha 0:0:0:0:0:FFFF o prefixo fixa.</span><span class="sxs-lookup"><span data-stu-id="f2960-243">The IPv4 address is encoded into the low-order 32 bits of the IPv6 address, and the high-order 96 bits hold the fixed prefix 0:0:0:0:0:FFFF.</span></span> <span data-ttu-id="f2960-244">O formato do endereço IPv6 mapeados para IPv4 é especificado no RFC 4291.</span><span class="sxs-lookup"><span data-stu-id="f2960-244">The IPv4-mapped IPv6 address format is specified in RFC 4291.</span></span> <span data-ttu-id="f2960-245">Para obter mais informações, consulte [www.ietf.org/rfc/rfc4291.txt](http://go.microsoft.com/fwlink/?LinkID=92231).</span><span class="sxs-lookup"><span data-stu-id="f2960-245">For more information, see [www.ietf.org/rfc/rfc4291.txt](http://go.microsoft.com/fwlink/?LinkID=92231).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="NetworkToHostOrder">
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f2960-246">Converte um número de ordem de byte de rede em ordem de byte de host.</span><span class="sxs-lookup"><span data-stu-id="f2960-246">Converts a number from network byte order to host byte order.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NetworkToHostOrder">
      <MemberSignature Language="C#" Value="public static short NetworkToHostOrder (short network);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 NetworkToHostOrder(int16 network) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.NetworkToHostOrder(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NetworkToHostOrder (network As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short NetworkToHostOrder(short network);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="network" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="network"><span data-ttu-id="f2960-247">O número a ser convertido, expresso em ordem de byte de rede.</span><span class="sxs-lookup"><span data-stu-id="f2960-247">The number to convert, expressed in network byte order.</span></span></param>
        <summary><span data-ttu-id="f2960-248">Converte um valor resumido da ordem de byte de rede em ordem de byte de host.</span><span class="sxs-lookup"><span data-stu-id="f2960-248">Converts a short value from network byte order to host byte order.</span></span></summary>
        <returns><span data-ttu-id="f2960-249">Um valor resumido, expresso em ordem de byte de host.</span><span class="sxs-lookup"><span data-stu-id="f2960-249">A short value, expressed in host byte order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-250">Computadores diferentes usam diferentes convenções para ordenar os bytes dentro de valores inteiros multibyte.</span><span class="sxs-lookup"><span data-stu-id="f2960-250">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="f2960-251">Alguns computadores colocados o byte mais significativo primeiro (conhecido como ordem big-endian) e outros colocar o byte menos significativo primeiro (conhecido como ordem de little endian).</span><span class="sxs-lookup"><span data-stu-id="f2960-251">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="f2960-252">Para trabalhar com computadores que usam a ordem de bytes diferentes, todos os valores de inteiro que são enviados pela rede são enviados na ordem de bytes de rede que tem o byte mais significativo primeiro.</span><span class="sxs-lookup"><span data-stu-id="f2960-252">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="f2960-253">O <xref:System.Net.IPAddress.NetworkToHostOrder%2A> método converte valores inteiros multibyte que são armazenados no sistema de host da ordem de bytes usado pela rede para a ordem de bytes usada pelo host.</span><span class="sxs-lookup"><span data-stu-id="f2960-253">The <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the network to the byte order used by the host.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f2960-254">O exemplo a seguir usa o <xref:System.Net.IPAddress.NetworkToHostOrder%2A> método para converter um valor curto de ordem de bytes de rede para ordem de byte do host.</span><span class="sxs-lookup"><span data-stu-id="f2960-254">The following example uses the <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method to convert a short value from network byte order to host byte order.</span></span>  
  
 [!code-cpp[IPAddress_NetworkToHost#1](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CPP/ipaddress_networktohost.cpp#1)]
 [!code-csharp[IPAddress_NetworkToHost#1](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CS/ipaddress_networktohost.cs#1)]
 [!code-vb[IPAddress_NetworkToHost#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_NetworkToHost/VB/ipaddress_networktohost.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="NetworkToHostOrder">
      <MemberSignature Language="C#" Value="public static int NetworkToHostOrder (int network);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 NetworkToHostOrder(int32 network) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.NetworkToHostOrder(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NetworkToHostOrder (network As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int NetworkToHostOrder(int network);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="network" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="network"><span data-ttu-id="f2960-255">O número a ser convertido, expresso em ordem de byte de rede.</span><span class="sxs-lookup"><span data-stu-id="f2960-255">The number to convert, expressed in network byte order.</span></span></param>
        <summary><span data-ttu-id="f2960-256">Converte um valor inteiro da ordem de byte de rede para a ordem de byte de host.</span><span class="sxs-lookup"><span data-stu-id="f2960-256">Converts an integer value from network byte order to host byte order.</span></span></summary>
        <returns><span data-ttu-id="f2960-257">Um valor de inteiro, expresso na ordem de byte de host.</span><span class="sxs-lookup"><span data-stu-id="f2960-257">An integer value, expressed in host byte order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-258">Computadores diferentes usam diferentes convenções para ordenar os bytes dentro de valores inteiros multibyte.</span><span class="sxs-lookup"><span data-stu-id="f2960-258">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="f2960-259">Alguns computadores colocados o byte mais significativo primeiro (conhecido como ordem big-endian) e outros colocar o byte menos significativo primeiro (conhecido como ordem de little endian).</span><span class="sxs-lookup"><span data-stu-id="f2960-259">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="f2960-260">Para trabalhar com computadores que usam a ordem de bytes diferentes, todos os valores de inteiro que são enviados pela rede são enviados na ordem de bytes de rede que tem o byte mais significativo primeiro.</span><span class="sxs-lookup"><span data-stu-id="f2960-260">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="f2960-261">O <xref:System.Net.IPAddress.NetworkToHostOrder%2A> método converte valores inteiros multibyte que são armazenados no sistema de host da ordem de bytes usado pela rede para a ordem de bytes usada pelo host.</span><span class="sxs-lookup"><span data-stu-id="f2960-261">The <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the network to the byte order used by the host.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f2960-262">O exemplo a seguir usa o <xref:System.Net.IPAddress.NetworkToHostOrder%2A> método para converter um valor inteiro de ordem de bytes de rede para ordem de byte do host.</span><span class="sxs-lookup"><span data-stu-id="f2960-262">The following example uses the <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method to convert an integer value from network byte order to host byte order.</span></span>  
  
 [!code-cpp[IPAddress_NetworkToHost#2](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CPP/ipaddress_networktohost.cpp#2)]
 [!code-csharp[IPAddress_NetworkToHost#2](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CS/ipaddress_networktohost.cs#2)]
 [!code-vb[IPAddress_NetworkToHost#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_NetworkToHost/VB/ipaddress_networktohost.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="NetworkToHostOrder">
      <MemberSignature Language="C#" Value="public static long NetworkToHostOrder (long network);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 NetworkToHostOrder(int64 network) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NetworkToHostOrder (network As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long NetworkToHostOrder(long network);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="network" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="network"><span data-ttu-id="f2960-263">O número a ser convertido, expresso em ordem de byte de rede.</span><span class="sxs-lookup"><span data-stu-id="f2960-263">The number to convert, expressed in network byte order.</span></span></param>
        <summary><span data-ttu-id="f2960-264">Converte um valor longo de ordem de byte de rede em ordem de byte de host.</span><span class="sxs-lookup"><span data-stu-id="f2960-264">Converts a long value from network byte order to host byte order.</span></span></summary>
        <returns><span data-ttu-id="f2960-265">Um valor longo, expresso em ordem de byte de host.</span><span class="sxs-lookup"><span data-stu-id="f2960-265">A long value, expressed in host byte order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-266">Computadores diferentes usam diferentes convenções para ordenar os bytes dentro de valores inteiros multibyte.</span><span class="sxs-lookup"><span data-stu-id="f2960-266">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="f2960-267">Alguns computadores colocados o byte mais significativo primeiro (conhecido como ordem big-endian) e outros colocar o byte menos significativo primeiro (conhecido como ordem de little endian).</span><span class="sxs-lookup"><span data-stu-id="f2960-267">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="f2960-268">Para trabalhar com computadores que usam a ordem de bytes diferentes, todos os valores de inteiro que são enviados pela rede são enviados na ordem de bytes de rede que tem o byte mais significativo primeiro.</span><span class="sxs-lookup"><span data-stu-id="f2960-268">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="f2960-269">O <xref:System.Net.IPAddress.NetworkToHostOrder%2A> método converte valores inteiros multibyte que são armazenados no sistema de host da ordem de bytes usado pela rede para a ordem de bytes usada pelo host.</span><span class="sxs-lookup"><span data-stu-id="f2960-269">The <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the network to the byte order used by the host.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f2960-270">O exemplo a seguir usa o <xref:System.Net.IPAddress.NetworkToHostOrder%2A> método para converter um valor longo de ordem de bytes de rede para ordem de byte do host.</span><span class="sxs-lookup"><span data-stu-id="f2960-270">The following example uses the <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method to convert a long value from network byte order to host byte order.</span></span>  
  
 [!code-cpp[IPAddress_NetworkToHost#3](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CPP/ipaddress_networktohost.cpp#3)]
 [!code-csharp[IPAddress_NetworkToHost#3](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CS/ipaddress_networktohost.cs#3)]
 [!code-vb[IPAddress_NetworkToHost#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_NetworkToHost/VB/ipaddress_networktohost.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="None">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress None;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress None" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.None" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly None As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ None;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f2960-271">Fornece um endereço IP que indica que nenhum adaptador de rede deve ser usado.</span><span class="sxs-lookup"><span data-stu-id="f2960-271">Provides an IP address that indicates that no network interface should be used.</span></span> <span data-ttu-id="f2960-272">Este campo é somente leitura.</span><span class="sxs-lookup"><span data-stu-id="f2960-272">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-273">O <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> método usa o <xref:System.Net.IPAddress.None> campo para indicar que um <xref:System.Net.Sockets.Socket> não deve escutar para a atividade do cliente.</span><span class="sxs-lookup"><span data-stu-id="f2960-273">The <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> method uses the <xref:System.Net.IPAddress.None> field to indicate that a <xref:System.Net.Sockets.Socket> must not listen for client activity.</span></span> <span data-ttu-id="f2960-274">O <xref:System.Net.IPAddress.None> campo é equivalente à 255.255.255.255 na notação pontilhada quad.</span><span class="sxs-lookup"><span data-stu-id="f2960-274">The <xref:System.Net.IPAddress.None> field is equivalent to 255.255.255.255 in dotted-quad notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f2960-275">O exemplo a seguir usa o <xref:System.Net.IPAddress.None> propriedade para indicar que nenhuma interface de rede deve ser usada.</span><span class="sxs-lookup"><span data-stu-id="f2960-275">The following example uses the <xref:System.Net.IPAddress.None> property to indicate that no network interface should be used.</span></span>  
  
 [!code-cpp[IPAddress_None#1](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_None/CPP/ipaddress_none.cpp#1)]
 [!code-csharp[IPAddress_None#1](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_None/CS/ipaddress_none.cs#1)]
 [!code-vb[IPAddress_None#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_None/VB/ipaddress_none.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Net.IPAddress Parse (ReadOnlySpan&lt;char&gt; ipString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.IPAddress Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; ipString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.Parse(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (ipString As ReadOnlySpan(Of Char)) As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::IPAddress ^ Parse(ReadOnlySpan&lt;char&gt; ipString);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="ipString">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Net.IPAddress Parse (string ipString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.IPAddress Parse(string ipString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (ipString As String) As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::IPAddress ^ Parse(System::String ^ ipString);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ipString"><span data-ttu-id="f2960-276">Uma cadeia de caracteres que contém um endereço IP em notação quádrupla com pontos para IPv4 e em notação hexadecimal com dois-pontos para IPv6.</span><span class="sxs-lookup"><span data-stu-id="f2960-276">A string that contains an IP address in dotted-quad notation for IPv4 and in colon-hexadecimal notation for IPv6.</span></span></param>
        <summary><span data-ttu-id="f2960-277">Converte uma cadeia de caracteres de endereços IP em uma instância <see cref="T:System.Net.IPAddress" />.</span><span class="sxs-lookup"><span data-stu-id="f2960-277">Converts an IP address string to an <see cref="T:System.Net.IPAddress" /> instance.</span></span></summary>
        <returns><span data-ttu-id="f2960-278">Uma instância <see cref="T:System.Net.IPAddress" />.</span><span class="sxs-lookup"><span data-stu-id="f2960-278">An <see cref="T:System.Net.IPAddress" /> instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-279">Estático <xref:System.Net.IPAddress.Parse%2A> método cria um <xref:System.Net.IPAddress> instância de um endereço IP expressada em notação pontilhada quad para IPv4 e em notação hexadecimal com dois-pontos para IPv6.</span><span class="sxs-lookup"><span data-stu-id="f2960-279">The static <xref:System.Net.IPAddress.Parse%2A> method creates an <xref:System.Net.IPAddress> instance from an IP address expressed in dotted-quad notation for IPv4 and in colon-hexadecimal notation for IPv6.</span></span>  
  
 <span data-ttu-id="f2960-280">O número de partes (cada parte é separado por um período) em `ipString` determina como o endereço IP é construído.</span><span class="sxs-lookup"><span data-stu-id="f2960-280">The number of parts (each part is separated by a period) in `ipString` determines how the IP address is constructed.</span></span> <span data-ttu-id="f2960-281">Um endereço de uma parte é armazenado diretamente no endereço de rede.</span><span class="sxs-lookup"><span data-stu-id="f2960-281">A one part address is stored directly in the network address.</span></span> <span data-ttu-id="f2960-282">Um endereço de duas partes, conveniente para especificar um endereço de classe A, coloca a parte à esquerda do primeiro byte e a parte à direita de três bytes mais à direita do endereço de rede.</span><span class="sxs-lookup"><span data-stu-id="f2960-282">A two part address, convenient for specifying a class A address, puts the leading part in the first byte and the trailing part in the right-most three bytes of the network address.</span></span> <span data-ttu-id="f2960-283">Um endereço de três partes, conveniente para especificar um endereço de classe B, coloca a primeira parte do primeiro byte, a segunda parte no segundo byte e a parte final de dois bytes mais à direita do endereço de rede.</span><span class="sxs-lookup"><span data-stu-id="f2960-283">A three part address, convenient for specifying a class B address, puts the first part in the first byte, the second part in the second byte, and the final part in the right-most two bytes of the network address.</span></span> <span data-ttu-id="f2960-284">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="f2960-284">For example:</span></span>  
  
|<span data-ttu-id="f2960-285">Número de partes e exemplo `ipString`</span><span class="sxs-lookup"><span data-stu-id="f2960-285">Number of parts and example `ipString`</span></span>|<span data-ttu-id="f2960-286">Endereço IPv4 para o endereço IP</span><span class="sxs-lookup"><span data-stu-id="f2960-286">IPv4 address for IPAddress</span></span>|  
|--------------------------------------------|--------------------------------|  
|<span data-ttu-id="f2960-287">1 -- "65535"</span><span class="sxs-lookup"><span data-stu-id="f2960-287">1 -- "65535"</span></span>|<span data-ttu-id="f2960-288">0.0.255.255</span><span class="sxs-lookup"><span data-stu-id="f2960-288">0.0.255.255</span></span>|  
|<span data-ttu-id="f2960-289">2 -- "20.2"</span><span class="sxs-lookup"><span data-stu-id="f2960-289">2 -- "20.2"</span></span>|<span data-ttu-id="f2960-290">20.0.0.2</span><span class="sxs-lookup"><span data-stu-id="f2960-290">20.0.0.2</span></span>|  
|<span data-ttu-id="f2960-291">2 -- "20.65535"</span><span class="sxs-lookup"><span data-stu-id="f2960-291">2 -- "20.65535"</span></span>|<span data-ttu-id="f2960-292">20.0.255.255</span><span class="sxs-lookup"><span data-stu-id="f2960-292">20.0.255.255</span></span>|  
|<span data-ttu-id="f2960-293">3 -- "128.1.2"</span><span class="sxs-lookup"><span data-stu-id="f2960-293">3 -- "128.1.2"</span></span>|<span data-ttu-id="f2960-294">128.1.0.2</span><span class="sxs-lookup"><span data-stu-id="f2960-294">128.1.0.2</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="f2960-295">O código a seguir converte uma cadeia de caracteres que contém um endereço IP, em notação pontilhada quad para IPv4 ou em notação hexadecimal com dois-pontos para IPv6, em uma instância de <xref:System.Net.IPAddress> classe.</span><span class="sxs-lookup"><span data-stu-id="f2960-295">The following code converts a string that contains an IP address, in dotted-quad notation for IPv4 or in colon-hexadecimal notation for IPv6, into an instance of the <xref:System.Net.IPAddress> class.</span></span> <span data-ttu-id="f2960-296">Em seguida, usa o sobrecarregado <xref:System.Net.IPAddress.ToString%2A> método para exibir o endereço na notação padrão.</span><span class="sxs-lookup"><span data-stu-id="f2960-296">Then it uses the overloaded <xref:System.Net.IPAddress.ToString%2A> method to display the address in standard notation.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.Parse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.Parse/CPP/parse.cpp#1)]
 [!code-csharp[System.Net.IPAddress.Parse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.Parse/CS/parse.cs#1)]
 [!code-vb[System.Net.IPAddress.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.Parse/VB/parse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f2960-297"><paramref name="ipString" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f2960-297"><paramref name="ipString" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="f2960-298"><paramref name="ipString" /> não é um endereço IP válido.</span><span class="sxs-lookup"><span data-stu-id="f2960-298"><paramref name="ipString" /> is not a valid IP address.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ScopeId">
      <MemberSignature Language="C#" Value="public long ScopeId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ScopeId" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.ScopeId" />
      <MemberSignature Language="VB.NET" Value="Public Property ScopeId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ScopeId { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f2960-299">Obtém ou define o identificador de escopo de endereço IPv6.</span><span class="sxs-lookup"><span data-stu-id="f2960-299">Gets or sets the IPv6 address scope identifier.</span></span></summary>
        <value><span data-ttu-id="f2960-300">Um inteiro longo que especifica o escopo do endereço.</span><span class="sxs-lookup"><span data-stu-id="f2960-300">A long integer that specifies the scope of the address.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-301">O significado de <xref:System.Net.IPAddress.ScopeId%2A> alterações dependendo do contexto no qual ele é usado.</span><span class="sxs-lookup"><span data-stu-id="f2960-301">The meaning of <xref:System.Net.IPAddress.ScopeId%2A> changes depending on the context in which it is used.</span></span>  
  
-   <span data-ttu-id="f2960-302">Endereço de conexão local.</span><span class="sxs-lookup"><span data-stu-id="f2960-302">Link-local address.</span></span> <span data-ttu-id="f2960-303">Em um host com várias interfaces conectadas para separar os links, o mesmo endereço de conexão local pode ser atribuído a várias interfaces.</span><span class="sxs-lookup"><span data-stu-id="f2960-303">On a host with multiple interfaces connected to separate links, the same link-local address can be assigned to multiple interfaces.</span></span> <span data-ttu-id="f2960-304">Para eliminar essa ambiguidade, um identificador de escopo é usado para especificar a interface através da qual as mensagens são trocadas.</span><span class="sxs-lookup"><span data-stu-id="f2960-304">To eliminate this ambiguity, a scope identifier is used to specify the interface over which messages are exchanged.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f2960-305">Endereços de conexão local, identificados por FE80 prefixo de formato (FP), são usados por nós ao se comunicar conosco vizinhos na mesma conexão.</span><span class="sxs-lookup"><span data-stu-id="f2960-305">Link-local addresses, identified by the Format Prefix (FP) FE80, are used by nodes when communicating with neighboring nodes on the same link.</span></span>  
  
-   <span data-ttu-id="f2960-306">Endereços de sites locais.</span><span class="sxs-lookup"><span data-stu-id="f2960-306">Site-local addresses.</span></span> <span data-ttu-id="f2960-307">Um host pode ser conectado a vários sites.</span><span class="sxs-lookup"><span data-stu-id="f2960-307">A host can be connected to multiple sites.</span></span> <span data-ttu-id="f2960-308">Nesse caso, um identificador de escopo é usado para indicar um site específico para se comunicar com.</span><span class="sxs-lookup"><span data-stu-id="f2960-308">In this case, a scope identifier is used to indicate a specific site to communicate with.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f2960-309">Endereços de sites locais, identificados por FEC0 prefixo de formato (FP), são usados por nós ao comunicar-se em intranets privadas.</span><span class="sxs-lookup"><span data-stu-id="f2960-309">Site-local addresses, identified by the Format Prefix (FP) FEC0, are used by nodes when communicating on private intranets.</span></span>  
  
 <span data-ttu-id="f2960-310">A notação usada para especificar o `ScopeId` com um endereço é `Address%ScopeId`.</span><span class="sxs-lookup"><span data-stu-id="f2960-310">The notation that is used to specify the `ScopeId` with an address is `Address%ScopeId`.</span></span> <span data-ttu-id="f2960-311">Por exemplo, `FE80::5EFE:192.168.41.30%2.`</span><span class="sxs-lookup"><span data-stu-id="f2960-311">For example, `FE80::5EFE:192.168.41.30%2.`</span></span>  
  
   
  
## Examples  
 [!code-cpp[System.Net.IPAddress#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#3)]
 [!code-csharp[System.Net.IPAddress#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#3)]
 [!code-vb[System.Net.IPAddress#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="f2960-312"><see langword="AddressFamily" /> = <see langword="InterNetwork" />.</span><span class="sxs-lookup"><span data-stu-id="f2960-312"><see langword="AddressFamily" /> = <see langword="InterNetwork" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f2960-313"><paramref name="scopeId" /> &lt; 0</span><span class="sxs-lookup"><span data-stu-id="f2960-313"><paramref name="scopeId" /> &lt; 0</span></span>  
  
 <span data-ttu-id="f2960-314">\- ou -</span><span class="sxs-lookup"><span data-stu-id="f2960-314">\- or -</span></span>  
  
-   <span data-ttu-id="f2960-315"><paramref name="scopeId" /> &gt; 0x00000000FFFFFFFF</span><span class="sxs-lookup"><span data-stu-id="f2960-315"><paramref name="scopeId" /> &gt; 0x00000000FFFFFFFF</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f2960-316">Converte um endereço de Internet em uma notação padrão.</span><span class="sxs-lookup"><span data-stu-id="f2960-316">Converts an Internet address to its standard notation.</span></span></summary>
        <returns><span data-ttu-id="f2960-317">Uma cadeia de caracteres que contém o endereço IP em qualquer notação pontilhada de IPv4 ou hexadecimal com dois pontos de IPv6.</span><span class="sxs-lookup"><span data-stu-id="f2960-317">A string that contains the IP address in either IPv4 dotted-quad or in IPv6 colon-hexadecimal notation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-318">O <xref:System.Net.IPAddress.ToString%2A> método converte o endereço IP que é armazenado no <xref:System.Net.IPAddress.Address%2A> propriedade quad pontilhada IPv4 ou IPv6 a notação hexadecimal.</span><span class="sxs-lookup"><span data-stu-id="f2960-318">The <xref:System.Net.IPAddress.ToString%2A> method converts the IP address that is stored in the <xref:System.Net.IPAddress.Address%2A> property to either IPv4 dotted-quad or IPv6 colon-hexadecimal notation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f2960-319">A família de endereços é <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> e o endereço é inválido.</span><span class="sxs-lookup"><span data-stu-id="f2960-319">The address family is <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> and the address is bad.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryFormat(System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryFormat(Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; ipString, out System.Net.IPAddress address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; ipString, [out] class System.Net.IPAddress&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryParse(System.ReadOnlySpan{System.Char},System.Net.IPAddress@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (ipString As ReadOnlySpan(Of Char), ByRef address As IPAddress) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; ipString, [Runtime::InteropServices::Out] System::Net::IPAddress ^ % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="address" Type="System.Net.IPAddress&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ipString">To be added.</param>
        <param name="address">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string ipString, out System.Net.IPAddress address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string ipString, [out] class System.Net.IPAddress&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryParse(System.String,System.Net.IPAddress@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (ipString As String, ByRef address As IPAddress) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ ipString, [Runtime::InteropServices::Out] System::Net::IPAddress ^ % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.String" />
        <Parameter Name="address" Type="System.Net.IPAddress&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ipString"><span data-ttu-id="f2960-320">A cadeia de caracteres a ser validada.</span><span class="sxs-lookup"><span data-stu-id="f2960-320">The string to validate.</span></span></param>
        <param name="address"><span data-ttu-id="f2960-321">A versão <see cref="T:System.Net.IPAddress" /> da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="f2960-321">The <see cref="T:System.Net.IPAddress" /> version of the string.</span></span></param>
        <summary><span data-ttu-id="f2960-322">Determina se uma cadeia de caracteres é um endereço IP válido.</span><span class="sxs-lookup"><span data-stu-id="f2960-322">Determines whether a string is a valid IP address.</span></span></summary>
        <returns>
          <span data-ttu-id="f2960-323"><see langword="true" /> se foi possível analisar <paramref name="ipString" /> como um endereço IP; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f2960-323"><see langword="true" /> if <paramref name="ipString" /> was able to be parsed as an IP address; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2960-324">Observe que esse método aceita como um ipString valor válido que pode ser analisado como um <xref:System.Int64>e, em seguida, trata esse Int64 como o valor longo de um endereço IP na ordem de bytes de rede, de modo semelhante ao que o <xref:System.Net.IPAddress.%23ctor%2A> construtor faz.</span><span class="sxs-lookup"><span data-stu-id="f2960-324">Note that this method accepts as valid an ipString value that can be parsed as an <xref:System.Int64>, and then treats that Int64 as the long value of an IP address in network byte order, similar to the way that the <xref:System.Net.IPAddress.%23ctor%2A> constructor does.</span></span> <span data-ttu-id="f2960-325">Isso significa que esse método retornará true se o Int64 é analisado com êxito, mesmo que ele representa um endereço que não é um endereço IP válido.</span><span class="sxs-lookup"><span data-stu-id="f2960-325">This means that this method returns true if the Int64 is parsed successfully, even if it represents an address that's not a valid IP address.</span></span> <span data-ttu-id="f2960-326">Por exemplo, se ipString é "1", este método retorna true, mesmo que "1" (ou 0.0.0.1) não é um endereço IP válido e você pode esperar que esse método para retornar false.</span><span class="sxs-lookup"><span data-stu-id="f2960-326">For example, if ipString is "1", this method returns true even though "1" (or 0.0.0.1) is not a valid IP address and you might expect this method to return false.</span></span> <span data-ttu-id="f2960-327">Corrigir esse erro interrompe aplicativos existentes, para que o comportamento atual não será alterado.</span><span class="sxs-lookup"><span data-stu-id="f2960-327">Fixing this bug would break existing apps, so the current behavior will not be changed.</span></span> <span data-ttu-id="f2960-328">Seu código pode evitar esse comportamento, garantindo que ele usa apenas esse método para analisar os endereços IP no formato decimal pontilhado.</span><span class="sxs-lookup"><span data-stu-id="f2960-328">Your code can avoid this behavior by ensuring that it only uses this method to parse IP addresses in dotted-decimal format.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryWriteBytes(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryWriteBytes(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>