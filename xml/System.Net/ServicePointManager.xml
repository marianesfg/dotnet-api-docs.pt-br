<Type Name="ServicePointManager" FullName="System.Net.ServicePointManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e73766e48f72f503e75edb08e42b322a7fa49965" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57918786" /></Metadata><TypeSignature Language="C#" Value="public class ServicePointManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ServicePointManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.ServicePointManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ServicePointManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServicePointManager" />
  <TypeSignature Language="F#" Value="type ServicePointManager = class" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.ServicePoint</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Gerencia a coleção de objetos <see cref="T:System.Net.ServicePoint" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager> é uma classe estática usada para criar, manter e excluir instâncias da <xref:System.Net.ServicePoint> classe.  
  
 Quando um aplicativo solicita uma conexão com um identificador de recurso uniforme (URI) do recurso da Internet por meio de <xref:System.Net.ServicePointManager> objeto, o <xref:System.Net.ServicePointManager> retorna um <xref:System.Net.ServicePoint> objeto que contém informações de conexão para o host e o esquema identificado por um URI. Se não houver um existente <xref:System.Net.ServicePoint> objeto para esse host e o esquema, o <xref:System.Net.ServicePointManager> objeto retorna existente <xref:System.Net.ServicePoint> do objeto; caso contrário, o <xref:System.Net.ServicePointManager> objeto cria um novo <xref:System.Net.ServicePoint> objeto.  
  
 O .NET Framework 4.6 inclui um novo recurso de segurança que impede algoritmos para conexões de hash e criptografia insegura. Aplicativos que usam o TLS/SSL por meio de APIs, como <xref:System.Net.Http.HttpClient>, <xref:System.Net.HttpWebRequest>, <xref:System.Net.FtpWebRequest>, <xref:System.Net.Mail.SmtpClient>, <xref:System.Net.Security.SslStream>, etc. e direcionamento do .NET Framework 4.6 obter o comportamento mais seguras por padrão.  
  
 Os desenvolvedores podem querer recusar esse comportamento para manter a interoperabilidade com seus serviços existentes de SSL3 ou TLS com os serviços de RC4. [Este artigo](https://support.microsoft.com/kb/3069494) explica como modificar seu código para que o novo comportamento está desabilitado.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um <xref:System.Net.ServicePoint> objeto para conexões com o URI www.contoso.com.  
  
 [!code-cpp[Classic ServicePoint Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic ServicePoint Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ServicePoint Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic ServicePoint Example/CS/source.cs#1)]
 [!code-vb[Classic ServicePoint Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic ServicePoint Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.ServicePoint" />
    <related type="Article" href="https://msdn.microsoft.com/library/6e5def51-3646-4ef6-a7bd-c69151321bec">Elemento ServicePointManager (configurações de rede)</related>
  </Docs>
  <Members>
    <Member MemberName="CertificatePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.ICertificatePolicy CertificatePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.ICertificatePolicy CertificatePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.CertificatePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CertificatePolicy As ICertificatePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::ICertificatePolicy ^ CertificatePolicy { System::Net::ICertificatePolicy ^ get(); void set(System::Net::ICertificatePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CertificatePolicy : System.Net.ICertificatePolicy with get, set" Usage="System.Net.ServicePointManager.CertificatePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use ServerCertificateValidationCallback instead", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("CertificatePolicy is obsoleted for this type, please use ServerCertificateValidationCallback instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICertificatePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a política para certificados de servidor.</summary>
        <value>Um objeto que implementa a interface do <see cref="T:System.Net.ICertificatePolicy" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o <xref:System.Net.ServicePointManager.CertificatePolicy%2A> estiver definida como uma <xref:System.Net.ICertificatePolicy> objeto de interface, o <xref:System.Net.ServicePointManager> objeto usa a política de certificado definida nessa instância, em vez da política de certificado padrão.  
  
 A política de certificado padrão permite que certificados válidos e certificados válidos que expiraram.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como capturar uma exceção de política de certificado para uma política de certificado personalizado. Ele pressupõe que o objeto de política de certificado foi definido, que o identificador de URI (Uniform Resource) para o recurso da Web está contida na variável `myUri`e se há um método chamado `ProcessResponse` que executa o trabalho do aplicativo.  
  
 [!code-cpp[Classic ServicePointManager.CertificatePolicy Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic ServicePointManager.CertificatePolicy Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ServicePointManager.CertificatePolicy Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic ServicePointManager.CertificatePolicy Example/CS/source.cs#1)]
 [!code-vb[Classic ServicePointManager.CertificatePolicy Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic ServicePointManager.CertificatePolicy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para definir o <see cref="P:System.Net.ServicePointManager.CertificatePolicy" /> propriedade. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
      </Docs>
    </Member>
    <Member MemberName="CheckCertificateRevocationList">
      <MemberSignature Language="C#" Value="public static bool CheckCertificateRevocationList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CheckCertificateRevocationList" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.CheckCertificateRevocationList" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CheckCertificateRevocationList As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CheckCertificateRevocationList { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CheckCertificateRevocationList : bool with get, set" Usage="System.Net.ServicePointManager.CheckCertificateRevocationList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("CRL checks not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor <see cref="T:System.Boolean" /> que indica se o certificado é verificado em relação à lista de revogação de autoridade de certificação.</summary>
        <value><see langword="true" /> se a lista de certificados revogados é verificada; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o <xref:System.Net.ServicePointManager.CheckCertificateRevocationList%2A> é `true`, o certificado é verificado em relação a lista de revogação de autoridade de certificação, como parte do processo de validação de certificado. Seu valor padrão é `false`.  
  
   
  
## Examples  
 O exemplo de código a seguir define essa propriedade.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para definir essa propriedade. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
      </Docs>
    </Member>
    <Member MemberName="ClientCipherSuitesCallback">
      <MemberSignature Language="C#" Value="public static System.Net.CipherSuitesCallback ClientCipherSuitesCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.CipherSuitesCallback ClientCipherSuitesCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ClientCipherSuitesCallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ClientCipherSuitesCallback As CipherSuitesCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::CipherSuitesCallback ^ ClientCipherSuitesCallback { System::Net::CipherSuitesCallback ^ get(); void set(System::Net::CipherSuitesCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCipherSuitesCallback : System.Net.CipherSuitesCallback with get, set" Usage="System.Net.ServicePointManager.ClientCipherSuitesCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Obsolete("This API is no longer supported.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CipherSuitesCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultConnectionLimit">
      <MemberSignature Language="C#" Value="public static int DefaultConnectionLimit { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultConnectionLimit" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.DefaultConnectionLimit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultConnectionLimit As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultConnectionLimit { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultConnectionLimit : int with get, set" Usage="System.Net.ServicePointManager.DefaultConnectionLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o número máximo de conexões simultâneas permitidas por um objeto <see cref="T:System.Net.ServicePoint" />.</summary>
        <value>O número máximo de conexões simultâneas permitidas por um objeto <see cref="T:System.Net.ServicePoint" />. O limite de conexão padrão é 10 para aplicativos ASP.NET hospedados e 2 para todas as outras. Quando um aplicativo é executado como um host ASP.NET, não é possível alterar o valor dessa propriedade por meio do arquivo de configuração se a propriedade de autoConfig está definida como <see langword="true" />. No entanto, é possível alterar o valor programaticamente quando a propriedade autoConfig for <see langword="true" />. Defina seu valor preferido uma vez, quando AppDomain for carregado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> propriedade define o número de máximo padrão de conexões simultâneas que o <xref:System.Net.ServicePointManager> objeto e o atribui para a <xref:System.Net.ServicePoint.ConnectionLimit%2A> propriedade durante a criação de <xref:System.Net.ServicePoint> objetos.  
  
 Alterando a <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> propriedade não tem nenhum efeito existente <xref:System.Net.ServicePoint> objetos; só afeta <xref:System.Net.ServicePoint> objetos que são inicializados após a alteração. Se o valor dessa propriedade não tiver sido definido diretamente ou por meio da configuração, o valor padrão é a constante <xref:System.Net.ServicePointManager.DefaultPersistentConnectionLimit>.  
  
> [!NOTE]
>  Todas as alterações para o <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> propriedade afetam as conexões de HTTP 1.0 e 1.1 do HTTP. Não é possível alterar separadamente o limite de conexão para protocolos HTTP 1.0 e 1.1 do HTTP.
  
   
  
## Examples  
 O exemplo de código a seguir define essa propriedade.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Net.ServicePointManager.DefaultConnectionLimit" /> é menor ou igual a 0.</exception>
        <permission cref="T:System.Net.WebPermission">para permissões irrestritas de Web. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.WebPermission" />
      </Docs>
    </Member>
    <Member MemberName="DefaultNonPersistentConnectionLimit">
      <MemberSignature Language="C#" Value="public const int DefaultNonPersistentConnectionLimit = 4;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 DefaultNonPersistentConnectionLimit = (4)" />
      <MemberSignature Language="DocId" Value="F:System.Net.ServicePointManager.DefaultNonPersistentConnectionLimit" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultNonPersistentConnectionLimit As Integer  = 4" />
      <MemberSignature Language="C++ CLI" Value="public: int DefaultNonPersistentConnectionLimit = 4;" />
      <MemberSignature Language="F#" Value="val mutable DefaultNonPersistentConnectionLimit : int" Usage="System.Net.ServicePointManager.DefaultNonPersistentConnectionLimit" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>4</MemberValue>
      <Docs>
        <summary>O número padrão de conexões não persistentes (4) permitidas em um objeto <see cref="T:System.Net.ServicePoint" /> conectado a um servidor HTTP/1.0 ou posterior. Este campo é constante, mas não é mais usado no .NET Framework 2.0.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultPersistentConnectionLimit">
      <MemberSignature Language="C#" Value="public const int DefaultPersistentConnectionLimit = 2;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 DefaultPersistentConnectionLimit = (2)" />
      <MemberSignature Language="DocId" Value="F:System.Net.ServicePointManager.DefaultPersistentConnectionLimit" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultPersistentConnectionLimit As Integer  = 2" />
      <MemberSignature Language="C++ CLI" Value="public: int DefaultPersistentConnectionLimit = 2;" />
      <MemberSignature Language="F#" Value="val mutable DefaultPersistentConnectionLimit : int" Usage="System.Net.ServicePointManager.DefaultPersistentConnectionLimit" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>O número padrão de conexões persistentes (2) permitidas em um objeto <see cref="T:System.Net.ServicePoint" /> conectado a um servidor HTTP/1.1 ou posterior. Esse campo é constante e será usado para inicializar a propriedade <see cref="P:System.Net.ServicePointManager.DefaultConnectionLimit" />, se o valor da propriedade <see cref="P:System.Net.ServicePointManager.DefaultConnectionLimit" /> não tiver sido definido diretamente ou por meio de configuração.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O seguinte exemplo de código define o <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> usando esse campo de propriedade.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DnsRefreshTimeout">
      <MemberSignature Language="C#" Value="public static int DnsRefreshTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DnsRefreshTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.DnsRefreshTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DnsRefreshTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DnsRefreshTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DnsRefreshTimeout : int with get, set" Usage="System.Net.ServicePointManager.DnsRefreshTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica por quanto tempo a resolução de um DNS (Serviço de Nomes de Domínio) é considerada válida.</summary>
        <value>O valor de tempo limite, em milissegundos. Um valor de -1 indica um período de tempo limite infinito. O valor padrão é de 120.000 milissegundos (dois minutos).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir define essa propriedade.  
  
 [!code-cpp[System.Net.ServicePointWhidbey#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/cpp/servicepoint.cpp#1)]
 [!code-csharp[System.Net.ServicePointWhidbey#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/CS/servicepoint.cs#1)]
 [!code-vb[System.Net.ServicePointWhidbey#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/VB/servicepoint.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="EnableDnsRoundRobin">
      <MemberSignature Language="C#" Value="public static bool EnableDnsRoundRobin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableDnsRoundRobin" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.EnableDnsRoundRobin" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableDnsRoundRobin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableDnsRoundRobin { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableDnsRoundRobin : bool with get, set" Usage="System.Net.ServicePointManager.EnableDnsRoundRobin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se uma resolução de DNS (serviço de nomes de domínio) gira entre os endereços IP (Protocolo IP) aplicáveis.</summary>
        <value><see langword="false" /> se uma resolução DNS sempre retorna o primeiro endereço IP para um determinado host; caso contrário, <see langword="true" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando mais de um endereço IP está associado um nome de host, uma resolução de DNS normalmente retorna somente o primeiro endereço IP. Se você definir essa propriedade como `true`, em seguida, resoluções DNS subsequentes para percorrer todos os endereços IP disponíveis para um host específico. Essa opção é útil quando um serviço usa o DNS como um mecanismo entre servidores ou clusters de servidores de balanceamento de carga.  
  
   
  
## Examples  
 O exemplo de código a seguir define essa propriedade.  
  
 [!code-cpp[System.Net.ServicePointWhidbey#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/cpp/servicepoint.cpp#1)]
 [!code-csharp[System.Net.ServicePointWhidbey#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/CS/servicepoint.cs#1)]
 [!code-vb[System.Net.ServicePointWhidbey#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/VB/servicepoint.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionPolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Security.EncryptionPolicy EncryptionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Net.Security.EncryptionPolicy EncryptionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.EncryptionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EncryptionPolicy As EncryptionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Security::EncryptionPolicy EncryptionPolicy { System::Net::Security::EncryptionPolicy get(); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionPolicy : System.Net.Security.EncryptionPolicy" Usage="System.Net.ServicePointManager.EncryptionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Always returns EncryptionPolicy.RequireEncryption.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Security.EncryptionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Net.Security.EncryptionPolicy" /> para essa instância de <see cref="T:System.Net.ServicePointManager" />.</summary>
        <value>A política de criptografia a ser usada para esta instância de <see cref="T:System.Net.ServicePointManager" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um valor não for especificado no arquivo de configuração, o <xref:System.Net.ServicePointManager.EncryptionPolicy%2A> propriedade assume como padrão <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType>. Isso é aplicado a uma sessão SSL/TLS sobre isso <xref:System.Net.ServicePointManager> instância.  
  
 O uso de criptografia a Null é necessário quando a política de criptografia é definida como <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="P:System.Net.Configuration.ServicePointManagerElement.EncryptionPolicy" />
        <altmember cref="T:System.Net.Security.EncryptionPolicy" />
        <related type="Article" href="https://msdn.microsoft.com/library/6e5def51-3646-4ef6-a7bd-c69151321bec">Elemento ServicePointManager (configurações de rede)</related>
      </Docs>
    </Member>
    <Member MemberName="Expect100Continue">
      <MemberSignature Language="C#" Value="public static bool Expect100Continue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Expect100Continue" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.Expect100Continue" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Expect100Continue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Expect100Continue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Expect100Continue : bool with get, set" Usage="System.Net.ServicePointManager.Expect100Continue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor <see cref="T:System.Boolean" /> que determina se o comportamento 100-Continue é usado.</summary>
        <value><see langword="true" /> para habilitar o comportamento 100-Continue. O valor padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando essa propriedade é definida como `true`, 100-Continue comportamento é usado. Solicitações de cliente que usam o `PUT` e `POST` métodos adicionará um cabeçalho Expect para a solicitação se o <xref:System.Net.ServicePointManager.Expect100Continue%2A> é de propriedade `true` e <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade é maior que zero ou a <xref:System.Net.HttpWebRequest.SendChunked%2A> propriedade é true. O cliente pretende receber 100-Continue a resposta do servidor para indicar que o cliente deve enviar os dados a ser postada. Esse mecanismo permite que os clientes para evitar o envio de grandes quantidades de dados pela rede quando o servidor, com base em cabeçalhos de solicitação, pretende rejeitar a solicitação.  
  
 Por exemplo, suponha que o <xref:System.Net.ServicePointManager.Expect100Continue%2A> é de propriedade `false`. Quando a solicitação é enviada ao servidor, ele inclui os dados. Se, depois de ler os cabeçalhos de solicitação, o servidor requer autenticação e deve enviar uma resposta 401, o cliente deve reenviar os dados com cabeçalhos de autenticação apropriados.  
  
 Se essa propriedade for `true`, os cabeçalhos de solicitação são enviados ao servidor. Se não, o servidor rejeitou a solicitação, ele envia um 100-Continue a sinalização de resposta que os dados podem ser transmitidos. Se, como no exemplo anterior, o servidor exigir autenticação, ele envia a resposta 401 e o cliente não transmitiu desnecessariamente os dados.  
  
 Alterar o valor dessa propriedade não afeta existente <xref:System.Net.ServicePoint> objetos. Somente novos <xref:System.Net.ServicePoint> objetos criados após a alteração são afetados.  
  
 O 100-Continue comportamento não é usado para solicitações de HTTP 1.0, mesmo se essa propriedade é definida como `true`.  
  
 O Expect 100-Continue comportamento é totalmente descrito na seção IETF RFC 2616 correspondentes de 10.1.1.  
  
   
  
## Examples  
 O exemplo de código a seguir define essa propriedade.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindServicePoint">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Localiza um objeto <see cref="T:System.Net.ServicePoint" /> existente ou cria um novo objeto <see cref="T:System.Net.ServicePoint" /> para gerenciar a comunicação para esta solicitação.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindServicePoint">
      <MemberSignature Language="C#" Value="public static System.Net.ServicePoint FindServicePoint (Uri address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.ServicePoint FindServicePoint(class System.Uri address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.FindServicePoint(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindServicePoint (address As Uri) As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::ServicePoint ^ FindServicePoint(Uri ^ address);" />
      <MemberSignature Language="F#" Value="static member FindServicePoint : Uri -&gt; System.Net.ServicePoint" Usage="System.Net.ServicePointManager.FindServicePoint address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="address">O objeto <see cref="T:System.Uri" /> do recurso da Internet para contatar.</param>
        <summary>Localiza um objeto <see cref="T:System.Net.ServicePoint" /> existente ou cria um novo objeto <see cref="T:System.Net.ServicePoint" /> para gerenciar as comunicações com o objeto <see cref="T:System.Uri" /> especificado.</summary>
        <returns>O objeto <see cref="T:System.Net.ServicePoint" /> que gerencia a comunicação para a solicitação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.ServicePointManager.FindServicePoint%2A> método retorna o <xref:System.Net.ServicePoint> objeto associado com o nome de host da Internet especificado. Se nenhum <xref:System.Net.ServicePoint> objeto existe para que o host, o <xref:System.Net.ServicePointManager> objeto cria um.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O número máximo de objetos <see cref="T:System.Net.ServicePoint" /> definidos no <see cref="P:System.Net.ServicePointManager.MaxServicePoints" /> foi atingido.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="FindServicePoint">
      <MemberSignature Language="C#" Value="public static System.Net.ServicePoint FindServicePoint (string uriString, System.Net.IWebProxy proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.ServicePoint FindServicePoint(string uriString, class System.Net.IWebProxy proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.FindServicePoint(System.String,System.Net.IWebProxy)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindServicePoint (uriString As String, proxy As IWebProxy) As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::ServicePoint ^ FindServicePoint(System::String ^ uriString, System::Net::IWebProxy ^ proxy);" />
      <MemberSignature Language="F#" Value="static member FindServicePoint : string * System.Net.IWebProxy -&gt; System.Net.ServicePoint" Usage="System.Net.ServicePointManager.FindServicePoint (uriString, proxy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="proxy" Type="System.Net.IWebProxy" />
      </Parameters>
      <Docs>
        <param name="uriString">O URI do recurso da Internet a ser contatado.</param>
        <param name="proxy">Os dados de proxy para esta solicitação.</param>
        <summary>Localiza um objeto <see cref="T:System.Net.ServicePoint" /> existente ou cria um novo objeto <see cref="T:System.Net.ServicePoint" /> para gerenciar as comunicações com o URI (Uniform Resource Identifier) especificado.</summary>
        <returns>O objeto <see cref="T:System.Net.ServicePoint" /> que gerencia a comunicação para a solicitação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.ServicePointManager.FindServicePoint%2A> método retorna o <xref:System.Net.ServicePoint> objeto associado com o nome de host da Internet especificado. Se nenhum <xref:System.Net.ServicePoint> objeto existe para que o host, o <xref:System.Net.ServicePointManager> objeto cria um.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra isso chamando esse método para acessar um <xref:System.Net.ServicePoint> objeto.  
  
 [!code-cpp[System.Net.ServicePoint#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#7)]
 [!code-csharp[System.Net.ServicePoint#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#7)]
 [!code-vb[System.Net.ServicePoint#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException">O URI especificado em <paramref name="uriString" /> é inválido.</exception>
        <exception cref="T:System.InvalidOperationException">O número máximo de objetos <see cref="T:System.Net.ServicePoint" /> definidos no <see cref="P:System.Net.ServicePointManager.MaxServicePoints" /> foi atingido.</exception>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="FindServicePoint">
      <MemberSignature Language="C#" Value="public static System.Net.ServicePoint FindServicePoint (Uri address, System.Net.IWebProxy proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.ServicePoint FindServicePoint(class System.Uri address, class System.Net.IWebProxy proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.FindServicePoint(System.Uri,System.Net.IWebProxy)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindServicePoint (address As Uri, proxy As IWebProxy) As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::ServicePoint ^ FindServicePoint(Uri ^ address, System::Net::IWebProxy ^ proxy);" />
      <MemberSignature Language="F#" Value="static member FindServicePoint : Uri * System.Net.IWebProxy -&gt; System.Net.ServicePoint" Usage="System.Net.ServicePointManager.FindServicePoint (address, proxy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Uri" />
        <Parameter Name="proxy" Type="System.Net.IWebProxy" />
      </Parameters>
      <Docs>
        <param name="address">Um objeto <see cref="T:System.Uri" /> que contém o endereço do recurso de Internet a ser contatado.</param>
        <param name="proxy">Os dados de proxy para esta solicitação.</param>
        <summary>Localiza um objeto <see cref="T:System.Net.ServicePoint" /> existente ou cria um novo objeto <see cref="T:System.Net.ServicePoint" /> para gerenciar as comunicações com o objeto <see cref="T:System.Uri" /> especificado.</summary>
        <returns>O objeto <see cref="T:System.Net.ServicePoint" /> que gerencia a comunicação para a solicitação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.ServicePointManager.FindServicePoint%2A> método retorna o <xref:System.Net.ServicePoint> objeto associado com o nome de host da Internet especificado. Se nenhum <xref:System.Net.ServicePoint> objeto existe para que o host, o <xref:System.Net.ServicePointManager> objeto cria um.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O número máximo de objetos <see cref="T:System.Net.ServicePoint" /> definidos no <see cref="P:System.Net.ServicePointManager.MaxServicePoints" /> foi atingido.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="MaxServicePointIdleTime">
      <MemberSignature Language="C#" Value="public static int MaxServicePointIdleTime { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxServicePointIdleTime" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.MaxServicePointIdleTime" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MaxServicePointIdleTime As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxServicePointIdleTime { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxServicePointIdleTime : int with get, set" Usage="System.Net.ServicePointManager.MaxServicePointIdleTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tempo ocioso máximo de um objeto <see cref="T:System.Net.ServicePoint" />.</summary>
        <value>O tempo ocioso máximo, em milissegundos, de um objeto <see cref="T:System.Net.ServicePoint" />. O valor padrão é 100.000 milissegundos (100 segundos).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.ServicePointManager.MaxServicePointIdleTime%2A> propriedade define o tempo ocioso máximo que o <xref:System.Net.ServicePointManager> objeto e o atribui para a <xref:System.Net.ServicePoint.MaxIdleTime%2A> propriedade durante a criação de <xref:System.Net.ServicePoint> objetos. As alterações a este valor afetam somente <xref:System.Net.ServicePoint> objetos que são inicializados após o valor é alterado.  
  
 Depois de um <xref:System.Net.ServicePoint> objeto ficou ocioso durante o tempo especificado no <xref:System.Net.ServicePoint.MaxIdleTime%2A>, ele está qualificado para coleta de lixo. Um <xref:System.Net.ServicePoint> objeto está ocioso quando a lista de conexões associado com o <xref:System.Net.ServicePoint> objeto está vazio.  
  
   
  
## Examples  
 O exemplo de código a seguir define essa propriedade.  
  
 [!code-cpp[System.Net.ServicePoint#8](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#8)]
 [!code-csharp[System.Net.ServicePoint#8](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#8)]
 [!code-vb[System.Net.ServicePoint#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Net.ServicePointManager.MaxServicePointIdleTime" /> é menor que <see cref="F:System.Threading.Timeout.Infinite" /> ou maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Net.WebPermission">Para permissões irrestritas de Web. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.WebPermission" />
      </Docs>
    </Member>
    <Member MemberName="MaxServicePoints">
      <MemberSignature Language="C#" Value="public static int MaxServicePoints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxServicePoints" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.MaxServicePoints" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MaxServicePoints As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxServicePoints { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxServicePoints : int with get, set" Usage="System.Net.ServicePointManager.MaxServicePoints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o número máximo de objetos <see cref="T:System.Net.ServicePoint" /> a serem mantidos por vez.</summary>
        <value>O número máximo de objetos <see cref="T:System.Net.ServicePoint" /> a serem mantidos. O valor padrão é 0, o que significa que não há nenhum limite para o número de objetos <see cref="T:System.Net.ServicePoint" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você reduz a <xref:System.Net.ServicePointManager.MaxServicePoints%2A> propriedade abaixo do número de <xref:System.Net.ServicePoint> objetos atualmente na existência, as <xref:System.Net.ServicePointManager> exclui o <xref:System.Net.ServicePoint> objetos com o tempo ocioso mais longa. Se o número de <xref:System.Net.ServicePoint> objetos com conexões ativas é maior que o valor da <xref:System.Net.ServicePointManager.MaxServicePoints%2A>, o <xref:System.Net.ServicePointManager> exclusões do objeto a <xref:System.Net.ServicePoint> objetos como se tornam ociosos.  
  
   
  
## Examples  
 O exemplo de código a seguir define essa propriedade.  
  
 [!code-cpp[System.Net.ServicePoint#8](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#8)]
 [!code-csharp[System.Net.ServicePoint#8](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#8)]
 [!code-vb[System.Net.ServicePoint#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Net.ServicePointManager.MaxServicePoints" /> é menor que 0 ou maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Net.WebPermission">para permissões irrestritas de Web. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.WebPermission" />
      </Docs>
    </Member>
    <Member MemberName="ReusePort">
      <MemberSignature Language="C#" Value="public static bool ReusePort { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool ReusePort" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ReusePort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ReusePort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool ReusePort { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReusePort : bool with get, set" Usage="System.Net.ServicePointManager.ReusePort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Definir esse valor da propriedade como <see langword="true" /> faz com que todas as conexões TCP de saída de HttpWebRequest usem a opção de soquete nativo SO_REUSE_UNICASTPORT no soquete. Isso faz com que as portas de saída subjacentes sejam compartilhadas. Isso é útil para cenários em que um grande número de conexões de saída é feito em um curto período de tempo e os riscos de aplicativo ficam sem portas.</summary>
        <value>Retorna <see cref="T:System.Boolean" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor padrão é `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SecurityProtocol">
      <MemberSignature Language="C#" Value="public static System.Net.SecurityProtocolType SecurityProtocol { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Net.SecurityProtocolType SecurityProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.SecurityProtocol" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SecurityProtocol As SecurityProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::SecurityProtocolType SecurityProtocol { System::Net::SecurityProtocolType get(); void set(System::Net::SecurityProtocolType value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityProtocol : System.Net.SecurityProtocolType with get, set" Usage="System.Net.ServicePointManager.SecurityProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.SecurityProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o protocolo de segurança usado pelos objetos <see cref="T:System.Net.ServicePoint" /> gerenciados pelo objeto <see cref="T:System.Net.ServicePointManager" />.</summary>
        <value>Um dos valores definidos na enumeração <see cref="T:System.Net.SecurityProtocolType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Essa propriedade seleciona a versão do protocolo Secure Sockets Layer (SSL) ou segurança de camada de transporte (TLS) para usar em novas conexões; as conexões existentes não são alteradas.  
  
Começando com o .NET Framework 4.7, o valor padrão dessa propriedade é <xref:System.Net.SecurityProtocolType.SystemDefault?displayProperty=nameWithType>. Isso permite que as APIs com base em de rede do .NET Framework <xref:System.Net.Security.SslStream> (como FTP, HTTP e SMTP) herdem os protocolos de segurança padrão do sistema operacional ou de todas as configurações personalizadas executadas pelo administrador do sistema. Para obter informações sobre quais SSL/TLS protocolos estão habilitados por padrão em cada versão do sistema operacional Windows, consulte [protocolos em TLS/SSL (Schannel SSP)](https://msdn.microsoft.com/library/windows/desktop/mt808159.aspx).
 
Para versões do .NET Framework por meio do .NET Framework 4.6.2, nenhum valor padrão é listado para essa propriedade. O panorama da segurança em constante mudança e o padrão de protocolos e níveis de proteção são alterados ao longo do tempo para evitar pontos fracos conhecidos. Os padrões variam dependendo da configuração de máquina individuais, softwares instalados e patches aplicados.  
  
 Seu código deve depender nunca implicitamente usando um nível de proteção específico, ou na suposição de que um determinado nível de segurança é usado por padrão. Se seu aplicativo depende do uso de um nível de segurança específico, você deve especificar explicitamente esse nível e, em seguida, verifique se ela é realmente em uso na conexão estabelecida. Além disso, seu código deve ser projetado para ser robusto diante de alterações para o qual há suporte para protocolos, como tal, muitas vezes alterações pouco antecipadamente para atenuar as ameaças emergentes.  
  
 O .NET Framework 4.6 inclui um novo recurso de segurança que impede algoritmos para conexões de hash e criptografia insegura. Por padrão, os aplicativos usando TLS/SSL por meio de APIs, como HttpClient, HttpWebRequest, FTPClient, SmtpClient, SslStream, etc. e direcionamento do .NET Framework 4.6 obter o comportamento mais seguras.  
  
 Os desenvolvedores podem querer recusar esse comportamento para manter a interoperabilidade com seus serviços existentes SSL3 ou TLS com os serviços de RC4. [Este artigo](https://support.microsoft.com/kb/3069494) explica como modificar seu código para que o novo comportamento está desabilitado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O valor especificado para definir a propriedade não é um valor de enumeração <see cref="T:System.Net.SecurityProtocolType" /> válido.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.SecurityProtocolType" />
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public static System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.ServicePointManager.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o retorno de chamada para validar um certificado do servidor.</summary>
        <value>Um <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" />. O valor padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Um aplicativo pode definir o <xref:System.Net.ServicePointManager.ServerCertificateValidationCallback%2A> propriedade para um método a ser usado para validação personalizada pelo cliente do certificado do servidor. Ao fazer a validação personalizada, o `sender` parâmetro passado para o <xref:System.Net.Security.RemoteCertificateValidationCallback> pode ser um nome de cadeia de caracteres de host ou um objeto derivado <xref:System.Net.WebRequest> (<xref:System.Net.HttpWebRequest>, por exemplo), dependendo o <xref:System.Net.ServicePointManager.CertificatePolicy%2A> propriedade.  
  
Quando a validação personalizada não for usada, o nome do certificado é comparado com o nome do host usado para criar a solicitação. Por exemplo, se <xref:System.Net.WebRequest.Create%28System.String%29> foi passado um parâmetro de "https://www.contoso.com/default.html", o comportamento padrão é para o cliente verificar o certificado em relação a www.contoso.com.  

Apesar de ser um delegado multicast, apenas o valor retornado do manipulador de eventos executada por último é considerado autoritativo. Em outras palavras, você pode anexar vários delegados, e que todos eles tenham um retorno de chamada de <xref:System.Net.ServicePointManager.ServerCertificateValidationCallback%2A>. Cada retorno de chamada retorna um valor que indica se o certificado é aceito ou não; No entanto, apenas o valor do último delegado é respeitado.
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para definir o <see cref="P:System.Net.ServicePointManager.ServerCertificateValidationCallback" /> propriedade. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
      </Docs>
    </Member>
    <Member MemberName="ServerCipherSuitesCallback">
      <MemberSignature Language="C#" Value="public static System.Net.CipherSuitesCallback ServerCipherSuitesCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.CipherSuitesCallback ServerCipherSuitesCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ServerCipherSuitesCallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ServerCipherSuitesCallback As CipherSuitesCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::CipherSuitesCallback ^ ServerCipherSuitesCallback { System::Net::CipherSuitesCallback ^ get(); void set(System::Net::CipherSuitesCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCipherSuitesCallback : System.Net.CipherSuitesCallback with get, set" Usage="System.Net.ServicePointManager.ServerCipherSuitesCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Obsolete("This API is no longer supported.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CipherSuitesCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTcpKeepAlive">
      <MemberSignature Language="C#" Value="public static void SetTcpKeepAlive (bool enabled, int keepAliveTime, int keepAliveInterval);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTcpKeepAlive(bool enabled, int32 keepAliveTime, int32 keepAliveInterval) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.SetTcpKeepAlive(System.Boolean,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTcpKeepAlive (enabled As Boolean, keepAliveTime As Integer, keepAliveInterval As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTcpKeepAlive(bool enabled, int keepAliveTime, int keepAliveInterval);" />
      <MemberSignature Language="F#" Value="static member SetTcpKeepAlive : bool * int * int -&gt; unit" Usage="System.Net.ServicePointManager.SetTcpKeepAlive (enabled, keepAliveTime, keepAliveInterval)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enabled" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="keepAliveTime" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="keepAliveInterval" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="enabled">Se definido como true, a opção keep alive do TCP em uma conexão TCP será habilitada usando os valores <paramref name="keepAliveTime" /> e <paramref name="keepAliveInterval" /> especificados.  
  
Se definido como false, em seguida, a opção keep alive do TCP será desabilitada e os parâmetros restantes serão ignorados.  
  
O valor padrão é false.</param>
        <param name="keepAliveTime">Especifica o tempo limite, em milissegundos, sem nenhuma atividade até que o primeiro pacote keep alive seja enviado.  
  
O valor deve ser maior que 0.  Se um valor menor ou igual a zero for passado, um <see cref="T:System.ArgumentOutOfRangeException" /> será lançado.</param>
        <param name="keepAliveInterval">Especifica o intervalo, em milissegundos, entre envios sucessivos de pacotes keep alive se nenhuma confirmação for recebida.  
  
O valor deve ser maior que 0.  Se um valor menor ou igual a zero for passado, um <see cref="T:System.ArgumentOutOfRangeException" /> será lançado.</param>
        <summary>Habilita ou desabilita a opção keep alive em uma conexão TCP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um aplicativo pode solicitar que um provedor de TCP/IP permitir o uso de pacotes keep alive em uma conexão TCP. O padrão é que o uso de pacotes keep-alive em uma conexão TCP está desabilitado.  
  
 As configurações padrão quando um soquete TCP é inicializado o tempo limite de conjuntos de keep-alive a 2 horas e o intervalo keep-alive a 1 segundo. O `keepAliveTime` parâmetro especifica o tempo limite, em milissegundos, sem nenhuma atividade até que o primeiro pacote keep alive seja enviado. O `keepAliveInterval` parâmetro especifica o intervalo, em milissegundos, entre envios de sucessivas pacotes keep-alive se nenhuma confirmação for recebida. O número de investigações keep-alive não pode ser alterado e é definido como 10.  
  
 Se uma conexão TCP é descartada como resultado de keep-alive, uma <xref:System.Net.Sockets.SocketError> dos <xref:System.Net.Sockets.SocketError.NetworkReset> é retornado para todas as chamadas em andamento no soquete, e todas as chamadas subsequentes falhará com um <xref:System.Net.Sockets.SocketError> de <xref:System.Net.Sockets.SocketError.NotConnected>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor especificado para o parâmetro <paramref name="keepAliveTime" /> ou <paramref name="keepAliveInterval" /> é menor ou igual a 0.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="UseNagleAlgorithm">
      <MemberSignature Language="C#" Value="public static bool UseNagleAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseNagleAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.UseNagleAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseNagleAlgorithm As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseNagleAlgorithm { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseNagleAlgorithm : bool with get, set" Usage="System.Net.ServicePointManager.UseNagleAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determina se o algoritmo de Nagle é usado pelos pontos de serviço gerenciados por este objeto <see cref="T:System.Net.ServicePointManager" />.</summary>
        <value><see langword="true" /> para usar o algoritmo de Nagle; caso contrário, <see langword="false" />. O valor padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O algoritmo de Nagle é usado para reduzir o tráfego de rede, armazenamento em buffer pacotes pequenos de dados e transmiti-los como um único pacote. Esse processo também é conhecido como "nagling"; ele é amplamente usado porque reduz o número de pacotes transmitidos e reduz a sobrecarga por pacote.  
  
 Alterar o valor dessa propriedade não afeta existente <xref:System.Net.ServicePoint> objetos. Somente novos pontos de serviço criados após a alteração são afetados.  
  
 O algoritmo de Nagle é totalmente descrito no IETF RFC 896.  
  
   
  
## Examples  
 O exemplo de código a seguir define essa propriedade.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
  </Members>
</Type>