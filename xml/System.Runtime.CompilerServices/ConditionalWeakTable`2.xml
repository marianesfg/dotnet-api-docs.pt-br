<Type Name="ConditionalWeakTable&lt;TKey,TValue&gt;" FullName="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;">
  <TypeSignature Language="C#" Value="public sealed class ConditionalWeakTable&lt;TKey,TValue&gt; where TKey : class where TValue : class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ConditionalWeakTable`2&lt;class TKey, class TValue&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ConditionalWeakTable(Of TKey, TValue)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA; where TKey : class where TValue : classpublic ref class ConditionalWeakTable sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
    <TypeParameter Name="TValue">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Docs>
    <typeparam name="TKey"><span data-ttu-id="72655-101">O tipo de referência ao qual o campo está anexado.</span><span class="sxs-lookup"><span data-stu-id="72655-101">The reference type to which the field is attached.</span></span></typeparam>
    <typeparam name="TValue"><span data-ttu-id="72655-102">O tipo do campo.</span><span class="sxs-lookup"><span data-stu-id="72655-102">The field's type.</span></span> <span data-ttu-id="72655-103">Este deve ser um tipo de referência.</span><span class="sxs-lookup"><span data-stu-id="72655-103">This must be a reference type.</span></span></typeparam>
    <summary><span data-ttu-id="72655-104">Permite que os compiladores anexem dinamicamente os campos de objeto para objetos gerenciados.</span><span class="sxs-lookup"><span data-stu-id="72655-104">Enables compilers to dynamically attach object fields to managed objects.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72655-105">O <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe permite que os compiladores anexem propriedades arbitrárias para objetos gerenciados em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="72655-105">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class enables language compilers to attach arbitrary properties to managed objects at run time.</span></span> <span data-ttu-id="72655-106">Um <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> objeto é um dicionário que associa um objeto gerenciado, que é representado por uma chave para sua propriedade anexada, que é representada por um valor.</span><span class="sxs-lookup"><span data-stu-id="72655-106">A <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> object is a dictionary that binds a managed object, which is represented by a key, to its attached property, which is represented by a value.</span></span> <span data-ttu-id="72655-107">Chaves do objeto são as instâncias individuais do `TKey` classe à qual a propriedade está anexada e seus valores são os valores de propriedade que são atribuídos a objetos correspondentes.</span><span class="sxs-lookup"><span data-stu-id="72655-107">The object's keys are the individual instances of the `TKey` class to which the property is attached, and its values are the property values that are assigned to the corresponding objects.</span></span>  
  
 <span data-ttu-id="72655-108">As chaves devem ser exclusivas; em outras palavras, a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe oferece suporte a um valor anexado por objeto gerenciado.</span><span class="sxs-lookup"><span data-stu-id="72655-108">Keys must be unique; in other words, the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class supports one attached value per managed object.</span></span> <span data-ttu-id="72655-109">Duas chaves são iguais se transmiti-los para o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método retornará `true`.</span><span class="sxs-lookup"><span data-stu-id="72655-109">Two keys are equal if passing them to the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method returns `true`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="72655-110">Você não pode controlar as comparações de igualdade, substituindo <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> para definir explicitamente o código hash para uma chave.</span><span class="sxs-lookup"><span data-stu-id="72655-110">You cannot control equality comparisons by overriding <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> to explicitly set the hash code for a key.</span></span> <span data-ttu-id="72655-111">O <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe não usa o <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> método para calcular os códigos de hash e, portanto, não chamar <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> substituições.</span><span class="sxs-lookup"><span data-stu-id="72655-111">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class does not use the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method to compute hash codes, and therefore does not invoke <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> overrides.</span></span>  
  
 <span data-ttu-id="72655-112">Embora o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe contém uma coleção de pares chave/valor, ele é mais considerado como uma tabela em vez de um objeto de dicionário.</span><span class="sxs-lookup"><span data-stu-id="72655-112">Although the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class holds a collection of key/value pairs, it is best thought of as a table rather than a dictionary object.</span></span> <span data-ttu-id="72655-113">O <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe difere de um dicionário de várias maneiras:</span><span class="sxs-lookup"><span data-stu-id="72655-113">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class differs from a dictionary in several ways:</span></span>  
  
-   <span data-ttu-id="72655-114">Ele não mantém as chaves.</span><span class="sxs-lookup"><span data-stu-id="72655-114">It does not persist keys.</span></span> <span data-ttu-id="72655-115">Ou seja, uma chave não é mantida ativa apenas porque ele é um membro da coleção.</span><span class="sxs-lookup"><span data-stu-id="72655-115">That is, a key is not kept alive only because it is a member of the collection.</span></span>  
  
-   <span data-ttu-id="72655-116">Ele não inclui todos os métodos (como `GetEnumerator` ou `Contains`) que normalmente tem um dicionário.</span><span class="sxs-lookup"><span data-stu-id="72655-116">It does not include all the methods (such as `GetEnumerator` or `Contains`) that a dictionary typically has.</span></span>  
  
-   <span data-ttu-id="72655-117">Ele não implementa o <xref:System.Collections.Generic.IDictionary%602> interface.</span><span class="sxs-lookup"><span data-stu-id="72655-117">It does not implement the <xref:System.Collections.Generic.IDictionary%602> interface.</span></span>  
  
 <span data-ttu-id="72655-118">O <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe difere de outros objetos de coleção em seu gerenciamento da vida útil do objeto de chaves armazenadas na coleção.</span><span class="sxs-lookup"><span data-stu-id="72655-118">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class differs from other collection objects in its management of the object lifetime of keys stored in the collection.</span></span> <span data-ttu-id="72655-119">Normalmente, quando um objeto é armazenado em uma coleção, seu tempo de vida dura até ser removido (e existem referências adicionais para o objeto) ou até que o objeto de coleção em si é destruído.</span><span class="sxs-lookup"><span data-stu-id="72655-119">Ordinarily, when an object is stored in a collection, its lifetime lasts until it is removed (and there are no additional references to the object) or until the collection object itself is destroyed.</span></span> <span data-ttu-id="72655-120">No entanto, a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe, adicionando um par chave/valor para a tabela não garante que a chave será mantido, mesmo que possa ser acessado diretamente de um valor armazenado na tabela (por exemplo, se a tabela contiver uma chave, A, com um valor V1 e com um valor de P2 que contém uma referência a um uma segunda chave, B).</span><span class="sxs-lookup"><span data-stu-id="72655-120">However, in the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class, adding a key/value pair to the table does not ensure that the key will persist, even if it can be reached directly from a value stored in the table (for example, if the table contains one key, A, with a value V1, and a second key, B, with a value P2 that contains a reference to A).</span></span> <span data-ttu-id="72655-121">Em vez disso, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> automaticamente remove a entrada de chave/valor como não há outras referências a uma chave existem fora da tabela.</span><span class="sxs-lookup"><span data-stu-id="72655-121">Instead, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> automatically removes the key/value entry as soon as no other references to a key exist outside the table.</span></span> <span data-ttu-id="72655-122">O exemplo fornece uma ilustração.</span><span class="sxs-lookup"><span data-stu-id="72655-122">The example provides an illustration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="72655-123">O exemplo a seguir ilustra que uma chave armazenada no <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabela não persiste após as referências a ele fora da tabela são destruídas.</span><span class="sxs-lookup"><span data-stu-id="72655-123">The following example illustrates that a key stored in the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table does not persist after references to it outside the table are destroyed.</span></span> <span data-ttu-id="72655-124">O exemplo define duas classes: `ManagedClass`, que representa a chave na tabela, e `ClassData`, que representa o valor da chave.</span><span class="sxs-lookup"><span data-stu-id="72655-124">The example defines two classes: `ManagedClass`, which represents the key in the table, and `ClassData`, which represents the key's value.</span></span> <span data-ttu-id="72655-125">O exemplo cria três objetos de cada tipo.</span><span class="sxs-lookup"><span data-stu-id="72655-125">The example instantiates three objects of each type.</span></span> <span data-ttu-id="72655-126">Ele também cria um <xref:System.WeakReference> objeto que representa o segundo `ManagedClass`e, em seguida, destrói o segundo `ManagedClass` instância.</span><span class="sxs-lookup"><span data-stu-id="72655-126">It also instantiates a <xref:System.WeakReference> object that represents the second `ManagedClass`, and then destroys the second `ManagedClass` instance.</span></span> <span data-ttu-id="72655-127">A tentativa de recuperar o segundo `ManagedClass` de objeto do <xref:System.WeakReference.Target%2A> propriedade indica que nenhuma referência ao objeto permanecem.</span><span class="sxs-lookup"><span data-stu-id="72655-127">The attempt to retrieve the second `ManagedClass` object from the <xref:System.WeakReference.Target%2A> property indicates that no references to the object remain.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/cs/example1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/vb/example1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="72655-128">Instâncias de <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> classe é thread-safe.</span><span class="sxs-lookup"><span data-stu-id="72655-128">Instances of the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> class are thread safe.</span></span> <span data-ttu-id="72655-129">Eles não exigem chamadores fazer qualquer bloqueio adicionais.</span><span class="sxs-lookup"><span data-stu-id="72655-129">They do not require callers to do any additional locking.</span></span></threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConditionalWeakTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConditionalWeakTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="72655-130">Inicializa uma nova instância da classe <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />.</span><span class="sxs-lookup"><span data-stu-id="72655-130">Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72655-131">O <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.%23ctor%2A> construtor instancia vazio <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabela; ou seja, a tabela não contém nenhum pares chave/valor.</span><span class="sxs-lookup"><span data-stu-id="72655-131">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.%23ctor%2A> constructor instantiates an empty <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table; that is, the table contains no key/value pairs.</span></span> <span data-ttu-id="72655-132">Você pode adicionar pares chave/valor chamando o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A>, ou <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> método.</span><span class="sxs-lookup"><span data-stu-id="72655-132">You can add key/value pairs by calling the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A>, or <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> method.</span></span>  
  
 <span data-ttu-id="72655-133">Todas as chaves em um <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> objeto deve ser exclusivo.</span><span class="sxs-lookup"><span data-stu-id="72655-133">Every key in a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> object must be unique.</span></span> <span data-ttu-id="72655-134">As chaves não forem exclusivas se eles se referem ao mesmo objeto (ou seja, se transmiti-los como argumentos para o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método `true`).</span><span class="sxs-lookup"><span data-stu-id="72655-134">Keys are not unique if they refer to the same object (that is, if passing them as arguments to the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method returns `true`).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(TKey key, TValue value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="72655-135">A chave a ser adicionada.</span><span class="sxs-lookup"><span data-stu-id="72655-135">The key to add.</span></span> <span data-ttu-id="72655-136"><c>key</c> representa objeto ao qual a propriedade é anexada.</span><span class="sxs-lookup"><span data-stu-id="72655-136"><c>key</c> represents the object to which the property is attached.</span></span></param>
        <param name="value"><span data-ttu-id="72655-137">O valor da propriedade da chave.</span><span class="sxs-lookup"><span data-stu-id="72655-137">The key's property value.</span></span></param>
        <summary><span data-ttu-id="72655-138">Adiciona uma chave à tabela.</span><span class="sxs-lookup"><span data-stu-id="72655-138">Adds a key to the table.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72655-139">Todas as chaves em um <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> objeto deve ser exclusivo.</span><span class="sxs-lookup"><span data-stu-id="72655-139">Every key in a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> object must be unique.</span></span> <span data-ttu-id="72655-140">As chaves não forem exclusivas se eles se referem ao mesmo objeto (ou seja, se transmiti-los como argumentos para o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método `true`).</span><span class="sxs-lookup"><span data-stu-id="72655-140">Keys are not unique if they refer to the same object (that is, if passing them as arguments to the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method returns `true`).</span></span>  
  
 <span data-ttu-id="72655-141">Se a chave é coletado como lixo durante a operação de adição, o par chave/valor existente será removido e o par chave/valor novo é adicionado sem uma exceção sendo lançada.</span><span class="sxs-lookup"><span data-stu-id="72655-141">If the key is garbage-collected during the addition operation, the existing key/value pair is removed and the new key/value pair is added without an exception being thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="72655-142">O exemplo a seguir define uma `MainClass` classe e um `MainInfo` classe, que fornece informações sobre o `MainClass` instância.</span><span class="sxs-lookup"><span data-stu-id="72655-142">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="72655-143">O exemplo, em seguida, chama o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> método para adicionar um `MainClass` objeto e seu anexado `MainInfo` o objeto para um <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabela.</span><span class="sxs-lookup"><span data-stu-id="72655-143">The example then calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> method to add a `MainClass` object and its attached `MainInfo` object to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="72655-144">O exemplo também ilustra chamadas para o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> e <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> métodos para adicionar pares chave/valor para a tabela e o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> método para recuperar o valor de uma chave existente.</span><span class="sxs-lookup"><span data-stu-id="72655-144">The example also illustrates calls to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> methods to add key/value pairs to the table, and to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to retrieve the value of an existing key.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="72655-145"><paramref name="key" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="72655-145"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="72655-146"><paramref name="key" /> já existe.</span><span class="sxs-lookup"><span data-stu-id="72655-146"><paramref name="key" /> already exists.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="72655-147">requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="72655-147">requires full trust for the immediate caller.</span></span> <span data-ttu-id="72655-148">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="72655-148">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdate">
      <MemberSignature Language="C#" Value="public void AddOrUpdate (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOrUpdate(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.AddOrUpdate(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOrUpdate (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOrUpdate(TKey key, TValue value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ConditionalWeakTable`2 ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ConditionalWeakTable`2 ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="72655-149">Garante que os recursos são liberados e outras operações de limpeza são executadas quando o coletor de lixo recupera o objeto <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />.</span><span class="sxs-lookup"><span data-stu-id="72655-149">Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72655-150">O coletor de lixo chama <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Finalize%2A> quando o objeto atual está pronto para ser finalizado.</span><span class="sxs-lookup"><span data-stu-id="72655-150">The garbage collector calls <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Finalize%2A> when the current object is ready to be finalized.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Finalize" />
      </Docs>
    </Member>
    <Member MemberName="GetOrCreateValue">
      <MemberSignature Language="C#" Value="public TValue GetOrCreateValue (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetOrCreateValue(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrCreateValue (key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetOrCreateValue(TKey key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="72655-151">A chave a ser pesquisada.</span><span class="sxs-lookup"><span data-stu-id="72655-151">The key to search for.</span></span> <span data-ttu-id="72655-152"><c>key</c> representa objeto ao qual a propriedade é anexada.</span><span class="sxs-lookup"><span data-stu-id="72655-152"><c>key</c> represents the object to which the property is attached.</span></span></param>
        <summary><span data-ttu-id="72655-153">Pesquisa de forma atômica por uma chave especificada na tabela e retorna o valor correspondente.</span><span class="sxs-lookup"><span data-stu-id="72655-153">Atomically searches for a specified key in the table and returns the corresponding value.</span></span> <span data-ttu-id="72655-154">Se a chave não existir na tabela, o método invocará o construtor padrão da classe que representa o valor da tabela para criar um valor associado à chave especificada.</span><span class="sxs-lookup"><span data-stu-id="72655-154">If the key does not exist in the table, the method invokes the default constructor of the class that represents the table's value to create a value that is bound to the specified key.</span></span></summary>
        <returns><span data-ttu-id="72655-155">O valor que corresponde a <paramref name="key" /> se <paramref name="key" /> já existir na tabela; caso contrário, um novo valor criado pelo construtor padrão da classe definida pelo parâmetro de tipo genérico <paramref name="TValue" />.</span><span class="sxs-lookup"><span data-stu-id="72655-155">The value that corresponds to <paramref name="key" />, if <paramref name="key" /> already exists in the table; otherwise, a new value created by the default constructor of the class defined by the <paramref name="TValue" /> generic type parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72655-156">Se `key` não existe na tabela, o método adiciona o conteúdo, juntamente com o objeto que é instanciado chamando o construtor padrão da classe definida pelo `TValue` parâmetro de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="72655-156">If `key` does not exist in the table, the method adds it, along with the object that is instantiated by calling the default constructor of the class defined by the `TValue` generic type parameter.</span></span> <span data-ttu-id="72655-157">Se o `TValue` classe não possui construtor padrão, um <xref:System.MissingMethodException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="72655-157">If the `TValue` class has no default constructor, a <xref:System.MissingMethodException> is thrown.</span></span>  
  
 <span data-ttu-id="72655-158">Este é o método recomendado para recuperar um valor existente ou adicionando um novo valor para o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabela se a classe de valor da tabela define um construtor padrão.</span><span class="sxs-lookup"><span data-stu-id="72655-158">This is the recommended method of retrieving an existing value or adding a new value to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table if the class of the table's value defines a default constructor.</span></span> <span data-ttu-id="72655-159">Se ele não define um construtor padrão, em vez disso, você pode chamar o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> método, que se baseia em um método de retorno de chamada fornecido para instanciar o objeto que representa o valor da tabela</span><span class="sxs-lookup"><span data-stu-id="72655-159">If it does not define a default constructor, you can instead call the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> method, which relies on a callback-provided method to instantiate the object representing the table's value</span></span>  
  
 <span data-ttu-id="72655-160">Para recuperar o valor de uma chave existente sem adicionar o par chave/valor se a chave não for encontrada na tabela, chame o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> método.</span><span class="sxs-lookup"><span data-stu-id="72655-160">To retrieve the value of an existing key without adding the key/value pair if the key is not found in the table, call the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="72655-161">O exemplo a seguir define uma `MainClass` classe e um `MainInfo` classe, que fornece informações sobre o `MainClass` instância.</span><span class="sxs-lookup"><span data-stu-id="72655-161">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="72655-162">O exemplo chama o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> método para adicionar um `MainClass` objeto e seu anexado `MainInfo` o objeto para um <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabela.</span><span class="sxs-lookup"><span data-stu-id="72655-162">The example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> method to add a `MainClass` object and its attached `MainInfo` object to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="72655-163">O exemplo também ilustra chamadas para o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> e <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> métodos para adicionar pares chave/valor para a tabela e o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> método para recuperar o valor de uma chave existente.</span><span class="sxs-lookup"><span data-stu-id="72655-163">The example also illustrates calls to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> methods to add key/value pairs to the table, and to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to retrieve the value of an existing key.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="72655-164"><paramref name="key" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="72655-164"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para>  
 <span data-ttu-id="72655-165">Em vez disso, no [.NET para aplicativos da Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou na [Biblioteca de Classes Portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capture a exceção de classe base, <see cref="T:System.MissingMemberException" />.</span><span class="sxs-lookup"><span data-stu-id="72655-165">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.MissingMemberException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="72655-166">A classe que representa o valor da tabela não define um construtor padrão.</span><span class="sxs-lookup"><span data-stu-id="72655-166">The class that represents the table's value does not define a default constructor.</span></span></exception>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public TValue GetValue (TKey key, System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;.CreateValueCallback createValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetValue(!TKey key, class System.Runtime.CompilerServices.ConditionalWeakTable`2/CreateValueCallback&lt;!TKey, !TValue&gt; createValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetValue(TKey key, System::Runtime::CompilerServices::ConditionalWeakTable&lt;TKey, TValue&gt;::CreateValueCallback ^ createValueCallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="createValueCallback" Type="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;+CreateValueCallback" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="72655-167">A chave a ser pesquisada.</span><span class="sxs-lookup"><span data-stu-id="72655-167">The key to search for.</span></span> <span data-ttu-id="72655-168"><c>key</c> representa objeto ao qual a propriedade é anexada.</span><span class="sxs-lookup"><span data-stu-id="72655-168"><c>key</c> represents the object to which the property is attached.</span></span></param>
        <param name="createValueCallback"><span data-ttu-id="72655-169">Um delegado de um método que pode criar um valor para o objeto <c>key</c> determinado.</span><span class="sxs-lookup"><span data-stu-id="72655-169">A delegate to a method that can create a value for the given <c>key</c>.</span></span> <span data-ttu-id="72655-170">Ele tem um único parâmetro do tipo <c>TKey</c> e retorna um valor do tipo <c>TValue</c>.</span><span class="sxs-lookup"><span data-stu-id="72655-170">It has a single parameter of type <c>TKey</c>, and returns a value of type <c>TValue</c>.</span></span></param>
        <summary><span data-ttu-id="72655-171">Pesquisa de forma atômica por uma chave especificada na tabela e retorna o valor correspondente.</span><span class="sxs-lookup"><span data-stu-id="72655-171">Atomically searches for a specified key in the table and returns the corresponding value.</span></span> <span data-ttu-id="72655-172">Se a chave não existir na tabela, o método invocará um método de retorno de chamada para criar um valor associado à chave especificada.</span><span class="sxs-lookup"><span data-stu-id="72655-172">If the key does not exist in the table, the method invokes a callback method to create a value that is bound to the specified key.</span></span></summary>
        <returns><span data-ttu-id="72655-173">O valor anexado a <paramref name="key" />, se <paramref name="key" /> já existir na tabela; caso contrário, o novo valor retornado pelo delegado <paramref name="createValueCallback" />.</span><span class="sxs-lookup"><span data-stu-id="72655-173">The value attached to <paramref name="key" />, if <paramref name="key" /> already exists in the table; otherwise, the new value returned by the <paramref name="createValueCallback" /> delegate.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72655-174">Se `key` não existe na tabela, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> invoca o método que é definido pelo `createValueCallback` parâmetro e passa a chave.</span><span class="sxs-lookup"><span data-stu-id="72655-174">If `key` does not exist in the table, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> invokes the method that is defined by the `createValueCallback` parameter and passes it the key.</span></span> <span data-ttu-id="72655-175">Um novo valor é associado à chave da tabela e retornado como resultado.</span><span class="sxs-lookup"><span data-stu-id="72655-175">A new value is bound to the key in the table and returned as a result.</span></span>  
  
 <span data-ttu-id="72655-176">Use esse método somente quando a classe que representa o valor da tabela não define um construtor padrão.</span><span class="sxs-lookup"><span data-stu-id="72655-176">Use this method only when the class that represents the table's value does not define a default constructor.</span></span> <span data-ttu-id="72655-177">Se ela define um construtor padrão, use o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> método em vez disso.</span><span class="sxs-lookup"><span data-stu-id="72655-177">If it does define a default constructor, use the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> method instead.</span></span> <span data-ttu-id="72655-178">Para recuperar o valor de uma chave existente sem adicionar o par chave/valor se a chave não for encontrada na tabela, chame o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> método.</span><span class="sxs-lookup"><span data-stu-id="72655-178">To retrieve the value of an existing key without adding the key/value pair if the key is not found in the table, call the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method.</span></span>  
  
 <span data-ttu-id="72655-179">Se vários threads tentarem criar a mesma chave, `createValueCallback` pode ser chamado várias vezes com a mesma chave.</span><span class="sxs-lookup"><span data-stu-id="72655-179">If multiple threads try to create the same key, `createValueCallback` may be invoked multiple times with the same key.</span></span> <span data-ttu-id="72655-180">Somente uma dessas chamadas terá êxito e o valor retornado será adicionado à tabela.</span><span class="sxs-lookup"><span data-stu-id="72655-180">Only one of these calls will succeed, and its returned value will be added to the table.</span></span> <span data-ttu-id="72655-181">Qual thread tiver êxito na criação do valor é indeterminado.</span><span class="sxs-lookup"><span data-stu-id="72655-181">Which thread succeeds in creating the value is indeterminate.</span></span> <span data-ttu-id="72655-182">Essa regra permite a tabela para invocar `createValueCallback` fora o bloqueio de tabela interna para evitar deadlocks.</span><span class="sxs-lookup"><span data-stu-id="72655-182">This rule permits the table to invoke `createValueCallback` outside the internal table lock to prevent deadlocks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="72655-183">O exemplo a seguir define uma `MainClass` classe e um `MainInfo` classe, que fornece informações sobre o `MainClass` instância.</span><span class="sxs-lookup"><span data-stu-id="72655-183">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="72655-184">Também define um static (`Shared` no Visual Basic) `CreateAttachedValue` método que pode ser atribuído ao <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.CreateValueCallback> delegar e passados para o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> método.</span><span class="sxs-lookup"><span data-stu-id="72655-184">It also defines a static (`Shared` in Visual Basic) `CreateAttachedValue` method that can be assigned to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.CreateValueCallback> delegate and passed to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> method.</span></span> <span data-ttu-id="72655-185">O exemplo chama o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> método para adicionar um `MainClass` objeto e seu anexado `MainInfo` o objeto para um <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabela.</span><span class="sxs-lookup"><span data-stu-id="72655-185">The example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> method to add a `MainClass` object and its attached `MainInfo` object to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="72655-186">O exemplo também ilustra chamadas para o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> e <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> métodos para adicionar pares chave/valor para a tabela e o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> método para recuperar o valor de uma chave existente.</span><span class="sxs-lookup"><span data-stu-id="72655-186">The example also illustrates calls to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> methods to add key/value pairs to the table, and to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to retrieve the value of an existing key.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="72655-187"><paramref name="key" /> ou <paramref name="createValueCallback" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="72655-187"><paramref name="key" /> or <paramref name="createValueCallback" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="72655-188">requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="72655-188">requires full trust for the immediate caller.</span></span> <span data-ttu-id="72655-189">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="72655-189">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
        <altmember cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="72655-190">A chave a ser removida.</span><span class="sxs-lookup"><span data-stu-id="72655-190">The key to remove.</span></span></param>
        <summary><span data-ttu-id="72655-191">Remove uma chave e seu valor da tabela.</span><span class="sxs-lookup"><span data-stu-id="72655-191">Removes a key and its value from the table.</span></span></summary>
        <returns>
          <span data-ttu-id="72655-192"><see langword="true" /> se a chave for encontrada e removida; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="72655-192"><see langword="true" /> if the key is found and removed; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72655-193">Se a chave é coletado como lixo durante esta operação, o método gera uma exceção e o valor retornado é indefinido.</span><span class="sxs-lookup"><span data-stu-id="72655-193">If the key is garbage-collected during this operation, the method does not raise an exception and the return value is undefined.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="72655-194"><paramref name="key" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="72655-194"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="72655-195">requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="72655-195">requires full trust for the immediate caller.</span></span> <span data-ttu-id="72655-196">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="72655-196">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue)) Implements IEnumerable(Of KeyValuePair(Of TKey, TValue)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="72655-197">A chave que representa um objeto com uma propriedade anexada.</span><span class="sxs-lookup"><span data-stu-id="72655-197">The key that represents an object with an attached property.</span></span></param>
        <param name="value"><span data-ttu-id="72655-198">Quando é retornado, este método contém o valor da propriedade anexada.</span><span class="sxs-lookup"><span data-stu-id="72655-198">When this method returns, contains the attached property value.</span></span> <span data-ttu-id="72655-199">Se <c>key</c> não for encontrado, <c>value</c> conterá o valor padrão.</span><span class="sxs-lookup"><span data-stu-id="72655-199">If <c>key</c> is not found, <c>value</c> contains the default value.</span></span></param>
        <summary><span data-ttu-id="72655-200">Obtém o valor da chave especificada.</span><span class="sxs-lookup"><span data-stu-id="72655-200">Gets the value of the specified key.</span></span></summary>
        <returns>
          <span data-ttu-id="72655-201"><see langword="true" /> se <paramref name="key" /> for encontrado; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="72655-201"><see langword="true" /> if <paramref name="key" /> is found; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72655-202">Se a chave é coletado como lixo durante esta operação, o método pode retornar `false` e defina `value` para o padrão de valor (como se a chave não estava presente).</span><span class="sxs-lookup"><span data-stu-id="72655-202">If the key is garbage-collected during this operation, the method may return `false` and set `value` to the default value (as if the key were not present).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="72655-203">O exemplo a seguir define uma `MainClass` classe e um `MainInfo` classe, que fornece informações sobre o `MainClass` instância.</span><span class="sxs-lookup"><span data-stu-id="72655-203">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="72655-204">O exemplo chama o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A>, e <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> métodos para adicionar pares de chave/valor para um <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabela.</span><span class="sxs-lookup"><span data-stu-id="72655-204">The example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A>, and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> methods to add key/value pairs to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="72655-205">Em cada caso, o exemplo chama o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> método para confirmar que o par chave/valor foi adicionado à tabela.</span><span class="sxs-lookup"><span data-stu-id="72655-205">In each case, the example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to confirm that the key/value pair has been added to the table.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="72655-206"><paramref name="key" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="72655-206"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="72655-207">requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="72655-207">requires full trust for the immediate caller.</span></span> <span data-ttu-id="72655-208">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="72655-208">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)" />
      </Docs>
    </Member>
  </Members>
</Type>