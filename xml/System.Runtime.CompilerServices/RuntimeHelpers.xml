<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="RuntimeHelpers.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5c39d8180904c9260ec3b7f679f09d3791b94ac31.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c39d8180904c9260ec3b7f679f09d3791b94ac31</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>Provides a set of static methods and properties that provide support for compilers.</source>
          <target state="translated">Fornece um conjunto de propriedades que dão suporte a compiladores e métodos estáticos.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>This class cannot be inherited.</source>
          <target state="translated">Essa classe não pode ser herdada.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>The following example shows how to reliably set handles by using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method.</source>
          <target state="translated">O exemplo a seguir mostra como definir confiável identificadores usando o <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>To reliably set a handle to a specified pre-existing handle, you must ensure that the allocation of the native handle and the subsequent recording of that handle within a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object is atomic.</source>
          <target state="translated">Para definir com segurança um identificador para um identificador pré-existente especificado, você deve garantir que a alocação do identificador nativo e a gravação subsequente desse identificador em um <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> objeto é atômico.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>Any failure between these operations (such as a thread abort or out-of-memory exception) will result in the native handle being leaked.</source>
          <target state="translated">Qualquer falha entre essas operações (por exemplo, uma exceção de falta de memória ou anulação de thread) resulta no identificador nativo vazem.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>You can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method to make sure that the handle is not leaked.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> método para certificar-se de que o identificador não vazou.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>Ensures that the remaining stack space is large enough to execute the average .NET Framework function.</source>
          <target state="translated">Garante que o espaço de pilha restante é grande o suficiente para executar a função média do .NET Framework.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A&gt;</ph> provides information about an artificially limited stack that preserves enough space for an exception to be raised and recovery action to be taken.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A&gt;</ph> Fornece informações sobre uma pilha artificialmente limitada que preserva espaço suficiente para uma exceção a ser gerado e a ação de recuperação a ser executada.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>The artificial stack limit is chosen by the common language runtime to ensure that enough space remains to throw an exception safely.</source>
          <target state="translated">O limite de pilha artificial é escolhido pelo common language runtime para garantir que há espaço suficiente permaneça gerar uma exceção com segurança.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>This method is useful in situations where stack overflow might occur as a result of unbounded recursion.</source>
          <target state="translated">Esse método é útil em situações em que o estouro de pilha pode ocorrer como resultado de recursão ilimitada.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>It is intended for use in compiler services scenarios, although it can also be used safely in other development scenarios.</source>
          <target state="translated">Ele é destinado ao uso em cenários de serviços do compilador, embora também possa ser usado com segurança em outros cenários de desenvolvimento.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>If the stack space is sufficient, the exception is not thrown, and most .NET Framework types and members can still be called.</source>
          <target state="translated">Se o espaço de pilha suficiente, a exceção não é gerada e a maioria dos tipos do .NET Framework e membros ainda podem ser chamados.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>This method is not part of the constrained execution region (CER) support, and should not be confused with the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Esse método não faz parte do suporte de região (CER) de execução restrita e não deve ser confundido com o <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>The available stack space is insufficient to execute the average .NET Framework function.</source>
          <target state="translated">O espaço de pilha disponível é insuficiente para executar a função média do .NET Framework.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source>The first object to compare.</source>
          <target state="translated">O primeiro objeto a ser comparado.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source>The second object to compare.</source>
          <target state="translated">O segundo objeto a ser comparado.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source>Determines whether the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> instances are considered equal.</source>
          <target state="translated">Determina se as instâncias <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> especificadas são consideradas iguais.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="o1" /&gt;</ph> parameter is the same instance as the <ph id="ph3">&lt;paramref name="o2" /&gt;</ph> parameter, or if both are <ph id="ph4">&lt;see langword="null" /&gt;</ph>, or if <bpt id="p1">&lt;c&gt;</bpt>o1.Equals(o2)<ept id="p1">&lt;/c&gt;</ept> returns <ph id="ph5">&lt;see langword="true" /&gt;</ph>; otherwise, <ph id="ph6">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o <ph id="ph2">&lt;paramref name="o1" /&gt;</ph> parâmetro estiver na mesma instância que o parâmetro <ph id="ph3">&lt;paramref name="o2" /&gt;</ph> ou se ambas forem <ph id="ph4">&lt;see langword="null" /&gt;</ph> ou se <bpt id="p1">&lt;c&gt;</bpt>o1. Equals(o2)<ept id="p1">&lt;/c&gt;</ept> retornar <ph id="ph5">&lt;see langword="true" /&gt;</ph>; caso contrário, <ph id="ph6">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source>This method is used by compilers.</source>
          <target state="translated">Esse método é usado por compiladores.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source>The following example demonstrates how to compare two objects by using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.Equals%2A&gt;</ph> method.</source>
          <target state="translated">O exemplo a seguir demonstra como comparar dois objetos usando o <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.Equals%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>A delegate to the code to try.</source>
          <target state="translated">Um delegado para o código a experimentar.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>A delegate to the code to run if an exception occurs.</source>
          <target state="translated">Um delegado para o código a executar se uma exceção ocorrer.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>The data to pass to <bpt id="p1">&lt;c&gt;</bpt>code<ept id="p1">&lt;/c&gt;</ept> and <bpt id="p2">&lt;c&gt;</bpt>backoutCode<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">Os dados a serem passados para o <bpt id="p1">&lt;c&gt;</bpt>código<ept id="p1">&lt;/c&gt;</ept> e <bpt id="p2">&lt;c&gt;</bpt>backoutCode<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>Executes code using a <ph id="ph1">&lt;see cref="T:System.Delegate" /&gt;</ph> while using another <ph id="ph2">&lt;see cref="T:System.Delegate" /&gt;</ph> to execute additional code in case of an exception.</source>
          <target state="translated">Executa o código usando um <ph id="ph1">&lt;see cref="T:System.Delegate" /&gt;</ph> enquanto usa outro <ph id="ph2">&lt;see cref="T:System.Delegate" /&gt;</ph> para executar código adicional no caso de uma exceção.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>This method is used by compilers.</source>
          <target state="translated">Esse método é usado por compiladores.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>An object to retrieve the hash code for.</source>
          <target state="translated">Um objeto para recuperar o código hash.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Serves as a hash function for a particular object, and is suitable for use in algorithms and data structures that use hash codes, such as a hash table.</source>
          <target state="translated">Serve como uma função de hash para um determinado objeto e é adequado para uso em algoritmos e estruturas de dados que usam códigos de hash, como uma tabela de hash.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>A hash code for the object identified by the <ph id="ph1">&lt;paramref name="o" /&gt;</ph> parameter.</source>
          <target state="translated">Um código hash para o objeto identificado pelo parâmetro <ph id="ph1">&lt;paramref name="o" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method always calls the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method non-virtually, even if the object's type has overridden the <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> método sempre chama o <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> método não virtualmente, mesmo se o tipo de objeto tiver substituído o <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Therefore, using <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> might differ from calling <ph id="ph2">`GetHashCode`</ph> directly on the object with the <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Portanto, o uso <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> pode diferir da chamada <ph id="ph2">`GetHashCode`</ph> diretamente no objeto com o <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Although the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method returns identical hash codes for identical object references, you should not use this method to test for object identity, because this hash code does not uniquely identify an object reference.</source>
          <target state="translated">Embora o <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> método retorna códigos de hash idênticos para referências de objeto idênticos, você não deve usar esse método para testar a identidade do objeto, pois esse código de hash não identifica exclusivamente uma referência de objeto.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>To test for object identify (that is, to test that two objects reference the same object in memory), call the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para testar para identificar de objeto (ou seja, para testar que dois objetos de referência o mesmo objeto na memória), chame o <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Nor should you use <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A&gt;</ph> to test whether two strings represent equal object references, because the string is interned.</source>
          <target state="translated">Ou você deve usar <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A&gt;</ph> para testar se duas cadeias de caracteres representam referências de objeto igual, porque a cadeia de caracteres é definidos como internos.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>To test for string interning, call the <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para testar a cadeia de caracteres como internos, chame o <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> methods differ as follows:</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> métodos diferem da seguinte maneira:</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> returns a hash code that is based on the object's definition of equality.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> Retorna um código de hash com base na definição do objeto de igualdade.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>For example, two strings with identical contents will return the same value for <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Por exemplo, duas cadeias de caracteres com conteúdo idêntico retornará o mesmo valor para <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> returns a hash code that indicates object identity.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> Retorna um código de hash que indica a identidade do objeto.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>That is, two string variables whose contents are identical and that represent a string that is interned (see the <bpt id="p1">[</bpt>String Interning<ept id="p1">](#interning)</ept> section) or that represent a single string in memory return identical hash codes.</source>
          <target state="translated">Ou seja, dois de cadeia de caracteres variáveis cujos conteúdos são idênticos e que representam uma cadeia de caracteres que é definidos como internos (consulte o <bpt id="p1">[</bpt>cadeia de caracteres como internos<ept id="p1">](#interning)</ept> seção) ou códigos de hash que representam uma única cadeia de caracteres na memória de retorno idênticos.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Note that <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A&gt;</ph> always returns identical hash codes for equal object references.</source>
          <target state="translated">Observe que <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A&gt;</ph> sempre retorna códigos de hash idênticos para referências de objeto igual.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>However, the reverse is not true: equal hash codes do not indicate equal object references.</source>
          <target state="translated">No entanto, o inverso é verdadeiro não: códigos hash igual não indicam referências de objeto igual.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>A particular hash code value is not unique to a particular object reference; different object references can generate identical hash codes.</source>
          <target state="translated">Um valor de código hash específico não é exclusivo para um determinado objeto de referência; referências de objeto diferentes podem gerar códigos hash idênticos.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>This method is used by compilers.</source>
          <target state="translated">Esse método é usado por compiladores.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>String Interning</source>
          <target state="translated">Centralização da cadeia de caracteres</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The common language runtime (CLR) maintains an internal pool of strings and stores literals in the pool.</source>
          <target state="translated">O common language runtime (CLR) mantém um pool interno de cadeias de caracteres e armazena literais no pool.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>If two strings (for example, <ph id="ph1">`str1`</ph> and <ph id="ph2">`str2`</ph>) are formed from an identical string literal, the CLR will set <ph id="ph3">`str1`</ph> and <ph id="ph4">`str2`</ph> to point to the same location on the managed heap to conserve memory.</source>
          <target state="translated">Se duas cadeias de caracteres (por exemplo, <ph id="ph1">`str1`</ph> e <ph id="ph2">`str2`</ph>) são formadas de uma cadeia de caracteres idêntica literal, o CLR definirá <ph id="ph3">`str1`</ph> e <ph id="ph4">`str2`</ph> para apontar para o mesmo local no heap gerenciado para conservar memória.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Calling <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> on these two string objects will produce the same hash code, contrary to the second bulleted item in the previous section.</source>
          <target state="translated">Chamando <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> na cadeia de caracteres dois objetos produzirá o mesmo código de hash, ao contrário do segundo item com marcador na seção anterior.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The CLR adds only literals to the pool.</source>
          <target state="translated">O CLR adiciona apenas literais para o pool.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Results of string operations such as concatenation are not added to the pool, unless the compiler resolves the string concatenation as a single string literal.</source>
          <target state="translated">Resultados das operações de cadeia de caracteres, como concatenação não são adicionados ao pool, a menos que o compilador resolve a concatenação de cadeia de caracteres como uma única cadeia de caracteres literal.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Therefore, if <ph id="ph1">`str2`</ph> was created as the result of a concatenation operation, and <ph id="ph2">`str2`</ph> is identical to <ph id="ph3">`str1`</ph>, using <ph id="ph4">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> on these two string objects will not produce the same hash code.</source>
          <target state="translated">Portanto, se <ph id="ph1">`str2`</ph> foi criado como resultado de uma operação de concatenação e <ph id="ph2">`str2`</ph> é idêntico ao <ph id="ph3">`str1`</ph>usando <ph id="ph4">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> na cadeia de caracteres dois objetos não produzirá o mesmo código de hash.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>If you want to add a concatenated string to the pool explicitly, use the <ph id="ph1">&lt;xref:System.String.Intern%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Se você deseja adicionar uma cadeia de caracteres concatenada ao pool explicitamente, use o <ph id="ph1">&lt;xref:System.String.Intern%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>You can also use the <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph> method to check whether a string has an interned reference.</source>
          <target state="translated">Você também pode usar o <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph> método para verificar se uma cadeia de caracteres tem uma referência interno.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The following example demonstrates the difference between the <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">O exemplo a seguir demonstra a diferença entre o <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The output from the example illustrates the following:</source>
          <target state="translated">A saída do exemplo ilustra o seguinte:</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Both sets of hash codes for the first set of strings passed to the <ph id="ph1">`ShowHashCodes`</ph> method are different, because the strings are completely different.</source>
          <target state="translated">Ambos os conjuntos de códigos de hash para o primeiro conjunto de cadeias de caracteres passada para o <ph id="ph1">`ShowHashCodes`</ph> método forem diferentes, pois as cadeias de caracteres são completamente diferentes.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> generates the same hash code for the second set of strings passed to the <ph id="ph2">`ShowHashCodes`</ph> method, because the strings are equal.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> gera o mesmo código hash para o segundo conjunto de cadeias de caracteres passada para o <ph id="ph2">`ShowHashCodes`</ph> método, porque as cadeias de caracteres são iguais.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>However, the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method does not.</source>
          <target state="translated">No entanto, o <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> método não.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The first string is defined by using a string literal and so is interned.</source>
          <target state="translated">A primeira cadeia de caracteres é definida usando uma literal de cadeia de caracteres e portanto é definidos como internos.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Although the value of the second string is the same, it is not interned, because it is returned by a call to the <ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Embora o valor da segunda cadeia de caracteres é o mesmo, ele não é definidos como internos, porque ele é retornado por uma chamada para o <ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>In the case of the third string, the hash codes produced by <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> for both strings are identical, as are the hash codes produced by <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">No caso de cadeia de caracteres terceira, os códigos hash produzido por <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> para ambas as cadeias de caracteres são idênticas, como são os códigos de hash produzidos pelo <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>This is because the compiler has treated the value assigned to both strings as a single string literal, and so the string variables refer to the same interned string.</source>
          <target state="translated">Isso é porque o compilador foi tratado o valor atribuído a duas cadeias de caracteres como uma única cadeia de caracteres literal e, portanto, as variáveis de cadeia de caracteres se referem à mesma cadeia de caracteres definidos como interno.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>The value type to be boxed.</source>
          <target state="translated">O tipo de valor a ser demarcado.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>Boxes a value type.</source>
          <target state="translated">Demarca como um tipo de valor.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>A boxed copy of <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> if it is a value class; otherwise, <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> itself.</source>
          <target state="translated">Uma cópia demarcada do <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> se for uma classe de valor; caso contrário, o próprio <ph id="ph2">&lt;paramref name="obj" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>Boxing a value type creates an object and performs a shallow copy of the fields of the specified value type into the new object.</source>
          <target state="translated">Um tipo de valor de conversão boxing cria um objeto e executa uma cópia superficial dos campos do tipo de valor especificado para o novo objeto.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>This method allows a value class to be manipulated as an object while it retains the aliasing behavior of a value class.</source>
          <target state="translated">Esse método permite que uma classe de valor a ser manipulada como um objeto enquanto mantém o comportamento de alias de uma classe de valor.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>The return value depends on whether the value class is mutable or immutable:</source>
          <target state="translated">O valor de retorno depende se a classe de valor é mutável ou imutável:</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>If the value being assigned is a mutable value class, the method returns a shallow copy of the class, because value classes have copy semantics.</source>
          <target state="translated">Se o valor que está sendo atribuído é uma classe de valor mutável, o método retorna uma cópia superficial da classe, porque as classes de valor tem semântica de cópia.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>If the value being assigned is an immutable value class, the method returns the object itself, instead of a copy of the class.</source>
          <target state="translated">Se o valor que está sendo atribuído é uma classe de valor imutável, o método retorna o objeto em si, em vez de uma cópia da classe.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>Compilers of dynamically typed languages can use this method to make sure that boxed value types work identically to unboxed value types.</source>
          <target state="translated">Compiladores de idiomas dinamicamente com tipo podem usar esse método para certificar-se de que tipos de valor boxed funcionam do mesmo modo para tipos de valor não Demarcado.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>That is, boxed value types get cloned when you pass them around, and they are always passed by value.</source>
          <target state="translated">Ou seja, tipos de valor boxed obtenham clonados quando você passá-los ao redor, e eles sempre são transmitidos por valor.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>The compiler can call <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A&gt;</ph> to assign a value type to an object or to pass a value type as a parameter of a type object.</source>
          <target state="translated">O compilador pode chamar <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A&gt;</ph> para atribuir um tipo de valor a um objeto ou para passar um tipo de valor como um parâmetro de um objeto de tipo.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>This method is used by compilers.</source>
          <target state="translated">Esse método é usado por compiladores.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>The following example demonstrates how to box a value class by using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A&gt;</ph> method.</source>
          <target state="translated">O exemplo a seguir demonstra como caixa de uma classe de valor usando o <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)">
          <source>The array to be initialized.</source>
          <target state="translated">A matriz a ser inicializada.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)">
          <source>A field handle that specifies the location of the data used to initialize the array.</source>
          <target state="translated">Um identificador de campo que especifica o local dos dados usados para inicializar a matriz.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)">
          <source>Provides a fast way to initialize an array from data that is stored in a module.</source>
          <target state="translated">Oferece uma maneira rápida de inicializar uma matriz de dados armazenados em um módulo.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)">
          <source>This method is used by compilers.</source>
          <target state="translated">Esse método é usado por compiladores.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData">
          <source>Gets the offset, in bytes, to the data in the given string.</source>
          <target state="translated">Obtém o deslocamento, em bytes, para os dados na cadeia de caracteres especificada.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData">
          <source>The byte offset, from the start of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object to the first character in the string.</source>
          <target state="translated">O deslocamento de byte, do início do objeto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> para o primeiro caractere na cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData">
          <source>Compilers use this property for unsafe, but efficient, pointer operations on the characters in a managed string.</source>
          <target state="translated">Compiladores usam essa propriedade para operações de ponteiro inseguro, mas eficiente, os caracteres em uma cadeia de caracteres gerenciada.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData">
          <source>Compilers should pin the string against movement by the garbage collector before use.</source>
          <target state="translated">Compiladores devem fixar movimentação pelo coletor de lixo antes de usar a cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData">
          <source>Note that common language runtime strings are immutable; that is, their contents can be read but not changed.</source>
          <target state="translated">Observe que as cadeias de caracteres de tempo de execução de linguagem comuns são imutáveis; Isto é, seu conteúdo pode ser lido mas não alterado.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>Designates a body of code as a constrained execution region (CER).</source>
          <target state="translated">Designa um corpo de código como uma região de execução restrita (CER).</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>Compilers use this method to mark <ph id="ph1">`catch`</ph>, <ph id="ph2">`finally`</ph>, and <ph id="ph3">`fault`</ph> blocks as constrained execution regions (CERs).</source>
          <target state="translated">Compiladores de usam esse método para marcar <ph id="ph1">`catch`</ph>, <ph id="ph2">`finally`</ph>, e <ph id="ph3">`fault`</ph> blocos como regiões de execução restrita (CERs).</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>Code that is marked as a constrained region must only call other code with strong reliability contracts.</source>
          <target state="translated">Código que está marcado como uma região restrita só deve chamar outro código com contratos de confiabilidade forte.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>It should not allocate or make virtual calls to unprepared or unreliable methods unless it is prepared to handle failures.</source>
          <target state="translated">Ele não deve alocar ou fazer chamadas virtuais para métodos não preparadas ou não confiáveis, a menos que ele está preparado para lidar com falhas.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>Note that no intermediate language opcodes, except <ph id="ph1">`NOP`</ph>, are allowed between a call to the <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method and the <ph id="ph3">`try`</ph> block.</source>
          <target state="translated">Observe que não intermediário opcodes de idioma, exceto <ph id="ph1">`NOP`</ph>, são permitidos entre uma chamada para o <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> método e o <ph id="ph3">`try`</ph> bloco.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>For more information about CERs, see the classes in the <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution&gt;</ph> namespace.</source>
          <target state="translated">Para obter mais informações sobre as CERs, consulte as classes de <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution&gt;</ph> namespace.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>CERs that are marked using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method do not work perfectly when a <ph id="ph2">&lt;xref:System.StackOverflowException&gt;</ph> is generated from the <ph id="ph3">`try`</ph> block.</source>
          <target state="translated">CERs são marcadas com o <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> método não funcionar perfeitamente quando um <ph id="ph2">&lt;xref:System.StackOverflowException&gt;</ph> é gerado a partir de <ph id="ph3">`try`</ph> bloco.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A&gt;</ph> method.</source>
          <target state="translated">Para obter mais informações, consulte o método <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method calls the <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> chamadas de método de <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>The following example shows how to reliably set handles by using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method.</source>
          <target state="translated">O exemplo a seguir mostra como definir confiável identificadores usando o <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>To reliably set a handle to a specified pre-existing handle, you must ensure that the allocation of the native handle and the subsequent recording of that handle within a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object is atomic.</source>
          <target state="translated">Para definir com segurança um identificador para um identificador pré-existente especificado, você deve garantir que a alocação do identificador nativo e a gravação subsequente desse identificador em um <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> objeto é atômico.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>Any failure between these operations (such as a thread abort or out-of-memory exception) will result in the native handle being leaked.</source>
          <target state="translated">Qualquer falha entre essas operações (por exemplo, uma exceção de falta de memória ou anulação de thread) resulta no identificador nativo vazem.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>You can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method to make sure that the handle is not leaked.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> método para certificar-se de que o identificador não vazou.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP">
          <source>Designates a body of code as a constrained execution region (CER) without performing any probing.</source>
          <target state="translated">Designa um corpo de código como uma CER (região de execução restrita) sem realizar nenhuma investigação.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP">
          <source>Compilers should not call this method directly.</source>
          <target state="translated">Compiladores não devem chamar este método diretamente.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP">
          <source>Instead, define a CER by calling the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Em vez disso, defina uma CER chamando o <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>The event delegate to prepare.</source>
          <target state="translated">O delegado do evento a ser preparado.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>Provides a way for applications to dynamically prepare <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> event delegates.</source>
          <target state="translated">Fornece uma maneira para os aplicativos prepararem dinamicamente representantes de eventos <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source><ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> event delegates such as <ph id="ph2">&lt;xref:System.AppDomain.DomainUnload&gt;</ph>, <ph id="ph3">&lt;xref:System.AppDomain.ProcessExit&gt;</ph>, and <ph id="ph4">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> are not automatically prepared at startup.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> evento delega como <ph id="ph2">&lt;xref:System.AppDomain.DomainUnload&gt;</ph>, <ph id="ph3">&lt;xref:System.AppDomain.ProcessExit&gt;</ph>, e <ph id="ph4">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> não está preparado automaticamente na inicialização.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>You can use the following methods to prepare them:</source>
          <target state="translated">Você pode usar os seguintes métodos para prepará-los:</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>Attribute the method by using the <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute&gt;</ph> attribute.</source>
          <target state="translated">O método de atributo usando o <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute&gt;</ph> atributo.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>Attribute the method by using the <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> attribute.</source>
          <target state="translated">O método de atributo usando o <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> atributo.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>Call the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A&gt;</ph> method to dynamically prepare the delegate.</source>
          <target state="translated">Chamar o <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A&gt;</ph> método preparar dinamicamente o delegado.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>For more information, see the article <bpt id="p1">[</bpt>Keep Your Code Running with the Reliability Features of the .NET Framework<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=145491)</ept> in the MSDN Magazine.</source>
          <target state="translated">Para obter mais informações, consulte o artigo <bpt id="p1">[</bpt>manter seu código em execução com os recursos de confiabilidade do .NET Framework<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=145491)</ept> no MSDN Magazine.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)">
          <source>The delegate type to prepare.</source>
          <target state="translated">O tipo de delegado a ser preparado.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)">
          <source>Indicates that the specified delegate should be prepared for inclusion in a constrained execution region (CER).</source>
          <target state="translated">Indica que o delegado especificado deve ser preparado para inclusão em uma CER (região de execução restrita).</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)">
          <source>Compilers use this method to prepare a delegate's invocation method and to prepare the target of that invocation (and the delegate's statically determinable call graph) as a constrained execution region (CER).</source>
          <target state="translated">Compiladores de usam esse método para preparar o método de invocação do delegado e preparar o destino dessa invocação (e o gráfico de chamada estaticamente determinável do representante) como uma região de execução restrita (CER).</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>Prepares a method for inclusion in a constrained execution region (CER).</source>
          <target state="translated">Prepara um método para inclusão em uma CER (região de execução restrita).</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>A handle to the method to prepare.</source>
          <target state="translated">Um identificador para o método a ser preparado.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>Prepares a method for inclusion in a constrained execution region (CER).</source>
          <target state="translated">Prepara um método para inclusão em uma CER (região de execução restrita).</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>Compilers use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29&gt;</ph> method to handle virtual calls that are made inside a constrained execution region (CER).</source>
          <target state="translated">Compiladores usam o <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29&gt;</ph> método para lidar com chamadas virtuais que são feitas dentro de uma região de execução restrita (CER).</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>At JIT compilation time, the common language runtime does not usually have enough information about the target of a virtual call.</source>
          <target state="translated">Em tempo de compilação JIT, o common language runtime geralmente não ter informações suficientes sobre o destino de uma chamada virtual.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>Therefore, the runtime does not initially prepare that segment of the call graph.</source>
          <target state="translated">Portanto, o tempo de execução não inicialmente preparar o segmento do gráfico de chamada.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>If the code that is using the CER has enough knowledge to determine the target at any point in time before the CER is actually entered, it can call <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29&gt;</ph> to perform the same runtime preparation normally done for a CER rooted at the method specified as an argument.</source>
          <target state="translated">Se o código que está usando a CER tem conhecimento suficiente determinar o destino em qualquer ponto no tempo antes do CER é efetivamente inserida, ele pode chamar <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29&gt;</ph> para realizar a preparação do tempo de execução mesmo normalmente é feita para a raiz de uma CER o método especificado como um argumento.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>A handle to the method to prepare.</source>
          <target state="translated">Um identificador para o método a ser preparado.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>The instantiation to pass to the method.</source>
          <target state="translated">A instanciação a ser passada para o método.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>Prepares a method for inclusion in a constrained execution region (CER) with the specified instantiation.</source>
          <target state="translated">Prepara um método para inclusão em uma CER (região de execução restrita) com a instanciação especificada.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>You can provide generics support for compilers by using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Você pode fornecer suporte a genéricos compiladores usando o <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>The common language runtime cannot prepare constrained execution regions (CERs) rooted in a method that has generic type parameters (either a type parameter on the class containing the method or one on the method itself) when those type parameters are instantiated as reference types.</source>
          <target state="translated">O common language runtime não é possível preparar as regiões de execução restrita (CERs) com raiz em um método que tem parâmetros de tipo genérico (um parâmetro de tipo na classe que contém o método ou um em que o próprio método) quando os parâmetros de tipo são instanciados como tipos de referência.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>You can use this overload to pass a specific instantiation (such as an array of types), specifying class type parameters first (if any), followed by method type parameters (if any).</source>
          <target state="translated">Você pode usar essa sobrecarga para passar uma instanciação específica (como uma matriz de tipos), especificando os parâmetros de tipo de classe primeiro (se houver), seguido pelos parâmetros de tipo de método (se houver).</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>The runtime prepares that instantiation of the method.</source>
          <target state="translated">O tempo de execução prepara essa instanciação do método.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>(This is necessary only if the instantiations you use contain at least one reference type parameter.) Thus, you can use a CER-style <ph id="ph1">`try`</ph> clause in a generic method (or a nongeneric method on a generic class) and it will work reliably with instantiations of <ph id="ph2">&lt;xref:System.Int32&gt;</ph> or other value types.</source>
          <target state="translated">(Isso é necessário apenas se a instâncias que você usar contém pelo menos um parâmetro de tipo de referência.) Assim, você pode usar um estilo de CER <ph id="ph1">`try`</ph> cláusula em um método genérico (ou um método não genérico em uma classe genérica) e ele funcionam de forma confiável com instanciações de <ph id="ph2">&lt;xref:System.Int32&gt;</ph> ou outros tipos de valor.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>To instantiate reference types such as <ph id="ph1">&lt;xref:System.String&gt;</ph>, you must use an explicit <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29&gt;</ph> method on the CER root method first.</source>
          <target state="translated">Para criar uma instância de referência de tipos, como <ph id="ph1">&lt;xref:System.String&gt;</ph>, você deve usar uma explícita <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29&gt;</ph> método no CER raiz método primeiro.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>Probes for a certain amount of stack space to ensure that a stack overflow cannot happen within a subsequent block of code (assuming that your code uses only a finite and moderate amount of stack space).</source>
          <target state="translated">Investiga uma determina quantidade de espaço de pilha para garantir que um estouro de pilha não possa acontecer dentro de um bloco de código subsequente (supondo que seu código usa apenas uma quantidade finita e moderada de espaço de pilha).</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>We recommend that you use a constrained execution region (CER) instead of this method.</source>
          <target state="translated">Recomendamos que você use uma CER (região de execução restrita) em vez desse método.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>This method is used by the constrained execution region (CER) infrastructure when running in hosts that are resilient to stack overflow such as Microsoft SQL Server and Microsoft Exchange Server.</source>
          <target state="translated">Esse método é usado pela infraestrutura de região (CER) de execução restrita quando em execução em hosts que são resistentes a estouro de pilha, como Microsoft SQL Server e Microsoft Exchange Server.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>This method currently probes for 48 KB of stack space on the x86 platform, but the exact amount may change over time and may vary on other platforms.</source>
          <target state="translated">Este método atualmente sondas de 48 KB de espaço de pilha em x86 plataforma, mas o valor exato pode ser alterado ao longo do tempo e pode variar em outras plataformas.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>This method is also used by compilers.</source>
          <target state="translated">Esse método também é usado por compiladores.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>Instead of using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A&gt;</ph> method, you should use a standard CER.</source>
          <target state="translated">Em vez de usar o <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A&gt;</ph> método, você deve usar uma CER padrão.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>That is, if you are planning to use a moderate amount of stack space, call the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType&gt;</ph> method immediately before your <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`finally`</ph> or <ph id="ph5">`try`</ph><ph id="ph6">/</ph><ph id="ph7">`catch`</ph> block.</source>
          <target state="translated">Ou seja, se você estiver planejando usar uma quantidade moderada de espaço de pilha, chame o <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType&gt;</ph> método imediatamente antes de sua <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`finally`</ph> ou <ph id="ph5">`try`</ph> <ph id="ph6">/</ph> <ph id="ph7">`catch`</ph> bloco.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>If you are calling a recursive method or plan to use a lot of stack space, you must use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Se você estiver chamando um método recursivo ou planeja usar muito espaço de pilha, você deve usar o <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)">
          <source>A type handle that specifies the class constructor method to run.</source>
          <target state="translated">Um identificador de tipo que especifica o método de construtor de classe a ser executado.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)">
          <source>Runs a specified class constructor method.</source>
          <target state="translated">Executa um método de construtor da classe especificado.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)">
          <source>This method is used by compilers.</source>
          <target state="translated">Esse método é usado por compiladores.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)">
          <source>The class initializer throws an exception.</source>
          <target state="translated">O inicializador de classe lança uma exceção.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)">
          <source>A handle that specifies the module constructor method to run.</source>
          <target state="translated">Um identificador que especifica o método do construtor de módulo a ser executado.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)">
          <source>Runs a specified module constructor method.</source>
          <target state="translated">Executa um método de construtor de módulo especificado.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)">
          <source>This method is used by compilers.</source>
          <target state="translated">Esse método é usado por compiladores.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)">
          <source>The module constructor throws an exception.</source>
          <target state="translated">O construtor de módulo gera uma exceção.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>