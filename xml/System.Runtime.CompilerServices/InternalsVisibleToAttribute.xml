<Type Name="InternalsVisibleToAttribute" FullName="System.Runtime.CompilerServices.InternalsVisibleToAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="72f45e174f70fa5053339a1308aae4feae8b8626" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30479970" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class InternalsVisibleToAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit InternalsVisibleToAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class InternalsVisibleToAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class InternalsVisibleToAttribute sealed : Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Assembly, AllowMultiple=true, Inherited=false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Especifica que os tipos que são normalmente visíveis somente dentro do assembly atual são visíveis para um assembly específico.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em geral, tipos e membros com `internal` escopo (em c#) e `friend` escopo (no Visual Basic) são visíveis somente no assembly no qual eles são definidos. O <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> atributo torna também visível para os tipos em um conjunto especificado, o que é conhecido como um assembly autorizado.  
  
 O atributo é aplicado no nível de assembly. Isso significa que pode ser incluída no início de um arquivo de código fonte, ou ele pode ser incluído no arquivo AssemblyInfo em um projeto do Visual Studio. Você pode usar o atributo para especificar um assembly friend único que pode acessar os tipos internos e membros do assembly atual. Você pode definir vários assemblies amigáveis de duas maneiras. Eles podem aparecer como atributos de nível de assembly individuais, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Runtime.CompilerServices.InternalsVisibleToAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.internalsvisibletoattribute/cs/multiple1.cs#3)]
 [!code-vb[System.Runtime.CompilerServices.InternalsVisibleToAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.internalsvisibletoattribute/vb/multiple1.vb#3)]  
  
 Eles também podem aparecer com separado <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> marcas, mas uma única `assembly` palavra-chave, como o exemplo a seguir ilustra.  
  
 [!code-csharp[System.Runtime.CompilerServices.InternalsVisibleToAttribute#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.internalsvisibletoattribute/cs/multiple2.cs#4)]
 [!code-vb[System.Runtime.CompilerServices.InternalsVisibleToAttribute#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.internalsvisibletoattribute/vb/multiple2.vb#4)]  
  
 O assembly friend é identificado pelo <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute.%23ctor%2A> construtor. O assembly atual e o assembly friend devem ser não assinados ou ambos os assemblies devem ser assinados com um nome forte.  
  
 Se os dois assemblies forem assinados, o `assemblyName` argumento consiste no nome do assembly friend, especificado sem uma extensão de nome de arquivo ou caminho do diretório.  
  
 Se os dois assemblies assinados com uma forte nome, o argumento para o <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute.%23ctor%2A> construtor deve conter o nome do assembly sem seu diretório caminho ou arquivo de extensão de nome, junto com a chave pública completa (e não seu token de chave pública). Para obter a chave pública completa de um assembly de nome forte, consulte o [obter a chave pública completa](#Key) seção mais adiante neste artigo. Para obter mais informações sobre como usar <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> com assemblies de nomes fortes, consulte o <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute.%23ctor%2A> construtor.  
  
 Não inclua valores para o <xref:System.Reflection.AssemblyName.CultureInfo%2A>, <xref:System.Reflection.AssemblyName.Version%2A>, ou <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A> campo no argumento; os compiladores do Visual Basic, C++ e c# tratam-o como um erro do compilador. Se você usar um compilador que não tratá-lo como um erro (como o [IL Assembler (ILAsm.exe)](~/docs/framework/tools/ilasm-exe-il-assembler.md)) e os assemblies de nome forte, um <xref:System.MethodAccessException> exceção será lançada na primeira vez que o assembly friend especificado acessa o assembly que contém o <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> atributo.  
  
 Para obter mais informações sobre como usar esse atributo, consulte os tópicos a seguir:  
  
-   [Assemblies amigáveis (C++)](http://msdn.microsoft.com/library/8d55fee0-b7c2-4fbe-a23b-dfe424dc71cd)  
  
-   [Assemblies Amigáveis](http://msdn.microsoft.com/library/df0c70ea-2c2a-4bdc-9526-df951ad2d055)  
  
<a name="Key"></a>   
## <a name="getting-the-full-public-key"></a>Obter a chave pública completa  
 Você pode usar o [ferramenta de nome forte (Sn.exe)](~/docs/framework/tools/sn-exe-strong-name-tool.md) para recuperar a chave pública completa de um arquivo de chave de nome forte (. snk). Para fazer isso, você deve executar as seguintes etapas:  
  
1.  Extrai a chave pública de nome forte do arquivo de chave para um arquivo separado:  
  
     **Sn -p**  *snk_file* *outfile*  
  
2.  Exiba a chave pública completa para o console:  
  
     **Sn -tp**  *outfile*  
  
3.  Copie e cole o valor da chave público completa em seu código-fonte.  
  
## <a name="compiling-the-friend-assembly-with-c"></a>Compilando o assembly friend com c#  
 Se você usar o compilador c# para compilar o assembly friend, você deve especificar explicitamente o nome do arquivo de saída (.exe ou. dll) usando o **/out** opção de compilador. Isso é necessário porque o compilador ainda não gerou o nome do assembly que está compilando no momento em que ele está se associando às referências externas. O **/out** opção de compilador é opcional para o compilador do Visual Basic e correspondente **-out** ou **-o** opção de compilador não deve ser usada quando se estiver compilando assemblies amigáveis com o compilador F #.  
  
## <a name="compiling-the-friend-assembly-with-c"></a>Compilando o assembly friend com C++  
 No C++, para tornar os membros internos habilitados pelo <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> atributo acessível a um assembly friend, você deve usar o `as_friend` atributo na diretiva de C++. Para obter mais informações, consulte [Friend Assemblies (C++)](http://msdn.microsoft.com/library/8d55fee0-b7c2-4fbe-a23b-dfe424dc71cd).  
  
   
  
## Examples  
 **Assemblies assinados**  
  
 O exemplo a seguir usa o <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> atributo para fazer uma `internal` método chamado `AppendDirectorySeparator` em um assembly assinado visível para outro assembly assinado. Define uma `FileUtilities` classe que inclui interno `AppendDirectorySeparator` método. O <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> atributo é aplicado ao assembly que contém o `FileUtilities` classe. O atributo permite que um assembly chamado `Friend1` para acessar esse membro interno.  
  
 [!code-csharp[System.Runtime.CompilerServices.InternalsVisibleToAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.internalsvisibletoattribute/cs/assembly1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.InternalsVisibleToAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.internalsvisibletoattribute/vb/assembly1.vb#1)]  
  
 Se o exemplo a seguir é compilado em um assembly de nome forte chamado `Friend1`, o `Example.Main` método `Friend1` pode chamar com êxito o `FileUtilities.AppendDirectorySeparator` método, embora o método é interno para o `Assembly1` assembly. Observe que se você estiver compilando em c# na linha de comando, você deve usar o **/out** opção de compilador para garantir que o nome do assembly friend está disponível quando o compilador associa a referências externas.  
  
 [!code-cpp[System.Runtime.CompilerServices.InternalsVisibleToAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.compilerservices.internalsvisibletoattribute/cpp/friend1.cpp#2)]
 [!code-csharp[System.Runtime.CompilerServices.InternalsVisibleToAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.internalsvisibletoattribute/cs/friend1.cs#2)]
 [!code-vb[System.Runtime.CompilerServices.InternalsVisibleToAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.internalsvisibletoattribute/vb/friend1.vb#2)]  
  
 **Assemblies não assinados**  
  
 O exemplo a seguir usa o <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> atributo para fazer uma `internal` assembly não assinado de membro de um assembly sem sinal visível para outro. O atributo garante que o `internal` `StringLib.IsFirstLetterUpperCase` método em um assembly nomeado `UtilityLib` é visível ao código em um assembly nomeado `Friend2`.  Este é o código-fonte para UtilityLib.dll:  
  
 [!code-csharp[System.Runtime.CompilerServices.InternalsVisibleToAttribute#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.internalsvisibletoattribute/cs/utilitylib.cs#5)]
 [!code-vb[System.Runtime.CompilerServices.InternalsVisibleToAttribute#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.internalsvisibletoattribute/vb/utilitylib.vb#5)]  
  
 O exemplo a seguir fornece o código-fonte para o `Friend2` assembly. Observe que se você estiver compilando em c# na linha de comando, você deve usar o **/out** opção de compilador para garantir que o nome do assembly friend está disponível quando o compilador associa a referências externas.  
  
 [!code-cpp[System.Runtime.CompilerServices.InternalsVisibleToAttribute#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.compilerservices.internalsvisibletoattribute/cpp/friend2.cpp#6)]
 [!code-csharp[System.Runtime.CompilerServices.InternalsVisibleToAttribute#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.internalsvisibletoattribute/cs/friend2.cs#6)]
 [!code-vb[System.Runtime.CompilerServices.InternalsVisibleToAttribute#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.internalsvisibletoattribute/vb/friend2.vb#6)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InternalsVisibleToAttribute (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.InternalsVisibleToAttribute.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (assemblyName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InternalsVisibleToAttribute(System::String ^ assemblyName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">O nome de um assembly amigável.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> com o nome do assembly amigável especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute.%23ctor%2A> construtor define um conjunto de amigo, que é um assembly que tem acesso para os tipos internos e membros do assembly atual.  
  
 O assembly atual e o assembly friend devem ser não assinados ou ambas devem ser assinadas com um nome forte. (Para obter mais informações sobre assemblies de nomes fortes, consulte [Creating and Using Strong-Named Assemblies](~/docs/framework/app-domains/create-and-use-strong-named-assemblies.md).) Se ambos são assinadas, o `assemblyName` argumento consiste no nome do assembly friend, especificado sem uma extensão de arquivo ou caminho do diretório. Se ambos forem assinadas, `assemblyName` consiste no nome do assembly friend sem seu diretório caminho ou arquivo de extensão de nome, junto com sua chave pública completa (mas não seu token de chave pública). Os outros componentes de um nome forte, como aqueles que fornecem a cultura, versão ou informação de arquitetura de processador, não podem ser especificados o `assemblyName` argumento.  
  
> [!IMPORTANT]
>  Se você usar o compilador c# para compilar o assembly friend, você deve especificar explicitamente o nome do arquivo de saída (.exe ou. dll) usando o **/out** opção de compilador. Isso é necessário porque o compilador ainda não gerou o nome do assembly que está compilando no momento em que ele está se associando às referências externas. O **/out** opção de compilador é opcional para o compilador do Visual Basic e correspondente **-out** ou **-o** opção de compilador não deve ser usada quando se estiver compilando assemblies amigáveis com o compilador F #.  
  
 Você pode usar [Sn.exe (ferramenta de nome forte)](~/docs/framework/tools/sn-exe-strong-name-tool.md) para recuperar a chave pública completa de um arquivo de chave de nome forte (. snk). Para fazer isso, você deve executar as seguintes etapas:  
  
1.  Extrai a chave pública de nome forte do arquivo de chave para um arquivo separado:  
  
     **Sn -p**  *snk_file* *outfile*  
  
2.  Exiba a chave pública completa para o console:  
  
     **Sn -tp**  *outfile*  
  
3.  Copie e cole o valor da chave público completa em seu código-fonte.  
  
 Para obter mais informações sobre como usar o <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> de atributo, consulte os tópicos a seguir:  
  
-   [Assemblies amigáveis (C++)](http://msdn.microsoft.com/library/8d55fee0-b7c2-4fbe-a23b-dfe424dc71cd)  
  
-   [Assemblies Amigáveis](http://msdn.microsoft.com/library/df0c70ea-2c2a-4bdc-9526-df951ad2d055)  
  
   
  
## Examples  
 **Assemblies assinados**  
  
 O exemplo a seguir usa o <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> atributo para fazer uma `internal` método chamado `AppendDirectorySeparator` em um assembly assinado visível para outro assembly assinado. Define uma `FileUtilities` classe que inclui interno `AppendDirectorySeparator` método. O <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> atributo é aplicado ao assembly que contém o `FileUtilities` classe. O atributo permite que um assembly chamado `Friend1` para acessar esse membro interno.  
  
 [!code-csharp[System.Runtime.CompilerServices.InternalsVisibleToAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.internalsvisibletoattribute/cs/assembly1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.InternalsVisibleToAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.internalsvisibletoattribute/vb/assembly1.vb#1)]  
  
 Se o exemplo a seguir é compilado em um assembly de nome forte chamado `Friend1`, ele pode chamar com êxito o `FileUtilities.AppendDirectorySeparator` método, mesmo que o método é interno a `Assembly1` assembly. Observe que se você estiver compilando em c# na linha de comando, você deve usar o **/out** opção de compilador para garantir que o nome do assembly friend está disponível quando o compilador associa a referências externas.  
  
 [!code-cpp[System.Runtime.CompilerServices.InternalsVisibleToAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.compilerservices.internalsvisibletoattribute/cpp/friend1.cpp#2)]
 [!code-csharp[System.Runtime.CompilerServices.InternalsVisibleToAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.internalsvisibletoattribute/cs/friend1.cs#2)]
 [!code-vb[System.Runtime.CompilerServices.InternalsVisibleToAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.internalsvisibletoattribute/vb/friend1.vb#2)]  
  
 O exemplo a seguir usa o <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> atributo para fazer uma `internal` assembly não assinado de membro de um assembly sem sinal visível para outro. O atributo garante que o `internal` `StringLib.IsFirstLetterUpperCase` método em um assembly nomeado `UtilityLib` é visível ao código em um assembly nomeado `Friend2`.  Este é o código-fonte para UtilityLib.dll:  
  
 [!code-csharp[System.Runtime.CompilerServices.InternalsVisibleToAttribute#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.internalsvisibletoattribute/cs/utilitylib.cs#5)]
 [!code-vb[System.Runtime.CompilerServices.InternalsVisibleToAttribute#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.internalsvisibletoattribute/vb/utilitylib.vb#5)]  
  
 **Assemblies não assinados**  
  
 O exemplo a seguir fornece o código-fonte para o `Friend2` assembly. Observe que se você estiver compilando em c# na linha de comando, você deve usar o **/out** opção de compilador para garantir que o nome do assembly friend está disponível quando o compilador associa a referências externas.  
  
 [!code-cpp[System.Runtime.CompilerServices.InternalsVisibleToAttribute#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.compilerservices.internalsvisibletoattribute/cpp/friend2.cpp#6)]
 [!code-csharp[System.Runtime.CompilerServices.InternalsVisibleToAttribute#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.internalsvisibletoattribute/cs/friend2.cs#6)]
 [!code-vb[System.Runtime.CompilerServices.InternalsVisibleToAttribute#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.internalsvisibletoattribute/vb/friend2.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllInternalsVisible">
      <MemberSignature Language="C#" Value="public bool AllInternalsVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllInternalsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.CompilerServices.InternalsVisibleToAttribute.AllInternalsVisible" />
      <MemberSignature Language="VB.NET" Value="Public Property AllInternalsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllInternalsVisible { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esta propriedade não é implementada.</summary>
        <value>Essa propriedade não retorna um valor.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyName">
      <MemberSignature Language="C#" Value="public string AssemblyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyName" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.CompilerServices.InternalsVisibleToAttribute.AssemblyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AssemblyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AssemblyName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome do assembly amigável para que todos os tipos e membros de tipo que são marcados com a palavra-chave <see langword="internal" /> tornem-se visíveis.</summary>
        <value>Uma cadeia de caracteres que representa o nome do assembly friend.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre como usar o <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> de atributo, consulte os tópicos a seguir:  
  
-   [Assemblies amigáveis (C++)](http://msdn.microsoft.com/library/8d55fee0-b7c2-4fbe-a23b-dfe424dc71cd)  
  
-   [Assemblies Amigáveis](http://msdn.microsoft.com/library/df0c70ea-2c2a-4bdc-9526-df951ad2d055)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>