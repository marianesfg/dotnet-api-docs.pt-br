<Type Name="MemoryCache" FullName="System.Runtime.Caching.MemoryCache">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4c6af75218569fa5ef3b2bc50fd52c286c6076c5" />
    <Meta Name="ms.sourcegitcommit" Value="723b8a6d92667ba86fcda96190bad3b4a03283b3" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="11/09/2018" />
    <Meta Name="ms.locfileid" Value="51311258" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MemoryCache : System.Runtime.Caching.ObjectCache, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MemoryCache extends System.Runtime.Caching.ObjectCache implements class System.Collections.IEnumerable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.MemoryCache" />
  <TypeSignature Language="VB.NET" Value="Public Class MemoryCache&#xA;Inherits ObjectCache&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryCache : System::Runtime::Caching::ObjectCache, IDisposable" />
  <TypeSignature Language="F#" Value="type MemoryCache = class&#xA;    inherit ObjectCache&#xA;    interface IEnumerable&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Runtime.Caching.ObjectCache</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa o tipo que implementa um cache na memória.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.Caching.MemoryCache> classe é uma implementação concreta do resumo <xref:System.Runtime.Caching.ObjectCache> classe.  
  
> [!NOTE]
>  O <xref:System.Runtime.Caching.MemoryCache> classe é semelhante ao ASP.NET <xref:System.Web.Caching.Cache> classe. O <xref:System.Runtime.Caching.MemoryCache> classe tem muitas propriedades e métodos para acessar o cache que serão familiar para você, se você tiver usado o ASP.NET <xref:System.Web.Caching.Cache> classe. As principais diferenças entre o <xref:System.Web.Caching.Cache> e <xref:System.Runtime.Caching.MemoryCache> classes são que o <xref:System.Runtime.Caching.MemoryCache> classe foi alterado para torná-lo utilizável por [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] aplicativos que não são aplicativos ASP.NET. Por exemplo, o <xref:System.Runtime.Caching.MemoryCache> classe não tem dependências no `System.Web` assembly. Outra diferença é que você pode criar várias instâncias de <xref:System.Runtime.Caching.MemoryCache> classe para uso no mesmo aplicativo e na mesma <xref:System.AppDomain> instância.  
  
 O <xref:System.Runtime.Caching.MemoryCache> não permite a classe `null` como um valor em cache. Qualquer tentativa de adicionar ou alterar uma entrada de cache com um valor de `null` falhará.  
  
 O <xref:System.Runtime.Caching.MemoryCache> o tipo não implementa *regiões de cache*. Portanto, quando você chama <xref:System.Runtime.Caching.MemoryCache> métodos que implementam os métodos básicos que contêm um parâmetro para as regiões, não passe um valor para o parâmetro. Os métodos que usam o parâmetro de região todos fornecem um padrão `null` valor. Por exemplo, o <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A?displayProperty=nameWithType> sobrecarga de método tem um `regionName` parâmetro cujo valor padrão é `null`.  
  
   
  
## Examples  
 O exemplo a seguir declara uma referência à instância padrão do cache de memória. A entrada de cache usa um <xref:System.Runtime.Caching.CacheItemPolicy> objeto para fornecer detalhes de remoção e expiração para a entrada de cache. Ele também usa um <xref:System.Runtime.Caching.ChangeMonitor> objeto para monitorar o estado da fonte de dados (que é um arquivo) no sistema de arquivos.  
  
```vb  
Private Sub btnGet_Click(ByVal sender As Object, ByVal e As EventArgs)   
    Dim cache As ObjectCache = MemoryCache.[Default]   
    Dim fileContents As String = TryCast(cache("filecontents"), String)   
  
    If fileContents Is Nothing Then   
        Dim policy As New CacheItemPolicy()   
        Dim filePaths As New List(Of String)()   
        filePaths.Add("c:\cache\example.txt")   
  
        policy.ChangeMonitors.Add(New HostFileChangeMonitor(filePaths))   
  
        ' Fetch the file contents.  
        fileContents = File.ReadAllText("c:\cache\example.txt")   
  
        cache.[Set]("filecontents", fileContents, policy)   
    End If   
  
    Label1.Text = fileContents  
End Sub  
```  
  
```csharp  
private void btnGet_Click(object sender, EventArgs e)  
{  
    ObjectCache cache = MemoryCache.Default;  
    string fileContents = cache["filecontents"] as string;  
  
    if (fileContents == null)  
    {  
        CacheItemPolicy policy = new CacheItemPolicy();  
  
        List<string> filePaths = new List<string>();  
        filePaths.Add("c:\\cache\\example.txt");  
  
        policy.ChangeMonitors.Add(new   
        HostFileChangeMonitor(filePaths));  
  
        // Fetch the file contents.  
        fileContents =   
            File.ReadAllText("c:\\cache\\example.txt");  
  
        cache.Set("filecontents", fileContents, policy);  
    }  
  
    Label1.Text = fileContents;  
}  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo é thread-safe.</threadsafe>
    <altmember cref="T:System.Runtime.Caching.ObjectCache" />
    <related type="Article" href="http://msdn.microsoft.com/library/942236f6-0138-4aaf-af71-a5ea451a1e23">Passo a passo: Armazenando dados de aplicativo no ASP.NET em cache.</related>
    <related type="Article" href="http://msdn.microsoft.com/library/c4b47ee0-4b82-4124-9bce-818088385e34">Armazenamento em cache em aplicativos do .NET Framework</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryCache (string name, System.Collections.Specialized.NameValueCollection config = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Collections.Specialized.NameValueCollection config) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.#ctor(System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, Optional config As NameValueCollection = null)" />
      <MemberSignature Language="F#" Value="new System.Runtime.Caching.MemoryCache : string * System.Collections.Specialized.NameValueCollection -&gt; System.Runtime.Caching.MemoryCache" Usage="new System.Runtime.Caching.MemoryCache (name, config)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="config" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="name">O nome a ser usado para pesquisar informações de configuração.  
  
 <c>Observação</c> Não é necessário que as informações de configuração existam para cada nome.  
  
Se houver uma entrada de configuração correspondente, as informações de configuração serão usadas para configurar a instância de <see cref="T:System.Runtime.Caching.MemoryCache" />. Se não existir uma entrada de configuração correspondente, o nome poderá ser acessado por meio da propriedade <see cref="P:System.Runtime.Caching.MemoryCache.Name" />, porque o nome especificado está associado à instância de <see cref="T:System.Runtime.Caching.MemoryCache" />. Para obter mais informações sobre a configuração de cache de memória, consulte <see cref="T:System.Runtime.Caching.Configuration.MemoryCacheElement" />.</param>
        <param name="config">Uma coleção de pares nome/valor das informações de configuração a serem usadas para configurar o cache.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Runtime.Caching.MemoryCache" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o <xref:System.Runtime.Caching.MemoryCache> classe é inicializada, ele verifica se há entradas de configuração que podem substituídas usando opcional `config` parâmetro no construtor. Você pode passar os seguintes parâmetros no `config` parâmetro. Todos os valores podem ser passados como inteiros.  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.CacheMemoryLimitMegabytes%2A>  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.PhysicalMemoryLimitPercentage%2A>  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.PollingInterval%2A>  
  
 Quando esse construtor é chamado, as definições de configuração pela primeira vez são recuperadas de arquivos de configuração do aplicativo. Se nenhuma entrada de configuração existir no arquivo de configuração do aplicativo, somente as configurações fornecidas no `config` são aplicadas. Se as entradas de configuração na configuração do aplicativo existem e se informações também são passadas em `config`, as informações a `config` substitui as informações que são lidos do arquivo de configuração.  
  
 O valor do nome que é atribuído a uma instância de cache é usado de duas maneiras:  
  
-   Para ajudá-lo a manter o controle de várias instâncias do cache quando houver mais de uma instância.  
  
-   Para fazer referência a configurações na configuração do arquivo quando o <xref:System.Runtime.Caching.MemoryCache> instância será inicializada.  
  
    > [!NOTE]
    >  Não há nenhum mecanismo para impor nomes exclusivos para as instâncias de cache. Portanto, é possível ter várias instâncias de cache com o mesmo nome.  
  
    > [!CAUTION]
    >  Não crie <xref:System.Runtime.Caching.MemoryCache> instâncias, a menos que seja necessário. Se você criar instâncias de cache no cliente e aplicativos Web, o <xref:System.Runtime.Caching.MemoryCache> instâncias devem ser criadas no início do ciclo de vida do aplicativo. Você deve criar somente o número de instâncias de cache que será usado em seu aplicativo e armazenam referências para as instâncias de cache em variáveis que podem ser acessadas globalmente. Por exemplo, em aplicativos ASP.NET, você pode armazenar as referências no estado do aplicativo. Se você criar apenas uma instância de cache único em seu aplicativo, use o cache padrão e obter uma referência a ele da <xref:System.Runtime.Caching.MemoryCache.Default%2A> propriedade quando precisar acessar o cache.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Um nome ou valor no parâmetro <paramref name="config" /> não pôde ser analisado.</exception>
        <exception cref="T:System.Configuration.ConfigurationException">Um valor da coleção <paramref name="config" /> é inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryCache (string name, System.Collections.Specialized.NameValueCollection config, bool ignoreConfigSection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Collections.Specialized.NameValueCollection config, bool ignoreConfigSection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.#ctor(System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, config As NameValueCollection, ignoreConfigSection As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryCache(System::String ^ name, System::Collections::Specialized::NameValueCollection ^ config, bool ignoreConfigSection);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Caching.MemoryCache : string * System.Collections.Specialized.NameValueCollection * bool -&gt; System.Runtime.Caching.MemoryCache" Usage="new System.Runtime.Caching.MemoryCache (name, config, ignoreConfigSection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="config" Type="System.Collections.Specialized.NameValueCollection" />
        <Parameter Name="ignoreConfigSection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">O nome a ser usado para pesquisar informações de configuração.</param>
        <param name="config">Uma coleção de pares nome/valor das informações de configuração a serem usadas para configurar o cache.</param>
        <param name="ignoreConfigSection">Indica se a seção de configuração deve ser ignorada.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Runtime.Caching.MemoryCache" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public override bool Add (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Add(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Add(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Add (item As CacheItem, policy As CacheItemPolicy) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Add(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="override this.Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool" Usage="memoryCache.Add (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a adicionar.</param>
        <param name="policy">Um objeto que contém os detalhes da remoção da entrada de cache. Esse objeto fornece mais opções de remoção do que uma expiração absoluta simples.</param>
        <summary>Insere uma entrada de cache no cache como uma instância <see cref="T:System.Runtime.Caching.CacheItem" /> e adiciona os detalhes sobre como a entrada deve ser removida.</summary>
        <returns>true se a inserção for bem-sucedida ou false se já houver uma entrada no cache com a mesma chave que o item.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  As sobrecargas do método <xref:System.Runtime.Caching.ObjectCache.Add%2A> e <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> não dão suporte à propriedade <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>. Portanto, para definir a propriedade <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> para uma entrada de cache, use as sobrecargas do método <xref:System.Runtime.Caching.MemoryCache.Set%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOrGetExisting">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Insere uma entrada de cache no cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A> sobrecargas de método são usadas para inserir uma entrada de cache no cache. Se não existir uma entrada de cache com uma chave correspondente, esses métodos de inserir uma nova entrada. Se já existir uma entrada de cache com uma chave correspondente, elas retornam a entrada existente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheItem AddOrGetExisting (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheItem AddOrGetExisting(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (item As CacheItem, policy As CacheItemPolicy) As CacheItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Runtime::Caching::CacheItem ^ AddOrGetExisting(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="override this.AddOrGetExisting : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; System.Runtime.Caching.CacheItem" Usage="memoryCache.AddOrGetExisting (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a adicionar.</param>
        <param name="policy">Um objeto que contém os detalhes da remoção da entrada de cache. Esse objeto fornece mais opções de remoção do que uma expiração absoluta simples.</param>
        <summary>Adiciona uma entrada de cache no cache usando a instância <see cref="T:System.Runtime.Caching.CacheItem" /> especificada e os detalhes sobre como remover a entrada.</summary>
        <returns>Se houver uma entrada de cache com a mesma chave, a entrada de cache existente; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `item` parâmetro fornece a chave e o valor que é usado pelo método. Se o cache tem uma entrada de cache com a mesma chave como chave do `item` parâmetro, o método retorna a entrada existente como um <xref:System.Runtime.Caching.CacheItem> instância. Se não houver nenhuma entrada de cache existente, o método cria uma nova usando a chave e o valor fornecido pelo `item` parâmetro e com os detalhes de remoção especificados pelo `policy`.  
  
> [!WARNING]
>  As sobrecargas do método <xref:System.Runtime.Caching.ObjectCache.Add%2A> e <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> não dão suporte à propriedade <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>. Portanto, para definir a propriedade <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> para uma entrada de cache, use as sobrecargas do método <xref:System.Runtime.Caching.MemoryCache.Set%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A propriedade <see cref="P:System.Runtime.Caching.CacheItem.Value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Os valores de expiração absoluta e deslizante para o objeto <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> são definidos como valores diferentes dos padrões dos campos <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> e <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. A classe <see cref="T:System.Runtime.Caching.MemoryCache" /> não pode definir a política de expiração com base em uma combinação de uma expiração absoluta e uma expiração deslizante. Somente uma configuração de expiração pode ser definida explicitamente quando você usa a instância <see cref="T:System.Runtime.Caching.MemoryCache" />. A outra configuração de expiração deve ser definida como o campo <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> ou o <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A propriedade <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> é definida com um valor menor que <see cref="F:System.TimeSpan.Zero" />.  
  
- ou - 
A propriedade <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> é definida com um valor maior que um ano.  
  
- ou - 
A propriedade <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> não é um valor da enumeração <see cref="T:System.Runtime.Caching.CacheItemPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override object AddOrGetExisting (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object AddOrGetExisting(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.AddOrGetExisting : string * obj * DateTimeOffset * string -&gt; obj" Usage="memoryCache.AddOrGetExisting (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Um identificador exclusivo para a entrada de cache a ser adicionada.</param>
        <param name="value">Os dados de entrada de cache.</param>
        <param name="absoluteExpiration">A data e a hora fixas em que a entrada de cache vai expirar.</param>
        <param name="regionName">Uma região nomeada no cache à qual uma entrada de cache pode ser adicionada. Não passe um valor para esse parâmetro. Esse parâmetro é <see langword="null" /> por padrão, pois a classe <see cref="T:System.Runtime.Caching.MemoryCache" /> não implementa regiões.</param>
        <summary>Adiciona uma entrada de cache ao cache usando a chave especificada e um valor de expiração absoluta.</summary>
        <returns>Se houver uma entrada de cache com a mesma chave, a entrada de cache existente; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o cache não tiver uma entrada de cache cuja chave corresponde a `key` parâmetro, uma nova entrada de cache é criada e o <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A?displayProperty=nameWithType> sobrecarga de método retorna `null`. Se houver uma entrada de cache correspondente, a entrada existente será retornada.  
  
> [!WARNING]
>  As sobrecargas do método <xref:System.Runtime.Caching.ObjectCache.Add%2A> e <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> não dão suporte à propriedade <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>. Portanto, para definir a propriedade <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> para uma entrada de cache, use as sobrecargas do método <xref:System.Runtime.Caching.MemoryCache.Set%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> não é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> não é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Os valores de expiração absoluta e deslizante para o objeto <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> são definidos como valores diferentes dos padrões dos campos <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> e <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. A classe <see cref="T:System.Runtime.Caching.MemoryCache" /> não pode definir a política de expiração com base em uma combinação de uma expiração absoluta e uma expiração deslizante. Somente uma configuração de expiração pode ser definida explicitamente quando você usa a instância <see cref="T:System.Runtime.Caching.MemoryCache" />. A outra configuração de expiração deve ser definida como <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> ou <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A propriedade <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> é definida com um valor menor que <see cref="F:System.TimeSpan.Zero" />.  
  
- ou - 
A propriedade <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> é definida com um valor maior que um ano.  
  
- ou - 
A propriedade <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> não é um valor da enumeração <see cref="T:System.Runtime.Caching.CacheItemPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override object AddOrGetExisting (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object AddOrGetExisting(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.AddOrGetExisting : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; obj" Usage="memoryCache.AddOrGetExisting (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Um identificador exclusivo da entrada de cache a ser adicionada ou obtida.</param>
        <param name="value">Os dados de entrada de cache.</param>
        <param name="policy">Um objeto que contém os detalhes da remoção da entrada de cache. Esse objeto fornece mais opções de remoção do que uma expiração absoluta simples.</param>
        <param name="regionName">Uma região nomeada no cache à qual uma entrada de cache pode ser adicionada. Não passe um valor para esse parâmetro. Por padrão, esse parâmetro é <see langword="null" />, pois a classe <see cref="T:System.Runtime.Caching.MemoryCache" /> não implementa regiões.</param>
        <summary>Insere uma entrada de cache no cache usando a chave e o valor especificados, bem como os detalhes especificados para sua remoção.</summary>
        <returns>Se uma entrada de cache correspondente já existir, uma entrada de cache; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  As sobrecargas do método <xref:System.Runtime.Caching.ObjectCache.Add%2A> e <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> não dão suporte à propriedade <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>. Portanto, para definir a propriedade <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> para uma entrada de cache, use as sobrecargas do método <xref:System.Runtime.Caching.MemoryCache.Set%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Os valores de expiração absoluta e deslizante para o objeto <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> são definidos como valores diferentes dos padrões de <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> e <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. A classe <see cref="T:System.Runtime.Caching.MemoryCache" /> não pode definir a política de expiração com base em uma combinação de uma expiração absoluta e uma expiração deslizante. Somente uma configuração de expiração pode ser definida explicitamente quando você usa a classe <see cref="T:System.Runtime.Caching.MemoryCache" />. A outra configuração deve ser definida como <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> ou <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.  
  
- ou - 
O retorno de chamada de remoção e o retorno de chamada de atualização foram especificados para <see cref="T:System.Runtime.Caching.CacheItemPolicy" />. O <see cref="T:System.Runtime.Caching.MemoryCache" /> dá suporte apenas ao uso de um tipo de retorno de chamada por entrada de cache.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A propriedade <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> é definida com um valor menor que <see cref="F:System.TimeSpan.Zero" />.  
  
- ou - 
O <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> foi definido como um valor maior que um ano.  
  
- ou - 
A propriedade <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> não é um valor da enumeração <see cref="T:System.Runtime.Caching.CacheItemPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CacheMemoryLimit">
      <MemberSignature Language="C#" Value="public long CacheMemoryLimit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 CacheMemoryLimit" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.CacheMemoryLimit" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CacheMemoryLimit As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long CacheMemoryLimit { long get(); };" />
      <MemberSignature Language="F#" Value="member this.CacheMemoryLimit : int64" Usage="System.Runtime.Caching.MemoryCache.CacheMemoryLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade de memória no computador, em bytes, que pode ser usada pelo cache.</summary>
        <value>A quantidade de memória em bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a instância atual do cache excede o limite de memória definido pelo <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> propriedade, a implementação de cache remove entradas de cache. Cada instância de cache no aplicativo pode usar a quantidade de memória que é especificada pelo <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> propriedade.  
  
 As configurações para o <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> propriedade pode ser especificada no arquivo de configuração do aplicativo. Como alternativa, pode ser passados no construtor quando o <xref:System.Runtime.Caching.MemoryCache> classe é inicializada. Para obter mais informações sobre como configurar essa propriedade, consulte [ &lt;namedCaches&gt; (configurações de Cache)](~/docs/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings.md). Para obter mais informações sobre como definir esse valor quando o <xref:System.Runtime.Caching.MemoryCache> classe está sendo inicializado, consulte o <xref:System.Runtime.Caching.MemoryCache.%23ctor%2A> método.  
  
 <xref:System.Runtime.Caching.MemoryCache> não impõe instantaneamente <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> sempre que um novo item é adicionado a um <xref:System.Runtime.Caching.MemoryCache> instância. A heurística interna que remove itens extras do <xref:System.Runtime.Caching.MemoryCache> faz isso gradualmente e considera informações de conta do coletor de lixo (consulte [coleta de lixo](~/docs/standard/garbage-collection/index.md)) e outros fatores, como o tamanho do cache atual e pressão de memória do sistema geral. Portanto, mesmo que o <xref:System.Runtime.Caching.MemoryCache> tenta manter o tamanho do cache em configurado <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> é possível temporariamente exceda o limite adicionando itens de cache em uma taxa muito alta.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6bd4fbc5-55a6-4dc4-998b-cdcc7e023330">&lt;namedCaches&gt; (configurações de Cache)</related>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public override bool Contains (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Contains(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Contains(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Contains (key As String, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Contains : string * string -&gt; bool" Usage="memoryCache.Contains (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Um identificador exclusivo para a entrada de cache a ser pesquisada.</param>
        <param name="regionName">Uma região nomeada no cache à qual uma entrada de cache foi adicionada. Não passe um valor para esse parâmetro. Esse parâmetro é <see langword="null" /> por padrão, pois a classe <see cref="T:System.Runtime.Caching.MemoryCache" /> não implementa regiões.</param>
        <summary>Determina se existe uma entrada de cache no cache.</summary>
        <returns>
          <see langword="true" /> se o cache contém uma entrada de cache cuja chave corresponde a <paramref name="key" />; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> não é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateCacheEntryChangeMonitor">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateCacheEntryChangeMonitor (keys As IEnumerable(Of String), Optional regionName As String = null) As CacheEntryChangeMonitor" />
      <MemberSignature Language="F#" Value="override this.CreateCacheEntryChangeMonitor : seq&lt;string&gt; * string -&gt; System.Runtime.Caching.CacheEntryChangeMonitor" Usage="memoryCache.CreateCacheEntryChangeMonitor (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheEntryChangeMonitor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Uma enumeração de chaves de entrada de cache exclusivas para o objeto <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" />.</param>
        <param name="regionName">Uma região nomeada no cache à qual uma entrada de cache pode ser adicionada. Não passe um valor para esse parâmetro. Esse parâmetro é <see langword="null" /> por padrão, pois a classe <see cref="T:System.Runtime.Caching.MemoryCache" /> não implementa regiões.</param>
        <summary>Cria um objeto <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" /> que pode disparar eventos em resposta a alterações nas entradas de cache especificadas.</summary>
        <returns>Um monitor de alteração que monitora as entradas no cache.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor%2A> método cria um <xref:System.Runtime.Caching.CacheEntryChangeMonitor> instância. Esse monitor de alteração especializado é usado para monitorar as entradas de cache que são especificadas no `keys` coleção e para disparar eventos quando as entradas de alteração.  
  
 Uma entrada monitorada será considerada foram alterados para qualquer um dos seguintes motivos:  
  
-   A chave não existir no momento da chamada para o <xref:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor%2A> método. Nesse caso, resultante <xref:System.Runtime.Caching.CacheEntryChangeMonitor> instância imediatamente é definida como um estado alterado. Isso significa que, quando o código associa subsequentemente um retorno de chamada de notificação de alteração, o retorno de chamada é acionado imediatamente.  
  
-   A entrada de cache associado foi removida do cache. Isso pode ocorrer se a entrada for explicitamente removida, se ele expirar ou se ele for removido para recuperar memória  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> não é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Um item na coleção <paramref name="keys" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Runtime.Caching.MemoryCache Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Caching.MemoryCache Default" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As MemoryCache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Caching::MemoryCache ^ Default { System::Runtime::Caching::MemoryCache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Runtime.Caching.MemoryCache" Usage="System.Runtime.Caching.MemoryCache.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.MemoryCache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma referência para a instância <see cref="T:System.Runtime.Caching.MemoryCache" /> padrão.</summary>
        <value>A instância padrão do cache.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade sempre retorna uma referência à instância padrão do cache. Para cenários típicos de aplicativos, apenas uma instância de <xref:System.Runtime.Caching.MemoryCache> é necessária.  
  
 Como a instância de cache padrão não é criada pelo construtor, você deve usar a configuração para definir explicitamente a memória e os valores de sondagem para a instância de cache padrão. Para obter mais informações, consulte [ &lt;memoryCache&gt; (configurações de Cache)](~/docs/framework/configure-apps/file-schema/runtime/memorycache-element-cache-settings.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/182a622f-f7cf-472d-9d0b-451d2fd94525">&lt;memoryCache&gt; (configurações de Cache)</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultCacheCapabilities">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.DefaultCacheCapabilities" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DefaultCacheCapabilities As DefaultCacheCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::Caching::DefaultCacheCapabilities DefaultCacheCapabilities { System::Runtime::Caching::DefaultCacheCapabilities get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCacheCapabilities : System.Runtime.Caching.DefaultCacheCapabilities" Usage="System.Runtime.Caching.MemoryCache.DefaultCacheCapabilities" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.DefaultCacheCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma descrição dos recursos que o cache fornece.</summary>
        <value>Uma combinação bit a bit dos sinalizadores que indica as funcionalidades padrão da implementação de cache.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os recursos de uma implementação de cache são uma combinação dos seguintes valores:  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.InMemoryProvider>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryChangeMonitors>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.AbsoluteExpirations>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.SlidingExpirations>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryUpdateCallback>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryRemovedCallback>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="memoryCache.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Runtime.Caching.MemoryCache" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada <xref:System.Runtime.Caching.MemoryCache> instância está associada a <xref:System.Web.Compilation.ClientBuildManager.AppDomainUnloaded> eventos. No entanto, durante o desligamento do domínio de aplicativo, se um cache baseado em memória não foi descartado explicitamente, a instância do cache automaticamente chamará o <xref:System.Runtime.Caching.MemoryCache.Dispose%2A> método.  
  
 A instância de cache descartado é desligada usando as seguintes etapas:  
  
1.  O estado do cache é definido para indicar que o cache é descartado. Qualquer tentativa para chamar público cache de métodos que alteram o estado do cache, como os métodos que adicionar, remover ou recuperar entradas de cache, pode causar um comportamento inesperado. Por exemplo, se você chamar o <xref:System.Runtime.Caching.MemoryCache.Set%2A> método depois que o cache é descartado, um erro sem op ocorre. Se você tentar se recuperar itens do cache, o <xref:System.Runtime.Caching.MemoryCache.Get%2A> método sempre retornará `null`.  
  
2.  Informações do contador de desempenho não são geradas da instância do cache atual.  
  
3.  Todas as referências a objetos em cache mantidos pela instância atual do cache são liberadas.  
  
4.  Qualquer <xref:System.Runtime.Caching.CacheEntryChangeMonitor> instâncias que estão monitorando no momento entradas no cache serão notificadas.  
  
5.  Objetos de retorno de chamada que fornecem notificação de alterações para esses monitores são chamados.  
  
6.  Qualquer <xref:System.Web.Caching.CacheItemRemovedCallback> são chamadas de instâncias que estão registradas com entradas no cache. A razão de remoção que é passada para os retornos de chamada é <xref:System.Runtime.Caching.CacheEntryRemovedReason.CacheSpecificEviction>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public override object Get (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Get(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Get(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Get (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.Get : string * string -&gt; obj" Usage="memoryCache.Get (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Um identificador exclusivo para a entrada de cache a ser obtida.</param>
        <param name="regionName">Uma região nomeada no cache à qual uma entrada de cache foi adicionada. Não passe um valor para esse parâmetro. Esse parâmetro é <see langword="null" /> por padrão, pois a classe <see cref="T:System.Runtime.Caching.MemoryCache" /> não implementa regiões.</param>
        <summary>Retorna uma entrada do cache.</summary>
        <returns>Uma referência para a entrada de cache identificada por <paramref name="key" /> se a entrada existir; caso contrário, <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> não é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCacheItem">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheItem GetCacheItem (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheItem GetCacheItem(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCacheItem (key As String, Optional regionName As String = null) As CacheItem" />
      <MemberSignature Language="F#" Value="override this.GetCacheItem : string * string -&gt; System.Runtime.Caching.CacheItem" Usage="memoryCache.GetCacheItem (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Um identificador exclusivo para a entrada de cache a ser obtida.</param>
        <param name="regionName">Uma região nomeada no cache à qual uma entrada de cache foi adicionada. Não passe um valor para esse parâmetro. Esse parâmetro é <see langword="null" /> por padrão, pois a classe <see cref="T:System.Runtime.Caching.MemoryCache" /> não implementa regiões.</param>
        <summary>Retorna a entrada especificada do cache como uma instância <see cref="T:System.Runtime.Caching.CacheItem" />.</summary>
        <returns>Uma referência para a entrada de cache identificada por <paramref name="key" /> se a entrada existir; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a entrada de cache especificado por `key` existe no cache, o <xref:System.Runtime.Caching.MemoryCache.GetCacheItem%2A> método retorna-o como um <xref:System.Runtime.Caching.CacheItem> instância. O <xref:System.Runtime.Caching.CacheItem.Key%2A> e <xref:System.Runtime.Caching.CacheItem.Value%2A> propriedades do <xref:System.Runtime.Caching.CacheItem> instância será definida. No entanto, o <xref:System.Runtime.Caching.CacheItem.RegionName%2A> propriedade será `null`, porque regiões não são implementadas no <xref:System.Runtime.Caching.MemoryCache> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> não é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCount">
      <MemberSignature Language="C#" Value="public override long GetCount (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetCount(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCount (Optional regionName As String = null) As Long" />
      <MemberSignature Language="F#" Value="override this.GetCount : string -&gt; int64" Usage="memoryCache.GetCount regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">Uma região nomeada no cache à qual uma entrada de cache foi adicionada. Não passe um valor para esse parâmetro. Esse parâmetro é <see langword="null" /> por padrão, pois a classe <see cref="T:System.Runtime.Caching.MemoryCache" /> não implementa regiões.</param>
        <summary>Retorna o número total de entradas de cache no cache.</summary>
        <returns>O número de entradas no cache.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> não é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected override System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="override this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt;" Usage="memoryCache.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um enumerador que pode ser usado para iterar entre uma coleção de entradas de cache.</summary>
        <returns>O objeto enumerador que fornece acesso aos itens no cache.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O que é retornado pelo enumerador o <xref:System.Runtime.Caching.MemoryCache.GetEnumerator%2A> método pode ser usado para iterar sobre entradas no cache.  
  
> [!IMPORTANT]
>  Recuperando um enumerador para um <xref:System.Runtime.Caching.MemoryCache> instância é uma operação de bloqueio e de uso intensivo de recursos. Portanto, o enumerador não deve ser usado em aplicativos de produção.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLastSize">
      <MemberSignature Language="C#" Value="public long GetLastSize (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLastSize(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetLastSize(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastSize (Optional regionName As String = null) As Long" />
      <MemberSignature Language="F#" Value="member this.GetLastSize : string -&gt; int64" Usage="memoryCache.GetLastSize regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">O nome da região.</param>
        <summary>Obtém o tamanho da região nomeada.</summary>
        <returns>O tamanho da região nomeada.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetValues(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetValues (keys As IEnumerable(Of String), Optional regionName As String = null) As IDictionary(Of String, Object)" />
      <MemberSignature Language="F#" Value="override this.GetValues : seq&lt;string&gt; * string -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="memoryCache.GetValues (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Um conjunto de identificadores exclusivos a serem retornados pelas entradas de cache.</param>
        <param name="regionName">Uma região nomeada no cache à qual uma entrada de cache foi adicionada. Não passe um valor para esse parâmetro. Esse parâmetro é <see langword="null" /> por padrão, pois a classe <see cref="T:System.Runtime.Caching.MemoryCache" /> não implementa regiões.</param>
        <summary>Retorna um conjunto de entradas de cache que correspondem às chaves especificadas.</summary>
        <returns>Um conjunto de entradas de cache que correspondem às chaves especificadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se uma entrada de cache que é representada pela `keys` não existir, o valor correspondente para o objeto retornado no dicionário é definido como `null`. Portanto, o dicionário retornado sempre tem o mesmo número de itens que o número de elementos em `keys`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> não é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Uma chave individual na coleção é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides Property Item(key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ key); void set(System::String ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj with get, set" Usage="System.Runtime.Caching.MemoryCache.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Um identificador exclusivo para o valor de cache a ser obtido ou definido.</param>
        <summary>Obtém ou define um valor em cache usando a propriedade indexadora padrão para uma instância da classe <see cref="T:System.Runtime.Caching.MemoryCache" />.</summary>
        <value>O valor na instância de cache para a chave especificada, se a entrada existir. Caso contrário, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você definir essa propriedade, o valor é inserido no cache. A política de expiração para a entrada de cache é definida como <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration>. Se já existir uma entrada de cache com uma chave correspondente, seu valor é atualizado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> é <see langword="null" />.  
  
- ou - 
O valor inserido é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.Caching.MemoryCache.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome do cache.</summary>
        <value>O nome do cache.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.Caching.MemoryCache.Name%2A> propriedade retorna o nome da instância atual do <xref:System.Runtime.Caching.MemoryCache> classe. Em um aplicativo que usa várias instâncias de cache, você pode usar o <xref:System.Runtime.Caching.MemoryCache.Name%2A> propriedade para ajudar a distinguir as instâncias. Para obter mais informações, consulte o método <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType>. O cache de memória com base no padrão retorna o nome padrão.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicalMemoryLimit">
      <MemberSignature Language="C#" Value="public long PhysicalMemoryLimit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PhysicalMemoryLimit" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalMemoryLimit As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PhysicalMemoryLimit { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PhysicalMemoryLimit : int64" Usage="System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o percentual de memória física que o cache pode usar.</summary>
        <value>O percentual de memória física que o cache pode usar.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit%2A> propriedade retorna a porcentagem de memória total do computador físico que pode ser usada por uma única instância da <xref:System.Runtime.Caching.MemoryCache> classe. Se a instância do cache excede o limite especificado, as entradas de cache são removidas.  
  
 As configurações para o <xref:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit%2A> propriedade pode ser especificada no arquivo de configuração do aplicativo. Como alternativa, eles podem ser passados por um chamador quando a <xref:System.Runtime.Caching.MemoryCache> classe é inicializada. Para obter mais informações sobre como configurar essa propriedade, consulte [ &lt;namedCaches&gt; (configurações de Cache)](~/docs/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings.md). Para obter mais informações sobre como configurar a propriedade quando o <xref:System.Runtime.Caching.MemoryCache> classe está sendo inicializado, consulte o <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6bd4fbc5-55a6-4dc4-998b-cdcc7e023330">&lt;namedCaches&gt; (configurações de Cache)</related>
      </Docs>
    </Member>
    <Member MemberName="PollingInterval">
      <MemberSignature Language="C#" Value="public TimeSpan PollingInterval { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PollingInterval" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.PollingInterval" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PollingInterval As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PollingInterval { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PollingInterval : TimeSpan" Usage="System.Runtime.Caching.MemoryCache.PollingInterval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tempo máximo após o qual o cache atualiza suas estatísticas de memória.</summary>
        <value>O tempo máximo que pode transcorrer antes que as estatísticas de memória sejam atualizadas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As configurações para o <xref:System.Runtime.Caching.MemoryCache.PollingInterval%2A> propriedade pode ser especificada no arquivo de configuração do aplicativo. Como alternativa, eles podem ser passados quando o <xref:System.Runtime.Caching.MemoryCache> classe é inicializada. Para obter mais informações sobre como configurar essa propriedade, consulte [ &lt;namedCaches&gt; (configurações de Cache)](~/docs/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings.md). Para obter mais informações sobre como configurar a propriedade quando o <xref:System.Runtime.Caching.MemoryCache> classe está sendo inicializado, consulte o <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6bd4fbc5-55a6-4dc4-998b-cdcc7e023330">&lt;namedCaches&gt; (configurações de Cache)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Remove o item especificado do cache.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public override object Remove (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Remove(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Remove (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.Remove : string * string -&gt; obj" Usage="memoryCache.Remove (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Um identificador exclusivo para a entrada de cache a ser removida.</param>
        <param name="regionName">Uma região nomeada no cache à qual uma entrada de cache foi adicionada. Não passe um valor para esse parâmetro. Esse parâmetro é <see langword="null" /> por padrão, pois a classe <see cref="T:System.Runtime.Caching.MemoryCache" /> não implementa regiões.</param>
        <summary>Remove uma entrada de cache do cache.</summary>
        <returns>Se a entrada for encontrada no cache, a entrada de cache removida; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a entrada especificada por `key` existe no cache, removendo os gatilhos de item qualquer monitores de alteração associada. Se o item removido está associado com um <xref:System.Web.Caching.CacheItemUpdateCallback> objeto ou uma <xref:System.Web.Caching.CacheItemRemovedCallback> do objeto, o motivo passado para o retorno de chamada é <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> não é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public object Remove (string key, System.Runtime.Caching.CacheEntryRemovedReason reason, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Remove(string key, valuetype System.Runtime.Caching.CacheEntryRemovedReason reason, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Remove(System.String,System.Runtime.Caching.CacheEntryRemovedReason,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As String, reason As CacheEntryRemovedReason, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.Remove : string * System.Runtime.Caching.CacheEntryRemovedReason * string -&gt; obj" Usage="memoryCache.Remove (key, reason, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="reason" Type="System.Runtime.Caching.CacheEntryRemovedReason" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Um identificador exclusivo para a entrada de cache a ser removida.</param>
        <param name="reason">O motivo pelo qual o item foi removido.</param>
        <param name="regionName">Uma região nomeada no cache à qual uma entrada de cache foi adicionada. Não passe um valor para esse parâmetro. Esse parâmetro é <see langword="null" /> por padrão, pois a classe <see cref="T:System.Runtime.Caching.MemoryCache" /> não implementa regiões.</param>
        <summary>Remove uma entrada de cache do cache usando o motivo.</summary>
        <returns>Se a entrada for encontrada no cache, a entrada de cache removida; caso contrário, <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Insere uma entrada de cache no cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a entrada especificada não existir, ele é criado. Se a entrada especificada existe, ele será atualizado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (item As CacheItem, policy As CacheItemPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Set(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="override this.Set : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; unit" Usage="memoryCache.Set (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Um objeto que representa uma entrada de cache a ser inserido.</param>
        <param name="policy">Um objeto que contém os detalhes da remoção da entrada de cache. Esse objeto fornece mais opções de remoção do que uma expiração absoluta simples.</param>
        <summary>Insere uma entrada de cache no cache usando uma instância <see cref="T:System.Runtime.Caching.CacheItem" /> para fornecer a chave e valor para a entrada de cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Como qualquer outro <xref:System.Runtime.Caching.MemoryCache.Set%2A> sobrecargas de método, o <xref:System.Runtime.Caching.MemoryCache.Set%2A> método sempre coloca um valor de cache no cache, independentemente se uma entrada já existe com a mesma chave. Se a entrada especificada não existe no cache, uma nova entrada de cache é inserida. Se a entrada especificada já existir, seu valor é atualizado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="item" /> é <see langword="null" />.  
  
- ou - 
A propriedade <see cref="P:System.Runtime.Caching.CacheItem.Key" /> é <see langword="null" />.  
  
- ou - 
A propriedade <see cref="P:System.Runtime.Caching.CacheItem.Value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Foi passada uma combinação de argumentos inválida para a entrada de cache. Isso ocorrerá se os seguintes detalhes de expiração forem definidos no objeto de política para a entrada de cache: 
-   Se os valores de expiração absoluta e deslizante para o objeto <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> forem definidos como valores diferentes dos padrões dos campos <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> e <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. A classe <see cref="T:System.Runtime.Caching.MemoryCache" /> não pode definir a política de expiração com base em na expiração absoluta e uma expiração deslizante. Somente uma configuração de expiração pode ser definida explicitamente quando você usa a classe <see cref="T:System.Runtime.Caching.MemoryCache" />. A outra configuração deve ser definida como propriedade <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> ou <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.  
  
- Se o retorno de chamada de remoção e o retorno de chamada de atualização são especificados para o objeto <see cref="T:System.Runtime.Caching.CacheItemPolicy" />. A classe <see cref="T:System.Runtime.Caching.MemoryCache" /> dá suporte apenas ao uso de um tipo de retorno de chamada por entrada de cache.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A propriedade <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> é definida com um valor menor que <see cref="F:System.TimeSpan.Zero" />.  
  
- ou - 
A propriedade <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> é definida com um valor maior que um ano.  
  
- ou - 
A propriedade <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> não é um valor da enumeração de <see cref="T:System.Runtime.Caching.CacheItemPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="override this.Set : string * obj * DateTimeOffset * string -&gt; unit" Usage="memoryCache.Set (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Um identificador exclusivo para a entrada de cache a ser inserida.</param>
        <param name="value">Os dados de entrada de cache.</param>
        <param name="absoluteExpiration">A data e a hora fixas em que a entrada de cache vai expirar.</param>
        <param name="regionName">Uma região nomeada no cache à qual uma entrada de cache pode ser adicionada. Não passe um valor para esse parâmetro. Esse parâmetro é <see langword="null" /> por padrão, pois a classe <see cref="T:System.Runtime.Caching.MemoryCache" /> não implementa regiões.</param>
        <summary>Insere uma entrada de cache no cache usando uma chave e um valor e especifica os detalhes de expiração baseados em tempo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Como qualquer outro <xref:System.Runtime.Caching.MemoryCache.Set%2A> sobrecargas de método, o <xref:System.Runtime.Caching.MemoryCache.Set%2A> método sempre coloca um valor de cache no cache, independentemente se já existe uma entrada com a mesma chave. Se a entrada especificada não existir, uma nova entrada de cache é inserida. Se a entrada especificada existe, ele será atualizado.  
  
 O `absoluteExpiration` parâmetro indica quando a entrada deve ser removida do cache.  
  
 Removendo uma entrada dispara qualquer monitores de alteração associada. Se o item removido está associado com um <xref:System.Web.Caching.CacheItemUpdateCallback> objeto ou <xref:System.Web.Caching.CacheItemRemovedCallback> do objeto, a razão para remoção que é passada para os retornos de chamada está contida no <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed> propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> não é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="Value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">- Foi passada uma combinação inválida de argumentos para a entrada de cache. Isso ocorrerá se os seguintes detalhes de expiração forem definidos no objeto de política para a entrada de cache: 
-   Se os valores de expiração absoluta e deslizante no objeto <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> forem definidos como valores diferentes dos padrões de <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> e <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. Isso ocorre porque a classe <see cref="T:System.Runtime.Caching.MemoryCache" /> não dá suporte a entradas de expiração com base em uma expiração absoluta e deslizante. Somente uma configuração de expiração pode ser definida explicitamente quando você usa a classe <see cref="T:System.Runtime.Caching.MemoryCache" />. A outra configuração deve ser definida como <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> ou <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.  
  
- Se o retorno de chamada de remoção e o retorno de chamada de atualização são especificados no objeto <see cref="T:System.Runtime.Caching.CacheItemPolicy" />. A classe <see cref="T:System.Runtime.Caching.MemoryCache" /> dá suporte apenas ao uso de um tipo de retorno de chamada por entrada de cache.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A propriedade <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> é definida com um valor menor que <see cref="F:System.TimeSpan.Zero" />.  
  
- ou - 
A propriedade <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> é definida com um valor maior que um ano.  
  
- ou - 
-   A propriedade <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> não é um valor da enumeração <see cref="T:System.Runtime.Caching.CacheItemPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="override this.Set : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; unit" Usage="memoryCache.Set (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Um identificador exclusivo para a entrada de cache a ser inserida.</param>
        <param name="value">Os dados de entrada de cache.</param>
        <param name="policy">Um objeto que contém os detalhes da remoção da entrada de cache. Esse objeto fornece mais opções de remoção do que uma expiração absoluta simples.</param>
        <param name="regionName">Uma região nomeada no cache à qual uma entrada de cache pode ser adicionada. Não passe um valor para esse parâmetro. Esse parâmetro é <see langword="null" /> por padrão, pois a classe <see cref="T:System.Runtime.Caching.MemoryCache" /> não implementa regiões.</param>
        <summary>Insere uma entrada de cache no cache usando uma chave e um valor e remoção.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Como qualquer outro <xref:System.Runtime.Caching.MemoryCache.Set%2A> sobrecargas de método, o <xref:System.Runtime.Caching.MemoryCache.Set%2A> método sempre coloca um valor de cache no cache, independentemente se uma entrada correspondente já existe. Se a entrada especificada não existe no cache, uma nova entrada de cache é inserida. Se a entrada especificada existe, ele será atualizado.  
  
 Removendo uma entrada dispara qualquer monitores de alteração associada. Se o item removido está associado com um <xref:System.Web.Caching.CacheItemUpdateCallback> objeto ou <xref:System.Web.Caching.CacheItemRemovedCallback> do objeto, a razão para remoção que é passada para os retornos de chamada está contida no <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed> propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="value" /> é <see langword="null" />  
  
- ou - 
A referência de retorno de chamada passada para o método auxiliar na propriedade <see cref="P:System.Runtime.Caching.CacheItemPolicy.UpdateCallback" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">- Existe uma combinação inválida de argumentos para a entrada de cache. Isso ocorrerá se os seguintes detalhes de expiração forem definidos no objeto de política para a entrada de cache: 
-   Se os valores de expiração absoluta e deslizante no objeto <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> forem definidos como valores diferentes dos padrões de <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> e <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. Isso ocorre porque a classe <see cref="T:System.Runtime.Caching.MemoryCache" /> não dá suporte a entradas de expiração com base em uma expiração absoluta e deslizante. Somente uma configuração de expiração pode ser definida explicitamente quando você usa a classe <see cref="T:System.Runtime.Caching.MemoryCache" />. A outra configuração deve ser definida como <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> ou <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.  
  
- Se o retorno de chamada de remoção e o retorno de chamada de atualização são especificados na classe <see cref="T:System.Runtime.Caching.CacheItemPolicy" />. A classe <see cref="T:System.Runtime.Caching.MemoryCache" /> dá suporte apenas ao uso de um tipo de retorno de chamada por entrada de cache.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A propriedade <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> é definida com um valor menor que <see cref="F:System.TimeSpan.Zero" />.  
  
- ou - 
A propriedade <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> é definida com um valor maior que um ano.  
  
- ou - 
A propriedade <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> não é um valor da enumeração <see cref="T:System.Runtime.Caching.CacheItemPriority" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> não é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dá suporte para iteração em uma coleção genérica.</summary>
        <returns>O objeto enumerador que dá acesso às entradas no cache.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele pode ser usado somente quando um <xref:System.Runtime.Caching.MemoryCache> instância é convertida para um <xref:System.Collections.IEnumerable> interface.  
  
 Você pode usar esse método para iterar por meio de uma coleção genérica de entradas de cache.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public long Trim (int percent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Trim(int32 percent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Trim(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (percent As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Trim(int percent);" />
      <MemberSignature Language="F#" Value="member this.Trim : int -&gt; int64" Usage="memoryCache.Trim percent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="percent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="percent">O percentual do total de entradas de cache a serem removidas.</param>
        <summary>Remove um percentual especificado de entradas de cache do objeto de cache.</summary>
        <returns>O número de elementos removidas do cache.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.Caching.MemoryCache.Trim%2A> propriedade primeiro remove as entradas que excederam absoluta ou a expiração deslizante. Qualquer retorno de chamada que é registrados para os itens removidos serão passados uma razão removida de <xref:System.Web.Caching.CacheItemRemovedReason.Expired>.  
  
 Se remover entradas expiradas for insuficiente para alcançar a porcentagem de corte especificada, entradas adicionais serão removidas do cache com base em um algoritmo de usados menos recentemente (LRU) até que a porcentagem de corte solicitada seja atingida. Qualquer retorno de chamada que é registrados para os itens que são removidos dessa maneira serão passados uma razão de remoção de <xref:System.Runtime.Caching.CacheEntryRemovedReason.Evicted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>