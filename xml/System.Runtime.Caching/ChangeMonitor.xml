<Type Name="ChangeMonitor" FullName="System.Runtime.Caching.ChangeMonitor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="84f8a6fb55cf74a47d97cac674e756ad9921ef43" />
    <Meta Name="ms.sourcegitcommit" Value="9dda17222b9f7d3edf130133bfb1370d5b410a4b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="09/22/2018" />
    <Meta Name="ms.locfileid" Value="46692387" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ChangeMonitor : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ChangeMonitor extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ChangeMonitor" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ChangeMonitor&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ChangeMonitor abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type ChangeMonitor = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fornece uma classe base para um tipo personalizado derivado que monitora alterações no estado dos dados, ao qual um item de cache depende.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.Caching.ChangeMonitor> classe é usada como a classe base para classes derivadas de monitor que são especializadas para implementações de cache específica. Um <xref:System.Runtime.Caching.ChangeMonitor> instância monitora as alterações feitas no estado dos dados que depende de um item de cache. Por exemplo, o item pode ser uma entidade de dados ou arquivo cujos conteúdos são armazenados em cache. Se a entidade de dados ou arquivo for atualizada, a entrada de cache associado deve ser alterada também. Itens comuns que podem ser monitorados incluem entidades de dados (como campos de banco de dados, valores, linhas ou tabelas), outra entrada de cache e arquivos e atributos de arquivo.  
  
 Uma alteração de dependência é uma alteração no estado de uma dependência. Em uma implementação típica do cache, depois que um <xref:System.Runtime.Caching.ChangeMonitor> instância notifica o cache de uma dependência foi alterada, o cache realiza a ação necessária, como invalidar a entrada de cache inseridas.  
  
 Derivado <xref:System.Runtime.Caching.ChangeMonitor> classes podem ser personalizadas para monitorar as alterações de dependência para armazenamentos de dados específicos de diferentes. Por exemplo, há implementações de cache para um sistema de arquivos, a memória física ou um banco de dados. O <xref:System.Runtime.Caching.ChangeMonitor> classe examina as alterações que ocorrem fora do cache e, em seguida, o cache que ocorreram alterações de alertas.  
  
 O [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] inclui as seguintes classes que derivam de <xref:System.Runtime.Caching.ChangeMonitor> classe:  
  
-   <xref:System.Runtime.Caching.CacheEntryChangeMonitor>  
  
-   <xref:System.Runtime.Caching.FileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.HostFileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.SqlChangeMonitor>  
  
 Cada uma dessas classes funciona com tipos diferentes de dependências. Por exemplo, a derivada <xref:System.Runtime.Caching.FileChangeMonitor> classe monitora as alterações feitas a um cache de dados do sistema de arquivos (arquivos e pastas) que o item de cache depende.  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo é thread-safe.</threadsafe>
    <block subset="none" type="overrides">
      <para>Se você criar um personalizado a implementação de cache ou uma alteração derivada monitorar tipo, você deve seguir certas diretrizes. A lista a seguir resume essas diretrizes. Para obter mais informações, consulte a documentação para as propriedades ou métodos individuais.  
  
-O construtor de uma classe derivada deve definir a <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> propriedade, comece a monitorar e chamar <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> método antes do método retorna. Se um construtor encontra um erro durante construções e deve ter para descartar os recursos, o construtor pode chamar apenas o <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> sobrecarregar após o <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> o método é chamado porque o <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> sobrecarga lançará um <see cref="T:System.InvalidOperationException" /> exceção se a inicialização não for concluída.  
  
-Se houver alterações nos dados que está sendo monitorados antes que a inicialização é concluída, o construtor deve chamar o <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> método antes de chamar o <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> método.  
  
-Após um derivado <see cref="T:System.Runtime.Caching.ChangeMonitor" /> tipo é instanciado, você deve inserir o monitor em um personalizado <see cref="T:System.Runtime.Caching.ObjectCache" /> implementação. Ou, se você tiver terminado de usar o monitor de alteração, chame o <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> método.  
  
-Após um <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instância é inserida em um <see cref="T:System.Runtime.Caching.ObjectCache" /> implementação, o <see cref="T:System.Runtime.Caching.ObjectCache" /> instância exigem que o monitor de alteração é descartado. Mesmo se a inserção é inválida e gera uma exceção, o <see cref="T:System.Runtime.Caching.ObjectCache" /> implementação deve chamar o <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> de sobrecarga.  
  
-Depois que um monitor de alteração derivado é inserido em um cache, o <see cref="T:System.Runtime.Caching.ObjectCache" /> deve chamar a implementação <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />, passando um <see cref="T:System.Runtime.Caching.OnChangedCallback" /> objeto. O <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> método pode ser chamado apenas uma vez. Se já tiver ocorrido uma alteração de dependência, o <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instância será chamada imediatamente quando <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> é chamado. Caso contrário, o <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instância será chamada apenas uma vez. Isso uma vez chamada ocorre quando o <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> o método é chamado porque o <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instância foi detectada uma alteração, ou quando o <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> método é chamado no <see cref="T:System.Runtime.Caching.ChangeMonitor" />, o que ocorrer primeiro.  
  
-A <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instância que é fornecida por um <see cref="T:System.Runtime.Caching.ObjectCache" /> implementação deve remover a entrada de cache associada e especifique um motivo usando o <see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" /> enumeração.  
  
-A <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instância poderá chamar o <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> método o antes de uma implementação de cache tiver chamado <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> método ou depois. Se o <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> método é chamado antes <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> é chamado, a base <see cref="T:System.Runtime.Caching.ChangeMonitor" /> implementação notificará o cache que isso tenha ocorrido e disparará a serem passados para o retorno de chamada <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> imediatamente quando <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> é invocado. Quaisquer dados de estado que são passados para o <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> método é salvo pelo monitor de alteração e subsequentemente passado para o <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> método quando o <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> método é invocado.  
  
-Um monitor de alteração deve implementar o <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> método. Para obter mais informações, consulte a documentação do método <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />.  
  
-A <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> sobrecarga do método deve ser chamada para descartar o <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instância. As regras para chamar Dispose são da seguinte maneira: 
-Antes de um item é inserido no cache, é responsabilidade do chamador para descartar um <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instância.  
  
-Item de cache uma vez e o <see cref="T:System.Runtime.Caching.ChangeMonitor" /> as instâncias que estão associadas ele são passadas para um cache, o implementador de cache deve verificar se que o <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> método é chamado, mesmo se a inserção falhará.  
  
-Depois de um item e seus associados <see cref="T:System.Runtime.Caching.ChangeMonitor" /> as instâncias são passadas para um cache, o chamador não deve descartar a dependência porque quando o <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> método é chamado, a chamada será tratada como se a dependência foi alterada. Como resultado, o <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> método é invocado automaticamente.  
  
-Levando essas regras em consideração, o <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> método deve ser chamado em uma das seguintes maneiras: 
-Os usuários devem chamar o <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> sobrecarga de método se eles não quiser inserir a instância derivada de monitor de alteração em um cache.  
  
-Se a implementação tenta inserir a instância do monitor de alteração em um cache de objeto, mas a inserção falhar, a implementação de cache é responsável por chamar o <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> de sobrecarga. Quando a tentativa de inserção faz com que uma exceção, a implementação de cache deve descartar quaisquer dependências associadas.  
  
-Se a entrada de cache for removida, a implementação de cache também deve descartar a dependência.  
  
-A implementação interna do <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> método chama automaticamente o <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> método depois que ele chama um retorno de chamada que é registrado por meio de <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />.  
  
 <block subset="none" type="note"><para>  
 Essa chamada automática para o método dispose durante o acionamento do evento só ocorrerá se a inicialização da <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instância anteriormente foi concluída.  
  
</para></block>  
  
Quando chama o construtor de um monitor de alteração derivado o <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> método, se já tiver sido alterado o estado do monitor de alteração (ou seja, o estado que é monitorado já alterados quando o construtor ainda estava ativo) o <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> será de método Descarte o monitor de alteração automaticamente.  
  
-A <see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" /> estiver definida como <see langword="true" /> depois que o <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> método é chamado pela instância derivada de monitor de alteração, independentemente se um <see cref="T:System.Runtime.Caching.OnChangedCallback" /> objeto foi definido por uma chamada para o <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> método ou não.</para>
    </block>
    <altmember cref="N:System.Web.Caching" />
    <altmember cref="T:System.Runtime.Caching.ObjectCache" />
    <related type="Article" href="http://msdn.microsoft.com/library/ac11c8ea-df5d-4de8-b315-9ccf1048b0ce">O cache do ASP.NET</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ChangeMonitor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ChangeMonitor();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Runtime.Caching.ChangeMonitor" />. Esse construtor é chamado de construtores em classes derivadas para inicializar a classe base.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.Caching.ChangeMonitor> classe tem um construtor padrão. No entanto, as classes que herdam da base <xref:System.Runtime.Caching.ChangeMonitor> de classe e definir o monitoramento de alterações personalizada comportamento deve executar a inicialização no construtor. Para obter mais informações, consulte as notas para a seção de herdeiros.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>O construtor de uma classe derivada deve definir a <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> propriedade, comece a monitorar e chamar o <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> classe antes de retornar. Se uma dependência é alterada antes da inicialização estiver concluída (por exemplo, se uma chave de cache dependente não for encontrada no cache), o construtor deve chamar o <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> método antes de chamar o <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> método. Nesse caso, o construtor pode chamar o <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> método somente após o <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> método é chamado, porque o <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> método gera uma exceção se a inicialização não for concluída.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método é usado para liberar o <xref:System.Runtime.Caching.ChangeMonitor> instância e recursos relacionados. O público <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método é invocado para coordenar o processo de descarte com eventos de ciclo de vida da chave de classes derivadas de monitor de alteração (como inicialização) e para liberar o <xref:System.Runtime.Caching.ChangeMonitor> da instância para que a instância pode ser coletado como lixo. O <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método é implementado por classes derivadas de monitor de alteração para descartar os seus recursos gerenciados e não gerenciados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="changeMonitor.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método invoca o <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método de apenas uma vez, na primeira vez que ele é chamado de classes derivadas. As chamadas subsequentes para o <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método não têm nenhum efeito. Depois que o método foi chamado, o <xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A> estiver definida como `true`.  
  
 O <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> sobrecarga deve ser chamada para descartar um <xref:System.Runtime.Caching.ChangeMonitor> instância. Seguem as regras para chamar o método dispose:  
  
-   Antes de um item é inserido no cache, é responsabilidade do chamador para descartar um <xref:System.Runtime.Caching.ChangeMonitor> instância.  
  
-   Uma vez o item de cache e o <xref:System.Runtime.Caching.ChangeMonitor> as instâncias que estão associadas ele são passadas a um cache, o implementador de cache que deve se certificar que <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> é chamado, mesmo se a inserção falhará.  
  
-   Depois de um item e seus associados <xref:System.Runtime.Caching.ChangeMonitor> as instâncias são passadas para um cache, o chamador não deve descartar a dependência porque quando o <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método é chamado, a chamada será tratada como se a dependência foi alterada. Como resultado, o <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método é invocado automaticamente.  
  
-   Levando essas regras em consideração, o <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método deve ser chamado em uma das seguintes maneiras:  
  
    -   Os usuários devem chamar o <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> sobrecarga de método se eles não quiser inserir a instância derivada de monitor de alteração em um cache.  
  
    -   A implementação de cache é responsável por chamar o <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> sobrecarga se a implementação tenta inserir a instância do monitor de alteração em um cache de objeto, mas a inserção falhar. Quando a tentativa de inserção faz com que uma exceção, a implementação de cache deve descartar quaisquer dependências associadas.  
  
    -   Se a entrada de cache for removida, a implementação de cache também deve descartar a dependência.  
  
 A implementação interna do <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método chama automaticamente o <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método depois que ele chama um retorno de chamada que é registrado por meio do <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> método.  
  
> [!NOTE]
>  Esse descarte automático durante o acionamento do evento ocorrerá somente se a inicialização da <xref:System.Runtime.Caching.ChangeMonitor> instância concluída anteriormente.  
  
 Quando chama o construtor de um monitor de alteração derivado o <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> método, se já tiver sido alterado o estado do monitor de alteração (ou seja, o estado que é monitorado já mudou quando o construtor ainda estava ativo), em seguida, <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> será de método descarta automaticamente o monitor de alteração.  
  
> [!NOTE]
>  Os usuários não devem chamar o <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método. No entanto, você não pode impedir que usuários chamando o método. Portanto, se o fizer, o <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método é invocado. Nesse caso, a entrada de cache é notificada como se a dependência foi alterada.  
  
 Para impedir que classes derivadas substituam <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método, o método não é uma implementação de interface explícita.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A inicialização não está concluída na classe do monitor de alteração derivada que chamou o método <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> de base.</exception>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected abstract void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit" Usage="changeMonitor.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> para liberar recursos gerenciados e não gerenciados, bem como referências a uma instância de <see cref="T:System.Runtime.Caching.ChangeMonitor" />; <see langword="false" /> para liberar apenas recursos não gerenciados. Quando <see langword="false" /> é passado, o método <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> é chamado por um thread <see langword="finalizer" /> e qualquer referência gerenciada externa provavelmente deixa de ser válida porque já foi coletada pelo coletor de lixo.</param>
        <summary>Libera todos os recursos gerenciados e não gerenciados e todas as referências à instância de <see cref="T:System.Runtime.Caching.ChangeMonitor" />. Essa sobrecarga deve ser implementada por classes de monitor de alteração derivadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o valor de `disposing` valor é `true`, todos os recursos gerenciados e não gerenciados sejam descartados e todas as referências a esse objeto são liberadas para que a instância do monitor de alteração derivada pode ser coletado como lixo. É garantido que a base <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método invocará o implementado <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método apenas uma vez.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Um monitor de alteração deve implementar o <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> sobrecarga para liberar todos os recursos gerenciados e quando o valor da <paramref name="disposing" /> é <see langword="true" />. O <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> sobrecarga de método que tem um <paramref name="disposing" /> valor <see langword="true" /> é chamado apenas uma vez, ou seja, quando a instância é descartada pela primeira vez. Um monitor de alteração não deve chamar o <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> sobrecarregar diretamente. Um monitor de alteração derivada pode chamar o público sem parâmetros <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> método na base de <see cref="T:System.Runtime.Caching.ChangeMonitor" /> classe.  
  
Como alternativa, um monitor de alteração pode implementar um método do finalizador. Nesse caso, o finalizador pode invocar o <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> método e passá-lo um <paramref name="disposing" /> valor <see langword="false" />. No entanto, isso normalmente é desnecessário. Monitoramento de alterações de dependência normalmente é executado por um serviço que mantém uma referência à instância do monitor de alteração. A referência impede que a instância que está sendo coletado como lixo e, portanto, faz com que um método do finalizador desnecessários. Para evitar vazamentos de memória, quando uma dependência for alterada, o <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> método descarta a instância do monitor de alteração (a menos que a inicialização não foi concluída).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="HasChanged">
      <MemberSignature Language="C#" Value="public bool HasChanged { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChanged" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasChanged As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasChanged { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasChanged : bool" Usage="System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica que o estado monitorado pela classe <see cref="T:System.Runtime.Caching.ChangeMonitor" /> foi alterado.</summary>
        <value>
          <see langword="true" /> Se o estado que é monitorado pelo <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instância tiver sido alterado; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode verificar o valor dessa propriedade em um derivada <xref:System.Runtime.Caching.ChangeMonitor> classe para ver se uma dependência foi alterado.  
  
 O valor é definido como `true` quando ocorre uma alteração de dependência (ou seja, quando o <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método é chamado). Após o <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método é chamado pela classe derivada, o valor da <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> propriedade será `true`, independentemente de uma <xref:System.Runtime.Caching.OnChangedCallback> instância foi notificada por uma chamada para o <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> método.  
  
> [!NOTE]
>  Os chamadores podem verificar o <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> propriedade para ver se uma dependência foi alterado. No entanto, uma abordagem mais simples e mais passível de manutenção em um ambiente multithread, é inserir dados em uma implementação de cache sem verificar o <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> propriedade. Implementações de cache devem verificar o <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> propriedade para você e não deve executar uma inserção ou operação de definição se um ou mais dependências associadas já tiverem sido alteradas.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InitializationComplete">
      <MemberSignature Language="C#" Value="protected void InitializationComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializationComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializationComplete ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializationComplete();" />
      <MemberSignature Language="F#" Value="member this.InitializationComplete : unit -&gt; unit" Usage="changeMonitor.InitializationComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chamado do construtor de classes derivadas para indicar que a inicialização foi concluída.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se uma dependência for alterada antes que a inicialização foi concluída em uma classe derivada, o construtor da classe derivada deve invocar o <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método.  
  
 Quando o <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método é invocado, o <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> propriedade é definida automaticamente como `true` pelo monitor de alteração. Como resultado, quando o construtor do monitor de alteração chama o <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> método, a classe base automaticamente chamará o <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método. Se a inicialização foi concluída, o <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método descarta a instância derivada de monitor de alteração automaticamente.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>O construtor de uma classe derivada deve chamar a base <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> método antes de retorna o construtor. O construtor de uma classe derivada pode chamar o <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> método somente após <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> é chamado, porque o <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> método gera uma exceção se a inicialização não for concluída.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDisposed : bool" Usage="System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica que a instância derivada de uma classe <see cref="T:System.Runtime.Caching.ChangeMonitor" /> foi descartada.</summary>
        <value>
          <see langword="true" /> Se a instância é descartada; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A propriedade é definida como `true` depois de base <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> chamadas de método a <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método em uma classe derivada de descartar a instância.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOnChanged">
      <MemberSignature Language="C#" Value="public void NotifyOnChanged (System.Runtime.Caching.OnChangedCallback onChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void NotifyOnChanged(class System.Runtime.Caching.OnChangedCallback onChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void NotifyOnChanged(System::Runtime::Caching::OnChangedCallback ^ onChangedCallback);" />
      <MemberSignature Language="F#" Value="member this.NotifyOnChanged : System.Runtime.Caching.OnChangedCallback -&gt; unit" Usage="changeMonitor.NotifyOnChanged onChangedCallback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="onChangedCallback" Type="System.Runtime.Caching.OnChangedCallback" />
      </Parameters>
      <Docs>
        <param name="onChangedCallback">Uma referência para um método que será invocado quando uma dependência tiver sido alterada.</param>
        <summary>Chamado pelos implementadores de cache para registrar um retorno de chamada e notificar uma instância de <see cref="T:System.Runtime.Caching.ObjectCache" /> por meio do delegado de <see cref="T:System.Runtime.Caching.OnChangedCallback" /> quando uma dependência tiver sido alterada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os implementadores de cache usam esse método para conectar-se até um monitor de alteração. Se você associar um ou mais monitores com o item de cache de alteração, você passa um <xref:System.Runtime.Caching.CacheItemPolicy> instância com uma propriedade de monitores de alteração preenchidas para o item de cache. Um implementador de cache dá suporte a monitores de alteração é responsável por iteração sobre o <xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A> propriedade e registrar o <xref:System.Runtime.Caching.OnChangedCallback> delegados com cada alterar monitor que encontra.  
  
 Porque o <xref:System.Runtime.Caching.OnChangedCallback> delegado inclui um parâmetro opcional de estado, uma implementação de monitor de alteração concreto pode passar informações de estado opcionais. O implementador de cache determina se uma dependência explícita no tipo de estado que passa de um monitor de alteração personalizada como parte do retorno de chamada pode ser realizada.  
  
> [!NOTE]
>  A API de extensibilidade do cache base tem sem a necessidade de dependência explícita no tipo de estado.  
  
 A implementação de <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> método determina automaticamente se o estado do monitor já foi alterado no momento <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> método é chamado. Se o <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> é de propriedade `true`, em seguida, o método chama automaticamente o <xref:System.Runtime.Caching.OnChangedCallback> manipulador de eventos, que foi registrado, por meio de <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método. Isso ocorre porque é possível que, desde o momento em que uma implementação de cache cria um monitor de alteração, até o momento em que uma implementação de cache obtém o monitor e conecta em si até ele, o estado monitorado subjacente foi alterado. Se o estado já mudou, em seguida, o objeto que é passado para o <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método é `null`.  
  
 O <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> método pode ser chamado apenas uma vez e lançará uma exceção em chamadas subsequentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O método de retorno de chamada já foi invocado.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="onChangedCallback" /> é <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>1.  Você deve chamar o <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> método a ser notificado de qualquer alteração de dependência. Se já tiver ocorrido uma alteração de dependência, o <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instância será chamada quando <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> é chamado. Caso contrário, o <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instância será chamada uma vez, quando o <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> método é chamado ou quando o <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> método é chamado, o que ocorrer primeiro. O <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instância fornecida pela implementação de cache deve remover a entrada de cache e se eles forem solicitados pelo chamador cache, acionar o evento de atualização de volta para o chamador original do cache ou alteração necessária.  
  
2.  A implementação de cache do objeto deve remover a entrada de cache que está associada uma alteração de dependência.</para>
        </block>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : obj -&gt; unit" Usage="changeMonitor.OnChanged state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Os dados do evento de alteração. Este valor pode ser <see langword="null" />.</param>
        <summary>Chamado por classes derivadas para gerar o evento quando uma dependência é alterada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, o <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método é chamado quando ocorrem alterações de dependência. O <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método também é chamado quando uma instância do monitor de alteração é descartada, mas o descarte ocorre somente se o retorno de chamada já não foi invocado.  
  
 Se o <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método é chamado antes do <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> método é chamado, os dados de estado da chamada para o <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método é salvo pela implementação de cache. Além disso, o retorno de chamada para o <xref:System.Runtime.Caching.OnChangedCallback> método é invocado imediatamente quando o <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> método é invocado.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      </Docs>
    </Member>
    <Member MemberName="UniqueId">
      <MemberSignature Language="C#" Value="public abstract string UniqueId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UniqueId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ UniqueId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UniqueId : string" Usage="System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que representa a instância da classe <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</summary>
        <value>O identificador para uma instância do monitor de alteração.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> o valor da propriedade normalmente consiste em dados de cadeia de caracteres de nomes combinados de dependência que exclusivamente identificadores os dados que está sendo monitorados por um <xref:System.Runtime.Caching.ChangeMonitor> instância. O valor da <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> propriedade é uma cadeia de caracteres. O valor da cadeia de caracteres é usado para atribuir a ID exclusiva do <xref:System.Runtime.Caching.ChangeMonitor> instância.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Substituindo a propriedade, você pode definir uma implementação personalizada para o valor de cadeia de caracteres da propriedade para atribuí-la uma ID exclusiva.</para>
        </block>
        <block subset="none" type="overrides">
          <para>Em classes derivadas, você deve definir o valor da propriedade no construtor.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>