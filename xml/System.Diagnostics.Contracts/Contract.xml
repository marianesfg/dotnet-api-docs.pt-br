<Type Name="Contract" FullName="System.Diagnostics.Contracts.Contract">
  <Metadata><Meta Name="ms.openlocfilehash" Value="22ebb681d45715d8c06270c81cbba6695310ae54" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52228607" /></Metadata><TypeSignature Language="C#" Value="public static class Contract" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Contract extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Contracts.Contract" />
  <TypeSignature Language="VB.NET" Value="Public Class Contract" />
  <TypeSignature Language="C++ CLI" Value="public ref class Contract abstract sealed" />
  <TypeSignature Language="F#" Value="type Contract = class" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="6a285-101">Contém métodos estáticos para representação de contratos de programa, como pré-condições, pós-condições e invariáveis de objeto.</span><span class="sxs-lookup"><span data-stu-id="6a285-101">Contains static methods for representing program contracts such as preconditions, postconditions, and object invariants.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6a285-102">Classes de contrato de código permitem que você especificar pré-condições, pós-condições e invariáveis de objeto em seu código.</span><span class="sxs-lookup"><span data-stu-id="6a285-102">Code contract classes let you specify preconditions, postconditions, and object invariants in your code.</span></span> <span data-ttu-id="6a285-103">As pré-condições são requisitos que devem ser atendidos ao inserir um método ou uma propriedade.</span><span class="sxs-lookup"><span data-stu-id="6a285-103">Preconditions are requirements that must be met when entering a method or property.</span></span> <span data-ttu-id="6a285-104">As pós-condições descrevem as expectativas no momento em que o código do método ou da propriedade é fechado.</span><span class="sxs-lookup"><span data-stu-id="6a285-104">Postconditions describe expectations at the time the method or property code exits.</span></span> <span data-ttu-id="6a285-105">Invariáveis de objeto descrevem o estado esperado de uma classe que não tem nenhum problema de condição.</span><span class="sxs-lookup"><span data-stu-id="6a285-105">Object invariants describe the expected state for a class that has no condition problems.</span></span> <span data-ttu-id="6a285-106">Para obter mais informações sobre como pré-condições, pós-condições e invariáveis de objeto, consulte [contratos de código](~/docs/framework/debug-trace-profile/code-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="6a285-106">For more information about preconditions, postconditions, and object invariants, see [Code Contracts](~/docs/framework/debug-trace-profile/code-contracts.md).</span></span>  
  
 <span data-ttu-id="6a285-107">Para obter ferramentas e instruções detalhadas sobre como usar contratos de código, consulte [Contratos de código](https://go.microsoft.com/fwlink/?LinkId=152461) no site do DevLabs no MSDN.</span><span class="sxs-lookup"><span data-stu-id="6a285-107">For tools and detailed instructions for using code contracts, see [Code Contracts](https://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="6a285-108">Você deve usar um regravador binário para inserir a imposição de contratos de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="6a285-108">You must use a binary rewriter to insert run-time enforcement of contracts.</span></span> <span data-ttu-id="6a285-109">Caso contrário, contratos, como o <xref:System.Diagnostics.Contracts.Contract.Ensures%2A?displayProperty=nameWithType> método só pode ser testado estaticamente e não lançam exceções durante o tempo de execução se um contrato é violado.</span><span class="sxs-lookup"><span data-stu-id="6a285-109">Otherwise, contracts such as the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A?displayProperty=nameWithType> method can only be tested statically and will not throw exceptions during run time if a contract is violated.</span></span> <span data-ttu-id="6a285-110">Você pode baixar o regravador binário CCRewrite partir [contratos de código](https://go.microsoft.com/fwlink/?LinkId=152461) no site do MSDN do DevLabs.</span><span class="sxs-lookup"><span data-stu-id="6a285-110">You can download the binary rewriter CCRewrite from [Code Contracts](https://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span> <span data-ttu-id="6a285-111">CCRewrite vem com um suplemento do Visual Studio que permite que você ative a imposição de contrato de tempo de execução do projeto **propriedades** página.</span><span class="sxs-lookup"><span data-stu-id="6a285-111">CCRewrite comes with a Visual Studio add-in that enables you to activate run-time contract enforcement from the project **Properties** page.</span></span> <span data-ttu-id="6a285-112">O regravador binário e o suplemento do Visual Studio não são fornecidos com [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] ou o SDK do Windows.</span><span class="sxs-lookup"><span data-stu-id="6a285-112">The binary rewriter and the Visual Studio add-in do not ship with [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] or the Windows SDK.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Assert">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6a285-113">Em builds de depuração, realiza um teste de tempo de execução para uma condição específica.</span><span class="sxs-lookup"><span data-stu-id="6a285-113">In debug builds, performs a run-time test for a specified condition.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition);" />
      <MemberSignature Language="F#" Value="static member Assert : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assert condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="6a285-114">A expressão condicional a ser testada.</span><span class="sxs-lookup"><span data-stu-id="6a285-114">The conditional expression to test.</span></span></param>
        <summary><span data-ttu-id="6a285-115">Verifica uma condição; se a condição for <see langword="false" />, seguirá a política de escalonamento definida para o analisador.</span><span class="sxs-lookup"><span data-stu-id="6a285-115">Checks for a condition; if the condition is <see langword="false" />, follows the escalation policy set for the analyzer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6a285-116">A diretiva de escalonamento de bloqueios padrão é para notificar o depurador anexado sobre uma falha de contrato ou para exibir uma **Assert** caixa de diálogo se um depurador não está anexado.</span><span class="sxs-lookup"><span data-stu-id="6a285-116">The default escalation policy is to notify the attached debugger about a contract failure or to display an **Assert** dialog box if a debugger is not attached.</span></span> <span data-ttu-id="6a285-117">Opcionalmente, o analisador pode ser instruído para lançar uma exceção.</span><span class="sxs-lookup"><span data-stu-id="6a285-117">Optionally, the analyzer can be instructed to throw an exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Assert : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assert (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="6a285-118">A expressão condicional a ser testada.</span><span class="sxs-lookup"><span data-stu-id="6a285-118">The conditional expression to test.</span></span></param>
        <param name="userMessage"><span data-ttu-id="6a285-119">Uma mensagem a ser exibida se a condição não for atendida.</span><span class="sxs-lookup"><span data-stu-id="6a285-119">A message to display if the condition is not met.</span></span></param>
        <summary><span data-ttu-id="6a285-120">Verifica uma condição; se a condição for <see langword="false" />, seguirá a política de escalonamento definida pelo analisador e exibirá a mensagem especificada.</span><span class="sxs-lookup"><span data-stu-id="6a285-120">Checks for a condition; if the condition is <see langword="false" />, follows the escalation policy set by the analyzer and displays the specified message.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6a285-121">A diretiva de escalonamento de bloqueios padrão é para notificar o depurador anexado sobre uma falha de contrato ou para exibir uma **Assert** caixa de diálogo se um depurador não está anexado.</span><span class="sxs-lookup"><span data-stu-id="6a285-121">The default escalation policy is to notify the attached debugger about a contract failure or to display an **Assert** dialog box if a debugger is not attached.</span></span> <span data-ttu-id="6a285-122">Opcionalmente, o analisador pode ser instruído para lançar uma exceção.</span><span class="sxs-lookup"><span data-stu-id="6a285-122">Optionally, the analyzer can be instructed to throw an exception.</span></span> <span data-ttu-id="6a285-123">O `userMessage` parâmetro é passado para a saída do depurador.</span><span class="sxs-lookup"><span data-stu-id="6a285-123">The `userMessage` parameter is passed to the debugger output.</span></span> <span data-ttu-id="6a285-124">Se `userMessage` não é uma cadeia de caracteres constante literal, ferramentas talvez não consiga lê-lo.</span><span class="sxs-lookup"><span data-stu-id="6a285-124">If `userMessage` is not a constant string literal, tools may not be able to read it.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Assume">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6a285-125">Instrui as ferramentas de análise de código a pressupor que a condição é <see langword="true" />, mesmo que ela não possa ser estaticamente comprovada ser sempre <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-125">Instructs code analysis tools to assume that a condition is <see langword="true" />, even if it cannot be statically proven to always be <see langword="true" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Assume">
      <MemberSignature Language="C#" Value="public static void Assume (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assume(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assume (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assume(bool condition);" />
      <MemberSignature Language="F#" Value="static member Assume : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assume condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="6a285-126">A expressão condicional que assumirá <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-126">The conditional expression to assume <see langword="true" />.</span></span></param>
        <summary><span data-ttu-id="6a285-127">Instrui as ferramentas de análise de código a assumir que a condição especificada é <see langword="true" />, mesmo que ela não possa ser estaticamente comprovada ser sempre <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-127">Instructs code analysis tools to assume that the specified condition is <see langword="true" />, even if it cannot be statically proven to always be <see langword="true" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6a285-128">Em tempo de execução, usando esse método é equivalente a usar o <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%29> método.</span><span class="sxs-lookup"><span data-stu-id="6a285-128">At run time, using this method is equivalent to using the <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%29> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assume">
      <MemberSignature Language="C#" Value="public static void Assume (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assume(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assume (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assume(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Assume : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assume (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="6a285-129">A expressão condicional que assumirá <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-129">The conditional expression to assume <see langword="true" />.</span></span></param>
        <param name="userMessage"><span data-ttu-id="6a285-130">A mensagem a ser postada se a pressuposição falhar.</span><span class="sxs-lookup"><span data-stu-id="6a285-130">The message to post if the assumption fails.</span></span></param>
        <summary><span data-ttu-id="6a285-131">Instrui as ferramentas de análise de código a pressupor que a condição é <see langword="true" />, mesmo que ela não possa ser estaticamente comprovada ser sempre <see langword="true" /> e exibe uma mensagem se a pressuposição falhar.</span><span class="sxs-lookup"><span data-stu-id="6a285-131">Instructs code analysis tools to assume that a condition is <see langword="true" />, even if it cannot be statically proven to always be <see langword="true" />, and displays a message if the assumption fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6a285-132">Se `userMessage` não é uma cadeia de caracteres constante literal, o contrato não pode ser compreendido por ferramentas.</span><span class="sxs-lookup"><span data-stu-id="6a285-132">If `userMessage` is not a constant string literal, the contract may not be understood by tools.</span></span>  
  
 <span data-ttu-id="6a285-133">Em tempo de execução, usando esse método é equivalente a usar o <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%2CSystem.String%29> método.</span><span class="sxs-lookup"><span data-stu-id="6a285-133">At run time, using this method is equivalent to using the <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%2CSystem.String%29> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContractFailed">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt; ContractFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Diagnostics.Contracts.ContractFailedEventArgs&gt; ContractFailed" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Contracts.Contract.ContractFailed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ContractFailed As EventHandler(Of ContractFailedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Diagnostics::Contracts::ContractFailedEventArgs ^&gt; ^ ContractFailed;" />
      <MemberSignature Language="F#" Value="member this.ContractFailed : EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt; " Usage="member this.ContractFailed : System.EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6a285-134">Ocorre quando um contrato falha.</span><span class="sxs-lookup"><span data-stu-id="6a285-134">Occurs when a contract fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6a285-135">As informações de evento para esse evento são fornecidas pelo <xref:System.Diagnostics.Contracts.ContractFailedEventArgs?displayProperty=nameWithType> objeto que é passado para o manipulador de eventos.</span><span class="sxs-lookup"><span data-stu-id="6a285-135">The event information for this event is supplied by the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs?displayProperty=nameWithType> object that is passed to the event handler.</span></span> <span data-ttu-id="6a285-136">Esse evento notifica um ambiente de aplicativo gerenciado, como um interpretador interativo ou um host do navegador da Web que um contrato de falha.</span><span class="sxs-lookup"><span data-stu-id="6a285-136">This event notifies a managed application environment such as an interactive interpreter or a Web browser host that a contract has failed.</span></span> <span data-ttu-id="6a285-137">Antes de fazer isso, ele irá gerar um evento que um aplicativo pode manipular conforme desejar.</span><span class="sxs-lookup"><span data-stu-id="6a285-137">Before doing so, it will raise an event that an application can handle as it sees fit.</span></span> <span data-ttu-id="6a285-138">Por exemplo, se o código está sendo executado em uma estrutura de teste, uma falha de teste de log e, em seguida, encerre o teste.</span><span class="sxs-lookup"><span data-stu-id="6a285-138">For example, if code is being run in a testing framework, you can log a test failure and then end the test.</span></span>  
  
 <span data-ttu-id="6a285-139">A implementação padrão do <xref:System.Diagnostics.Contracts.Internal.ContractHelper.RaiseContractFailedEvent%2A> método na biblioteca de classes do .NET Framework é chamar cada manipulador que está registrado com o <xref:System.Diagnostics.Contracts.Contract.ContractFailed> eventos.</span><span class="sxs-lookup"><span data-stu-id="6a285-139">The default implementation of the <xref:System.Diagnostics.Contracts.Internal.ContractHelper.RaiseContractFailedEvent%2A> method in the .NET Framework class library is to call each handler that is registered with the <xref:System.Diagnostics.Contracts.Contract.ContractFailed> event.</span></span> <span data-ttu-id="6a285-140">As exceções lançadas por manipuladores são ignoradas, mas cada manipulador pode indicar se a falha é tratada chamando o <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetHandled%2A> método para os argumentos do evento.</span><span class="sxs-lookup"><span data-stu-id="6a285-140">Exceptions thrown by handlers are ignored, but each handler can indicate whether the failure is handled by calling the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetHandled%2A> method for the event arguments.</span></span> <span data-ttu-id="6a285-141">Se qualquer manipulador define a falha como manipulado, o método retorna `null` e nenhuma outra ação é executada.</span><span class="sxs-lookup"><span data-stu-id="6a285-141">If any handler sets the failure as handled, the method returns `null` and no further action is taken.</span></span> <span data-ttu-id="6a285-142">Como alternativa, os manipuladores podem chamar o <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetUnwind%2A> método para instruir o código de desenrolamento.</span><span class="sxs-lookup"><span data-stu-id="6a285-142">Alternatively, handlers can call the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetUnwind%2A> method to instruct the code to unwind.</span></span> <span data-ttu-id="6a285-143">Nesse caso, uma exceção é lançada após a execução de todos os manipuladores.</span><span class="sxs-lookup"><span data-stu-id="6a285-143">In that case, an exception is thrown after all handlers have executed.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6a285-144">requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="6a285-144">requires full trust for the immediate caller.</span></span> <span data-ttu-id="6a285-145">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="6a285-145">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="EndContractBlock">
      <MemberSignature Language="C#" Value="public static void EndContractBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndContractBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EndContractBlock" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndContractBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndContractBlock();" />
      <MemberSignature Language="F#" Value="static member EndContractBlock : unit -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.EndContractBlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6a285-146">Marca o fim da seção do contrato quando os contratos de um método contêm apenas precondições no formato <see langword="if" />-<see langword="then" />-<see langword="throw" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-146">Marks the end of the contract section when a method's contracts contain only preconditions in the <see langword="if" />-<see langword="then" />-<see langword="throw" /> form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6a285-147">A maioria dos códigos já contém alguma validação de parâmetro na forma de `if` - `then` - `throw` código.</span><span class="sxs-lookup"><span data-stu-id="6a285-147">Most code already contains some parameter validation in the form of `if`-`then`-`throw` code.</span></span> <span data-ttu-id="6a285-148">As ferramentas de contrato reconhecem `if` - `then` - `throw` instruções como pré-condições quando as instruções aparecem primeiros dentro de um método, e todo o conjunto de instruções desse tipo é seguido por um explícita<xref:System.Diagnostics.Contracts.Contract> chamada de método, como um <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, ou <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>.</span><span class="sxs-lookup"><span data-stu-id="6a285-148">The contract tools recognize `if`-`then`-`throw` statements as preconditions when the statements appear first inside a method, and the entire set of such statements is followed by an explicit <xref:System.Diagnostics.Contracts.Contract> method call, such as a <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, or <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>.</span></span>  
  
 <span data-ttu-id="6a285-149">Quando `if` - `then` - `throw` instruções aparecem neste formulário, as ferramentas de contrato reconhecem como herdado-requerem instruções.</span><span class="sxs-lookup"><span data-stu-id="6a285-149">When `if`-`then`-`throw` statements appear in this form, the contract tools recognize them as legacy-require statements.</span></span> <span data-ttu-id="6a285-150">O <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> formulário é usado somente se nenhum outro contrato seguir a `if` - `then` - `throw` sequências, mas eles ainda devem ser marcadas como herdado-requer.</span><span class="sxs-lookup"><span data-stu-id="6a285-150">The <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> form is used only if no other contracts follow the `if`-`then`-`throw` sequences, but they should still be tagged as legacy-requires.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ensures">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6a285-151">Especifica um contrato de pós-condição para o método ou a propriedade delimitadora.</span><span class="sxs-lookup"><span data-stu-id="6a285-151">Specifies a postcondition contract for the enclosing method or property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ensures">
      <MemberSignature Language="C#" Value="public static void Ensures (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ensures(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ensures (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Ensures(bool condition);" />
      <MemberSignature Language="F#" Value="static member Ensures : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Ensures condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="6a285-152">A expressão condicional a ser testada.</span><span class="sxs-lookup"><span data-stu-id="6a285-152">The conditional expression to test.</span></span> <span data-ttu-id="6a285-153">A expressão pode incluir os valores de <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />, <see cref="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" /> e <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-153">The expression may include <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />, <see cref="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" />, and <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> values.</span></span></param>
        <summary><span data-ttu-id="6a285-154">Especifica um contrato de pós-condição para o método ou a propriedade delimitadora.</span><span class="sxs-lookup"><span data-stu-id="6a285-154">Specifies a postcondition contract for the enclosing method or property.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6a285-155">O `condition` parâmetro especifica uma pós-condição que deve ser `true` quando a propriedade ou método delimitador normalmente retorna.</span><span class="sxs-lookup"><span data-stu-id="6a285-155">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property returns normally.</span></span>  
  
-   <span data-ttu-id="6a285-156">Esta chamada de método deve ser no início de um método ou propriedade, antes de qualquer outro código.</span><span class="sxs-lookup"><span data-stu-id="6a285-156">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="6a285-157">Você deve usar o regravador binário (disponível em [contratos de código](https://go.microsoft.com/fwlink/?LinkId=152461) no site do MSDN do DevLabs) para a imposição de tempo de execução desse pós-condição.</span><span class="sxs-lookup"><span data-stu-id="6a285-157">You must use the binary rewriter (available at [Code Contracts](https://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site) for run-time enforcement of this postcondition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6a285-158">O exemplo a seguir mostra como usar o <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> método para garantir que um valor esperado é retornado.</span><span class="sxs-lookup"><span data-stu-id="6a285-158">The following example shows how to use the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> method to ensure that an expected value is returned.</span></span> <span data-ttu-id="6a285-159">Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Diagnostics.Contracts.ContractClassAttribute> classe.</span><span class="sxs-lookup"><span data-stu-id="6a285-159">This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.</span></span>  
  
 [!code-csharp[ContractExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#3)]
 [!code-vb[ContractExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ensures">
      <MemberSignature Language="C#" Value="public static void Ensures (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ensures(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ensures (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Ensures(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Ensures : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Ensures (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="6a285-160">A expressão condicional a ser testada.</span><span class="sxs-lookup"><span data-stu-id="6a285-160">The conditional expression to test.</span></span> <span data-ttu-id="6a285-161">A expressão pode incluir os valores de <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" /> e <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-161">The expression may include <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" /> and <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> values.</span></span></param>
        <param name="userMessage"><span data-ttu-id="6a285-162">Uma mensagem a ser exibida se a expressão não for <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-162">The message to display if the expression is not <see langword="true" />.</span></span></param>
        <summary><span data-ttu-id="6a285-163">Especifica um contrato de pós-condição para uma condição de saída fornecida e uma mensagem a ser exibida se a condição for <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-163">Specifies a postcondition contract for a provided exit condition and a message to display if the condition is <see langword="false" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6a285-164">O `condition` parâmetro especifica uma pós-condição que deve ser `true` quando a propriedade ou método delimitador normalmente retorna.</span><span class="sxs-lookup"><span data-stu-id="6a285-164">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property returns normally.</span></span>  
  
-   <span data-ttu-id="6a285-165">Esta chamada de método deve ser no início de um método ou propriedade, antes de qualquer outro código.</span><span class="sxs-lookup"><span data-stu-id="6a285-165">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="6a285-166">Esse contrato é exposto aos clientes; Portanto, ele deve ser somente os membros de referência, pelo menos, tão visíveis quanto o método delimitador.</span><span class="sxs-lookup"><span data-stu-id="6a285-166">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="6a285-167">Você deve usar o regravador binário (disponível em [contratos de código](https://go.microsoft.com/fwlink/?LinkId=152461) no site do MSDN do DevLabs) para a imposição de tempo de execução desse pós-condição.</span><span class="sxs-lookup"><span data-stu-id="6a285-167">You must use the binary rewriter (available at [Code Contracts](https://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site) for run-time enforcement of this postcondition.</span></span>  
  
-   <span data-ttu-id="6a285-168">Se `userMessage` não é uma cadeia de caracteres constante literal, o contrato não pode ser compreendido por ferramentas.</span><span class="sxs-lookup"><span data-stu-id="6a285-168">If `userMessage` is not a constant string literal, the contract may not be understood by tools.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnsuresOnThrow&lt;TException&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6a285-169">Especifica um contrato de pós-condição para o método ou a propriedade delimitadora, com base na exceção e na condição fornecidas.</span><span class="sxs-lookup"><span data-stu-id="6a285-169">Specifies a postcondition contract for the enclosing method or property based on the provided exception and condition.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnsuresOnThrow&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void EnsuresOnThrow&lt;TException&gt; (bool condition) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsuresOnThrow&lt;(class System.Exception) TException&gt;(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnsuresOnThrow(Of TException As Exception) (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void EnsuresOnThrow(bool condition);" />
      <MemberSignature Language="F#" Value="static member EnsuresOnThrow : bool -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.EnsuresOnThrow condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TException"><span data-ttu-id="6a285-170">O tipo de exceção que invoca a verificação de pós-condição.</span><span class="sxs-lookup"><span data-stu-id="6a285-170">The type of exception that invokes the postcondition check.</span></span></typeparam>
        <param name="condition"><span data-ttu-id="6a285-171">A expressão condicional a ser testada.</span><span class="sxs-lookup"><span data-stu-id="6a285-171">The conditional expression to test.</span></span></param>
        <summary><span data-ttu-id="6a285-172">Especifica um contrato de pós-condição para o método ou a propriedade delimitadora, com base na exceção e na condição fornecidas.</span><span class="sxs-lookup"><span data-stu-id="6a285-172">Specifies a postcondition contract for the enclosing method or property, based on the provided exception and condition.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6a285-173">O `condition` parâmetro especifica uma pós-condição que deve ser `true` quando a propriedade ou método delimitador termina de maneira anormal e uma exceção do tipo `TException` é gerada.</span><span class="sxs-lookup"><span data-stu-id="6a285-173">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property terminates abnormally and an exception of type `TException` is thrown.</span></span>  
  
-   <span data-ttu-id="6a285-174">Esta chamada de método deve ser no início de um método ou propriedade, antes de qualquer outro código.</span><span class="sxs-lookup"><span data-stu-id="6a285-174">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="6a285-175">Esse contrato é exposto aos clientes; Portanto, ele deve ser somente os membros de referência, pelo menos, tão visíveis quanto o método delimitador.</span><span class="sxs-lookup"><span data-stu-id="6a285-175">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="6a285-176">Você deve usar o regravador binário para a imposição de tempo de execução desse pós-condição.</span><span class="sxs-lookup"><span data-stu-id="6a285-176">You must use the binary rewriter for run-time enforcement of this postcondition.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsuresOnThrow&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void EnsuresOnThrow&lt;TException&gt; (bool condition, string userMessage) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsuresOnThrow&lt;(class System.Exception) TException&gt;(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnsuresOnThrow(Of TException As Exception) (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void EnsuresOnThrow(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member EnsuresOnThrow : bool * string -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.EnsuresOnThrow (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TException"><span data-ttu-id="6a285-177">O tipo de exceção que invoca a verificação de pós-condição.</span><span class="sxs-lookup"><span data-stu-id="6a285-177">The type of exception that invokes the postcondition check.</span></span></typeparam>
        <param name="condition"><span data-ttu-id="6a285-178">A expressão condicional a ser testada.</span><span class="sxs-lookup"><span data-stu-id="6a285-178">The conditional expression to test.</span></span></param>
        <param name="userMessage"><span data-ttu-id="6a285-179">A mensagem a ser exibida se a expressão for <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-179">The message to display if the expression is <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="6a285-180">Especifica um contrato de pós-condição e uma mensagem a ser exibida se a condição for <see langword="false" /> para o método ou a propriedade delimitadora, com base na exceção e na condição fornecidas.</span><span class="sxs-lookup"><span data-stu-id="6a285-180">Specifies a postcondition contract and a message to display if the condition is <see langword="false" /> for the enclosing method or property, based on the provided exception and condition.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6a285-181">O `condition` parâmetro especifica uma pós-condição que deve ser `true` quando a propriedade ou método delimitador termina de maneira anormal e uma exceção do tipo `TException` é gerada.</span><span class="sxs-lookup"><span data-stu-id="6a285-181">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property terminates abnormally and an exception of type `TException` is thrown.</span></span> <span data-ttu-id="6a285-182">O `message` parâmetro especifica uma mensagem a ser exibida se a condição for `false`.</span><span class="sxs-lookup"><span data-stu-id="6a285-182">The `message` parameter specifies a message to display if the condition is `false`.</span></span>  
  
-   <span data-ttu-id="6a285-183">Esta chamada de método deve ser no início de um método ou propriedade, antes de qualquer outro código.</span><span class="sxs-lookup"><span data-stu-id="6a285-183">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="6a285-184">Esse contrato é exposto aos clientes; Portanto, ele deve ser somente os membros de referência, pelo menos, tão visíveis quanto o método delimitador.</span><span class="sxs-lookup"><span data-stu-id="6a285-184">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="6a285-185">Você deve usar o regravador binário para a imposição de tempo de execução desse pós-condição.</span><span class="sxs-lookup"><span data-stu-id="6a285-185">You must use the binary rewriter for run-time enforcement of this postcondition.</span></span>  
  
-   <span data-ttu-id="6a285-186">Se `userMessage` não é uma cadeia de caracteres constante literal, o contrato não pode ser compreendido por ferramentas.</span><span class="sxs-lookup"><span data-stu-id="6a285-186">If `userMessage` is not a constant string literal, the contract may not be understood by tools.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (int fromInclusive, int toExclusive, Predicate&lt;int&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(int32 fromInclusive, int32 toExclusive, class System.Predicate`1&lt;int32&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (fromInclusive As Integer, toExclusive As Integer, predicate As Predicate(Of Integer)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(int fromInclusive, int toExclusive, Predicate&lt;int&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Exists : int * int * Predicate&lt;int&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.Exists (fromInclusive, toExclusive, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="predicate" Type="System.Predicate&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="6a285-187">O primeiro inteiro a passar para <paramref name="predicate" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-187">The first integer to pass to <paramref name="predicate" />.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="6a285-188">Um a mais do que o último inteiro a passar para <paramref name="predicate" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-188">One more than the last integer to pass to <paramref name="predicate" />.</span></span></param>
        <param name="predicate"><span data-ttu-id="6a285-189">A função a ser avaliada para qualquer valor do inteiro no intervalo especificado.</span><span class="sxs-lookup"><span data-stu-id="6a285-189">The function to evaluate for any value of the integer in the specified range.</span></span></param>
        <summary><span data-ttu-id="6a285-190">Determina se um teste especificado é verdadeiro para qualquer inteiro dentro do intervalo de inteiros.</span><span class="sxs-lookup"><span data-stu-id="6a285-190">Determines whether a specified test is true for any integer within a range of integers.</span></span></summary>
        <returns><span data-ttu-id="6a285-191"><see langword="true" /> se <paramref name="predicate" /> retornar <see langword="true" /> para qualquer inteiro a partir de <paramref name="fromInclusive" /> para <paramref name="toExclusive" /> - 1.</span><span class="sxs-lookup"><span data-stu-id="6a285-191"><see langword="true" /> if <paramref name="predicate" /> returns <see langword="true" /> for any integer starting from <paramref name="fromInclusive" /> to <paramref name="toExclusive" /> - 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6a285-192">O `toExclusive` parâmetro é um mais do que o último inteiro para facilitar o uso o comprimento de um intervalo de inteiros começando em 0.</span><span class="sxs-lookup"><span data-stu-id="6a285-192">The `toExclusive` parameter is one more than the last integer to facilitate using the length of a range of integers starting at 0.</span></span> <span data-ttu-id="6a285-193">Por exemplo, ele seria definido para 5 para números inteiros de 0 a 4.</span><span class="sxs-lookup"><span data-stu-id="6a285-193">For example, it would be set to 5 for integers 0 through 4.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6a285-194"><paramref name="predicate" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-194"><paramref name="predicate" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6a285-195"><paramref name="toExclusive" /> é menor que <paramref name="fromInclusive" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-195"><paramref name="toExclusive" /> is less than <paramref name="fromInclusive" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; collection, class System.Predicate`1&lt;!!T&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (collection As IEnumerable(Of T), predicate As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, Predicate&lt;T&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Exists : seq&lt;'T&gt; * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.Exists (collection, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="predicate" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="6a285-196">O tipo que está contido em <paramref name="collection" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-196">The type that is contained in <paramref name="collection" />.</span></span></typeparam>
        <param name="collection"><span data-ttu-id="6a285-197">A coleção da qual os elementos do tipo <c>T</c> serão desenhados para serem passados para <paramref name="predicate" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-197">The collection from which elements of type <c>T</c> will be drawn to pass to <paramref name="predicate" />.</span></span></param>
        <param name="predicate"><span data-ttu-id="6a285-198">A função a ser avaliada para um elemento na <paramref name="collection" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-198">The function to evaluate for an element in <paramref name="collection" />.</span></span></param>
        <summary><span data-ttu-id="6a285-199">Determina se um elemento em uma coleção de elementos existe dentro de uma função.</span><span class="sxs-lookup"><span data-stu-id="6a285-199">Determines whether an element within a collection of elements exists within a function.</span></span></summary>
        <returns><span data-ttu-id="6a285-200"><see langword="true" /> se e somente se <paramref name="predicate" /> retornar <see langword="true" /> para qualquer elemento do tipo <paramref name="T" /> em <paramref name="collection" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-200"><see langword="true" /> if and only if <paramref name="predicate" /> returns <see langword="true" /> for any element of type <paramref name="T" /> in <paramref name="collection" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6a285-201"><paramref name="collection" /> ou <paramref name="predicate" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-201"><paramref name="collection" /> or <paramref name="predicate" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      </Docs>
    </Member>
    <Member MemberName="ForAll">
      <MemberSignature Language="C#" Value="public static bool ForAll (int fromInclusive, int toExclusive, Predicate&lt;int&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ForAll(int32 fromInclusive, int32 toExclusive, class System.Predicate`1&lt;int32&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForAll (fromInclusive As Integer, toExclusive As Integer, predicate As Predicate(Of Integer)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ForAll(int fromInclusive, int toExclusive, Predicate&lt;int&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member ForAll : int * int * Predicate&lt;int&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.ForAll (fromInclusive, toExclusive, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="predicate" Type="System.Predicate&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="6a285-202">O primeiro inteiro a passar para <paramref name="predicate" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-202">The first integer to pass to <paramref name="predicate" />.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="6a285-203">Um a mais do que o último inteiro a passar para <paramref name="predicate" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-203">One more than the last integer to pass to <paramref name="predicate" />.</span></span></param>
        <param name="predicate"><span data-ttu-id="6a285-204">A função para avaliar a existência de inteiros no intervalo especificado.</span><span class="sxs-lookup"><span data-stu-id="6a285-204">The function to evaluate for the existence of the integers in the specified range.</span></span></param>
        <summary><span data-ttu-id="6a285-205">Determina se uma determinada condição é válida para todos os números inteiros em um intervalo especificado.</span><span class="sxs-lookup"><span data-stu-id="6a285-205">Determines whether a particular condition is valid for all integers in a specified range.</span></span></summary>
        <returns><span data-ttu-id="6a285-206"><see langword="true" /> se <paramref name="predicate" /> retornar <see langword="true" /> para todos os inteiros a partir de <paramref name="fromInclusive" /> para <paramref name="toExclusive" /> ‑ 1.</span><span class="sxs-lookup"><span data-stu-id="6a285-206"><see langword="true" /> if <paramref name="predicate" /> returns <see langword="true" /> for all integers starting from <paramref name="fromInclusive" /> to <paramref name="toExclusive" /> - 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6a285-207">O `toExclusive` parâmetro é um mais do que o último inteiro para facilitar o uso o comprimento de um intervalo de inteiros começando em 0.</span><span class="sxs-lookup"><span data-stu-id="6a285-207">The `toExclusive` parameter is one more than the last integer to facilitate using the length of a range of integers starting at 0.</span></span> <span data-ttu-id="6a285-208">Por exemplo, ele seria definido para 5 para números inteiros de 0 a 4.</span><span class="sxs-lookup"><span data-stu-id="6a285-208">For example, it would be set to 5 for integers 0 through 4.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6a285-209">O exemplo a seguir demonstra como usar o <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> método para determinar se uma matriz tem um elemento nulo.</span><span class="sxs-lookup"><span data-stu-id="6a285-209">The following example demonstrates how to use the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> method to determine whether an array has a null element.</span></span>  
  
 [!code-csharp[Contract.ForAllExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/contract.forallexample/cs/program.cs#1)]
 [!code-vb[Contract.ForAllExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/contract.forallexample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6a285-210"><paramref name="predicate" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-210"><paramref name="predicate" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6a285-211"><paramref name="toExclusive" /> é menor que <paramref name="fromInclusive" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-211"><paramref name="toExclusive" /> is less than <paramref name="fromInclusive" />.</span></span></exception>
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      </Docs>
    </Member>
    <Member MemberName="ForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool ForAll&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ForAll&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; collection, class System.Predicate`1&lt;!!T&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForAll(Of T) (collection As IEnumerable(Of T), predicate As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool ForAll(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, Predicate&lt;T&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member ForAll : seq&lt;'T&gt; * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.ForAll (collection, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="predicate" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="6a285-212">O tipo que está contido em <paramref name="collection" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-212">The type that is contained in <paramref name="collection" />.</span></span></typeparam>
        <param name="collection"><span data-ttu-id="6a285-213">A coleção da qual os elementos do tipo <c>T</c> serão desenhados para serem passados para <paramref name="predicate" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-213">The collection from which elements of type <c>T</c> will be drawn to pass to <paramref name="predicate" />.</span></span></param>
        <param name="predicate"><span data-ttu-id="6a285-214">A função a ser avaliada quanto à existência de todos os elementos em <paramref name="collection" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-214">The function to evaluate for the existence of all the elements in <paramref name="collection" />.</span></span></param>
        <summary><span data-ttu-id="6a285-215">Determina se todos os elementos de uma coleção existem em uma função.</span><span class="sxs-lookup"><span data-stu-id="6a285-215">Determines whether all the elements in a collection exist within a function.</span></span></summary>
        <returns><span data-ttu-id="6a285-216"><see langword="true" /> se e somente se <paramref name="predicate" /> retornar <see langword="true" /> para todos os elementos do tipo <paramref name="T" /> em <paramref name="collection" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-216"><see langword="true" /> if and only if <paramref name="predicate" /> returns <see langword="true" /> for all elements of type <paramref name="T" /> in <paramref name="collection" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="6a285-217">O exemplo a seguir demonstra como usar o <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> método para determinar se uma coleção tem um elemento nulo.</span><span class="sxs-lookup"><span data-stu-id="6a285-217">The following example demonstrates how to use the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> method to determine whether a collection has a null element.</span></span>  
  
 [!code-csharp[Contract.ForAllExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/contract.forallexample/cs/program.cs#1)]
 [!code-vb[Contract.ForAllExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/contract.forallexample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6a285-218"><paramref name="collection" /> ou <paramref name="predicate" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-218"><paramref name="collection" /> or <paramref name="predicate" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invariant">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6a285-219">Especifica um contrato para um método ou uma propriedade delimitadora.</span><span class="sxs-lookup"><span data-stu-id="6a285-219">Specifies a contract for an enclosing method or property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invariant">
      <MemberSignature Language="C#" Value="public static void Invariant (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invariant(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invariant (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invariant(bool condition);" />
      <MemberSignature Language="F#" Value="static member Invariant : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Invariant condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="6a285-220">A expressão condicional a ser testada.</span><span class="sxs-lookup"><span data-stu-id="6a285-220">The conditional expression to test.</span></span></param>
        <summary><span data-ttu-id="6a285-221">Especifica um contrato invariável para o método ou a propriedade delimitadora.</span><span class="sxs-lookup"><span data-stu-id="6a285-221">Specifies an invariant contract for the enclosing method or property.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6a285-222"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> contratos estão contidos dentro de um método que é identificado pelo <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> atributo; normalmente, o método é chamado `ObjectInvariant`.</span><span class="sxs-lookup"><span data-stu-id="6a285-222"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> contracts are contained within a method that is identified by the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute; typically, the method is named `ObjectInvariant`.</span></span>  
  
-   <span data-ttu-id="6a285-223">Esse contrato pode ser especificado somente em um método invariável dedicado que é declarado em uma classe.</span><span class="sxs-lookup"><span data-stu-id="6a285-223">This contract can be specified only in a dedicated invariant method that is declared on a class.</span></span> <span data-ttu-id="6a285-224">Se o método não for fechado, ela deve se referir somente para membros protegidos, não membros privados, para que as subclasses podem não se esqueça de manter as invariáveis.</span><span class="sxs-lookup"><span data-stu-id="6a285-224">If the method is not sealed, it should refer only to protected members, not private members, so that subclasses can be sure to maintain the invariants.</span></span>  
  
-   <span data-ttu-id="6a285-225">Este contrato não é exposto aos clientes; Portanto, ele pode fazer referência a membros que são menos visíveis que o método delimitador.</span><span class="sxs-lookup"><span data-stu-id="6a285-225">This contract is not exposed to clients; therefore, it may reference members that are less visible than the enclosing method.</span></span>  
  
-   <span data-ttu-id="6a285-226">Você deve usar o regravador binário para a imposição de invariável nesse tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="6a285-226">You must use the binary rewriter for run-time enforcement of this invariant.</span></span>  
  
-   <span data-ttu-id="6a285-227">As invariáveis são definidas condicionalmente com base na presença do `CONTRACTS FULL` símbolo.</span><span class="sxs-lookup"><span data-stu-id="6a285-227">Invariants are conditionally defined based on the presence of the `CONTRACTS FULL` symbol.</span></span> <span data-ttu-id="6a285-228">Durante a verificação em tempo de execução, as invariáveis são verificadas ao final de cada método público.</span><span class="sxs-lookup"><span data-stu-id="6a285-228">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="6a285-229">Se uma invariável mencionar um método público na mesma classe, a verificação de invariáveis que normalmente ocorre no final do método público é desabilitada e verificada somente no final da chamada de método externa para essa classe.</span><span class="sxs-lookup"><span data-stu-id="6a285-229">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled and checked only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="6a285-230">Isso também ocorrerá se a classe for inserida novamente devido a uma chamada a um método em outra classe.</span><span class="sxs-lookup"><span data-stu-id="6a285-230">This also happens if the class is re-entered because of a call to a method on another class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invariant">
      <MemberSignature Language="C#" Value="public static void Invariant (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invariant(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invariant (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invariant(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Invariant : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Invariant (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="6a285-231">A expressão condicional a ser testada.</span><span class="sxs-lookup"><span data-stu-id="6a285-231">The conditional expression to test.</span></span></param>
        <param name="userMessage"><span data-ttu-id="6a285-232">A mensagem a ser exibida se a condição for <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-232">The message to display if the condition is <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="6a285-233">Especifica um contrato invariável para a propriedade ou o método delimitador e exibe uma mensagem se a condição para o contrato falhar.</span><span class="sxs-lookup"><span data-stu-id="6a285-233">Specifies an invariant contract for the enclosing method or property, and displays a message if the condition for the contract fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6a285-234"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> contratos estão contidos dentro de um método que é identificado pelo <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> atributo; normalmente, o método é chamado `ObjectInvariant`.</span><span class="sxs-lookup"><span data-stu-id="6a285-234"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> contracts are contained within a method that is identified by the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute; typically, the method is named `ObjectInvariant`.</span></span>  
  
-   <span data-ttu-id="6a285-235">Esse contrato pode ser especificado somente em um método invariável dedicado que é declarado em uma classe.</span><span class="sxs-lookup"><span data-stu-id="6a285-235">This contract can be specified only in a dedicated invariant method that is declared on a class.</span></span>  
  
-   <span data-ttu-id="6a285-236">Este contrato não é exposto aos clientes; Portanto, ele pode fazer referência a membros que são menos visíveis que o método delimitador.</span><span class="sxs-lookup"><span data-stu-id="6a285-236">This contract is not exposed to clients; therefore, it may reference members that are less visible than the enclosing method.</span></span>  
  
-   <span data-ttu-id="6a285-237">Você deve usar o regravador binário para a imposição de invariável nesse tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="6a285-237">You must use the binary rewriter for run-time enforcement of this invariant.</span></span>  
  
-   <span data-ttu-id="6a285-238">As invariáveis são definidas condicionalmente no `CONTRACTS FULL` símbolo.</span><span class="sxs-lookup"><span data-stu-id="6a285-238">Invariants are conditionally defined on the `CONTRACTS FULL` symbol.</span></span> <span data-ttu-id="6a285-239">Durante a verificação em tempo de execução, as invariáveis são verificadas ao final de cada método público.</span><span class="sxs-lookup"><span data-stu-id="6a285-239">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="6a285-240">Se uma invariável mencionar um método público na mesma classe, a verificação de invariáveis que normalmente ocorre no final do método público é desabilitada e verificada somente no final da chamada de método externa para essa classe.</span><span class="sxs-lookup"><span data-stu-id="6a285-240">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled and checked only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="6a285-241">Isso também ocorrerá se a classe for inserida novamente devido a uma chamada a um método em outra classe.</span><span class="sxs-lookup"><span data-stu-id="6a285-241">This also happens if the class is re-entered because of a call to a method on another class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OldValue&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T OldValue&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T OldValue&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OldValue(Of T) (value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T OldValue(T value);" />
      <MemberSignature Language="F#" Value="static member OldValue : 'T -&gt; 'T" Usage="System.Diagnostics.Contracts.Contract.OldValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="6a285-242">O tipo do valor.</span><span class="sxs-lookup"><span data-stu-id="6a285-242">The type of value.</span></span></typeparam>
        <param name="value"><span data-ttu-id="6a285-243">O valor a ser representado (campo ou parâmetro).</span><span class="sxs-lookup"><span data-stu-id="6a285-243">The value to represent (field or parameter).</span></span></param>
        <summary><span data-ttu-id="6a285-244">Representa valores como eram no início de um método ou propriedade.</span><span class="sxs-lookup"><span data-stu-id="6a285-244">Represents values as they were at the start of a method or property.</span></span></summary>
        <returns><span data-ttu-id="6a285-245">O valor do parâmetro ou campo no início de um método ou propriedade.</span><span class="sxs-lookup"><span data-stu-id="6a285-245">The value of the parameter or field at the start of a method or property.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6a285-246">Esse método pode ser usado apenas em uma expressão condicional para o <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contrato.</span><span class="sxs-lookup"><span data-stu-id="6a285-246">This method can be used only in the conditional expression for the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contract.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6a285-247">O exemplo a seguir mostra o uso do <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> método para garantir que uma contagem foi atualizada.</span><span class="sxs-lookup"><span data-stu-id="6a285-247">The following example shows the use of the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method to ensure that a count has been updated.</span></span> <span data-ttu-id="6a285-248">Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Diagnostics.Contracts.ContractClassAttribute> classe.</span><span class="sxs-lookup"><span data-stu-id="6a285-248">This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.</span></span>  
  
 [!code-csharp[ContractExample#5](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#5)]
 [!code-vb[ContractExample#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Requires">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6a285-249">Especifica um contrato de pré-condição para um método ou uma propriedade delimitadora.</span><span class="sxs-lookup"><span data-stu-id="6a285-249">Specifies a precondition contract for an enclosing method or property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Requires">
      <MemberSignature Language="C#" Value="public static void Requires (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Requires(bool condition);" />
      <MemberSignature Language="F#" Value="static member Requires : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Requires condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="6a285-250">A expressão condicional a ser testada.</span><span class="sxs-lookup"><span data-stu-id="6a285-250">The conditional expression to test.</span></span></param>
        <summary><span data-ttu-id="6a285-251">Especifica um contrato de pré-condição para o método ou a propriedade delimitadora.</span><span class="sxs-lookup"><span data-stu-id="6a285-251">Specifies a precondition contract for the enclosing method or property.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   <span data-ttu-id="6a285-252">Esta chamada de método deve ser no início de um método ou propriedade, antes de qualquer outro código.</span><span class="sxs-lookup"><span data-stu-id="6a285-252">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="6a285-253">Esse contrato é exposto aos clientes; Portanto, ele deve ser somente os membros de referência, pelo menos, tão visíveis quanto o método delimitador.</span><span class="sxs-lookup"><span data-stu-id="6a285-253">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="6a285-254">Use esse método em vez do <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%29?displayProperty=nameWithType> método quando a compatibilidade com versões anteriores não força a gerar uma exceção específica.</span><span class="sxs-lookup"><span data-stu-id="6a285-254">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%29?displayProperty=nameWithType> method when backward compatibility does not force you to throw a particular exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires">
      <MemberSignature Language="C#" Value="public static void Requires (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Requires(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Requires : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Requires (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="6a285-255">A expressão condicional a ser testada.</span><span class="sxs-lookup"><span data-stu-id="6a285-255">The conditional expression to test.</span></span></param>
        <param name="userMessage"><span data-ttu-id="6a285-256">A mensagem a ser exibida se a condição for <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-256">The message to display if the condition is <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="6a285-257">Especifica um contrato de precondição para a propriedade ou o método delimitador e exibe uma mensagem se a condição para o contrato falhar.</span><span class="sxs-lookup"><span data-stu-id="6a285-257">Specifies a precondition contract for the enclosing method or property, and displays a message if the condition for the contract fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   <span data-ttu-id="6a285-258">Esta chamada de método deve ser no início de um método ou propriedade, antes de qualquer outro código.</span><span class="sxs-lookup"><span data-stu-id="6a285-258">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="6a285-259">Esse contrato é exposto aos clientes; Portanto, ele deve ser somente os membros de referência, pelo menos, tão visíveis quanto o método delimitador.</span><span class="sxs-lookup"><span data-stu-id="6a285-259">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="6a285-260">Use esse método em vez do <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> método quando a compatibilidade com versões anteriores não força a gerar uma exceção específica.</span><span class="sxs-lookup"><span data-stu-id="6a285-260">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> method when backward compatibility does not force you to throw a particular exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void Requires&lt;TException&gt; (bool condition) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires&lt;(class System.Exception) TException&gt;(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires(Of TException As Exception) (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void Requires(bool condition);" />
      <MemberSignature Language="F#" Value="static member Requires : bool -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.Requires condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TException"><span data-ttu-id="6a285-261">A exceção a ser lançada se a condição for <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-261">The exception to throw if the condition is <see langword="false" />.</span></span></typeparam>
        <param name="condition"><span data-ttu-id="6a285-262">A expressão condicional a ser testada.</span><span class="sxs-lookup"><span data-stu-id="6a285-262">The conditional expression to test.</span></span></param>
        <summary><span data-ttu-id="6a285-263">Especifica um contrato de precondição para a propriedade ou o método delimitador e lança uma exceção se a condição para o contrato falhar.</span><span class="sxs-lookup"><span data-stu-id="6a285-263">Specifies a precondition contract for the enclosing method or property, and throws an exception if the condition for the contract fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="6a285-264">Você deve ativar a verificação para usar o tempo de execução a <xref:System.Diagnostics.Contracts.Contract.Requires%2A> método.</span><span class="sxs-lookup"><span data-stu-id="6a285-264">You must turn on run-time checking to use the <xref:System.Diagnostics.Contracts.Contract.Requires%2A> method.</span></span> <span data-ttu-id="6a285-265">Se a verificação de tempo de execução estiver desativada, o processo será encerrado.</span><span class="sxs-lookup"><span data-stu-id="6a285-265">If run-time checking is turned off, the process will be terminated.</span></span> <span data-ttu-id="6a285-266">Para obter as ferramentas de verificação de tempo de execução, consulte [contratos de código](https://go.microsoft.com/fwlink/?LinkId=152461) no site do MSDN do DevLabs.</span><span class="sxs-lookup"><span data-stu-id="6a285-266">To obtain the tools for runtime checking, see [Code Contracts](https://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span>  
  
-   <span data-ttu-id="6a285-267">Esta chamada de método deve ser no início de um método ou propriedade, antes de qualquer outro código.</span><span class="sxs-lookup"><span data-stu-id="6a285-267">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="6a285-268">Esse contrato é exposto aos clientes; Portanto, ele deve ser somente os membros de referência, pelo menos, tão visíveis quanto o método delimitador.</span><span class="sxs-lookup"><span data-stu-id="6a285-268">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="6a285-269">Use esse método em vez do <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%29?displayProperty=nameWithType> método quando quiser lançar uma exceção se a pré-condição falhar.</span><span class="sxs-lookup"><span data-stu-id="6a285-269">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%29?displayProperty=nameWithType> method when you want to throw an exception if the precondition fails.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void Requires&lt;TException&gt; (bool condition, string userMessage) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires&lt;(class System.Exception) TException&gt;(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires(Of TException As Exception) (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void Requires(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Requires : bool * string -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.Requires (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TException"><span data-ttu-id="6a285-270">A exceção a ser lançada se a condição for <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-270">The exception to throw if the condition is <see langword="false" />.</span></span></typeparam>
        <param name="condition"><span data-ttu-id="6a285-271">A expressão condicional a ser testada.</span><span class="sxs-lookup"><span data-stu-id="6a285-271">The conditional expression to test.</span></span></param>
        <param name="userMessage"><span data-ttu-id="6a285-272">A mensagem a ser exibida se a condição for <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-272">The message to display if the condition is <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="6a285-273">Especifica um contrato de precondição para a propriedade ou o método delimitador e lança uma exceção com a mensagem fornecida se a condição para o contrato falhar.</span><span class="sxs-lookup"><span data-stu-id="6a285-273">Specifies a precondition contract for the enclosing method or property, and throws an exception with the provided message if the condition for the contract fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   > [!IMPORTANT]
    >  <span data-ttu-id="6a285-274">Você deve ativar a verificação para usar o tempo de execução a <xref:System.Diagnostics.Contracts.Contract.Requires%2A> método.</span><span class="sxs-lookup"><span data-stu-id="6a285-274">You must turn on run-time checking to use the <xref:System.Diagnostics.Contracts.Contract.Requires%2A> method.</span></span> <span data-ttu-id="6a285-275">Se a verificação de tempo de execução estiver desativada, o processo será encerrado.</span><span class="sxs-lookup"><span data-stu-id="6a285-275">If run-time checking is turned off, the process will be terminated.</span></span> <span data-ttu-id="6a285-276">Para obter as ferramentas de verificação de tempo de execução, consulte [contratos de código](https://go.microsoft.com/fwlink/?LinkId=152461) no site do MSDN do DevLabs.</span><span class="sxs-lookup"><span data-stu-id="6a285-276">To obtain the tools for runtime checking, see [Code Contracts](https://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span>  
  
     <span data-ttu-id="6a285-277">Esta chamada de método deve ser no início de um método ou propriedade, antes de qualquer outro código.</span><span class="sxs-lookup"><span data-stu-id="6a285-277">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="6a285-278">Esse contrato é exposto aos clientes; Portanto, ele deve ser somente os membros de referência, pelo menos, tão visíveis quanto o método delimitador.</span><span class="sxs-lookup"><span data-stu-id="6a285-278">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="6a285-279">Use esse método em vez do <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> método quando quiser lançar uma exceção se a pré-condição falhar.</span><span class="sxs-lookup"><span data-stu-id="6a285-279">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> method when you want to throw an exception if the precondition fails.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Result&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Result&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Result&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Result``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Result(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Result();" />
      <MemberSignature Language="F#" Value="static member Result : unit -&gt; 'T" Usage="System.Diagnostics.Contracts.Contract.Result " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T"><span data-ttu-id="6a285-280">Tipo de valor retornado do método ou da propriedade delimitadora.</span><span class="sxs-lookup"><span data-stu-id="6a285-280">Type of return value of the enclosing method or property.</span></span></typeparam>
        <summary><span data-ttu-id="6a285-281">Representa o valor retornado de um método ou uma propriedade.</span><span class="sxs-lookup"><span data-stu-id="6a285-281">Represents the return value of a method or property.</span></span></summary>
        <returns><span data-ttu-id="6a285-282">Valor retornado do método ou da propriedade delimitadora.</span><span class="sxs-lookup"><span data-stu-id="6a285-282">Return value of the enclosing method or property.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6a285-283">Esse método pode ser usado apenas em uma expressão condicional para o <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contrato.</span><span class="sxs-lookup"><span data-stu-id="6a285-283">This method can be used only in the conditional expression for the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contract.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6a285-284">O exemplo a seguir mostra como usar o <xref:System.Diagnostics.Contracts.Contract.Result%2A> método para especificar um valor de retorno esperado.</span><span class="sxs-lookup"><span data-stu-id="6a285-284">The following example shows how to use the <xref:System.Diagnostics.Contracts.Contract.Result%2A> method to specify an expected return value.</span></span> <span data-ttu-id="6a285-285">Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Diagnostics.Contracts.ContractClassAttribute> classe.</span><span class="sxs-lookup"><span data-stu-id="6a285-285">This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.</span></span>  
  
 [!code-csharp[ContractExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#3)]
 [!code-vb[ContractExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueAtReturn&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T ValueAtReturn&lt;T&gt; (out T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T ValueAtReturn&lt;T&gt;([out] !!T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ValueAtReturn(Of T) (ByRef value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T ValueAtReturn([Runtime::InteropServices::Out] T % value);" />
      <MemberSignature Language="F#" Value="static member ValueAtReturn :  -&gt; 'T" Usage="System.Diagnostics.Contracts.Contract.ValueAtReturn value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="6a285-286">O tipo do parâmetro <see langword="out" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-286">The type of the <see langword="out" /> parameter.</span></span></typeparam>
        <param name="value"><span data-ttu-id="6a285-287">O parâmetro <see langword="out" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-287">The <see langword="out" /> parameter.</span></span></param>
        <summary><span data-ttu-id="6a285-288">Representa o valor final (a saída) de um parâmetro <see langword="out" /> ao retornar de um método.</span><span class="sxs-lookup"><span data-stu-id="6a285-288">Represents the final (output) value of an <see langword="out" /> parameter when returning from a method.</span></span></summary>
        <returns><span data-ttu-id="6a285-289">O valor de saída do parâmetro <see langword="out" />.</span><span class="sxs-lookup"><span data-stu-id="6a285-289">The output value of the <see langword="out" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6a285-290">Esse método pode ser usado apenas em uma expressão condicional para o <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contrato.</span><span class="sxs-lookup"><span data-stu-id="6a285-290">This method can be used only in the conditional expression for the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contract.</span></span> <span data-ttu-id="6a285-291">Assim como ocorre com o método <xref:System.Diagnostics.Contracts.Contract.OldValue%2A>, é possível omitir o parâmetro de tipo genérico sempre que o compilador pode inferir seu tipo.</span><span class="sxs-lookup"><span data-stu-id="6a285-291">As with the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method, you can omit the generic type parameter whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="6a285-292">O reescritor de contrato substitui a chamada de método pelo valor do parâmetro `out`.</span><span class="sxs-lookup"><span data-stu-id="6a285-292">The contract rewriter replaces the method call with the value of the `out` parameter.</span></span> <span data-ttu-id="6a285-293">O método <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> pode aparecer somente em pós-condições.</span><span class="sxs-lookup"><span data-stu-id="6a285-293">The <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method may appear only in postconditions.</span></span> <span data-ttu-id="6a285-294">O argumento para o método deve ser um parâmetro `out` ou um campo de um parâmetro `out` de estrutura.</span><span class="sxs-lookup"><span data-stu-id="6a285-294">The argument to the method must be an `out` parameter or a field of a structure `out` parameter.</span></span> <span data-ttu-id="6a285-295">Esse último também é útil ao se referir a campos na pós-condição de um construtor de estrutura.</span><span class="sxs-lookup"><span data-stu-id="6a285-295">The latter is also useful when referring to fields in the postcondition of a structure constructor.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>