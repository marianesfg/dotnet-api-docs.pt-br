<Type Name="AssemblyLoadContext" FullName="System.Runtime.Loader.AssemblyLoadContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e3cdf5b1dd5217e7f54ec5ce6fcb7f581a871d9d" /><Meta Name="ms.sourcegitcommit" Value="4ee26ac79338b0bf99fa1e0913e8a06b21994d8e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="03/26/2019" /><Meta Name="ms.locfileid" Value="58455206" /></Metadata><TypeSignature Language="C#" Value="public abstract class AssemblyLoadContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit AssemblyLoadContext extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Loader.AssemblyLoadContext" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class AssemblyLoadContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class AssemblyLoadContext abstract" />
  <TypeSignature Language="F#" Value="type AssemblyLoadContext = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Loader</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="b3e73-101">Representa o conceito de tempo de execução de um escopo para a associação.</span><span class="sxs-lookup"><span data-stu-id="b3e73-101">Represents the runtime's concept of a scope for binding.</span></span> <span data-ttu-id="b3e73-102">Esta classe é abstrata.</span><span class="sxs-lookup"><span data-stu-id="b3e73-102">This class is abstract.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b3e73-103">O <xref:System.Runtime.Loader.AssemblyLoadContext> representa um contexto de carregamento.</span><span class="sxs-lookup"><span data-stu-id="b3e73-103">The <xref:System.Runtime.Loader.AssemblyLoadContext> represents a load context.</span></span> <span data-ttu-id="b3e73-104">Conceitualmente, um contexto de carga cria um escopo para carregamento, resolvendo e potencialmente descarregando um conjunto de assemblies.</span><span class="sxs-lookup"><span data-stu-id="b3e73-104">Conceptually, a load context creates a scope for loading, resolving, and potentially unloading a set of assemblies.</span></span>
 
 <span data-ttu-id="b3e73-105"><xref:System.Runtime.Loader.AssemblyLoadContext> é uma classe abstrata.</span><span class="sxs-lookup"><span data-stu-id="b3e73-105"><xref:System.Runtime.Loader.AssemblyLoadContext> is an abstract class.</span></span> <span data-ttu-id="b3e73-106">O <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> precisa ser implementado para criar uma classe concreta.</span><span class="sxs-lookup"><span data-stu-id="b3e73-106">The <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> needs to be implemented to create a concrete class.</span></span>
 
 <span data-ttu-id="b3e73-107">O <xref:System.Runtime.Loader.AssemblyLoadContext> existe principalmente para fornecer isolamento de associação de assembly.</span><span class="sxs-lookup"><span data-stu-id="b3e73-107">The <xref:System.Runtime.Loader.AssemblyLoadContext> exists primarily to provide assembly binding isolation.</span></span> <span data-ttu-id="b3e73-108">Ele permite que várias versões do mesmo assembly a ser carregado em um único processo.</span><span class="sxs-lookup"><span data-stu-id="b3e73-108">It allows multiple versions of the same assembly to be loaded within a single process.</span></span> <span data-ttu-id="b3e73-109">Ele substitui os mecanismos de isolamento fornecidos por vários <xref:System.AppDomain> instâncias no .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="b3e73-109">It replaces the isolation mechanisms provided by multiple <xref:System.AppDomain> instances in the .NET Framework.</span></span>
 
 > [!NOTE]
 > <span data-ttu-id="b3e73-110"><xref:System.Runtime.Loader.AssemblyLoadContext> não fornece quaisquer recursos de segurança.</span><span class="sxs-lookup"><span data-stu-id="b3e73-110"><xref:System.Runtime.Loader.AssemblyLoadContext> does not provide any security features.</span></span> <span data-ttu-id="b3e73-111">Todo o código tem permissão total do processo.</span><span class="sxs-lookup"><span data-stu-id="b3e73-111">All code has full permissions of the process.</span></span>

### <a name="usage-in-the-runtime"></a><span data-ttu-id="b3e73-112">Uso no tempo de execução</span><span class="sxs-lookup"><span data-stu-id="b3e73-112">Usage in the runtime</span></span>
 <span data-ttu-id="b3e73-113">O tempo de execução implementa dois contextos de carregamento de assembly:</span><span class="sxs-lookup"><span data-stu-id="b3e73-113">The runtime implements two assembly load contexts:</span></span>
 * <span data-ttu-id="b3e73-114"><xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> representa o contexto de associação de padrão do tempo de execução que é usado para o assembly principal do aplicativo e suas dependências estáticas.</span><span class="sxs-lookup"><span data-stu-id="b3e73-114"><xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> represents the runtime's default binding context which is used for the application main assembly and its static dependencies.</span></span>
 * <span data-ttu-id="b3e73-115">O <xref:System.Reflection.Assembly.LoadFile(System.String)?displayProperty=nameWithType> método isola os assemblies que ele carrega instanciando mais básica <xref:System.Runtime.Loader.AssemblyLoadContext>.</span><span class="sxs-lookup"><span data-stu-id="b3e73-115">The <xref:System.Reflection.Assembly.LoadFile(System.String)?displayProperty=nameWithType> method isolates the assemblies it loads by instantiating the most basic <xref:System.Runtime.Loader.AssemblyLoadContext>.</span></span> <span data-ttu-id="b3e73-116">Ele tem um esquema de isolamento simplista que carrega cada assembly em seu próprio <xref:System.Runtime.Loader.AssemblyLoadContext> sem resolução de dependência.</span><span class="sxs-lookup"><span data-stu-id="b3e73-116">It has a simplistic isolation scheme which loads each assembly in its own <xref:System.Runtime.Loader.AssemblyLoadContext> with no dependency resolution.</span></span>
 
### <a name="application-usage"></a><span data-ttu-id="b3e73-117">Uso do aplicativo</span><span class="sxs-lookup"><span data-stu-id="b3e73-117">Application usage</span></span>
 <span data-ttu-id="b3e73-118">Um aplicativo pode criar seu próprio <xref:System.Runtime.Loader.AssemblyLoadContext> para criar uma solução personalizada para cenários de associação avançada.</span><span class="sxs-lookup"><span data-stu-id="b3e73-118">An application can create its own <xref:System.Runtime.Loader.AssemblyLoadContext> to create a custom solution for advanced binding scenarios.</span></span> <span data-ttu-id="b3e73-119">A personalização se concentra na definição de mecanismos de resolução de dependência.</span><span class="sxs-lookup"><span data-stu-id="b3e73-119">The customization focuses on defining dependency resolution mechanisms.</span></span>
 
 <span data-ttu-id="b3e73-120">O <xref:System.Runtime.Loader.AssemblyLoadContext> fornece dois pontos de extensão para implementar a resolução de assembly gerenciado:</span><span class="sxs-lookup"><span data-stu-id="b3e73-120">The <xref:System.Runtime.Loader.AssemblyLoadContext> provides two extension points to implement managed assembly resolution:</span></span>
 1. <span data-ttu-id="b3e73-121">O <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> fornece a primeira oportunidade para o <xref:System.Runtime.Loader.AssemblyLoadContext> para resolver o assembly, carregá-lo e retorná-lo.</span><span class="sxs-lookup"><span data-stu-id="b3e73-121">The <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> provides the first chance for the <xref:System.Runtime.Loader.AssemblyLoadContext> to resolve the assembly, load it and return it.</span></span> <span data-ttu-id="b3e73-122">Se o <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> retorna `null`, o carregador tenta carregar o assembly no <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b3e73-122">If the <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> returns `null`, the loader will try to load the assembly into the <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span></span>
 2. <span data-ttu-id="b3e73-123">Se o <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> não pode resolver o assembly, o original <xref:System.Runtime.Loader.AssemblyLoadContext> obtém uma segunda chance para resolver o assembly.</span><span class="sxs-lookup"><span data-stu-id="b3e73-123">If the <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> is unable to resolve the assembly, the original <xref:System.Runtime.Loader.AssemblyLoadContext> gets a second chance to resolve the assembly.</span></span> <span data-ttu-id="b3e73-124">O tempo de execução gera o <xref:System.Runtime.Loader.AssemblyLoadContext.Resolving> eventos.</span><span class="sxs-lookup"><span data-stu-id="b3e73-124">The runtime raises the <xref:System.Runtime.Loader.AssemblyLoadContext.Resolving> event.</span></span>
 
 <span data-ttu-id="b3e73-125">Além do <xref:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDll(System.String)?displayProperty=nameWithType> método virtual permite a personalização da resolução de assembly padrão não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b3e73-125">Additionally the <xref:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDll(System.String)?displayProperty=nameWithType> virtual method allows customization of the default unmanaged assembly resolution.</span></span> <span data-ttu-id="b3e73-126">A implementação padrão retorna `null`, que faz com que a pesquisa de tempo de execução usar sua diretiva de pesquisa padrão que é suficiente para a maioria dos cenários.</span><span class="sxs-lookup"><span data-stu-id="b3e73-126">The default implementation returns `null`, which causes the runtime search to use its default search policy which is sufficient for most scenarios.</span></span>

### <a name="technical-challenges"></a><span data-ttu-id="b3e73-127">Desafios técnicos</span><span class="sxs-lookup"><span data-stu-id="b3e73-127">Technical challenges</span></span>
 * <span data-ttu-id="b3e73-128">Não é possível carregar várias versões do tempo de execução em um único processo.</span><span class="sxs-lookup"><span data-stu-id="b3e73-128">It is not possible to load multiple versions of the runtime in a single process.</span></span>
     > [!CAUTION]
     > <span data-ttu-id="b3e73-129">Carregar várias cópias ou versões diferentes de assemblies do framework pode levar a inesperado e difíceis de diagnosticar o comportamento.</span><span class="sxs-lookup"><span data-stu-id="b3e73-129">Loading multiple copies or different versions of framework assemblies can lead to unexpected and hard to diagnose behavior.</span></span>
     
     > [!TIP]
     > <span data-ttu-id="b3e73-130">Use os limites do processo com comunicação remota e/ou a comunicação entre processos para resolver esse problema de isolamento.</span><span class="sxs-lookup"><span data-stu-id="b3e73-130">Use process boundaries with remoting and/or interprocess communication to solve this isolation problem.</span></span>
 
 * <span data-ttu-id="b3e73-131">O tempo de carregamento de assembly pode dificultar teste e depuração.</span><span class="sxs-lookup"><span data-stu-id="b3e73-131">The timing of assembly loading can make testing and debugging difficult.</span></span> <span data-ttu-id="b3e73-132">Assemblies são normalmente carregados sem suas dependências que está sendo resolvidas imediatamente.</span><span class="sxs-lookup"><span data-stu-id="b3e73-132">Assemblies are typically loaded without their dependencies immediately being resolved.</span></span> <span data-ttu-id="b3e73-133">As dependências são carregadas conforme eles são necessários:</span><span class="sxs-lookup"><span data-stu-id="b3e73-133">The dependencies are loaded as they are needed:</span></span>
     * <span data-ttu-id="b3e73-134">Quando o código ramificações em um assembly dependente.</span><span class="sxs-lookup"><span data-stu-id="b3e73-134">When code branches into a dependent assembly.</span></span>
     * <span data-ttu-id="b3e73-135">Quando o código carrega recursos.</span><span class="sxs-lookup"><span data-stu-id="b3e73-135">When code loads resources.</span></span>
     * <span data-ttu-id="b3e73-136">Quando o código carrega explicitamente os assemblies.</span><span class="sxs-lookup"><span data-stu-id="b3e73-136">When code explicitly loads assemblies.</span></span>
 
 * <span data-ttu-id="b3e73-137">A implementação de <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> pode adicionar novas dependências que talvez precise ser isolado para permitir que diferentes versões de existir.</span><span class="sxs-lookup"><span data-stu-id="b3e73-137">The implementation of <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> can add new dependencies which may need to be isolated to allow different versions to exist.</span></span> <span data-ttu-id="b3e73-138">A implementação mais natural seria colocar essas dependências no contexto padrão.</span><span class="sxs-lookup"><span data-stu-id="b3e73-138">The most natural implementation would place these dependencies in the default context.</span></span> <span data-ttu-id="b3e73-139">Um design cuidadoso pode isolar as dependências de novo.</span><span class="sxs-lookup"><span data-stu-id="b3e73-139">Careful design can isolate the new dependencies.</span></span>
 
 * <span data-ttu-id="b3e73-140">O processo de isolamento de associação cria vários tipos com o mesmo nome de tipo.</span><span class="sxs-lookup"><span data-stu-id="b3e73-140">The binding isolation process creates multiple types with the same type name.</span></span>
     * <span data-ttu-id="b3e73-141">Isso pode levar a confundir as mensagens de erro, por exemplo "Foo.Foo não pode ser convertido para o tipo Foo.Foo."</span><span class="sxs-lookup"><span data-stu-id="b3e73-141">This can lead to confusing error messages, for example "type Foo.Foo cannot be cast to type Foo.Foo."</span></span>
     * <span data-ttu-id="b3e73-142">Marshaling entre limites de isolamento é não trivial.</span><span class="sxs-lookup"><span data-stu-id="b3e73-142">Marshalling across isolation boundaries is non-trivial.</span></span> <span data-ttu-id="b3e73-143">Uma solução típica seria usar uma interface definida em um assembly que é carregado apenas no contexto de carregamento padrão.</span><span class="sxs-lookup"><span data-stu-id="b3e73-143">A typical solution would be to use an interface defined in an assembly which is only loaded into the default load context.</span></span>
 
 ]]></format>
    </remarks>
    <related type="Article" href="https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/assemblyloadcontext.md"><span data-ttu-id="b3e73-144">Documento de design do AssemblyLoadContext CoreCLR</span><span class="sxs-lookup"><span data-stu-id="b3e73-144">AssemblyLoadContext CoreCLR design document</span></span></related>
    <related type="Article" href="/en-us/dotnet/standard/assembly/unloadability-howto"><span data-ttu-id="b3e73-145">Como usar e depurar unloadability assembly no .NET Core</span><span class="sxs-lookup"><span data-stu-id="b3e73-145">How to use and debug assembly unloadability in .NET Core</span></span></related>
    <related type="Article" href="https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/unloadability.md"><span data-ttu-id="b3e73-146">Documento de design de unloadability AssemblyLoadContext</span><span class="sxs-lookup"><span data-stu-id="b3e73-146">AssemblyLoadContext unloadability design document</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected AssemblyLoadContext ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; AssemblyLoadContext();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b3e73-147">Inicializa uma nova instância da classe <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</span><span class="sxs-lookup"><span data-stu-id="b3e73-147">Initializes a new instance of the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="b3e73-148">Esse construtor é protegido.</span><span class="sxs-lookup"><span data-stu-id="b3e73-148">This constructor is protected.</span></span> <span data-ttu-id="b3e73-149">Ele só pode ser chamado do <xref:System.Runtime.Loader.AssemblyLoadContext> classe ou suas classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="b3e73-149">It can only be called from the <xref:System.Runtime.Loader.AssemblyLoadContext> class or its derived classes.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected AssemblyLoadContext (bool isCollectible);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(bool isCollectible) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (isCollectible As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; AssemblyLoadContext(bool isCollectible);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Loader.AssemblyLoadContext : bool -&gt; System.Runtime.Loader.AssemblyLoadContext" Usage="new System.Runtime.Loader.AssemblyLoadContext isCollectible" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="isCollectible" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="isCollectible"><span data-ttu-id="b3e73-150"><see langword="true" /> para habilitar a coleta de lixo, caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="b3e73-150"><see langword="true" /> to enable garbage collection; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="b3e73-151">Inicializa uma nova instância da classe <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> com um valor que indica se a coleta de lixo está habilitada.</span><span class="sxs-lookup"><span data-stu-id="b3e73-151">Initializes a new instance of the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> class with a value that indicates whether garbage collection is enabled.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Runtime.Loader.AssemblyLoadContext Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Loader.AssemblyLoadContext Default" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As AssemblyLoadContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Loader::AssemblyLoadContext ^ Default { System::Runtime::Loader::AssemblyLoadContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Runtime.Loader.AssemblyLoadContext" Usage="System.Runtime.Loader.AssemblyLoadContext.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3e73-152">Obtém o <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> padrão.</span><span class="sxs-lookup"><span data-stu-id="b3e73-152">Gets the default <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</span></span> <span data-ttu-id="b3e73-153">O contexto padrão contém o assembly principal do aplicativo e suas dependências estáticas.</span><span class="sxs-lookup"><span data-stu-id="b3e73-153">The default context contains the main application assembly and its static dependencies.</span></span></summary>
        <value><span data-ttu-id="b3e73-154">O contexto de carregamento de assembly padrão.</span><span class="sxs-lookup"><span data-stu-id="b3e73-154">The default assembly load context.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyName">
      <MemberSignature Language="C#" Value="public static System.Reflection.AssemblyName GetAssemblyName (string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.AssemblyName GetAssemblyName(string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.GetAssemblyName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAssemblyName (assemblyPath As String) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::AssemblyName ^ GetAssemblyName(System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="static member GetAssemblyName : string -&gt; System.Reflection.AssemblyName" Usage="System.Runtime.Loader.AssemblyLoadContext.GetAssemblyName assemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyPath"><span data-ttu-id="b3e73-155">O caminho para o assembly.</span><span class="sxs-lookup"><span data-stu-id="b3e73-155">The path to the assembly.</span></span></param>
        <summary><span data-ttu-id="b3e73-156">Obtém um <see cref="T:System.Reflection.AssemblyName" /> para um caminho de assembly.</span><span class="sxs-lookup"><span data-stu-id="b3e73-156">Gets an <see cref="T:System.Reflection.AssemblyName" /> for an assembly path.</span></span></summary>
        <returns><span data-ttu-id="b3e73-157">Um objeto que contém o nome de assembly totalmente analisados para o assembly em <paramref name="assemblyPath" />.</span><span class="sxs-lookup"><span data-stu-id="b3e73-157">An object that contains the fully parsed assembly name for the assembly at <paramref name="assemblyPath" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3e73-158"><paramref name="assemblyPath" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="b3e73-158"><paramref name="assemblyPath" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="b3e73-159">Não foi possível localizar o assembly.</span><span class="sxs-lookup"><span data-stu-id="b3e73-159">The assembly cannot be found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="b3e73-160">O assembly não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="b3e73-160">The assembly is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetLoadContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Loader.AssemblyLoadContext GetLoadContext (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Loader.AssemblyLoadContext GetLoadContext(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Loader::AssemblyLoadContext ^ GetLoadContext(System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="static member GetLoadContext : System.Reflection.Assembly -&gt; System.Runtime.Loader.AssemblyLoadContext" Usage="System.Runtime.Loader.AssemblyLoadContext.GetLoadContext assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly"><span data-ttu-id="b3e73-161">Um assembly.</span><span class="sxs-lookup"><span data-stu-id="b3e73-161">An assembly.</span></span></param>
        <summary><span data-ttu-id="b3e73-162">Obtém o <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> que contém o <see cref="T:System.Reflection.Assembly" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="b3e73-162">Gets the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> containing the specified <see cref="T:System.Reflection.Assembly" />.</span></span></summary>
        <returns><span data-ttu-id="b3e73-163">O contexto de carregamento do assembly que contém o <paramref name="assembly" />.</span><span class="sxs-lookup"><span data-stu-id="b3e73-163">The assembly load context containing the <paramref name="assembly" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3e73-164"><paramref name="assembly" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="b3e73-164"><paramref name="assembly" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsCollectible">
      <MemberSignature Language="C#" Value="public bool IsCollectible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollectible" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.IsCollectible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCollectible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCollectible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCollectible : bool" Usage="System.Runtime.Loader.AssemblyLoadContext.IsCollectible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3e73-165">Obtém um valor que indica se este <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> é uma coleção.</span><span class="sxs-lookup"><span data-stu-id="b3e73-165">Gets a value that indicates whether this <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> is collectible.</span></span></summary>
        <value><span data-ttu-id="b3e73-166"><see langword="true" /> Se este <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> coleção; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="b3e73-166"><see langword="true" /> if this <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> is collectible; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="b3e73-167">Se um valor não for especificado no construtor, o valor será <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="b3e73-167">If a value is not specified in the constructor, the value is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b3e73-168">Para obter mais informações, consulte <see href="/en-us/dotnet/standard/assembly/unloadability-howto">como usar e depurar unloadability assembly no .NET Core</see>.</span><span class="sxs-lookup"><span data-stu-id="b3e73-168">For more information see <see href="/en-us/dotnet/standard/assembly/unloadability-howto">How to use and debug assembly unloadability in .NET Core</see>.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyName);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.Load assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="b3e73-169">O objeto que descreve o assembly a ser carregado.</span><span class="sxs-lookup"><span data-stu-id="b3e73-169">The object that describes the assembly to be loaded.</span></span></param>
        <summary><span data-ttu-id="b3e73-170">Quando substituído em uma classe derivada, permite que um assembly seja resolvido e carregado com base em seu <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="b3e73-170">When overridden in a derived class, allows an assembly to be resolved and loaded based on its <see cref="T:System.Reflection.AssemblyName" />.</span></span></summary>
        <returns><span data-ttu-id="b3e73-171">O assembly carregado ou <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="b3e73-171">The loaded assembly, or <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
 
## Remarks
 <span data-ttu-id="b3e73-172">Durante a resolução de assembly, o <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)> método tem a primeira oportunidade para resolver o nome do assembly para um assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="b3e73-172">During assembly resolution, the <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)> method has the first chance to resolve the assembly name to a loaded assembly.</span></span> <span data-ttu-id="b3e73-173">Ele pode carregar um assembly ou retorno `null`.</span><span class="sxs-lookup"><span data-stu-id="b3e73-173">It can either load an assembly or return `null`.</span></span> <span data-ttu-id="b3e73-174">Se ele retornar `null`, continua o processo de resolução.</span><span class="sxs-lookup"><span data-stu-id="b3e73-174">If it returns `null`, the resolution process continues.</span></span> <span data-ttu-id="b3e73-175">Consulte <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)> para obter a descrição completa do processo.</span><span class="sxs-lookup"><span data-stu-id="b3e73-175">See <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)> for the full process description.</span></span>
 
 > [!IMPORTANT]
 > <span data-ttu-id="b3e73-176">Para evitar o estouro de pilha recursivo, não chame esta instância <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)> método deste método.</span><span class="sxs-lookup"><span data-stu-id="b3e73-176">To prevent recursive stack overflow, do not call this instance's <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)> method from this method.</span></span>
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyName">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyName (System.Reflection.AssemblyName assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyName(class System.Reflection.AssemblyName assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyName(System::Reflection::AssemblyName ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyName : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromAssemblyName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="b3e73-177">O objeto que descreve o assembly a ser carregado.</span><span class="sxs-lookup"><span data-stu-id="b3e73-177">The object that describes the assembly to load.</span></span></param>
        <summary><span data-ttu-id="b3e73-178">Resolve e carrega um assembly dado seu <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="b3e73-178">Resolves and loads an assembly given its <see cref="T:System.Reflection.AssemblyName" />.</span></span></summary>
        <returns><span data-ttu-id="b3e73-179">O assembly carregado ou gera algo.</span><span class="sxs-lookup"><span data-stu-id="b3e73-179">The loaded assembly, or throws.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b3e73-180"><xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName%2A> carrega um assembly, resolvendo o <xref:System.Reflection.AssemblyName>.</span><span class="sxs-lookup"><span data-stu-id="b3e73-180"><xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName%2A> loads an assembly by resolving the <xref:System.Reflection.AssemblyName>.</span></span> <span data-ttu-id="b3e73-181">Isso dispara uma resolução completa.</span><span class="sxs-lookup"><span data-stu-id="b3e73-181">This triggers a full resolution.</span></span> <span data-ttu-id="b3e73-182">A sequência de fallback de resolução segue este processo: 1.</span><span class="sxs-lookup"><span data-stu-id="b3e73-182">The resolution fallback sequence follows this process: 1.</span></span> <span data-ttu-id="b3e73-183">As chamadas de método <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)>.</span><span class="sxs-lookup"><span data-stu-id="b3e73-183">The method calls <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)>.</span></span>
         > [!IMPORTANT]
         > <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)> must not call this method to prevent recursive stack overflow.
     2. Unless the assembly is loaded or an exception is thrown, the method attempts to load the assembly in the default <xref:System.Runtime.Loader.AssemblyLoadContext>.
     3. Unless the assembly is loaded or an exception is thrown, the method fires the <xref:System.Runtime.Loader.AssemblyLoadContext.Resolving> event.
     4. Unless the assembly is loaded or an exception is thrown, the method fires the <xref:System.AppDomain.AssemblyResolve> event.
 
 > [!NOTE]
 > <span data-ttu-id="b3e73-184"><xref:System.IO.FileLoadException> será gerada se `assemblyRef` Especifica o nome completo do assembly e o primeiro conjunto que corresponde ao nome simple tem uma versão incompatível ou cultura.</span><span class="sxs-lookup"><span data-stu-id="b3e73-184"><xref:System.IO.FileLoadException> is thrown if `assemblyRef` specifies the full assembly name, and the first assembly that matches the simple name has a incompatible version or culture.</span></span> <span data-ttu-id="b3e73-185">O carregador não continuar a sondagem de outros assemblies que correspondem ao nome simple.</span><span class="sxs-lookup"><span data-stu-id="b3e73-185">The loader does not continue probing for other assemblies that match the simple name.</span></span>
 
 <span data-ttu-id="b3e73-186">Cada <xref:System.Runtime.Loader.AssemblyLoadContext> pode carregar apenas: \* uma versão de um assembly executável.</span><span class="sxs-lookup"><span data-stu-id="b3e73-186">Each <xref:System.Runtime.Loader.AssemblyLoadContext> can load only: \* One version of an executable assembly.</span></span>
<span data-ttu-id="b3e73-187">\* Uma versão de um assembly satélite para cada cultura.</span><span class="sxs-lookup"><span data-stu-id="b3e73-187">\* One version of a satellite assembly for each culture.</span></span>
 
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3e73-188"><paramref name="assemblyName" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="b3e73-188"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="b3e73-189"><paramref name="assemblyName" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="b3e73-189"><paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="b3e73-190"><paramref name="assemblyName" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="b3e73-190"><paramref name="assemblyName" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="b3e73-191">Foi carregado um assembly ou módulo que não correspondeu ao <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="b3e73-191">An assembly or module was loaded which did not match the <paramref name="assemblyName" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyPath">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyPath (string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyPath(string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromAssemblyPath (assemblyPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyPath(System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyPath : string -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromAssemblyPath assemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyPath"><span data-ttu-id="b3e73-192">O caminho totalmente qualificado do arquivo a ser carregado.</span><span class="sxs-lookup"><span data-stu-id="b3e73-192">The fully qualified path of the file to load.</span></span></param>
        <summary><span data-ttu-id="b3e73-193">Carrega o conteúdo de um arquivo do assembly no caminho especificado.</span><span class="sxs-lookup"><span data-stu-id="b3e73-193">Loads the contents of an assembly file on the specified path.</span></span></summary>
        <returns><span data-ttu-id="b3e73-194">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="b3e73-194">The loaded assembly.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3e73-195">O argumento <paramref name="assemblyPath" /> não é um caminho absoluto.</span><span class="sxs-lookup"><span data-stu-id="b3e73-195">The <paramref name="assemblyPath" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3e73-196">O parâmetro <paramref name="assemblyPath" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="b3e73-196">The <paramref name="assemblyPath" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="b3e73-197">Não foi possível carregar um arquivo que foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="b3e73-197">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="b3e73-198">O parâmetro <paramref name="assemblyPath" /> é uma cadeia de caracteres vazia ("") ou não existe.</span><span class="sxs-lookup"><span data-stu-id="b3e73-198">The <paramref name="assemblyPath" /> parameter is an empty string ("") or does not exist.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="b3e73-199"><paramref name="assemblyPath" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="b3e73-199"><paramref name="assemblyPath" /> is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromNativeImagePath">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromNativeImagePath (string nativeImagePath, string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromNativeImagePath(string nativeImagePath, string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromNativeImagePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromNativeImagePath (nativeImagePath As String, assemblyPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromNativeImagePath(System::String ^ nativeImagePath, System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="member this.LoadFromNativeImagePath : string * string -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromNativeImagePath (nativeImagePath, assemblyPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nativeImagePath" Type="System.String" />
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="nativeImagePath"><span data-ttu-id="b3e73-200">O caminho totalmente qualificado do arquivo a ser carregado.</span><span class="sxs-lookup"><span data-stu-id="b3e73-200">The fully qualified path of the file to load.</span></span></param>
        <param name="assemblyPath"><span data-ttu-id="b3e73-201">O caminho totalmente qualificado da versão de IL do arquivo a ser carregado ou <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="b3e73-201">The fully qualified path of the IL version of the file to load, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="b3e73-202">Carrega o conteúdo da imagem nativa de um arquivo do assembly gerenciado no caminho especificado.</span><span class="sxs-lookup"><span data-stu-id="b3e73-202">Loads the contents of the native image of a managed assembly file on the specified path.</span></span></summary>
        <returns><span data-ttu-id="b3e73-203">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="b3e73-203">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b3e73-204">A imagem nativa de um assembly gerenciado é pré-compilados para otimizar a execução em uma plataforma específica.</span><span class="sxs-lookup"><span data-stu-id="b3e73-204">The native image of a managed assembly is pre-jitted to optimize running on a specific platform.</span></span>
 
 <span data-ttu-id="b3e73-205">O caminho do assembly refere-se para o caminho para a versão de IL do assembly.</span><span class="sxs-lookup"><span data-stu-id="b3e73-205">The assembly path refers to the path to the IL version of the assembly.</span></span> <span data-ttu-id="b3e73-206">É um argumento opcional como a IL normalmente é incluída na imagem nativa.</span><span class="sxs-lookup"><span data-stu-id="b3e73-206">It is an optional argument as the IL is typically included in the native image.</span></span> <span data-ttu-id="b3e73-207">Ele pode ser usado pelo tempo de execução como um fallback se a imagem nativa não for encontrada.</span><span class="sxs-lookup"><span data-stu-id="b3e73-207">It can be used by the runtime as a fallback if the native image is not found.</span></span>
 
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3e73-208">O argumento <paramref name="nativeImagePath" /> não é um caminho absoluto.</span><span class="sxs-lookup"><span data-stu-id="b3e73-208">The <paramref name="nativeImagePath" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3e73-209">O argumento <paramref name="assemblyPath" /> não é um caminho absoluto.</span><span class="sxs-lookup"><span data-stu-id="b3e73-209">The <paramref name="assemblyPath" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3e73-210">O parâmetro <paramref name="nativeImagePath" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="b3e73-210">The <paramref name="nativeImagePath" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="b3e73-211">Não foi possível carregar um arquivo que foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="b3e73-211">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="b3e73-212">O parâmetro <paramref name="nativeImagePath" /> é uma cadeia de caracteres vazia ("") ou não existe.</span><span class="sxs-lookup"><span data-stu-id="b3e73-212">The <paramref name="nativeImagePath" /> parameter is an empty string ("") or does not exist.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="b3e73-213"><paramref name="assemblyPath" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="b3e73-213"><paramref name="assemblyPath" /> is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromStream">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromStream (System.IO.Stream assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromStream(class System.IO.Stream assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromStream(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromStream(System::IO::Stream ^ assembly);" />
      <MemberSignature Language="F#" Value="member this.LoadFromStream : System.IO.Stream -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromStream assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="assembly"><span data-ttu-id="b3e73-214">Uma matriz de bytes que é uma imagem baseada em COFF contendo um assembly gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b3e73-214">A byte array that is a COFF-based image containing a managed assembly.</span></span></param>
        <summary><span data-ttu-id="b3e73-215">Carrega o assembly com uma imagem baseada no formato COFF que contém um assembly gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b3e73-215">Loads the assembly with a common object file format (COFF)-based image containing a managed assembly.</span></span></summary>
        <returns><span data-ttu-id="b3e73-216">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="b3e73-216">The loaded assembly.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3e73-217"><paramref name="assembly" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="b3e73-217"><paramref name="assembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="b3e73-218"><paramref name="assembly" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="b3e73-218"><paramref name="assembly" /> is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromStream">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromStream (System.IO.Stream assembly, System.IO.Stream assemblySymbols);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromStream(class System.IO.Stream assembly, class System.IO.Stream assemblySymbols) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromStream(System.IO.Stream,System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromStream(System::IO::Stream ^ assembly, System::IO::Stream ^ assemblySymbols);" />
      <MemberSignature Language="F#" Value="member this.LoadFromStream : System.IO.Stream * System.IO.Stream -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromStream (assembly, assemblySymbols)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.IO.Stream" />
        <Parameter Name="assemblySymbols" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="assembly"><span data-ttu-id="b3e73-219">Uma matriz de bytes que é uma imagem baseada em COFF contendo um assembly gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b3e73-219">A byte array that is a COFF-based image containing a managed assembly.</span></span></param>
        <param name="assemblySymbols"><span data-ttu-id="b3e73-220">Uma matriz de bytes que contém os bytes brutos que representam os símbolos do assembly.</span><span class="sxs-lookup"><span data-stu-id="b3e73-220">A byte array that contains the raw bytes representing the symbols for the assembly.</span></span></param>
        <summary><span data-ttu-id="b3e73-221">Carrega o assembly com uma imagem baseada no formato COFF, contendo um assembly gerenciado e com a opção de incluir símbolos para o assembly.</span><span class="sxs-lookup"><span data-stu-id="b3e73-221">Loads the assembly with a common object file format (COFF)-based image containing a managed assembly, optionally including symbols for the assembly.</span></span></summary>
        <returns><span data-ttu-id="b3e73-222">O assembly carregado.</span><span class="sxs-lookup"><span data-stu-id="b3e73-222">The loaded assembly.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3e73-223"><paramref name="assembly" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="b3e73-223"><paramref name="assembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="b3e73-224"><paramref name="assembly" /> não é um assembly válido.</span><span class="sxs-lookup"><span data-stu-id="b3e73-224"><paramref name="assembly" /> is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadUnmanagedDll">
      <MemberSignature Language="C#" Value="protected virtual IntPtr LoadUnmanagedDll (string unmanagedDllName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance native int LoadUnmanagedDll(string unmanagedDllName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDll(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LoadUnmanagedDll (unmanagedDllName As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IntPtr LoadUnmanagedDll(System::String ^ unmanagedDllName);" />
      <MemberSignature Language="F#" Value="abstract member LoadUnmanagedDll : string -&gt; nativeint&#xA;override this.LoadUnmanagedDll : string -&gt; nativeint" Usage="assemblyLoadContext.LoadUnmanagedDll unmanagedDllName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unmanagedDllName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="unmanagedDllName"><span data-ttu-id="b3e73-225">Nome da biblioteca não gerenciada.</span><span class="sxs-lookup"><span data-stu-id="b3e73-225">Name of the unmanaged library.</span></span> <span data-ttu-id="b3e73-226">Normalmente, esse é o nome do arquivo sem seu caminho ou suas extensões.</span><span class="sxs-lookup"><span data-stu-id="b3e73-226">Typically this is the filename without its path or extensions.</span></span></param>
        <summary><span data-ttu-id="b3e73-227">Permite que uma classe derivada carregue uma biblioteca não gerenciada por nome.</span><span class="sxs-lookup"><span data-stu-id="b3e73-227">Allows derived class to load an unmanaged library by name.</span></span></summary>
        <returns><span data-ttu-id="b3e73-228">Um identificador da biblioteca carregada ou <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="b3e73-228">A handle to the loaded library, or <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b3e73-229">A implementação padrão sempre retornam `null`.</span><span class="sxs-lookup"><span data-stu-id="b3e73-229">The default implementation always return `null`.</span></span> <span data-ttu-id="b3e73-230">Quando `null` for retornado, o tempo de execução carrega a biblioteca com a sua política padrão.</span><span class="sxs-lookup"><span data-stu-id="b3e73-230">When `null` is returned, the runtime loads the library with its default policy.</span></span>
 
 <span data-ttu-id="b3e73-231">Esse método virtual pode ser substituído para personalizar o algoritmo de pesquisa de biblioteca não gerenciada.</span><span class="sxs-lookup"><span data-stu-id="b3e73-231">This virtual method can be overridden to customize the unmanaged library search algorithm.</span></span> <span data-ttu-id="b3e73-232">Quando substituído o nome pode ser usado para identificar a biblioteca.</span><span class="sxs-lookup"><span data-stu-id="b3e73-232">When overridden the name can be used to identify the library.</span></span> <span data-ttu-id="b3e73-233">A Biblioteca carregada não precisa corresponder ao solicitado nome, mas podem ser transformadas conforme necessário.</span><span class="sxs-lookup"><span data-stu-id="b3e73-233">The loaded library does not need to match the requested name, but can be transformed as needed.</span></span> <span data-ttu-id="b3e73-234">Isso pode incluir ajustando o nome para a nomeação de específico da plataforma.</span><span class="sxs-lookup"><span data-stu-id="b3e73-234">This could include adjusting the name for platform specific naming.</span></span>
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadUnmanagedDllFromPath">
      <MemberSignature Language="C#" Value="protected IntPtr LoadUnmanagedDllFromPath (string unmanagedDllPath);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance native int LoadUnmanagedDllFromPath(string unmanagedDllPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDllFromPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Function LoadUnmanagedDllFromPath (unmanagedDllPath As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; IntPtr LoadUnmanagedDllFromPath(System::String ^ unmanagedDllPath);" />
      <MemberSignature Language="F#" Value="member this.LoadUnmanagedDllFromPath : string -&gt; nativeint" Usage="assemblyLoadContext.LoadUnmanagedDllFromPath unmanagedDllPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unmanagedDllPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="unmanagedDllPath"><span data-ttu-id="b3e73-235">O caminho para a biblioteca não gerenciada.</span><span class="sxs-lookup"><span data-stu-id="b3e73-235">The path to the unmanaged library.</span></span></param>
        <summary><span data-ttu-id="b3e73-236">Carrega uma biblioteca não gerenciada por meio do caminho especificado.</span><span class="sxs-lookup"><span data-stu-id="b3e73-236">Loads an unmanaged library from the specified path.</span></span></summary>
        <returns><span data-ttu-id="b3e73-237">Um identificador da biblioteca carregada.</span><span class="sxs-lookup"><span data-stu-id="b3e73-237">A handle to the loaded library.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b3e73-238"><paramref name="unmanagedDllPath" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="b3e73-238"><paramref name="unmanagedDllPath" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b3e73-239">O argumento <paramref name="unmanagedDllPath" /> não é um caminho absoluto.</span><span class="sxs-lookup"><span data-stu-id="b3e73-239">The <paramref name="unmanagedDllPath" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="b3e73-240">A biblioteca não gerenciada não pode ser encontrada.</span><span class="sxs-lookup"><span data-stu-id="b3e73-240">The unmanaged library cannot be found.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Resolving">
      <MemberSignature Language="C#" Value="public event Func&lt;System.Runtime.Loader.AssemblyLoadContext,System.Reflection.AssemblyName,System.Reflection.Assembly&gt; Resolving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Func`3&lt;class System.Runtime.Loader.AssemblyLoadContext, class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; Resolving" />
      <MemberSignature Language="DocId" Value="E:System.Runtime.Loader.AssemblyLoadContext.Resolving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Resolving As Func(Of AssemblyLoadContext, AssemblyName, Assembly) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Func&lt;System::Runtime::Loader::AssemblyLoadContext ^, System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ Resolving;" />
      <MemberSignature Language="F#" Value="member this.Resolving : Func&lt;System.Runtime.Loader.AssemblyLoadContext, System.Reflection.AssemblyName, System.Reflection.Assembly&gt; " Usage="member this.Resolving : System.Func&lt;System.Runtime.Loader.AssemblyLoadContext, System.Reflection.AssemblyName, System.Reflection.Assembly&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Runtime.Loader.AssemblyLoadContext,System.Reflection.AssemblyName,System.Reflection.Assembly&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3e73-241">Ocorre quando a resolução de um assembly falha durante a tentativa de carregamento nesse contexto de carregamento de assembly.</span><span class="sxs-lookup"><span data-stu-id="b3e73-241">Occurs when the resolution of an assembly fails when attempting to load into this assembly load context.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b3e73-242">É responsabilidade do manipulador para este evento para retornar o assembly que é especificado, ou para retornar `null` se o assembly não é reconhecido.</span><span class="sxs-lookup"><span data-stu-id="b3e73-242">It is the responsibility of the handler for this event to return the assembly that is specified, or to return `null` if the assembly is not recognized.</span></span>
 
 > [!IMPORTANT]
 >  <span data-ttu-id="b3e73-243">Se mais de um manipulador de eventos é registrado para este evento, os manipuladores de eventos são chamados na ordem até que um manipulador de eventos retorna um valor que não seja `null`.</span><span class="sxs-lookup"><span data-stu-id="b3e73-243">If more than one event handler is registered for this event, the event handlers are called in order until an event handler returns a value that isn't `null`.</span></span> <span data-ttu-id="b3e73-244">Manipuladores de eventos subsequentes serão ignorados.</span><span class="sxs-lookup"><span data-stu-id="b3e73-244">Subsequent event handlers are ignored.</span></span>
 
 <span data-ttu-id="b3e73-245">Para obter mais informações sobre como manipular eventos, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="b3e73-245">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>
 
 <span data-ttu-id="b3e73-246">É importante que um manipulador pode ser adicionado para esse evento em qualquer <xref:System.Runtime.Loader.AssemblyLoadContext>, incluindo o contexto padrão.</span><span class="sxs-lookup"><span data-stu-id="b3e73-246">It is noteworthy that a handler can be added for this event on any <xref:System.Runtime.Loader.AssemblyLoadContext>, including the default context.</span></span>
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolvingUnmanagedDll">
      <MemberSignature Language="C#" Value="public event Func&lt;System.Reflection.Assembly,string,IntPtr&gt; ResolvingUnmanagedDll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Func`3&lt;class System.Reflection.Assembly, string, native int&gt; ResolvingUnmanagedDll" />
      <MemberSignature Language="DocId" Value="E:System.Runtime.Loader.AssemblyLoadContext.ResolvingUnmanagedDll" />
      <MemberSignature Language="VB.NET" Value="Public Event ResolvingUnmanagedDll As Func(Of Assembly, String, IntPtr) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Func&lt;System::Reflection::Assembly ^, System::String ^, IntPtr&gt; ^ ResolvingUnmanagedDll;" />
      <MemberSignature Language="F#" Value="member this.ResolvingUnmanagedDll : Func&lt;System.Reflection.Assembly, string, nativeint&gt; " Usage="member this.ResolvingUnmanagedDll : System.Func&lt;System.Reflection.Assembly, System.string, System.nativeint&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Reflection.Assembly,System.String,System.IntPtr&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetProfileOptimizationRoot">
      <MemberSignature Language="C#" Value="public void SetProfileOptimizationRoot (string directoryPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetProfileOptimizationRoot(string directoryPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.SetProfileOptimizationRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetProfileOptimizationRoot (directoryPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetProfileOptimizationRoot(System::String ^ directoryPath);" />
      <MemberSignature Language="F#" Value="member this.SetProfileOptimizationRoot : string -&gt; unit" Usage="assemblyLoadContext.SetProfileOptimizationRoot directoryPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directoryPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directoryPath">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartProfileOptimization">
      <MemberSignature Language="C#" Value="public void StartProfileOptimization (string profile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartProfileOptimization(string profile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.StartProfileOptimization(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartProfileOptimization (profile As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartProfileOptimization(System::String ^ profile);" />
      <MemberSignature Language="F#" Value="member this.StartProfileOptimization : string -&gt; unit" Usage="assemblyLoadContext.StartProfileOptimization profile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="profile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="profile">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public void Unload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unload ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unload();" />
      <MemberSignature Language="F#" Value="member this.Unload : unit -&gt; unit" Usage="assemblyLoadContext.Unload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b3e73-247">Inicia um descarregamento deste <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</span><span class="sxs-lookup"><span data-stu-id="b3e73-247">Initiates an unload of this <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

+ <span data-ttu-id="b3e73-248">Um AssemblyLoadContext só pode ser descarregado, se ele for de coleção.</span><span class="sxs-lookup"><span data-stu-id="b3e73-248">An AssemblyLoadContext can only be unloaded if it is collectible.</span></span>
+ <span data-ttu-id="b3e73-249">Descarregando ocorrerá de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="b3e73-249">Unloading will occur asynchronously.</span></span>
+ <span data-ttu-id="b3e73-250">Descarregamento não ocorrerá enquanto houver referências para o AssemblyLoadContext.</span><span class="sxs-lookup"><span data-stu-id="b3e73-250">Unloading will not occur while there are references to the AssemblyLoadContext.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b3e73-251">O descarregamento não é permitido.</span><span class="sxs-lookup"><span data-stu-id="b3e73-251">Unloading is not allowed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Unloading">
      <MemberSignature Language="C#" Value="public event Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt; Unloading;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;class System.Runtime.Loader.AssemblyLoadContext&gt; Unloading" />
      <MemberSignature Language="DocId" Value="E:System.Runtime.Loader.AssemblyLoadContext.Unloading" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloading As Action(Of AssemblyLoadContext) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Action&lt;System::Runtime::Loader::AssemblyLoadContext ^&gt; ^ Unloading;" />
      <MemberSignature Language="F#" Value="member this.Unloading : Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt; " Usage="member this.Unloading : System.Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b3e73-252">Ocorre quando o <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> é descarregado.</span><span class="sxs-lookup"><span data-stu-id="b3e73-252">Occurs when the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> is unloaded.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>