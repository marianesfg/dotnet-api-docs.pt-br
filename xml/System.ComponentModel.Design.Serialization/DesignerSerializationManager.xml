<Type Name="DesignerSerializationManager" FullName="System.ComponentModel.Design.Serialization.DesignerSerializationManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0eda15e23f21f745f5e7c31728f28857fab008f9" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36708821" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DesignerSerializationManager : IServiceProvider, System.ComponentModel.Design.Serialization.IDesignerSerializationManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DesignerSerializationManager extends System.Object implements class System.ComponentModel.Design.Serialization.IDesignerSerializationManager, class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.Design.Serialization.DesignerSerializationManager" />
  <TypeSignature Language="VB.NET" Value="Public Class DesignerSerializationManager&#xA;Implements IDesignerSerializationManager, IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class DesignerSerializationManager : IServiceProvider, System::ComponentModel::Design::Serialization::IDesignerSerializationManager" />
  <TypeSignature Language="F#" Value="type DesignerSerializationManager = class&#xA;    interface IDesignerSerializationManager&#xA;    interface IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Design</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.Design.Serialization.IDesignerSerializationManager</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Provides an implementation of the <see cref="T:System.ComponentModel.Design.Serialization.IDesignerSerializationManager" /> interface.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager> interface é projetada para ser uma interface independente de formato para um objeto que controla a serialização. Essencialmente, ele fornece contexto e serviços para serializadores, o que realmente executam a desserialização. <xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager> auxilia no processo de desserialização, controlando de objetos. Isso é semelhante a técnica para o <xref:System.ComponentModel.Design.IDesignerHost> interface: designers, na verdade, fornecem a interface do usuário (IU), e <xref:System.ComponentModel.Design.IDesignerHost> fornece a liga que permite que os designers diferentes trabalhar juntos.  
  
 O <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager> classe implementa <xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager>. Ele é projetado para fornecer um formulário genérico de desserialização é semelhante a serializadores de tempo de execução como o <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>.  
  
 O <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager> classe atinge três objetivos:  
  
-   É um objeto simple, completo, que pode ser usado para desserializar uma variedade de formatos.  
  
-   É genérico e não associado a qualquer formato específico. Ele pode ser usado igualmente para desserialização de CodeDOM, bem como a desserialização de marcação.  
  
-   Ele é extensível e oferece suporte a métodos de serialização diferentes que são usados em cenários de copiar/colar e desfazer/refazer.  
  
 Serialização de tempo de design tem as seguintes diferenças de serialização do objeto de tempo de execução:  
  
-   O objeto que realiza a serialização é geralmente separado do objeto de tempo de execução, para que a lógica de tempo de design pode ser removida de um componente.  
  
-   O esquema de serialização pressupõe que o objeto será criado completamente inicializado e, em seguida, modificadas por meio de chamadas de método e propriedade durante a desserialização.  
  
-   Propriedades de um objeto que têm valores que nunca foram definidos no objeto (as propriedades contêm os valores padrão) não são serializadas. Por outro lado, o fluxo de desserialização pode ter falhas.  
  
-   A qualidade do conteúdo dentro do fluxo de serialização, em vez da serialização completa de um objeto é dada ênfase. Isso significa que, se não houver nenhuma forma definida para serializar um objeto, esse objeto pode ser ignorado em vez de gerar uma exceção. O mecanismo de serialização pode fornecer a heurística para decidir qual falhas podem ser ignoradas e quais são irrecuperável.  
  
-   O fluxo de serialização pode ter mais dados do que é necessário para desserialização. Serialização de código fonte, por exemplo, tem misturado com o código necessário para desserializar um gráfico de objeto de código do usuário. Esse código de usuário deve ser ignorado na desserialização e preservado na serialização.  
  
 Devido a essas diferenças, um modelo de serialização diferentes se aplica a serialização de tempo de design. Esse modelo utiliza um objeto serializador separado para cada tipo de dados que está sendo serializado. Cada serializador fornece sua contribuição pequena para o problema como um todo. Esses serializadores estejam todos coordenados por meio de um Gerenciador de serialização comum. O Gerenciador de serialização é responsável por manter o estado entre esses serializadores diferentes. Por exemplo, considere a seguinte classe:  
  
 [!code-csharp[System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject/CS/Program.cs#2)]
 [!code-vb[System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject/VB/Program.vb#2)]  
  
 Uma instância dessa classe utilizaria três serializadores diferentes: uma para `SampleObject`, um para cadeias de caracteres e outro para números inteiros. O serializador para `SampleObject` é chamado o serializador raiz porque `SampleObject` é a raiz do gráfico de serialização. Gráficos de objeto mais complexos podem ser criados também. Por exemplo, considere o que aconteceria se `SampleObject` foram alterados da seguinte maneira:  
  
 [!code-csharp[System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject/CS/SampleObject.cs#11)]
 [!code-vb[System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject/VB/SampleObject.vb#11)]  
  
 Isso permite que `SampleObject` ter um filho que é outra instância de si mesma. O gráfico de objeto preenche o código a seguir:  
  
 [!code-csharp[System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject/CS/SampleObject.cs#12)]
 [!code-vb[System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.Design.Serialization.DesignerSerializationManager.SampleObject/VB/SampleObject.vb#12)]  
  
 Quando `root` é serializado, haverá quatro serializadores usados: o serializador de uma raiz, um serializador para o filho `SampleObject`, um serializador para `int`e um serializador para `string`. Serializadores são armazenados em cache com base no tipo, portanto, não há necessidade de criar um serializador para cada instância do `SampleObject`.  
  
 O <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager> classe baseia-se a ideia de uma sessão de serialização. Uma sessão mantém o estado que pode ser acessado pelos serializadores vários. Quando uma sessão é descartada, esse estado é destruído. Isso ajuda a garantir que serializadores permanecem em grande parte sem monitoração de estado, e ajuda a limpar os serializadores que estão corrompida. As tabelas a seguir descrevem como o estado é gerenciado no e entre as sessões.  
  
## <a name="global-state"></a>Estado global  
 Esse estado é de propriedade do objeto do Gerenciador de serialização, mas é independente da sessão atual de serialização.  
  
|Objeto|Uso|  
|------------|-----------|  
|Provedores de serialização|Objetos podem adicionar a mesmos como provedores de serialização personalizada. Como esses provedores são usados para localizar os serializadores, eles sobreviver além de uma sessão de serialização.|  
  
## <a name="session-owned-state"></a>Estado de sessão de propriedade  
 Esse estado é de propriedade de uma sessão e é destruído quando uma sessão é destruída. Consequentemente, acessar quaisquer propriedades ou métodos que poderiam manipular esse estado lançará uma exceção se o Gerenciador de serialização não estiver em uma sessão ativa.  
  
|Objeto|Uso|  
|------------|-----------|  
|Evento <xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ResolveName>|O <xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ResolveName> evento está conectado por um serializador para fornecer a resolução de nomes adicional. Todos os manipuladores são desanexados desse evento quando uma sessão termina.|  
|Evento <xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.SerializationComplete>|O <xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.SerializationComplete> é gerado antes de uma sessão é descartada. Em seguida, todos os manipuladores são desanexados desse evento.|  
|Tabela de nomes|O Gerenciador de serialização mantém uma tabela que mapeia entre objetos e seus nomes. Serializadores podem resultar em nomes de objetos para facilitar sua identificação. Esta tabela de nome é apagada quando o término da sessão.|  
|Cache do serializador|O Gerenciador de serialização mantém um cache de serializadores que foi solicitado a fornecer. Esse cache é limpo quando a sessão termina. O público <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetSerializer%2A> método pode ser chamado com segurança a qualquer momento, mas seu valor é armazenado em cache somente se ele é chamado de dentro de uma sessão.|  
|Pilha de contexto|O Gerenciador de serialização mantém um objeto chamado a pilha de contexto, você pode acessar com o <xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Context%2A> propriedade. Serializadores podem usar esta pilha para armazenar informações adicionais que estão disponíveis para outros serializadores. Por exemplo, um serializador que é serializar um valor de propriedade pode enviar por push o nome da propriedade na pilha de serialização antes de solicitar o valor para serializar. Esta pilha é limpo quando a sessão é encerrada.|  
|Lista de erros|O Gerenciador de serialização mantém uma lista de erros que ocorreram durante a serialização. Essa lista, que é acessada por meio de <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.Errors%2A> propriedade, será apagada quando a sessão é encerrada. Acessando o <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.Errors%2A> propriedade entre sessões resultará em uma exceção.|  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerSerializationManager" />
    <altmember cref="T:System.ComponentModel.Design.IDesignerHost" />
    <altmember cref="T:System.ComponentModel.Design.Serialization.ContextStack" />
    <altmember cref="T:System.IServiceProvider" />
    <altmember cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.ComponentModel.Design.Serialization.DesignerSerializationManager" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignerSerializationManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignerSerializationManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.ComponentModel.Design.Serialization.DesignerSerializationManager" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse construtor define o <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.PreserveNames%2A> e <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes%2A> propriedades `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.PreserveNames" />
        <altmember cref="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignerSerializationManager (IServiceProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IServiceProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.#ctor(System.IServiceProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (provider As IServiceProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignerSerializationManager(IServiceProvider ^ provider);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.Design.Serialization.DesignerSerializationManager : IServiceProvider -&gt; System.ComponentModel.Design.Serialization.DesignerSerializationManager" Usage="new System.ComponentModel.Design.Serialization.DesignerSerializationManager provider" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="provider" Type="System.IServiceProvider" />
      </Parameters>
      <Docs>
        <param name="provider">An <see cref="T:System.IServiceProvider" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.ComponentModel.Design.Serialization.DesignerSerializationManager" /> class with the given service provider.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um serializador de solicitações de serviços que não podem ser atendidos pelo Gerenciador de serialização, a implementação padrão encaminhar essas solicitações para o `provider` parâmetro.  
  
 Esse construtor define o <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.PreserveNames%2A> e <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes%2A> propriedades `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="provider" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.IServiceProvider" />
        <altmember cref="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.PreserveNames" />
        <altmember cref="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes" />
      </Docs>
    </Member>
    <Member MemberName="Container">
      <MemberSignature Language="C#" Value="public System.ComponentModel.IContainer Container { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.IContainer Container" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.Container" />
      <MemberSignature Language="VB.NET" Value="Public Property Container As IContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::IContainer ^ Container { System::ComponentModel::IContainer ^ get(); void set(System::ComponentModel::IContainer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Container : System.ComponentModel.IContainer with get, set" Usage="System.ComponentModel.Design.Serialization.DesignerSerializationManager.Container" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets to the container for this serialization manager.</summary>
        <value>O <see cref="T:System.ComponentModel.IContainer" /> à qual o Gerenciador de serialização adicionará componentes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se existe um contêiner, todos os componentes que são criados pelo Gerenciador de serialização serão adicionados ao contêiner. A implementação padrão dessa propriedade pesquisará o provedor de serviços para um <xref:System.ComponentModel.Design.IDesignerHost> e usar o contêiner fornecido pelo host do designer, um existe. Caso contrário, essa propriedade retornará `null` e componentes não serão adicionados a um contêiner.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The serialization manager has an active serialization session.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected virtual object CreateInstance (Type type, System.Collections.ICollection arguments, string name, bool addToContainer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object CreateInstance(class System.Type type, class System.Collections.ICollection arguments, string name, bool addToContainer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ CreateInstance(Type ^ type, System::Collections::ICollection ^ arguments, System::String ^ name, bool addToContainer);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : Type * System.Collections.ICollection * string * bool -&gt; obj&#xA;override this.CreateInstance : Type * System.Collections.ICollection * string * bool -&gt; obj" Usage="designerSerializationManager.CreateInstance (type, arguments, name, addToContainer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Collections.ICollection" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="addToContainer" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">The type to create an instance of.</param>
        <param name="arguments">The parameters of the type’s constructor. This can be <see langword="null" /> or an empty collection to invoke the default constructor.</param>
        <param name="name">A name to give the object. If <see langword="null" />, the object will not be given a name, unless the object is added to a container and the container gives the object a name.</param>
        <param name="addToContainer">
          <see langword="true" /> to add the object to the container if the object implements <see cref="T:System.ComponentModel.IComponent" />; otherwise, <see langword="false" />.</param>
        <summary>Creates an instance of a type.</summary>
        <returns>A new instance of the type specified by <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado pelo serializadores quando tentam criar uma instância de um tipo. A implementação padrão cria uma nova instância do tipo, ou pode retornar uma instância existente, dependendo dos valores da <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.PreserveNames%2A> e <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.RecycleInstances%2A> propriedades. O <xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.CreateInstance%2A> método usa reflexão para criar instâncias e executará alguns genérico <xref:System.IConvertible> transformações em parâmetros para localizar um construtor correspondente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">
          <paramref name="type" /> does not have a constructor that takes parameters contained in <paramref name="arguments" />.</exception>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateSession" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetInstance(System.String)" />
        <altmember cref="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.RecycleInstances" />
        <altmember cref="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes" />
      </Docs>
    </Member>
    <Member MemberName="CreateSession">
      <MemberSignature Language="C#" Value="public IDisposable CreateSession ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IDisposable CreateSession() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateSession" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSession () As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IDisposable ^ CreateSession();" />
      <MemberSignature Language="F#" Value="member this.CreateSession : unit -&gt; IDisposable" Usage="designerSerializationManager.CreateSession " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a new serialization session.</summary>
        <returns>An <see cref="T:System.IDisposable" /> that represents a new serialization session.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A maioria dos dados dentro do Gerenciador de serialização é transitórios e existe somente durante a vida útil de uma sessão de serialização. Quando uma sessão é descartada, serialização é considerada concluída e estado transiente está desmarcado. Isso permite que uma única instância de um Gerenciador de serialização a ser usado para serializar várias árvores de objeto. Alguns estados, incluindo o provedor de serviços e quaisquer provedores de serialização personalizada que foram adicionados ao Gerenciador de serialização, abrangem as sessões.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The serialization manager is already within a session. This version of <see cref="T:System.ComponentModel.Design.Serialization.DesignerSerializationManager" /> does not support simultaneous sessions.</exception>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionCreated(System.EventArgs)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionDisposed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Errors">
      <MemberSignature Language="C#" Value="public System.Collections.IList Errors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IList Errors" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.Errors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Errors As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IList ^ Errors { System::Collections::IList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Errors : System.Collections.IList" Usage="System.ComponentModel.Design.Serialization.DesignerSerializationManager.Errors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the list of errors that occurred during serialization or deserialization.</summary>
        <value>A lista de erros que ocorreram durante a serialização ou desserialização.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você somente pode ler a lista de erros durante uma sessão de serialização ativa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property was accessed outside of a serialization session.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRuntimeType">
      <MemberSignature Language="C#" Value="public Type GetRuntimeType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetRuntimeType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetRuntimeType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRuntimeType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetRuntimeType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.GetRuntimeType : string -&gt; Type" Usage="designerSerializationManager.GetRuntimeType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">The name of the type to get.</param>
        <summary>Gets the type corresponding to the specified type name.</summary>
        <returns>The specified type.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSerializer">
      <MemberSignature Language="C#" Value="public object GetSerializer (Type objectType, Type serializerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSerializer(class System.Type objectType, class System.Type serializerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetSerializer(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSerializer (objectType As Type, serializerType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSerializer(Type ^ objectType, Type ^ serializerType);" />
      <MemberSignature Language="F#" Value="member this.GetSerializer : Type * Type -&gt; obj" Usage="designerSerializationManager.GetSerializer (objectType, serializerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectType" Type="System.Type" />
        <Parameter Name="serializerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="objectType">The type of object for which to retrieve the serializer.</param>
        <param name="serializerType">The type of serializer to retrieve.</param>
        <summary>Gets the serializer for the given object type.</summary>
        <returns>The serializer for <paramref name="objectType" />, or <see langword="null" />, if not found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode solicitar o tipo de serializador desejado. Este método retorna `null` se não houver nenhum serializador do tipo solicitado para o tipo de objeto especificado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="objectType" /> or <paramref name="serializerType" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#AddSerializationProvider(System.ComponentModel.Design.Serialization.IDesignerSerializationProvider)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#RemoveSerializationProvider(System.ComponentModel.Design.Serialization.IDesignerSerializationProvider)" />
      </Docs>
    </Member>
    <Member MemberName="GetService">
      <MemberSignature Language="C#" Value="protected virtual object GetService (Type serviceType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object GetService(class System.Type serviceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetService (serviceType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ GetService(Type ^ serviceType);" />
      <MemberSignature Language="F#" Value="abstract member GetService : Type -&gt; obj&#xA;override this.GetService : Type -&gt; obj" Usage="designerSerializationManager.GetService serviceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="serviceType">The type of service to retrieve.</param>
        <summary>Gets the requested service.</summary>
        <returns>The requested service, or <see langword="null" /> if the service cannot be resolved.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetService%2A> método fornece acesso ao contêiner subjacente ou provedor de serviço que foi definida no construtor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="protected virtual Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ GetType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="override this.GetType : string -&gt; Type" Usage="designerSerializationManager.GetType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">The name of the type to retrieve.</param>
        <summary>Gets the requested type.</summary>
        <returns>The requested type, or <see langword="null" /> if the type cannot be resolved.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetType%2A> método pesquisará o provedor de serviços para um <xref:System.ComponentModel.Design.ITypeResolutionService> e, se disponível, ele delegará a esse serviço para resolver o tipo. Se um <xref:System.ComponentModel.Design.ITypeResolutionService> não estiver disponível, <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetType%2A> chamará o <xref:System.Object.GetType%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnResolveName">
      <MemberSignature Language="C#" Value="protected virtual void OnResolveName (System.ComponentModel.Design.Serialization.ResolveNameEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResolveName(class System.ComponentModel.Design.Serialization.ResolveNameEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnResolveName(System.ComponentModel.Design.Serialization.ResolveNameEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResolveName (e As ResolveNameEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResolveName(System::ComponentModel::Design::Serialization::ResolveNameEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnResolveName : System.ComponentModel.Design.Serialization.ResolveNameEventArgs -&gt; unit&#xA;override this.OnResolveName : System.ComponentModel.Design.Serialization.ResolveNameEventArgs -&gt; unit" Usage="designerSerializationManager.OnResolveName e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.Design.Serialization.ResolveNameEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.ComponentModel.Design.Serialization.ResolveNameEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ResolveName" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](~/docs/standard/events/index.md).  
  
 O <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnResolveName%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnResolveName(System.ComponentModel.Design.Serialization.ResolveNameEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnResolveName(System.ComponentModel.Design.Serialization.ResolveNameEventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
        <altmember cref="E:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ResolveName" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetName(System.Object)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#SetName(System.Object,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionCreated">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionCreated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionCreated : EventArgs -&gt; unit&#xA;override this.OnSessionCreated : EventArgs -&gt; unit" Usage="designerSerializationManager.OnSessionCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.ComponentModel.Design.Serialization.DesignerSerializationManager.SessionCreated" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](~/docs/standard/events/index.md).  
  
 O <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionCreated%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionCreated(System.EventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionCreated(System.EventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateSession" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionDisposed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionDisposed">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionDisposed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionDisposed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionDisposed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionDisposed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionDisposed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionDisposed : EventArgs -&gt; unit&#xA;override this.OnSessionDisposed : EventArgs -&gt; unit" Usage="designerSerializationManager.OnSessionDisposed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.ComponentModel.Design.Serialization.DesignerSerializationManager.SessionDisposed" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](~/docs/standard/events/index.md).  
  
 O <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionDisposed%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionDisposed(System.EventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionDisposed(System.EventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateSession" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.OnSessionCreated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="PreserveNames">
      <MemberSignature Language="C#" Value="public bool PreserveNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreserveNames" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.PreserveNames" />
      <MemberSignature Language="VB.NET" Value="Public Property PreserveNames As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PreserveNames { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreserveNames : bool with get, set" Usage="System.ComponentModel.Design.Serialization.DesignerSerializationManager.PreserveNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether the <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" /> method should check for the presence of the given name in the container.</summary>
        <value>
          <see langword="true" /> Se <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" /> passará o nome do componente especificado; <see langword="false" /> se <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" /> verifica a presença do nome fornecido no contêiner. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.PreserveNames%2A> propriedade determina o comportamento do <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> método. Se `true`, <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> passará o nome do componente especificado. Se `false`, <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> verifica a presença do nome fornecido no contêiner. Se o nome não existe no contêiner, <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> usará o nome fornecido. Se o nome existe no contêiner, <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> passará um valor nulo como o nome de um componente ao adicioná-lo para o contêiner, assim, dando a ele um novo nome. Essa segunda é útil para implementar um serializador que duplica sempre objetos, em vez de supondo que esses objetos não existem. Colar comandos geralmente usam esse tipo de serializador.  
  
 Você só pode alterar essa propriedade quando você não estiver em uma sessão de serialização.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property was changed from within a serialization session.</exception>
        <altmember cref="Overload:System.ComponentModel.Design.Serialization.DesignerSerializationManager.#ctor" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="PropertyProvider">
      <MemberSignature Language="C#" Value="public object PropertyProvider { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object PropertyProvider" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.PropertyProvider" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyProvider As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ PropertyProvider { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyProvider : obj with get, set" Usage="System.ComponentModel.Design.Serialization.DesignerSerializationManager.PropertyProvider" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the object that should be used to provide properties to the serialization manager's <see cref="P:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Properties" /> property.</summary>
        <value>O objeto que deve ser usado para fornecer as propriedades para o Gerenciador de serialização <see cref="P:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Properties" /> propriedade.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.PropertyProvider%2A> propriedade fornece uma maneira de dar o Gerenciador de serialização de um conjunto de propriedades de serialização que serializadores podem usar para configurar seu comportamento.  
  
 As propriedades públicas do objeto serão inspecionadas e encapsuladas em novos descritores de propriedade que tem um objeto de destino do Gerenciador de serialização.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecycleInstances">
      <MemberSignature Language="C#" Value="public bool RecycleInstances { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RecycleInstances" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.RecycleInstances" />
      <MemberSignature Language="VB.NET" Value="Public Property RecycleInstances As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RecycleInstances { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RecycleInstances : bool with get, set" Usage="System.ComponentModel.Design.Serialization.DesignerSerializationManager.RecycleInstances" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a flag indicating whether <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" /> will always create a new instance of a type.</summary>
        <value>
          <see langword="true" /> Se <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" /> retornará a instância existente; <see langword="false" /> se <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" /> criará uma nova instância de um tipo. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.RecycleInstances%2A> é de propriedade `false`, o <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> método sempre criará uma nova instância de um tipo. Se <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.RecycleInstances%2A> é `true`, <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> pesquisará primeiro a tabela de nome e o contêiner para um objeto do mesmo nome. Se tal objeto exista e seja do mesmo tipo, <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> retornará a instância existente. Essa segunda é útil para implementar um serializador que aplica o estado de serialização para um conjunto de objetos existentes, em vez de criar sempre uma nova árvore. O **desfazer** comando geralmente usa esse tipo de serializador.  
  
 No caso em que o <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.RecycleInstances%2A> é de propriedade `true`, o <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes%2A> propriedade mais irá modificar o comportamento de <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> dependendo dos tipos de dois objetos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The serialization manager has an active serialization session.</exception>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" />
        <altmember cref="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes" />
      </Docs>
    </Member>
    <Member MemberName="SessionCreated">
      <MemberSignature Language="C#" Value="public event EventHandler SessionCreated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SessionCreated" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.Serialization.DesignerSerializationManager.SessionCreated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SessionCreated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SessionCreated;" />
      <MemberSignature Language="F#" Value="member this.SessionCreated : EventHandler " Usage="member this.SessionCreated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a session is created.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionDisposed">
      <MemberSignature Language="C#" Value="public event EventHandler SessionDisposed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SessionDisposed" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.Serialization.DesignerSerializationManager.SessionDisposed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SessionDisposed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SessionDisposed;" />
      <MemberSignature Language="F#" Value="member this.SessionDisposed : EventHandler " Usage="member this.SessionDisposed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a session is disposed.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.AddSerializationProvider">
      <MemberSignature Language="C#" Value="void IDesignerSerializationManager.AddSerializationProvider (System.ComponentModel.Design.Serialization.IDesignerSerializationProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.Design.Serialization.IDesignerSerializationManager.AddSerializationProvider(class System.ComponentModel.Design.Serialization.IDesignerSerializationProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#AddSerializationProvider(System.ComponentModel.Design.Serialization.IDesignerSerializationProvider)" />
      <MemberSignature Language="VB.NET" Value="Sub AddSerializationProvider (provider As IDesignerSerializationProvider) Implements IDesignerSerializationManager.AddSerializationProvider" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.Design.Serialization.IDesignerSerializationManager.AddSerializationProvider(System::ComponentModel::Design::Serialization::IDesignerSerializationProvider ^ provider) = System::ComponentModel::Design::Serialization::IDesignerSerializationManager::AddSerializationProvider;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.Design.Serialization.IDesignerSerializationProvider" />
      </Parameters>
      <Docs>
        <param name="provider">The serialization provider to add.</param>
        <summary>Adds a custom serialization provider to the serialization manager.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetSerializer%2A> método é usado para solicitar um provedor de serialização, o Gerenciador de serialização consulta os provedores de serialização personalizada primeiro antes procurando nos metadados do tipo de serializador adequado.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetSerializer(System.Type,System.Type)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#RemoveSerializationProvider(System.ComponentModel.Design.Serialization.IDesignerSerializationProvider)" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Context">
      <MemberSignature Language="C#" Value="System.ComponentModel.Design.Serialization.ContextStack System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.Design.Serialization.ContextStack System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Context" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#Context" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Context As ContextStack Implements IDesignerSerializationManager.Context" />
      <MemberSignature Language="C++ CLI" Value="property System::ComponentModel::Design::Serialization::ContextStack ^ System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Context { System::ComponentModel::Design::Serialization::ContextStack ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.Design.Serialization.DesignerSerializationManager.System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Context" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.Serialization.ContextStack</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the context stack for this serialization session.</summary>
        <value>Um <see cref="T:System.ComponentModel.Design.Serialization.ContextStack" /> que armazena dados.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pilha de contexto fornece uma área de armazenamento definida pelo usuário, implementada como uma pilha. Essa área de armazenamento é uma maneira útil para fornecer comunicação entre serializadores, como a serialização é um processo geralmente hierárquico.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property was accessed outside of a serialization session.</exception>
        <altmember cref="T:System.ComponentModel.Design.Serialization.ContextStack" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateSession" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.CreateInstance">
      <MemberSignature Language="C#" Value="object IDesignerSerializationManager.CreateInstance (Type type, System.Collections.ICollection arguments, string name, bool addToContainer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.ComponentModel.Design.Serialization.IDesignerSerializationManager.CreateInstance(class System.Type type, class System.Collections.ICollection arguments, string name, bool addToContainer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.ComponentModel.Design.Serialization.IDesignerSerializationManager.CreateInstance(Type ^ type, System::Collections::ICollection ^ arguments, System::String ^ name, bool addToContainer) = System::ComponentModel::Design::Serialization::IDesignerSerializationManager::CreateInstance;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Collections.ICollection" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="addToContainer" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">The data type to create.</param>
        <param name="arguments">The arguments to pass to the constructor for this type.</param>
        <param name="name">The name of the object. This name can be used to access the object later through <see cref="M:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetInstance(System.String)" />. If <see langword="null" /> is passed, the object is still created but cannot be accessed by name.</param>
        <param name="addToContainer">
          <see langword="true" /> to add this object to the design container. The object must implement <see cref="T:System.ComponentModel.IComponent" /> for this to have any effect.</param>
        <summary>Implements the <see cref="M:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" /> method.</summary>
        <returns>The newly created object instance.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetInstance">
      <MemberSignature Language="C#" Value="object IDesignerSerializationManager.GetInstance (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetInstance(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetInstance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function GetInstance (name As String) As Object Implements IDesignerSerializationManager.GetInstance" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetInstance(System::String ^ name) = System::ComponentModel::Design::Serialization::IDesignerSerializationManager::GetInstance;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the object to retrieve.</param>
        <summary>Retrieves an instance of a created object of the specified name.</summary>
        <returns>An instance of the object with the given name, or <see langword="null" /> if no object by that name can be found.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">This property was accessed outside of a serialization session.</exception>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetName(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetName">
      <MemberSignature Language="C#" Value="string IDesignerSerializationManager.GetName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function GetName (value As Object) As String Implements IDesignerSerializationManager.GetName" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetName(System::Object ^ value) = System::ComponentModel::Design::Serialization::IDesignerSerializationManager::GetName;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The object for which to retrieve the name.</param>
        <summary>Retrieves a name for the specified object.</summary>
        <returns>The name of the object, or <see langword="null" /> if the object is unnamed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System%23ComponentModel%23Design%23Serialization%23IDesignerSerializationManager%23GetName%2A> método não é possível localizar um nome correspondente para o `value` parâmetro, ele gera o <xref:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ResolveName> evento antes de retornar `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">This property was accessed outside of a serialization session.</exception>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetInstance(System.String)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#SetName(System.Object,System.String)" />
        <altmember cref="E:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ResolveName" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetSerializer">
      <MemberSignature Language="C#" Value="object IDesignerSerializationManager.GetSerializer (Type objectType, Type serializerType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetSerializer(class System.Type objectType, class System.Type serializerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetSerializer(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetSerializer (objectType As Type, serializerType As Type) As Object Implements IDesignerSerializationManager.GetSerializer" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetSerializer(Type ^ objectType, Type ^ serializerType) = System::ComponentModel::Design::Serialization::IDesignerSerializationManager::GetSerializer;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectType" Type="System.Type" />
        <Parameter Name="serializerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="objectType">The type of the object to get the serializer for.</param>
        <param name="serializerType">The type of the serializer to retrieve.</param>
        <summary>Gets a serializer of the requested type for the specified object type.</summary>
        <returns>An instance of the requested serializer, or <see langword="null" /> if no appropriate serializer can be located.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetType">
      <MemberSignature Language="C#" Value="Type IDesignerSerializationManager.GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function GetType (typeName As String) As Type Implements IDesignerSerializationManager.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.ComponentModel.Design.Serialization.IDesignerSerializationManager.GetType(System::String ^ typeName) = System::ComponentModel::Design::Serialization::IDesignerSerializationManager::GetType;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">The fully qualified name of the type to load.</param>
        <summary>Gets a type of the specified name.</summary>
        <returns>An instance of the type, or <see langword="null" /> if the type cannot be loaded.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">This property was accessed outside of a serialization session.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Properties">
      <MemberSignature Language="C#" Value="System.ComponentModel.PropertyDescriptorCollection System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.PropertyDescriptorCollection System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Properties" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#Properties" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Properties As PropertyDescriptorCollection Implements IDesignerSerializationManager.Properties" />
      <MemberSignature Language="C++ CLI" Value="property System::ComponentModel::PropertyDescriptorCollection ^ System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Properties { System::ComponentModel::PropertyDescriptorCollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.Design.Serialization.DesignerSerializationManager.System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Implements the <see cref="P:System.ComponentModel.Design.Serialization.IDesignerSerializationManager.Properties" /> property.</summary>
        <value>Um <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> que contém as propriedades a serem serializados.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.RemoveSerializationProvider">
      <MemberSignature Language="C#" Value="void IDesignerSerializationManager.RemoveSerializationProvider (System.ComponentModel.Design.Serialization.IDesignerSerializationProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.Design.Serialization.IDesignerSerializationManager.RemoveSerializationProvider(class System.ComponentModel.Design.Serialization.IDesignerSerializationProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#RemoveSerializationProvider(System.ComponentModel.Design.Serialization.IDesignerSerializationProvider)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveSerializationProvider (provider As IDesignerSerializationProvider) Implements IDesignerSerializationManager.RemoveSerializationProvider" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.Design.Serialization.IDesignerSerializationManager.RemoveSerializationProvider(System::ComponentModel::Design::Serialization::IDesignerSerializationProvider ^ provider) = System::ComponentModel::Design::Serialization::IDesignerSerializationManager::RemoveSerializationProvider;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.Design.Serialization.IDesignerSerializationProvider" />
      </Parameters>
      <Docs>
        <param name="provider">The <see cref="T:System.ComponentModel.Design.Serialization.IDesignerSerializationProvider" /> to remove.</param>
        <summary>Removes a previously added serialization provider.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System%23ComponentModel%23Design%23Serialization%23IDesignerSerializationManager%23RemoveSerializationProvider%2A> método Remove um provedor de serialização personalizada que foi adicionado anteriormente por uma chamada para o <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System%23ComponentModel%23Design%23Serialization%23IDesignerSerializationManager%23AddSerializationProvider%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.GetSerializer(System.Type,System.Type)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#AddSerializationProvider(System.ComponentModel.Design.Serialization.IDesignerSerializationProvider)" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ReportError">
      <MemberSignature Language="C#" Value="void IDesignerSerializationManager.ReportError (object errorInformation);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ReportError(object errorInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#ReportError(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub ReportError (errorInformation As Object) Implements IDesignerSerializationManager.ReportError" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.Design.Serialization.IDesignerSerializationManager.ReportError(System::Object ^ errorInformation) = System::ComponentModel::Design::Serialization::IDesignerSerializationManager::ReportError;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorInformation" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="errorInformation">An object containing the error information, usually of type <see cref="T:System.String" /> or <see cref="T:System.Exception" />.</param>
        <summary>Used to report a recoverable error in serialization.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Serializadores podem ser escritos para manipular erros recuperáveis normalmente chamando o <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System%23ComponentModel%23Design%23Serialization%23IDesignerSerializationManager%23ReportError%2A> método com as informações de erro. O Gerenciador de serialização pode oferecer suporte a uma lista de erros de emissão de relatórios depois que ela é concluída, ou pode lançar uma exceção desse método e anular o processo de serialização. O serializador deve continuar depois de chamar essa função.  
  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System%23ComponentModel%23Design%23Serialization%23IDesignerSerializationManager%23ReportError%2A> Adiciona o `errorInformation` parâmetro para o <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.Errors%2A> coleção. Se `errorInformation` é `null`, nenhuma ação será tomada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property was accessed outside of a serialization session.</exception>
        <altmember cref="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.Errors" />
        <altmember cref="M:System.Collections.ArrayList.Add(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationManager.SetName">
      <MemberSignature Language="C#" Value="void IDesignerSerializationManager.SetName (object instance, string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.Design.Serialization.IDesignerSerializationManager.SetName(object instance, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#SetName(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub SetName (instance As Object, name As String) Implements IDesignerSerializationManager.SetName" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.Design.Serialization.IDesignerSerializationManager.SetName(System::Object ^ instance, System::String ^ name) = System::ComponentModel::Design::Serialization::IDesignerSerializationManager::SetName;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="instance">The object to set the name.</param>
        <param name="name">A <see cref="T:System.String" /> used as the name of the object.</param>
        <summary>Sets the name for the specified object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System%23ComponentModel%23Design%23Serialization%23IDesignerSerializationManager%23SetName%2A> método fornece uma maneira de definir o nome de um objeto existente. Isso permite a criação de uma instância do objeto por meio de uma chamada para o <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System%23ComponentModel%23Design%23Serialization%23IDesignerSerializationManager%23GetInstance%2A> método, evitando a sobrecarga do <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">One or both of the parameters are <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The object specified by instance already has a name, or <paramref name="name" /> is already used by another named object.</exception>
        <exception cref="T:System.InvalidOperationException">This property was accessed outside of a serialization session.</exception>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetName(System.Object)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#ComponentModel#Design#Serialization#IDesignerSerializationManager#GetInstance(System.String)" />
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type serviceType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type serviceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.System#IServiceProvider#GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetService (serviceType As Type) As Object Implements IServiceProvider.GetService" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IServiceProvider.GetService(Type ^ serviceType) = IServiceProvider::GetService;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="serviceType">An object that specifies the type of service object to get.</param>
        <summary>For a description of this member, see the <see cref="M:System.IServiceProvider.GetService(System.Type)" /> method.</summary>
        <returns>A service object of type <paramref name="serviceType" />.  -or-  <see langword="null" /> if there is no service object of type <paramref name="serviceType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager> é convertida em uma interface de <xref:System.IServiceProvider>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateRecycledTypes">
      <MemberSignature Language="C#" Value="public bool ValidateRecycledTypes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidateRecycledTypes" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidateRecycledTypes As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidateRecycledTypes { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidateRecycledTypes : bool with get, set" Usage="System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a flag indicating whether the <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" /> method will verify that matching names refer to the same type.</summary>
        <value>
          <see langword="true" /> Se <see cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" /> verifica tipos; caso contrário, <see langword="false" /> se não existir. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes%2A> propriedade modifica o comportamento do <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance%2A> método quando o <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.RecycleInstances%2A> é de propriedade `true`, conforme detalhado na tabela a seguir.  
  
|`RecycleInstances`|`ValidateRecycledTypes`|Comportamento de `CreateInstance`|  
|------------------------|-----------------------------|----------------------------------|  
|`false`|`true` ou `false`|Sempre crie uma nova instância do tipo especificado|  
|`true`|`false`|Se uma instância correspondente for encontrada, que será retornado, independentemente de seu tipo.|  
|`true`|`true`|Se uma instância correspondente for encontrada, ele é retornado somente se seu tipo for a mesma especificada na chamada do método.|  
  
 <xref:System.ComponentModel.Design.Serialization.DesignerSerializationManager.ValidateRecycledTypes%2A> é útil para metamorfose um tipo de objeto para outro se eles têm propriedades semelhantes, mas não compartilham nenhum pai comum ou interface.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The serialization manager has an active serialization session.</exception>
        <altmember cref="M:System.ComponentModel.Design.Serialization.DesignerSerializationManager.CreateInstance(System.Type,System.Collections.ICollection,System.String,System.Boolean)" />
        <altmember cref="P:System.ComponentModel.Design.Serialization.DesignerSerializationManager.RecycleInstances" />
      </Docs>
    </Member>
  </Members>
</Type>