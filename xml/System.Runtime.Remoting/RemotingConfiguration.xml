<Type Name="RemotingConfiguration" FullName="System.Runtime.Remoting.RemotingConfiguration">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b654cf7aaff3b7f435c3a0fac58f6c81a15372e4" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30490640" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class RemotingConfiguration" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit RemotingConfiguration extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Remoting.RemotingConfiguration" />
  <TypeSignature Language="VB.NET" Value="Public Class RemotingConfiguration" />
  <TypeSignature Language="C++ CLI" Value="public ref class RemotingConfiguration abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece vários métodos estáticos para configurar a infraestrutura de comunicação remota.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="ApplicationId">
      <MemberSignature Language="C#" Value="public static string ApplicationId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ApplicationId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.RemotingConfiguration.ApplicationId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ApplicationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ApplicationId { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a ID do aplicativo em execução no momento.</summary>
        <value>Um <see cref="T:System.String" /> que contém a ID do aplicativo em execução no momento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A ID do aplicativo é anexada ao URI dos objetos criados pelo aplicativo em execução no momento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O chamador imediato não tem permissão de infraestrutura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a operação com código de infraestrutura. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public static string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.RemotingConfiguration.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nome do aplicativo de comunicação remota.</summary>
        <value>O nome de um aplicativo de comunicação remota.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um nome de aplicativo pode ser definido apenas uma vez, por meio da propriedade atual ou por meio de um arquivo de configuração. Se um aplicativo estiver em execução dentro de um ambiente hospedado, como os serviços de informações da Internet (IIS), esse valor pode ter já foi definido (normalmente para o diretório virtual). A propriedade current retornará `null` se o nome do aplicativo não foi definido.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Runtime.Remoting.RemotingConfiguration.ApplicationName%2A> propriedade para indicar o nome do aplicativo de comunicação remota. Para o código de exemplo completo, consulte os exemplos para o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> e <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType%2A> métodos.  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/server.cpp#2)]
 [!code-csharp[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/server.cs#2)]
 [!code-vb[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/server.vb#2)]  
  
 O exemplo de código a seguir demonstra como acessar um objeto remoto de um aplicativo nomeado.  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/client.cpp#6)]
 [!code-csharp[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/client.cs#6)]
 [!code-vb[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/client.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota. Essa exceção é gerada apenas ao configurar o valor da propriedade.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Configure">
      <MemberSignature Language="C#" Value="public static void Configure (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Configure(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.Configure(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Configure (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Configure(System::String ^ filename);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use Configure(String,Boolean)")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">O nome do arquivo de configuração de comunicação remota. Pode ser <see langword="null" />.</param>
        <summary>Lê o arquivo de configuração e configura a infraestrutura de comunicação remota. <see cref="M:System.Runtime.Remoting.RemotingConfiguration.Configure(System.String)" /> é obsoleto. Use <see cref="M:System.Runtime.Remoting.RemotingConfiguration.Configure(System.String,System.Boolean)" /> em seu lugar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <xref:System.Runtime.Remoting.RemotingConfiguration.Configure%28System.String%29> é obsoleto. Use <xref:System.Runtime.Remoting.RemotingConfiguration.Configure%28System.String%2CSystem.Boolean%29> em seu lugar.  
  
 Passando `null` como o `filename` parâmetro fará com que a inicialização de comunicação remota padrão sem exigir a existência de um arquivo de configuração.  
  
 Para obter a sintaxe do arquivo de configuração, consulte [esquema de configurações de comunicação remota](http://msdn.microsoft.com/library/dc2d1e62-9af7-4ca1-99fd-98b93bb4db9e).  
  
> [!NOTE]
>  Objetos de marshaling por referência (MBRs) não estão na memória para sempre. Em vez disso, a menos que o tipo substitui <xref:System.MarshalByRefObject.InitializeLifetimeService%2A?displayProperty=nameWithType> para controlar suas próprias diretivas de tempo de vida, cada MBR tem um tempo de vida finito antes do sistema de comunicação remota do .NET Framework começa o processo de exclusão e recuperação de memória. Para obter mais informações, consulte [concessões de tempo de vida](http://msdn.microsoft.com/library/c72d561c-1266-4c8b-b258-2c168c08da9a).  
  
   
  
## Examples  
 [!code-cpp[RemotingConfiguration_Configure_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/CPP/remotingconfiguration_configure_server.cpp#1)]
 [!code-csharp[RemotingConfiguration_Configure_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/CS/remotingconfiguration_configure_server.cs#1)]
 [!code-vb[RemotingConfiguration_Configure_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/VB/remotingconfiguration_configure_server.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Configure">
      <MemberSignature Language="C#" Value="public static void Configure (string filename, bool ensureSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Configure(string filename, bool ensureSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.Configure(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Configure (filename As String, ensureSecurity As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Configure(System::String ^ filename, bool ensureSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="ensureSecurity" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">O nome do arquivo de configuração de comunicação remota. Pode ser <see langword="null" />.</param>
        <param name="ensureSecurity">Se definido como <see langword="true" />, será necessária segurança. Se definido como <see langword="false" />, a segurança não será necessária, mas ainda poderá ser usada.</param>
        <summary>Lê o arquivo de configuração e configura a infraestrutura de comunicação remota.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Passando `null` como o `filename` parâmetro fará com que a inicialização de comunicação remota padrão sem exigir a existência de um arquivo de configuração. Para obter mais informações sobre segurança e comunicação remota consulte [segurança na comunicação remota.](http://msdn.microsoft.com/library/9574262c-d4b1-41c5-8600-24ff147c0add)  
  
 Para obter a sintaxe do arquivo de configuração, consulte [esquema de configurações de comunicação remota](http://msdn.microsoft.com/library/dc2d1e62-9af7-4ca1-99fd-98b93bb4db9e).  
  
> [!NOTE]
>  Objetos de marshaling por referência (MBRs) não estão na memória para sempre. Em vez disso, a menos que o tipo substitui <xref:System.MarshalByRefObject.InitializeLifetimeService%2A?displayProperty=nameWithType> para controlar suas próprias diretivas de tempo de vida, cada MBR tem um tempo de vida finito antes do sistema de comunicação remota do .NET Framework começa o processo de exclusão e recuperação de memória. Para obter mais informações, consulte [concessões de tempo de vida](http://msdn.microsoft.com/library/c72d561c-1266-4c8b-b258-2c168c08da9a).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CustomErrorsEnabled">
      <MemberSignature Language="C#" Value="public static bool CustomErrorsEnabled (bool isLocalRequest);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CustomErrorsEnabled(bool isLocalRequest) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.CustomErrorsEnabled(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CustomErrorsEnabled (isLocalRequest As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CustomErrorsEnabled(bool isLocalRequest);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isLocalRequest" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isLocalRequest">
          <see langword="true" /> para especificar os chamadores locais, <see langword="false" /> para especificar os chamadores remotos.</param>
        <summary>Indica se os canais de servidor neste domínio de aplicativo retornam informações de exceção completas ou filtradas para chamadores locais ou remotos.</summary>
        <returns>
          <see langword="true" /> se apenas as informações de exceção filtradas forem retornadas para chamadores locais ou remotos, conforme especificado pelo parâmetro <paramref name="isLocalRequest" />, <see langword="false" /> se as informações de exceção completas forem retornadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informações de exceção completa incluem a exceção de servidor exata e o rastreamento de pilha do servidor. Informações filtradas incluem uma exceção de comunicação remota padrão, mas nenhum rastreamento de pilha do servidor.  
  
 O `CustomErrorsEnabled` método reflete as definições de configuração que foram especificadas no `mode` atributo do `<customErrors>` elemento do arquivo de configuração do aplicativo. Para obter mais informações sobre opções de configuração, consulte [ &#91; \<topic://cpconconfiguration >&#93;](http://msdn.microsoft.com/library/92c0c097-d984-4315-835b-7490ecdf1097).  
  
 A tabela a seguir mostra o canal do servidor de três valores de propriedades que especificam quais chamadores recebem informações de exceção e o tipo de informação que eles recebem.  
  
|Valor|Descrição|  
|-----------|-----------------|  
|`off`|Todos os chamadores recebem informações de exceção completa.|  
|`on`|Todos os chamadores recebem informações de exceção filtrada.|  
|`remoteOnly`|Os chamadores locais recebem informações de exceção completas; os chamadores remotos recebem informações de exceção filtradas.|  
  
 A tabela a seguir mostra a interação entre o `isLocalRequest` parâmetro e o servidor de propriedade do canal.  
  
|Valor|isLocalRequest|Valor retornado|Descrição|  
|-----------|--------------------|------------------|-----------------|  
|`on`|`true`|`true`|Chamadores locais recebem informações de exceção filtrados.|  
|`on`|`false`|`true`|Chamadores remotos recebem informações de exceção filtrados.|  
|`off`|`true`|`false`|Chamadores locais recebem informações de exceção completa.|  
|`off`|`false`|`false`|Chamadores remotos recebem informações de exceção completa.|  
|`remoteOnly`|`true`|`false`|Chamadores locais recebem informações de exceção completa.|  
|`remoteOnly`|`false`|`true`|Chamadores remotos recebem informações de exceção filtrados.|  
  
 Para obter informações sobre como usar arquivos de configuração do aplicativo para controlar o retorno de informações de exceção para chamadores, consulte o `<customErrors>` elemento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomErrorsMode">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.CustomErrorsModes CustomErrorsMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Runtime.Remoting.CustomErrorsModes CustomErrorsMode" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.RemotingConfiguration.CustomErrorsMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CustomErrorsMode As CustomErrorsModes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::CustomErrorsModes CustomErrorsMode { System::Runtime::Remoting::CustomErrorsModes get(); void set(System::Runtime::Remoting::CustomErrorsModes value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.CustomErrorsModes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica como os erros personalizados são tratados.</summary>
        <value>Um membro da enumeração <see cref="T:System.Runtime.Remoting.CustomErrorsModes" /> que indica como os erros personalizados são tratados.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredActivatedClientTypes">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ActivatedClientTypeEntry[] GetRegisteredActivatedClientTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ActivatedClientTypeEntry[] GetRegisteredActivatedClientTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedClientTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRegisteredActivatedClientTypes () As ActivatedClientTypeEntry()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Runtime::Remoting::ActivatedClientTypeEntry ^&gt; ^ GetRegisteredActivatedClientTypes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ActivatedClientTypeEntry[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera uma matriz de tipos de objeto registrados no cliente como tipos que serão ativados remotamente.</summary>
        <returns>Uma matriz de tipos de objeto registrados no cliente como tipos que serão ativados remotamente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter uma descrição detalhada de objetos ativado pelo cliente, consulte [ &#91; \<topic://cpconClientActivation >&#93;](http://msdn.microsoft.com/library/4a791494-c18a-4711-a5c1-4ab0e49a8f1a).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Type)" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredActivatedServiceTypes">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ActivatedServiceTypeEntry[] GetRegisteredActivatedServiceTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ActivatedServiceTypeEntry[] GetRegisteredActivatedServiceTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedServiceTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRegisteredActivatedServiceTypes () As ActivatedServiceTypeEntry()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Runtime::Remoting::ActivatedServiceTypeEntry ^&gt; ^ GetRegisteredActivatedServiceTypes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ActivatedServiceTypeEntry[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera uma matriz de tipos de objeto registrados no lado do serviço que podem ser ativados na solicitação de um cliente.</summary>
        <returns>Uma matriz de tipos de objeto registrados no lado do serviço que podem ser ativados na solicitação de um cliente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter uma descrição detalhada de objetos ativado pelo cliente, consulte [ &#91; \<topic://cpconClientActivation >&#93;](http://msdn.microsoft.com/library/4a791494-c18a-4711-a5c1-4ab0e49a8f1a).  
  
   
  
## Examples  
 [!code-cpp[RemotingConfiguration_GetRegisteredActivatedServer_Client#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/CPP/RemotingConfiguration_GetRegisteredActivatedService_server.cpp#2)]
 [!code-csharp[RemotingConfiguration_GetRegisteredActivatedServer_Client#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/CS/remotingconfiguration_getregisteredactivatedservice_server.cs#2)]
 [!code-vb[RemotingConfiguration_GetRegisteredActivatedServer_Client#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/VB/remotingconfiguration_getregisteredactivatedservice_server.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Type)" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredWellKnownClientTypes">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.WellKnownClientTypeEntry[] GetRegisteredWellKnownClientTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.WellKnownClientTypeEntry[] GetRegisteredWellKnownClientTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownClientTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRegisteredWellKnownClientTypes () As WellKnownClientTypeEntry()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Runtime::Remoting::WellKnownClientTypeEntry ^&gt; ^ GetRegisteredWellKnownClientTypes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.WellKnownClientTypeEntry[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera uma matriz de tipos de objeto registrados no lado do cliente como tipos conhecidos.</summary>
        <returns>Uma matriz de tipos de objeto registrados no lado do cliente como tipos conhecidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tipos de objeto Well-Known podem ser chamada único ou singleton. Se um tipo de objeto for a única chamada, uma nova instância dele é criada sempre que uma chamada do cliente for. Todas as chamadas para um objeto de singleton são tratadas por uma instância do objeto.  
  
 Para obter uma descrição mais detalhada de objetos conhecidos, consulte [ &#91; \<topic://cpconServerActivation >&#93;](http://msdn.microsoft.com/library/77ded6e2-4ca8-448b-acf2-562d27fd4396).  
  
   
  
## Examples  
 [!code-cpp[RemotingConfiguration_GetRegisteredWellKnownClient_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredWellKnownClient_Client/CPP/remotingconfiguration_getregisteredwellknownclient_client.cpp#1)]
 [!code-csharp[RemotingConfiguration_GetRegisteredWellKnownClient_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredWellKnownClient_Client/CS/remotingconfiguration_getregisteredwellknownclient_client.cs#1)]
 [!code-vb[RemotingConfiguration_GetRegisteredWellKnownClient_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredWellKnownClient_Client/VB/remotingconfiguration_getregisteredwellknownclient_client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Type,System.String,System.Runtime.Remoting.WellKnownObjectMode)" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredWellKnownServiceTypes">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.WellKnownServiceTypeEntry[] GetRegisteredWellKnownServiceTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.WellKnownServiceTypeEntry[] GetRegisteredWellKnownServiceTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownServiceTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRegisteredWellKnownServiceTypes () As WellKnownServiceTypeEntry()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Runtime::Remoting::WellKnownServiceTypeEntry ^&gt; ^ GetRegisteredWellKnownServiceTypes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.WellKnownServiceTypeEntry[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera uma matriz de tipos de objeto registrados no lado do serviço como tipos conhecidos.</summary>
        <returns>Uma matriz de tipos de objeto registrados no lado do serviço como tipos conhecidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tipos de objeto Well-Known podem ser chamada único ou singleton. Se um tipo de objeto for a única chamada, uma nova instância dele é criada sempre que uma chamada do cliente for. Todas as chamadas para um objeto de singleton são tratadas por uma instância do objeto.  
  
 Para obter uma descrição mais detalhada de objetos conhecidos, consulte [ &#91; \<topic://cpconServerActivation >&#93;](http://msdn.microsoft.com/library/77ded6e2-4ca8-448b-acf2-562d27fd4396).  
  
   
  
## Examples  
 [!code-cpp[RemotingConfiguration_Configure_Client#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/CPP/remotingconfiguration_configure_server.cpp#2)]
 [!code-csharp[RemotingConfiguration_Configure_Client#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/CS/remotingconfiguration_configure_server.cs#2)]
 [!code-vb[RemotingConfiguration_Configure_Client#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/VB/remotingconfiguration_configure_server.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Type,System.String,System.Runtime.Remoting.WellKnownObjectMode)" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsActivationAllowed">
      <MemberSignature Language="C#" Value="public static bool IsActivationAllowed (Type svrType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsActivationAllowed(class System.Type svrType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.IsActivationAllowed(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsActivationAllowed (svrType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsActivationAllowed(Type ^ svrType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="svrType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="svrType">O objeto <see cref="T:System.Type" /> a ser verificado.</param>
        <summary>Retorna um valor booliano que indica se o <see cref="T:System.Type" /> especificado pode ser ativado pelo cliente.</summary>
        <returns>
          <see langword="true" /> se o <see cref="T:System.Type" /> especificado puder ser ativado pelo cliente, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método atual é usado na extremidade do servidor para determinar se uma ativação do objeto <xref:System.Type> seja explicitamente permitido pelo servidor.  
  
   
  
## Examples  
 [!code-cpp[RemotingConfiguration_GetRegisteredActivatedServer_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/CPP/RemotingConfiguration_GetRegisteredActivatedService_server.cpp#1)]
 [!code-csharp[RemotingConfiguration_GetRegisteredActivatedServer_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/CS/remotingconfiguration_getregisteredactivatedservice_server.cs#1)]
 [!code-vb[RemotingConfiguration_GetRegisteredActivatedServer_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/VB/remotingconfiguration_getregisteredactivatedservice_server.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsRemotelyActivatedClientType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verifica se o tipo de objeto especificado está registrado como um tipo de cliente ativado remotamente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsRemotelyActivatedClientType">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType (Type svrType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType(class System.Type svrType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsRemotelyActivatedClientType (svrType As Type) As ActivatedClientTypeEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ActivatedClientTypeEntry ^ IsRemotelyActivatedClientType(Type ^ svrType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ActivatedClientTypeEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="svrType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="svrType">O tipo de objeto a ser verificado.</param>
        <summary>Verifica se o <see cref="T:System.Type" /> de objeto especificado está registrado como um tipo de cliente ativado remotamente.</summary>
        <returns>O <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" /> que corresponde ao tipo de objeto especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[RemotingConfiguration_IsRemotelyActivatedClientType1_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType1_Client/CPP/remotingconfiguration_isremotelyactivatedclienttype1_client.cpp#1)]
 [!code-csharp[RemotingConfiguration_IsRemotelyActivatedClientType1_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType1_Client/CS/remotingconfiguration_isremotelyactivatedclienttype1_client.cs#1)]
 [!code-vb[RemotingConfiguration_IsRemotelyActivatedClientType1_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType1_Client/VB/remotingconfiguration_isremotelyactivatedclienttype1_client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsRemotelyActivatedClientType">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType (string typeName, string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType(string typeName, string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsRemotelyActivatedClientType (typeName As String, assemblyName As String) As ActivatedClientTypeEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ActivatedClientTypeEntry ^ IsRemotelyActivatedClientType(System::String ^ typeName, System::String ^ assemblyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ActivatedClientTypeEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">O nome do tipo do objeto a ser verificado.</param>
        <param name="assemblyName">O nome do assembly do objeto a ser verificado.</param>
        <summary>Verifica se o objeto especificado por seu nome de tipo e o nome do assembly é registrado como um tipo de cliente ativado remotamente.</summary>
        <returns>O <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" /> que corresponde ao tipo de objeto especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[RemotingConfiguration_IsRemotelyActivatedClientType2_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType2_Client/CPP/remotingconfiguration_isremotelyactivatedclienttype2_client.cpp#1)]
 [!code-csharp[RemotingConfiguration_IsRemotelyActivatedClientType2_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType2_Client/CS/remotingconfiguration_isremotelyactivatedclienttype2_client.cs#1)]
 [!code-vb[RemotingConfiguration_IsRemotelyActivatedClientType2_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType2_Client/VB/remotingconfiguration_isremotelyactivatedclienttype2_client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsWellKnownClientType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verifica se o tipo de objeto especificado está registrado como um tipo de cliente conhecido.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsWellKnownClientType">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType (Type svrType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType(class System.Type svrType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWellKnownClientType (svrType As Type) As WellKnownClientTypeEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::WellKnownClientTypeEntry ^ IsWellKnownClientType(Type ^ svrType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.WellKnownClientTypeEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="svrType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="svrType">O objeto <see cref="T:System.Type" /> a ser verificado.</param>
        <summary>Verifica se o <see cref="T:System.Type" /> de objeto especificado está registrado como um tipo de cliente conhecido.</summary>
        <returns>O <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" /> que corresponde ao tipo de objeto especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[RemotingConfiguration_IsWellKnownClientType1_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType1_Client/CPP/remotingconfiguration_iswellknownclienttype1_client.cpp#1)]
 [!code-csharp[RemotingConfiguration_IsWellKnownClientType1_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType1_Client/CS/remotingconfiguration_iswellknownclienttype1_client.cs#1)]
 [!code-vb[RemotingConfiguration_IsWellKnownClientType1_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType1_Client/VB/remotingconfiguration_iswellknownclienttype1_client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsWellKnownClientType">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType (string typeName, string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType(string typeName, string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWellKnownClientType (typeName As String, assemblyName As String) As WellKnownClientTypeEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::WellKnownClientTypeEntry ^ IsWellKnownClientType(System::String ^ typeName, System::String ^ assemblyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.WellKnownClientTypeEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">O nome do tipo do objeto a ser verificado.</param>
        <param name="assemblyName">O nome do assembly do objeto a ser verificado.</param>
        <summary>Verifica se o objeto especificado por seu nome de tipo e o nome do assembly é registrado como um tipo de cliente conhecido.</summary>
        <returns>O <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" /> que corresponde ao tipo de objeto especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[RemotingConfiguration_IsWellKnownClientType2_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType2_Client/CPP/remotingconfiguration_iswellknownclienttype2_client.cpp#1)]
 [!code-csharp[RemotingConfiguration_IsWellKnownClientType2_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType2_Client/CS/remotingconfiguration_iswellknownclienttype2_client.cs#1)]
 [!code-vb[RemotingConfiguration_IsWellKnownClientType2_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType2_Client/VB/remotingconfiguration_iswellknownclienttype2_client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ProcessId">
      <MemberSignature Language="C#" Value="public static string ProcessId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProcessId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.RemotingConfiguration.ProcessId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProcessId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProcessId { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a ID do processo em execução no momento.</summary>
        <value>Um <see cref="T:System.String" /> que contém a ID do processo em execução no momento.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">O chamador imediato não tem permissão de infraestrutura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a operação com código de infraestrutura. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterActivatedClientType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra um objeto <see cref="T:System.Type" /> no lado do cliente como um tipo que pode ser ativado no servidor.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterActivatedClientType">
      <MemberSignature Language="C#" Value="public static void RegisterActivatedClientType (System.Runtime.Remoting.ActivatedClientTypeEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterActivatedClientType(class System.Runtime.Remoting.ActivatedClientTypeEntry entry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Runtime.Remoting.ActivatedClientTypeEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterActivatedClientType (entry As ActivatedClientTypeEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterActivatedClientType(System::Runtime::Remoting::ActivatedClientTypeEntry ^ entry);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="System.Runtime.Remoting.ActivatedClientTypeEntry" />
      </Parameters>
      <Docs>
        <param name="entry">Definições de configuração para o tipo ativado pelo cliente.</param>
        <summary>Registra um <see cref="T:System.Type" /> de objeto registrado no <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" /> fornecido no lado do cliente como um tipo que pode ser ativado no servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para criar uma instância de um objeto ativado pelo cliente no servidor, você deve saber o <xref:System.Type> e ele deve ser registrado na extremidade do servidor usando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> método. Para obter um proxy para uma nova instância do objeto cliente ativado, o cliente deve primeiro registrar um canal com <xref:System.Runtime.Remoting.Channels.ChannelServices> e, em seguida, ativar o objeto chamando `new`.  
  
 Para ativar um tipo de objeto ativado pelo cliente com o `new` palavra-chave, você deve primeiro registrar o tipo de objeto no cliente final usando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> método. Chamando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> método fornece a infraestrutura de comunicação remota a localização do aplicativo remoto onde `new` tentará criá-la. Se, por outro lado, você usa o <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método para criar uma nova instância do objeto cliente ativado, você deve fornecer a URL do aplicativo remoto como um parâmetro, portanto, nenhum registro anterior no lado do cliente é necessário. Para fornecer o <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método com a URL do servidor onde você deseja criar o objeto, você deve encapsular a URL em uma instância do <xref:System.Runtime.Remoting.Activation.UrlAttribute> classe.  
  
 Para obter uma descrição detalhada de objetos ativado pelo cliente, consulte [ &#91; \<topic://cpconClientActivation >&#93;](http://msdn.microsoft.com/library/4a791494-c18a-4711-a5c1-4ab0e49a8f1a).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
      </Docs>
    </Member>
    <Member MemberName="RegisterActivatedClientType">
      <MemberSignature Language="C#" Value="public static void RegisterActivatedClientType (Type type, string appUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterActivatedClientType(class System.Type type, string appUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterActivatedClientType(Type ^ type, System::String ^ appUrl);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="appUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">O objeto <see cref="T:System.Type" />.</param>
        <param name="appUrl">URL do aplicativo em que esse tipo está ativado.</param>
        <summary>Registra um <see cref="T:System.Type" /> de objeto na extremidade do cliente como um tipo que pode ser ativado no servidor, usando os parâmetros especificados para inicializar uma nova instância da classe <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para criar uma instância de um objeto ativado pelo cliente no servidor, você deve saber o <xref:System.Type> e ele deve ser registrado na extremidade do servidor usando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> método. Para obter um proxy para uma nova instância do objeto cliente ativado, o cliente deve primeiro registrar um canal com <xref:System.Runtime.Remoting.Channels.ChannelServices> e, em seguida, ativar o objeto chamando `new`.  
  
 Para ativar um tipo de objeto ativado pelo cliente com o `new` palavra-chave, você deve primeiro registrar o tipo de objeto no cliente final usando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> método. Chamando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> método fornece a infraestrutura de comunicação remota a localização do aplicativo remoto onde `new` tentará criá-la. Se, por outro lado, você usa o <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método para criar uma nova instância do objeto cliente ativado, você deve fornecer a URL do aplicativo remoto como um parâmetro, portanto, nenhum registro anterior no lado do cliente é necessário. Para fornecer o <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método com a URL do servidor onde você deseja criar o objeto, você deve encapsular a URL em uma instância do <xref:System.Runtime.Remoting.Activation.UrlAttribute> classe.  
  
 Para obter uma descrição detalhada de objetos ativado pelo cliente, consulte [ &#91; \<topic://cpconClientActivation >&#93;](http://msdn.microsoft.com/library/4a791494-c18a-4711-a5c1-4ab0e49a8f1a)  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o registro de um tipo de objeto no lado do cliente como um tipo que pode ser ativado no servidor. Para o código de servidor que corresponde ao código cliente apresentada, consulte o exemplo para o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> método.  
  
 [!code-cpp[RemotingConfiguration.ClientActivation#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CPP/client.cpp#1)]
 [!code-csharp[RemotingConfiguration.ClientActivation#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CS/client.cs#1)]
 [!code-vb[RemotingConfiguration.ClientActivation#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/VB/client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="typeName" /> ou <paramref name="URI" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterActivatedServiceType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra um <see cref="T:System.Type" /> de objeto no lado do serviço como um que pode ser ativado na solicitação de um cliente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterActivatedServiceType">
      <MemberSignature Language="C#" Value="public static void RegisterActivatedServiceType (System.Runtime.Remoting.ActivatedServiceTypeEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterActivatedServiceType(class System.Runtime.Remoting.ActivatedServiceTypeEntry entry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Runtime.Remoting.ActivatedServiceTypeEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterActivatedServiceType (entry As ActivatedServiceTypeEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterActivatedServiceType(System::Runtime::Remoting::ActivatedServiceTypeEntry ^ entry);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="System.Runtime.Remoting.ActivatedServiceTypeEntry" />
      </Parameters>
      <Docs>
        <param name="entry">Definições de configuração para o tipo ativado pelo cliente.</param>
        <summary>Registra um tipo de objeto registrado no <see cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" /> fornecido no lado do serviço como um que pode ser ativado na solicitação de um cliente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para criar uma instância de um objeto ativado pelo cliente no servidor, você deve saber o <xref:System.Type> e ele deve ser registrado na extremidade do servidor usando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> método. Para obter um proxy para uma nova instância do objeto cliente ativado, o cliente deve primeiro registrar um canal com <xref:System.Runtime.Remoting.Channels.ChannelServices> e, em seguida, ativar o objeto chamando `new` ou <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>.  
  
 Para ativar um tipo de objeto ativado pelo cliente com o `new` palavra-chave, você deve primeiro registrar o tipo de objeto no cliente final usando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> método. Chamando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> método fornece a infraestrutura de comunicação remota a localização do aplicativo remoto, onde `new` tentará criá-la. Se, por outro lado, você usa o <xref:System.Activator.CreateInstance%2A> método para criar uma nova instância do objeto cliente ativado, você deve fornecer a URL do aplicativo remoto como um parâmetro, portanto, nenhum registro anterior no lado do cliente é necessário. Para fornecer o <xref:System.Activator.CreateInstance%2A> método com a URL do servidor onde você deseja criar o objeto, você deve encapsular a URL em uma instância do <xref:System.Runtime.Remoting.Activation.UrlAttribute> classe.  
  
 Para obter uma descrição detalhada de objetos ativado pelo cliente, consulte [ &#91; \<topic://cpconClientActivation >&#93;](http://msdn.microsoft.com/library/4a791494-c18a-4711-a5c1-4ab0e49a8f1a).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
      </Docs>
    </Member>
    <Member MemberName="RegisterActivatedServiceType">
      <MemberSignature Language="C#" Value="public static void RegisterActivatedServiceType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterActivatedServiceType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterActivatedServiceType(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">O <see cref="T:System.Type" /> do objeto a ser registrado.</param>
        <summary>Registra um tipo de objeto especificado no lado do serviço como um tipo que pode ser ativado na solicitação de um cliente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para criar uma instância de um objeto ativado pelo cliente no servidor, você deve saber o <xref:System.Type> e ele deve ser registrado na extremidade do servidor usando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> método. Para obter um proxy para uma nova instância do objeto cliente ativado, o cliente deve primeiro registrar um canal com <xref:System.Runtime.Remoting.Channels.ChannelServices> e, em seguida, ativar o objeto chamando `new` ou <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>.  
  
 Para ativar um tipo de objeto ativado pelo cliente com o `new` palavra-chave, você deve primeiro registrar o tipo de objeto no cliente final usando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> método. Chamando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> método fornece a infraestrutura de comunicação remota a localização do aplicativo remoto, onde `new` tentará criá-la. Se, por outro lado, você usa o <xref:System.Activator.CreateInstance%2A> método para criar uma nova instância do objeto cliente ativado, você deve fornecer a URL do aplicativo remoto como um parâmetro, portanto, nenhum registro anterior no lado do cliente é necessário. Para fornecer o <xref:System.Activator.CreateInstance%2A> método com a URL do servidor onde você deseja criar o objeto, você deve encapsular a URL em uma instância do <xref:System.Runtime.Remoting.Activation.UrlAttribute> classe.  
  
 Para obter uma descrição detalhada de objetos ativado pelo cliente, consulte [ &#91; \<topic://cpconClientActivation >&#93;](http://msdn.microsoft.com/library/4a791494-c18a-4711-a5c1-4ab0e49a8f1a).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o registro de um tipo de objeto no servidor como um tipo que pode ser ativado pelo cliente. Para o código do cliente que corresponde ao código de servidor apresentada, consulte o exemplo para o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> método.  
  
 [!code-cpp[RemotingConfiguration.ClientActivation#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CPP/server.cpp#2)]
 [!code-csharp[RemotingConfiguration.ClientActivation#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CS/server.cs#2)]
 [!code-vb[RemotingConfiguration.ClientActivation#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/VB/server.vb#2)]  
  
 O exemplo de código a seguir mostra o objeto de serviço registrado no código de exemplo acima.  
  
 [!code-cpp[RemotingConfiguration.ClientActivation#3](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CPP/service.cpp#3)]
 [!code-csharp[RemotingConfiguration.ClientActivation#3](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CS/service.cs#3)]
 [!code-vb[RemotingConfiguration.ClientActivation#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/VB/service.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWellKnownClientType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra um <see cref="T:System.Type" /> de objeto no lado do cliente como um tipo conhecido (chamada única ou singleton).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWellKnownClientType">
      <MemberSignature Language="C#" Value="public static void RegisterWellKnownClientType (System.Runtime.Remoting.WellKnownClientTypeEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterWellKnownClientType(class System.Runtime.Remoting.WellKnownClientTypeEntry entry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Runtime.Remoting.WellKnownClientTypeEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterWellKnownClientType (entry As WellKnownClientTypeEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterWellKnownClientType(System::Runtime::Remoting::WellKnownClientTypeEntry ^ entry);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="System.Runtime.Remoting.WellKnownClientTypeEntry" />
      </Parameters>
      <Docs>
        <param name="entry">Definições de configuração para o tipo conhecido.</param>
        <summary>Registra um <see cref="T:System.Type" /> de objeto registrado no <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" /> fornecido no lado do cliente como um tipo conhecido que pode ser ativado no servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer cliente que saiba o URI de um objeto conhecido registrado pode obter um proxy para o objeto registrando o canal que ele prefere com <xref:System.Runtime.Remoting.Channels.ChannelServices>e ativar o objeto chamando `new` ou <xref:System.Activator.GetObject%2A?displayProperty=nameWithType>. Para ativar um objeto conhecido com `new`, você deve primeiro registrar o tipo de objeto conhecido no cliente usando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> método. Chamando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> método fornece a infraestrutura de comunicação remota a localização do objeto remoto, que permite que o `new` palavra-chave para criá-lo. Se, por outro lado, você usa o <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> método para ativar o objeto conhecido, você deve fornecê-lo com a URL do objeto como um argumento, portanto, nenhum registro anterior no lado do cliente é necessário.  
  
 Para obter uma descrição detalhada de objetos conhecidos, consulte [ &#91; \<topic://cpconServerActivation >&#93;](http://msdn.microsoft.com/library/77ded6e2-4ca8-448b-acf2-562d27fd4396).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
      </Docs>
    </Member>
    <Member MemberName="RegisterWellKnownClientType">
      <MemberSignature Language="C#" Value="public static void RegisterWellKnownClientType (Type type, string objectUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterWellKnownClientType(class System.Type type, string objectUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterWellKnownClientType(Type ^ type, System::String ^ objectUrl);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="objectUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">O objeto <see cref="T:System.Type" />.</param>
        <param name="objectUrl">URL de um objeto de cliente conhecido.</param>
        <summary>Registra um objeto <see cref="T:System.Type" /> na extremidade do cliente como um tipo conhecido que pode ser ativado no servidor, usando os parâmetros especificados para inicializar uma nova instância da classe <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer cliente que saiba o URI de um objeto conhecido registrado pode obter um proxy para o objeto registrando o canal que ele prefere com <xref:System.Runtime.Remoting.Channels.ChannelServices>e ativar o objeto chamando `new` ou <xref:System.Activator.GetObject%2A?displayProperty=nameWithType>. Para ativar um objeto conhecido com `new`, você deve primeiro registrar o tipo de objeto conhecido no cliente usando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> método. Chamando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> método fornece a infraestrutura de comunicação remota a localização do objeto remoto, que permite que o `new` palavra-chave para criá-lo. Se, por outro lado, você usa o <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> método para ativar o objeto conhecido, você deve fornecê-lo com a URL do objeto como um argumento, portanto, nenhum registro anterior no lado do cliente é necessário.  
  
 Para obter uma descrição detalhada de objetos conhecidos, consulte [ &#91; \<topic://cpconServerActivation >&#93;](http://msdn.microsoft.com/library/77ded6e2-4ca8-448b-acf2-562d27fd4396).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o registro de um tipo de objeto no lado do cliente como um tipo conhecido. Para o código de servidor que corresponde ao código cliente apresentada, consulte o exemplo para o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType%2A> método.  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/client.cpp#5)]
 [!code-csharp[RemotingConfiguration.ServerActivation1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/client.cs#5)]
 [!code-vb[RemotingConfiguration.ServerActivation1#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/client.vb#5)]  
[!code-cpp[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/client.cpp#6)]
[!code-csharp[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/client.cs#6)]
[!code-vb[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/client.vb#6)]  
[!code-cpp[RemotingConfiguration.ServerActivation1#7](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/client.cpp#7)]
[!code-csharp[RemotingConfiguration.ServerActivation1#7](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/client.cs#7)]
[!code-vb[RemotingConfiguration.ServerActivation1#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/client.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWellKnownServiceType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra um <see cref="T:System.Type" /> de objeto no lado do serviço como um tipo conhecido (chamada única ou singleton).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWellKnownServiceType">
      <MemberSignature Language="C#" Value="public static void RegisterWellKnownServiceType (System.Runtime.Remoting.WellKnownServiceTypeEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterWellKnownServiceType(class System.Runtime.Remoting.WellKnownServiceTypeEntry entry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Runtime.Remoting.WellKnownServiceTypeEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterWellKnownServiceType (entry As WellKnownServiceTypeEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterWellKnownServiceType(System::Runtime::Remoting::WellKnownServiceTypeEntry ^ entry);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="System.Runtime.Remoting.WellKnownServiceTypeEntry" />
      </Parameters>
      <Docs>
        <param name="entry">Definições de configuração para o tipo conhecido.</param>
        <summary>Registra um objeto <see cref="T:System.Type" /> registrado no <see cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" /> fornecido na extremidade do serviço como um tipo conhecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer cliente que saiba o URI de um objeto conhecido registrado pode obter um proxy para o objeto registrando o canal que ele prefere com <xref:System.Runtime.Remoting.Channels.ChannelServices>e ativar o objeto chamando `new` ou <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> método. Para ativar um objeto conhecido com `new`, você deve primeiro registrar o tipo de objeto conhecido no cliente usando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> método. Chamando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> método fornece a infraestrutura de comunicação remota a localização do objeto remoto, que permite que o `new` palavra-chave para criá-lo. Se, por outro lado, você usa o <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> método para ativar o objeto conhecido, você deve fornecê-lo com a URL do objeto como um argumento, portanto, nenhum registro anterior no lado do cliente é necessário.  
  
 Quando a chamada chega ao servidor, o .NET Framework extrai o URI da mensagem, examina as tabelas de comunicação remota para localizar a referência para o objeto que coincide com o URI e, em seguida, cria o objeto, se necessário, a chamada de método para o objeto de encaminhamento. Se o objeto é registrado como <xref:System.Runtime.Remoting.WellKnownObjectMode.SingleCall>, ele será destruído depois que a chamada do método está concluída. Uma nova instância do objeto é criada para cada método de chamada. A única diferença entre <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> e `new` é que a primeira permite que você especifique uma URL como um parâmetro e o último obtém a URL da configuração.  
  
 O objeto remoto em si não é instanciado pelo processo de registro. Isso só acontece quando um cliente tentar chamar um método no objeto ou ativa o objeto do lado do cliente.  
  
 Para obter uma descrição detalhada de objetos conhecidos, consulte [ &#91; \<topic://cpconServerActivation >&#93;](http://msdn.microsoft.com/library/77ded6e2-4ca8-448b-acf2-562d27fd4396).  
  
   
  
## Examples  
 [!code-cpp[CreateObjRef2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/CreateObjRef2/CPP/example.cpp#2)]
 [!code-csharp[CreateObjRef2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/CreateObjRef2/CS/example.cs#2)]
 [!code-vb[CreateObjRef2#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/CreateObjRef2/VB/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
      </Docs>
    </Member>
    <Member MemberName="RegisterWellKnownServiceType">
      <MemberSignature Language="C#" Value="public static void RegisterWellKnownServiceType (Type type, string objectUri, System.Runtime.Remoting.WellKnownObjectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterWellKnownServiceType(class System.Type type, string objectUri, valuetype System.Runtime.Remoting.WellKnownObjectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Type,System.String,System.Runtime.Remoting.WellKnownObjectMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterWellKnownServiceType(Type ^ type, System::String ^ objectUri, System::Runtime::Remoting::WellKnownObjectMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="objectUri" Type="System.String" />
        <Parameter Name="mode" Type="System.Runtime.Remoting.WellKnownObjectMode" />
      </Parameters>
      <Docs>
        <param name="type">O objeto <see cref="T:System.Type" />.</param>
        <param name="objectUri">O URI do objeto.</param>
        <param name="mode">O modo de ativação do tipo de objeto conhecido que está sendo registrado. (Consulte <see cref="T:System.Runtime.Remoting.WellKnownObjectMode" />.)</param>
        <summary>Registra um <see cref="T:System.Type" /> de objeto no lado do serviço como um tipo conhecido, usando os parâmetros fornecidos para inicializar uma nova instância de <see cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer cliente que saiba o URI de um objeto conhecido registrado pode obter um proxy para o objeto registrando o canal que ele prefere com <xref:System.Runtime.Remoting.Channels.ChannelServices>e ativar o objeto chamando `new` ou <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> método. Para ativar um objeto conhecido com `new`, você deve primeiro registrar o tipo de objeto conhecido no cliente usando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> método. Chamando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> método fornece a infraestrutura de comunicação remota a localização do objeto remoto, que permite que o `new` palavra-chave para criá-lo. Se, por outro lado, você usa o <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> método para ativar o objeto conhecido, você deve fornecê-lo com a URL do objeto como um argumento, portanto, nenhum registro anterior no lado do cliente é necessário.  
  
 Quando a chamada chega ao servidor, o .NET Framework extrai o URI da mensagem, examina as tabelas de comunicação remota para localizar a referência para o objeto que coincide com o URI e, em seguida, cria o objeto, se necessário, a chamada de método para o objeto de encaminhamento. Se o objeto é registrado como <xref:System.Runtime.Remoting.WellKnownObjectMode.SingleCall>, ele será destruído depois que a chamada do método está concluída. Uma nova instância do objeto é criada para cada método de chamada. A única diferença entre <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> e `new` é que a primeira permite que você especifique uma URL como um parâmetro e o último obtém a URL da configuração.  
  
 O objeto remoto em si não é instanciado pelo processo de registro. Isso só acontece quando um cliente tentar chamar um método no objeto ou ativa o objeto do lado do cliente.  
  
 Para obter uma descrição detalhada de objetos conhecidos, consulte [ &#91; \<topic://cpconServerActivation >&#93;](http://msdn.microsoft.com/library/77ded6e2-4ca8-448b-acf2-562d27fd4396).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o registro de um tipo de objeto no servidor como um tipo de objeto conhecido. Para o código do cliente que corresponde ao código de servidor apresentada, consulte o exemplo para o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> método.  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/server.cpp#1)]
 [!code-csharp[RemotingConfiguration.ServerActivation1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/server.cs#1)]
 [!code-vb[RemotingConfiguration.ServerActivation1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/server.vb#1)]  
[!code-cpp[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/server.cpp#2)]
[!code-csharp[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/server.cs#2)]
[!code-vb[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/server.vb#2)]  
[!code-cpp[RemotingConfiguration.ServerActivation1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/server.cpp#3)]
[!code-csharp[RemotingConfiguration.ServerActivation1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/server.cs#3)]
[!code-vb[RemotingConfiguration.ServerActivation1#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/server.vb#3)]  
  
 O exemplo de código a seguir mostra o objeto de serviço registrado no código de exemplo acima.  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/service.cpp#4)]
 [!code-csharp[RemotingConfiguration.ServerActivation1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/service.cs#4)]
 [!code-vb[RemotingConfiguration.ServerActivation1#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/service.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
      </Docs>
    </Member>
  </Members>
</Type>