<Type Name="RemotingConfiguration" FullName="System.Runtime.Remoting.RemotingConfiguration">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="34ce3c84c00cd67c48df02d07f9b62f04e00022c" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37467390" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class RemotingConfiguration" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit RemotingConfiguration extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Remoting.RemotingConfiguration" />
  <TypeSignature Language="VB.NET" Value="Public Class RemotingConfiguration" />
  <TypeSignature Language="C++ CLI" Value="public ref class RemotingConfiguration abstract sealed" />
  <TypeSignature Language="F#" Value="type RemotingConfiguration = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece vários métodos estáticos para configurar a infraestrutura de comunicação remota.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="ApplicationId">
      <MemberSignature Language="C#" Value="public static string ApplicationId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ApplicationId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.RemotingConfiguration.ApplicationId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ApplicationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ApplicationId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationId : string" Usage="System.Runtime.Remoting.RemotingConfiguration.ApplicationId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a ID do aplicativo em execução no momento.</summary>
        <value>Um <see cref="T:System.String" /> que contém a ID do aplicativo em execução no momento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A ID do aplicativo é anexada para o URI dos objetos criados pelo aplicativo em execução no momento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O chamador imediato não tem permissão de infraestrutura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para a operação com código de infraestrutura. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public static string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.RemotingConfiguration.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.Runtime.Remoting.RemotingConfiguration.ApplicationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nome do aplicativo de comunicação remota.</summary>
        <value>O nome de um aplicativo de comunicação remota.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um nome de aplicativo pode ser definido apenas uma vez, por meio da propriedade atual ou por meio de um arquivo de configuração. Se um aplicativo estiver em execução dentro de um ambiente hospedado, como o Internet Information Services (IIS), esse valor pode ter já foi definido (normalmente, para o diretório virtual). A propriedade current retornará `null` se o nome do aplicativo não tiver sido definido.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Runtime.Remoting.RemotingConfiguration.ApplicationName%2A> propriedade para indicar o nome do aplicativo de comunicação remota. Para obter o código de exemplo completo, consulte exemplos para o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> e <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType%2A> métodos.  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/server.cpp#2)]
 [!code-csharp[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/server.cs#2)]
 [!code-vb[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/server.vb#2)]  
  
 O exemplo de código a seguir demonstra como acessar um objeto remoto de um aplicativo nomeado.  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/client.cpp#6)]
 [!code-csharp[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/client.cs#6)]
 [!code-vb[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/client.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota. Essa exceção é gerada apenas ao configurar o valor da propriedade.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Configure">
      <MemberSignature Language="C#" Value="public static void Configure (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Configure(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.Configure(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Configure (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Configure(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="static member Configure : string -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.Configure filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use Configure(String,Boolean)")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">O nome do arquivo de configuração de comunicação remota. Pode ser <see langword="null" />.</param>
        <summary>Lê o arquivo de configuração e configura a infraestrutura de comunicação remota. <see cref="M:System.Runtime.Remoting.RemotingConfiguration.Configure(System.String)" /> é obsoleto. Use <see cref="M:System.Runtime.Remoting.RemotingConfiguration.Configure(System.String,System.Boolean)" /> em seu lugar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <xref:System.Runtime.Remoting.RemotingConfiguration.Configure%28System.String%29> é obsoleto. Use <xref:System.Runtime.Remoting.RemotingConfiguration.Configure%28System.String%2CSystem.Boolean%29> em seu lugar.  
  
 Passando `null` como o `filename` parâmetro fará com que a inicialização de comunicação remota padrão sem a necessidade da existência de um arquivo de configuração.  
  
 Para obter a sintaxe do arquivo de configuração, consulte [esquema de configurações de comunicação remota](http://msdn.microsoft.com/library/dc2d1e62-9af7-4ca1-99fd-98b93bb4db9e).  
  
> [!NOTE]
>  Objetos de marshaling por referência (MBRs) não residem na memória para sempre. Em vez disso, a menos que o tipo substitui <xref:System.MarshalByRefObject.InitializeLifetimeService%2A?displayProperty=nameWithType> para controlar suas próprias diretivas de tempo de vida, cada MBR tem um tempo de vida finito antes que o sistema de comunicação remota do .NET Framework começa o processo de excluí-lo e recuperar a memória. Para obter mais informações, consulte [concessões de tempo de vida](http://msdn.microsoft.com/library/c72d561c-1266-4c8b-b258-2c168c08da9a).  
  
   
  
## Examples  
 [!code-cpp[RemotingConfiguration_Configure_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/CPP/remotingconfiguration_configure_server.cpp#1)]
 [!code-csharp[RemotingConfiguration_Configure_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/CS/remotingconfiguration_configure_server.cs#1)]
 [!code-vb[RemotingConfiguration_Configure_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/VB/remotingconfiguration_configure_server.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Configure">
      <MemberSignature Language="C#" Value="public static void Configure (string filename, bool ensureSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Configure(string filename, bool ensureSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.Configure(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Configure (filename As String, ensureSecurity As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Configure(System::String ^ filename, bool ensureSecurity);" />
      <MemberSignature Language="F#" Value="static member Configure : string * bool -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.Configure (filename, ensureSecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="ensureSecurity" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">O nome do arquivo de configuração de comunicação remota. Pode ser <see langword="null" />.</param>
        <param name="ensureSecurity">Se definido como <see langword="true" />, será necessária segurança. Se definido como <see langword="false" />, a segurança não será necessária, mas ainda poderá ser usada.</param>
        <summary>Lê o arquivo de configuração e configura a infraestrutura de comunicação remota.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Passando `null` como o `filename` parâmetro fará com que a inicialização de comunicação remota padrão sem a necessidade da existência de um arquivo de configuração. Para obter mais informações sobre a segurança e a comunicação remota, consulte [segurança na comunicação remota.](http://msdn.microsoft.com/library/9574262c-d4b1-41c5-8600-24ff147c0add)  
  
 Para obter a sintaxe do arquivo de configuração, consulte [esquema de configurações de comunicação remota](http://msdn.microsoft.com/library/dc2d1e62-9af7-4ca1-99fd-98b93bb4db9e).  
  
> [!NOTE]
>  Objetos de marshaling por referência (MBRs) não residem na memória para sempre. Em vez disso, a menos que o tipo substitui <xref:System.MarshalByRefObject.InitializeLifetimeService%2A?displayProperty=nameWithType> para controlar suas próprias diretivas de tempo de vida, cada MBR tem um tempo de vida finito antes que o sistema de comunicação remota do .NET Framework começa o processo de excluí-lo e recuperar a memória. Para obter mais informações, consulte [concessões de tempo de vida](http://msdn.microsoft.com/library/c72d561c-1266-4c8b-b258-2c168c08da9a).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CustomErrorsEnabled">
      <MemberSignature Language="C#" Value="public static bool CustomErrorsEnabled (bool isLocalRequest);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CustomErrorsEnabled(bool isLocalRequest) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.CustomErrorsEnabled(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CustomErrorsEnabled (isLocalRequest As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CustomErrorsEnabled(bool isLocalRequest);" />
      <MemberSignature Language="F#" Value="static member CustomErrorsEnabled : bool -&gt; bool" Usage="System.Runtime.Remoting.RemotingConfiguration.CustomErrorsEnabled isLocalRequest" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isLocalRequest" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isLocalRequest">
          <see langword="true" /> para especificar os chamadores locais, <see langword="false" /> para especificar os chamadores remotos.</param>
        <summary>Indica se os canais de servidor neste domínio de aplicativo retornam informações de exceção completas ou filtradas para chamadores locais ou remotos.</summary>
        <returns>
          <see langword="true" /> se apenas as informações de exceção filtradas forem retornadas para chamadores locais ou remotos, conforme especificado pelo parâmetro <paramref name="isLocalRequest" />, <see langword="false" /> se as informações de exceção completas forem retornadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informações de exceção completa incluem a exceção de servidor exata e o rastreamento de pilha do servidor. Informações filtradas incluem uma exceção de comunicação remota padrão, mas nenhum rastreamento de pilha do servidor.  
  
 O `CustomErrorsEnabled` método reflete as definições de configuração que foram especificadas na `mode` atributo do `<customErrors>` elemento do arquivo de configuração do aplicativo. Para obter mais informações sobre opções de configuração, consulte [ &#91; \<topic://cpconconfiguration >&#93;](http://msdn.microsoft.com/library/92c0c097-d984-4315-835b-7490ecdf1097).  
  
 A tabela a seguir mostra o canal de servidor de três valores de propriedade que especificam que os chamadores recebem informações de exceção e quais tipos de informações que eles recebem.  
  
|Valor|Descrição|  
|-----------|-----------------|  
|`off`|Todos os chamadores recebem informações de exceção completa.|  
|`on`|Todos os chamadores recebem informações de exceção filtrada.|  
|`remoteOnly`|Os chamadores locais recebem informações de exceção completas; os chamadores remotos recebem informações de exceção filtradas.|  
  
 A tabela a seguir mostra a interação entre o `isLocalRequest` parâmetro e o servidor de propriedade de canal.  
  
|Valor|isLocalRequest|Valor retornado|Descrição|  
|-----------|--------------------|------------------|-----------------|  
|`on`|`true`|`true`|Os chamadores locais recebem informações de exceção filtradas.|  
|`on`|`false`|`true`|Os chamadores remotos recebem informações de exceção filtradas.|  
|`off`|`true`|`false`|Os chamadores locais recebem informações de exceção completas.|  
|`off`|`false`|`false`|Os chamadores remotos recebem informações de exceção completas.|  
|`remoteOnly`|`true`|`false`|Os chamadores locais recebem informações de exceção completas.|  
|`remoteOnly`|`false`|`true`|Os chamadores remotos recebem informações de exceção filtradas.|  
  
 Para obter informações sobre como usar arquivos de configuração de aplicativo para controlar o retorno das informações de exceção para os chamadores, consulte o `<customErrors>` elemento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomErrorsMode">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.CustomErrorsModes CustomErrorsMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Runtime.Remoting.CustomErrorsModes CustomErrorsMode" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.RemotingConfiguration.CustomErrorsMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CustomErrorsMode As CustomErrorsModes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::CustomErrorsModes CustomErrorsMode { System::Runtime::Remoting::CustomErrorsModes get(); void set(System::Runtime::Remoting::CustomErrorsModes value); };" />
      <MemberSignature Language="F#" Value="member this.CustomErrorsMode : System.Runtime.Remoting.CustomErrorsModes with get, set" Usage="System.Runtime.Remoting.RemotingConfiguration.CustomErrorsMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.CustomErrorsModes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica como os erros personalizados são tratados.</summary>
        <value>Um membro da enumeração <see cref="T:System.Runtime.Remoting.CustomErrorsModes" /> que indica como os erros personalizados são tratados.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredActivatedClientTypes">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ActivatedClientTypeEntry[] GetRegisteredActivatedClientTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ActivatedClientTypeEntry[] GetRegisteredActivatedClientTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedClientTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRegisteredActivatedClientTypes () As ActivatedClientTypeEntry()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Runtime::Remoting::ActivatedClientTypeEntry ^&gt; ^ GetRegisteredActivatedClientTypes();" />
      <MemberSignature Language="F#" Value="static member GetRegisteredActivatedClientTypes : unit -&gt; System.Runtime.Remoting.ActivatedClientTypeEntry[]" Usage="System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedClientTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ActivatedClientTypeEntry[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera uma matriz de tipos de objeto registrados no cliente como tipos que serão ativados remotamente.</summary>
        <returns>Uma matriz de tipos de objeto registrados no cliente como tipos que serão ativados remotamente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter uma descrição detalhada de objetos ativados pelo cliente, consulte [ &#91; \<topic://cpconClientActivation >&#93;](http://msdn.microsoft.com/library/4a791494-c18a-4711-a5c1-4ab0e49a8f1a).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Type)" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredActivatedServiceTypes">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ActivatedServiceTypeEntry[] GetRegisteredActivatedServiceTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ActivatedServiceTypeEntry[] GetRegisteredActivatedServiceTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedServiceTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRegisteredActivatedServiceTypes () As ActivatedServiceTypeEntry()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Runtime::Remoting::ActivatedServiceTypeEntry ^&gt; ^ GetRegisteredActivatedServiceTypes();" />
      <MemberSignature Language="F#" Value="static member GetRegisteredActivatedServiceTypes : unit -&gt; System.Runtime.Remoting.ActivatedServiceTypeEntry[]" Usage="System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedServiceTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ActivatedServiceTypeEntry[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera uma matriz de tipos de objeto registrados no lado do serviço que podem ser ativados na solicitação de um cliente.</summary>
        <returns>Uma matriz de tipos de objeto registrados no lado do serviço que podem ser ativados na solicitação de um cliente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter uma descrição detalhada de objetos ativados pelo cliente, consulte [ &#91; \<topic://cpconClientActivation >&#93;](http://msdn.microsoft.com/library/4a791494-c18a-4711-a5c1-4ab0e49a8f1a).  
  
   
  
## Examples  
 [!code-cpp[RemotingConfiguration_GetRegisteredActivatedServer_Client#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/CPP/RemotingConfiguration_GetRegisteredActivatedService_server.cpp#2)]
 [!code-csharp[RemotingConfiguration_GetRegisteredActivatedServer_Client#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/CS/remotingconfiguration_getregisteredactivatedservice_server.cs#2)]
 [!code-vb[RemotingConfiguration_GetRegisteredActivatedServer_Client#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/VB/remotingconfiguration_getregisteredactivatedservice_server.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Type)" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredWellKnownClientTypes">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.WellKnownClientTypeEntry[] GetRegisteredWellKnownClientTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.WellKnownClientTypeEntry[] GetRegisteredWellKnownClientTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownClientTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRegisteredWellKnownClientTypes () As WellKnownClientTypeEntry()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Runtime::Remoting::WellKnownClientTypeEntry ^&gt; ^ GetRegisteredWellKnownClientTypes();" />
      <MemberSignature Language="F#" Value="static member GetRegisteredWellKnownClientTypes : unit -&gt; System.Runtime.Remoting.WellKnownClientTypeEntry[]" Usage="System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownClientTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.WellKnownClientTypeEntry[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera uma matriz de tipos de objeto registrados no lado do cliente como tipos conhecidos.</summary>
        <returns>Uma matriz de tipos de objeto registrados no lado do cliente como tipos conhecidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tipos de objeto Well-Known podem ser chamada única ou singleton. Se um tipo de objeto for uma única chamada, uma nova instância dele é criada sempre que uma chamada do cliente vem. Todas as chamadas para um objeto singleton são tratadas por uma instância desse objeto.  
  
 Para obter uma descrição mais detalhada dos objetos bem conhecidos, consulte [ &#91; \<topic://cpconServerActivation >&#93;](http://msdn.microsoft.com/library/77ded6e2-4ca8-448b-acf2-562d27fd4396).  
  
   
  
## Examples  
 [!code-cpp[RemotingConfiguration_GetRegisteredWellKnownClient_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredWellKnownClient_Client/CPP/remotingconfiguration_getregisteredwellknownclient_client.cpp#1)]
 [!code-csharp[RemotingConfiguration_GetRegisteredWellKnownClient_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredWellKnownClient_Client/CS/remotingconfiguration_getregisteredwellknownclient_client.cs#1)]
 [!code-vb[RemotingConfiguration_GetRegisteredWellKnownClient_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredWellKnownClient_Client/VB/remotingconfiguration_getregisteredwellknownclient_client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Type,System.String,System.Runtime.Remoting.WellKnownObjectMode)" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredWellKnownServiceTypes">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.WellKnownServiceTypeEntry[] GetRegisteredWellKnownServiceTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.WellKnownServiceTypeEntry[] GetRegisteredWellKnownServiceTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownServiceTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRegisteredWellKnownServiceTypes () As WellKnownServiceTypeEntry()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Runtime::Remoting::WellKnownServiceTypeEntry ^&gt; ^ GetRegisteredWellKnownServiceTypes();" />
      <MemberSignature Language="F#" Value="static member GetRegisteredWellKnownServiceTypes : unit -&gt; System.Runtime.Remoting.WellKnownServiceTypeEntry[]" Usage="System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownServiceTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.WellKnownServiceTypeEntry[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera uma matriz de tipos de objeto registrados no lado do serviço como tipos conhecidos.</summary>
        <returns>Uma matriz de tipos de objeto registrados no lado do serviço como tipos conhecidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tipos de objeto Well-Known podem ser chamada única ou singleton. Se um tipo de objeto for uma única chamada, uma nova instância dele é criada sempre que uma chamada do cliente vem. Todas as chamadas para um objeto singleton são tratadas por uma instância desse objeto.  
  
 Para obter uma descrição mais detalhada dos objetos bem conhecidos, consulte [ &#91; \<topic://cpconServerActivation >&#93;](http://msdn.microsoft.com/library/77ded6e2-4ca8-448b-acf2-562d27fd4396).  
  
   
  
## Examples  
 [!code-cpp[RemotingConfiguration_Configure_Client#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/CPP/remotingconfiguration_configure_server.cpp#2)]
 [!code-csharp[RemotingConfiguration_Configure_Client#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/CS/remotingconfiguration_configure_server.cs#2)]
 [!code-vb[RemotingConfiguration_Configure_Client#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/VB/remotingconfiguration_configure_server.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Type,System.String,System.Runtime.Remoting.WellKnownObjectMode)" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsActivationAllowed">
      <MemberSignature Language="C#" Value="public static bool IsActivationAllowed (Type svrType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsActivationAllowed(class System.Type svrType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.IsActivationAllowed(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsActivationAllowed (svrType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsActivationAllowed(Type ^ svrType);" />
      <MemberSignature Language="F#" Value="static member IsActivationAllowed : Type -&gt; bool" Usage="System.Runtime.Remoting.RemotingConfiguration.IsActivationAllowed svrType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="svrType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="svrType">O objeto <see cref="T:System.Type" /> a ser verificado.</param>
        <summary>Retorna um valor booliano que indica se o <see cref="T:System.Type" /> especificado pode ser ativado pelo cliente.</summary>
        <returns>
          <see langword="true" /> se o <see cref="T:System.Type" /> especificado puder ser ativado pelo cliente, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método atual é usado na extremidade do servidor para determinar se uma ativação do objeto <xref:System.Type> seja explicitamente permitido pelo servidor.  
  
   
  
## Examples  
 [!code-cpp[RemotingConfiguration_GetRegisteredActivatedServer_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/CPP/RemotingConfiguration_GetRegisteredActivatedService_server.cpp#1)]
 [!code-csharp[RemotingConfiguration_GetRegisteredActivatedServer_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/CS/remotingconfiguration_getregisteredactivatedservice_server.cs#1)]
 [!code-vb[RemotingConfiguration_GetRegisteredActivatedServer_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/VB/remotingconfiguration_getregisteredactivatedservice_server.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsRemotelyActivatedClientType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verifica se o tipo de objeto especificado está registrado como um tipo de cliente ativado remotamente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsRemotelyActivatedClientType">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType (Type svrType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType(class System.Type svrType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsRemotelyActivatedClientType (svrType As Type) As ActivatedClientTypeEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ActivatedClientTypeEntry ^ IsRemotelyActivatedClientType(Type ^ svrType);" />
      <MemberSignature Language="F#" Value="static member IsRemotelyActivatedClientType : Type -&gt; System.Runtime.Remoting.ActivatedClientTypeEntry" Usage="System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType svrType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ActivatedClientTypeEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="svrType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="svrType">O tipo de objeto a ser verificado.</param>
        <summary>Verifica se o <see cref="T:System.Type" /> de objeto especificado está registrado como um tipo de cliente ativado remotamente.</summary>
        <returns>O <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" /> que corresponde ao tipo de objeto especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[RemotingConfiguration_IsRemotelyActivatedClientType1_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType1_Client/CPP/remotingconfiguration_isremotelyactivatedclienttype1_client.cpp#1)]
 [!code-csharp[RemotingConfiguration_IsRemotelyActivatedClientType1_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType1_Client/CS/remotingconfiguration_isremotelyactivatedclienttype1_client.cs#1)]
 [!code-vb[RemotingConfiguration_IsRemotelyActivatedClientType1_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType1_Client/VB/remotingconfiguration_isremotelyactivatedclienttype1_client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsRemotelyActivatedClientType">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType (string typeName, string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType(string typeName, string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsRemotelyActivatedClientType (typeName As String, assemblyName As String) As ActivatedClientTypeEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ActivatedClientTypeEntry ^ IsRemotelyActivatedClientType(System::String ^ typeName, System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="static member IsRemotelyActivatedClientType : string * string -&gt; System.Runtime.Remoting.ActivatedClientTypeEntry" Usage="System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType (typeName, assemblyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ActivatedClientTypeEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">O nome do tipo do objeto a ser verificado.</param>
        <param name="assemblyName">O nome do assembly do objeto a ser verificado.</param>
        <summary>Verifica se o objeto especificado por seu nome de tipo e o nome do assembly é registrado como um tipo de cliente ativado remotamente.</summary>
        <returns>O <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" /> que corresponde ao tipo de objeto especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[RemotingConfiguration_IsRemotelyActivatedClientType2_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType2_Client/CPP/remotingconfiguration_isremotelyactivatedclienttype2_client.cpp#1)]
 [!code-csharp[RemotingConfiguration_IsRemotelyActivatedClientType2_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType2_Client/CS/remotingconfiguration_isremotelyactivatedclienttype2_client.cs#1)]
 [!code-vb[RemotingConfiguration_IsRemotelyActivatedClientType2_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType2_Client/VB/remotingconfiguration_isremotelyactivatedclienttype2_client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsWellKnownClientType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verifica se o tipo de objeto especificado está registrado como um tipo de cliente conhecido.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsWellKnownClientType">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType (Type svrType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType(class System.Type svrType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWellKnownClientType (svrType As Type) As WellKnownClientTypeEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::WellKnownClientTypeEntry ^ IsWellKnownClientType(Type ^ svrType);" />
      <MemberSignature Language="F#" Value="static member IsWellKnownClientType : Type -&gt; System.Runtime.Remoting.WellKnownClientTypeEntry" Usage="System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType svrType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.WellKnownClientTypeEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="svrType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="svrType">O objeto <see cref="T:System.Type" /> a ser verificado.</param>
        <summary>Verifica se o <see cref="T:System.Type" /> de objeto especificado está registrado como um tipo de cliente conhecido.</summary>
        <returns>O <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" /> que corresponde ao tipo de objeto especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[RemotingConfiguration_IsWellKnownClientType1_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType1_Client/CPP/remotingconfiguration_iswellknownclienttype1_client.cpp#1)]
 [!code-csharp[RemotingConfiguration_IsWellKnownClientType1_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType1_Client/CS/remotingconfiguration_iswellknownclienttype1_client.cs#1)]
 [!code-vb[RemotingConfiguration_IsWellKnownClientType1_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType1_Client/VB/remotingconfiguration_iswellknownclienttype1_client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsWellKnownClientType">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType (string typeName, string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType(string typeName, string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWellKnownClientType (typeName As String, assemblyName As String) As WellKnownClientTypeEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::WellKnownClientTypeEntry ^ IsWellKnownClientType(System::String ^ typeName, System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="static member IsWellKnownClientType : string * string -&gt; System.Runtime.Remoting.WellKnownClientTypeEntry" Usage="System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType (typeName, assemblyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.WellKnownClientTypeEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">O nome do tipo do objeto a ser verificado.</param>
        <param name="assemblyName">O nome do assembly do objeto a ser verificado.</param>
        <summary>Verifica se o objeto especificado por seu nome de tipo e o nome do assembly é registrado como um tipo de cliente conhecido.</summary>
        <returns>O <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" /> que corresponde ao tipo de objeto especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[RemotingConfiguration_IsWellKnownClientType2_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType2_Client/CPP/remotingconfiguration_iswellknownclienttype2_client.cpp#1)]
 [!code-csharp[RemotingConfiguration_IsWellKnownClientType2_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType2_Client/CS/remotingconfiguration_iswellknownclienttype2_client.cs#1)]
 [!code-vb[RemotingConfiguration_IsWellKnownClientType2_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType2_Client/VB/remotingconfiguration_iswellknownclienttype2_client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ProcessId">
      <MemberSignature Language="C#" Value="public static string ProcessId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProcessId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.RemotingConfiguration.ProcessId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProcessId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProcessId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessId : string" Usage="System.Runtime.Remoting.RemotingConfiguration.ProcessId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a ID do processo em execução no momento.</summary>
        <value>Um <see cref="T:System.String" /> que contém a ID do processo em execução no momento.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">O chamador imediato não tem permissão de infraestrutura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para a operação com código de infraestrutura. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterActivatedClientType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra um objeto <see cref="T:System.Type" /> no lado do cliente como um tipo que pode ser ativado no servidor.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterActivatedClientType">
      <MemberSignature Language="C#" Value="public static void RegisterActivatedClientType (System.Runtime.Remoting.ActivatedClientTypeEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterActivatedClientType(class System.Runtime.Remoting.ActivatedClientTypeEntry entry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Runtime.Remoting.ActivatedClientTypeEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterActivatedClientType (entry As ActivatedClientTypeEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterActivatedClientType(System::Runtime::Remoting::ActivatedClientTypeEntry ^ entry);" />
      <MemberSignature Language="F#" Value="static member RegisterActivatedClientType : System.Runtime.Remoting.ActivatedClientTypeEntry -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType entry" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="System.Runtime.Remoting.ActivatedClientTypeEntry" />
      </Parameters>
      <Docs>
        <param name="entry">Definições de configuração para o tipo ativado pelo cliente.</param>
        <summary>Registra um <see cref="T:System.Type" /> de objeto registrado no <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" /> fornecido no lado do cliente como um tipo que pode ser ativado no servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para criar uma instância de um objeto ativado pelo cliente no servidor, você deve saber sua <xref:System.Type> e deve ser registrado na extremidade do servidor usando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> método. Para obter um proxy para uma nova instância do objeto ativado pelo cliente, o cliente deve primeiro registrar um canal com <xref:System.Runtime.Remoting.Channels.ChannelServices> e, em seguida, ative o objeto chamando `new`.  
  
 Para ativar um tipo de objeto ativado pelo cliente com o `new` palavra-chave, você deve primeiro registrar o tipo de objeto no cliente final usando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> método. Chamar o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> método fornece a infraestrutura de comunicação remota o local do aplicativo remoto onde `new` tentará criá-la. Se, por outro lado, você usa o <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método para criar uma nova instância do objeto ativado pelo cliente, você deve fornecer a URL do aplicativo remoto como um parâmetro, portanto, nenhum registro anterior no lado do cliente é necessário. Para fornecer a <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método com a URL do servidor onde você deseja criar o objeto, você deve encapsular a URL em uma instância da <xref:System.Runtime.Remoting.Activation.UrlAttribute> classe.  
  
 Para obter uma descrição detalhada de objetos ativados pelo cliente, consulte [ &#91; \<topic://cpconClientActivation >&#93;](http://msdn.microsoft.com/library/4a791494-c18a-4711-a5c1-4ab0e49a8f1a).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
      </Docs>
    </Member>
    <Member MemberName="RegisterActivatedClientType">
      <MemberSignature Language="C#" Value="public static void RegisterActivatedClientType (Type type, string appUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterActivatedClientType(class System.Type type, string appUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterActivatedClientType(Type ^ type, System::String ^ appUrl);" />
      <MemberSignature Language="F#" Value="static member RegisterActivatedClientType : Type * string -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType (type, appUrl)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="appUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">O objeto <see cref="T:System.Type" />.</param>
        <param name="appUrl">URL do aplicativo em que esse tipo está ativado.</param>
        <summary>Registra um <see cref="T:System.Type" /> de objeto na extremidade do cliente como um tipo que pode ser ativado no servidor, usando os parâmetros especificados para inicializar uma nova instância da classe <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para criar uma instância de um objeto ativado pelo cliente no servidor, você deve saber sua <xref:System.Type> e deve ser registrado na extremidade do servidor usando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> método. Para obter um proxy para uma nova instância do objeto ativado pelo cliente, o cliente deve primeiro registrar um canal com <xref:System.Runtime.Remoting.Channels.ChannelServices> e, em seguida, ative o objeto chamando `new`.  
  
 Para ativar um tipo de objeto ativado pelo cliente com o `new` palavra-chave, você deve primeiro registrar o tipo de objeto no cliente final usando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> método. Chamar o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> método fornece a infraestrutura de comunicação remota o local do aplicativo remoto onde `new` tentará criá-la. Se, por outro lado, você usa o <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método para criar uma nova instância do objeto ativado pelo cliente, você deve fornecer a URL do aplicativo remoto como um parâmetro, portanto, nenhum registro anterior no lado do cliente é necessário. Para fornecer a <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método com a URL do servidor onde você deseja criar o objeto, você deve encapsular a URL em uma instância da <xref:System.Runtime.Remoting.Activation.UrlAttribute> classe.  
  
 Para obter uma descrição detalhada de objetos ativados pelo cliente, consulte [ &#91; \<topic://cpconClientActivation >&#93;](http://msdn.microsoft.com/library/4a791494-c18a-4711-a5c1-4ab0e49a8f1a)  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o registro de um tipo de objeto no lado do cliente como um tipo que pode ser ativado no servidor. Para o código de servidor que corresponde ao código do cliente apresentada, consulte o exemplo para o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> método.  
  
 [!code-cpp[RemotingConfiguration.ClientActivation#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CPP/client.cpp#1)]
 [!code-csharp[RemotingConfiguration.ClientActivation#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CS/client.cs#1)]
 [!code-vb[RemotingConfiguration.ClientActivation#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/VB/client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="typeName" /> ou <paramref name="URI" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterActivatedServiceType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra um <see cref="T:System.Type" /> de objeto no lado do serviço como um que pode ser ativado na solicitação de um cliente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterActivatedServiceType">
      <MemberSignature Language="C#" Value="public static void RegisterActivatedServiceType (System.Runtime.Remoting.ActivatedServiceTypeEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterActivatedServiceType(class System.Runtime.Remoting.ActivatedServiceTypeEntry entry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Runtime.Remoting.ActivatedServiceTypeEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterActivatedServiceType (entry As ActivatedServiceTypeEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterActivatedServiceType(System::Runtime::Remoting::ActivatedServiceTypeEntry ^ entry);" />
      <MemberSignature Language="F#" Value="static member RegisterActivatedServiceType : System.Runtime.Remoting.ActivatedServiceTypeEntry -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType entry" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="System.Runtime.Remoting.ActivatedServiceTypeEntry" />
      </Parameters>
      <Docs>
        <param name="entry">Definições de configuração para o tipo ativado pelo cliente.</param>
        <summary>Registra um tipo de objeto registrado no <see cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" /> fornecido no lado do serviço como um que pode ser ativado na solicitação de um cliente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para criar uma instância de um objeto ativado pelo cliente no servidor, você deve saber sua <xref:System.Type> e deve ser registrado na extremidade do servidor usando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> método. Para obter um proxy para uma nova instância do objeto ativado pelo cliente, o cliente deve primeiro registrar um canal com <xref:System.Runtime.Remoting.Channels.ChannelServices> e, em seguida, ative o objeto chamando `new` ou <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>.  
  
 Para ativar um tipo de objeto ativado pelo cliente com o `new` palavra-chave, você deve primeiro registrar o tipo de objeto no cliente final usando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> método. Chamar o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> método fornece a infraestrutura de comunicação remota o local do aplicativo remoto, onde `new` tentará criá-la. Se, por outro lado, você usa o <xref:System.Activator.CreateInstance%2A> método para criar uma nova instância do objeto ativado pelo cliente, você deve fornecer a URL do aplicativo remoto como um parâmetro, portanto, nenhum registro anterior no lado do cliente é necessário. Para fornecer a <xref:System.Activator.CreateInstance%2A> método com a URL do servidor onde você deseja criar o objeto, você deve encapsular a URL em uma instância da <xref:System.Runtime.Remoting.Activation.UrlAttribute> classe.  
  
 Para obter uma descrição detalhada de objetos ativados pelo cliente, consulte [ &#91; \<topic://cpconClientActivation >&#93;](http://msdn.microsoft.com/library/4a791494-c18a-4711-a5c1-4ab0e49a8f1a).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
      </Docs>
    </Member>
    <Member MemberName="RegisterActivatedServiceType">
      <MemberSignature Language="C#" Value="public static void RegisterActivatedServiceType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterActivatedServiceType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterActivatedServiceType(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member RegisterActivatedServiceType : Type -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">O <see cref="T:System.Type" /> do objeto a ser registrado.</param>
        <summary>Registra um tipo de objeto especificado no lado do serviço como um tipo que pode ser ativado na solicitação de um cliente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para criar uma instância de um objeto ativado pelo cliente no servidor, você deve saber sua <xref:System.Type> e deve ser registrado na extremidade do servidor usando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> método. Para obter um proxy para uma nova instância do objeto ativado pelo cliente, o cliente deve primeiro registrar um canal com <xref:System.Runtime.Remoting.Channels.ChannelServices> e, em seguida, ative o objeto chamando `new` ou <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>.  
  
 Para ativar um tipo de objeto ativado pelo cliente com o `new` palavra-chave, você deve primeiro registrar o tipo de objeto no cliente final usando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> método. Chamar o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> método fornece a infraestrutura de comunicação remota o local do aplicativo remoto, onde `new` tentará criá-la. Se, por outro lado, você usa o <xref:System.Activator.CreateInstance%2A> método para criar uma nova instância do objeto ativado pelo cliente, você deve fornecer a URL do aplicativo remoto como um parâmetro, portanto, nenhum registro anterior no lado do cliente é necessário. Para fornecer a <xref:System.Activator.CreateInstance%2A> método com a URL do servidor onde você deseja criar o objeto, você deve encapsular a URL em uma instância da <xref:System.Runtime.Remoting.Activation.UrlAttribute> classe.  
  
 Para obter uma descrição detalhada de objetos ativados pelo cliente, consulte [ &#91; \<topic://cpconClientActivation >&#93;](http://msdn.microsoft.com/library/4a791494-c18a-4711-a5c1-4ab0e49a8f1a).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o registro de um tipo de objeto no servidor como um tipo que pode ser ativado pelo cliente. Para o código de cliente que corresponde ao código apresentado server, consulte o exemplo para o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> método.  
  
 [!code-cpp[RemotingConfiguration.ClientActivation#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CPP/server.cpp#2)]
 [!code-csharp[RemotingConfiguration.ClientActivation#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CS/server.cs#2)]
 [!code-vb[RemotingConfiguration.ClientActivation#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/VB/server.vb#2)]  
  
 O exemplo de código a seguir mostra o objeto de serviço registrado no código de exemplo acima.  
  
 [!code-cpp[RemotingConfiguration.ClientActivation#3](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CPP/service.cpp#3)]
 [!code-csharp[RemotingConfiguration.ClientActivation#3](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CS/service.cs#3)]
 [!code-vb[RemotingConfiguration.ClientActivation#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/VB/service.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWellKnownClientType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra um <see cref="T:System.Type" /> de objeto no lado do cliente como um tipo conhecido (chamada única ou singleton).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWellKnownClientType">
      <MemberSignature Language="C#" Value="public static void RegisterWellKnownClientType (System.Runtime.Remoting.WellKnownClientTypeEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterWellKnownClientType(class System.Runtime.Remoting.WellKnownClientTypeEntry entry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Runtime.Remoting.WellKnownClientTypeEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterWellKnownClientType (entry As WellKnownClientTypeEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterWellKnownClientType(System::Runtime::Remoting::WellKnownClientTypeEntry ^ entry);" />
      <MemberSignature Language="F#" Value="static member RegisterWellKnownClientType : System.Runtime.Remoting.WellKnownClientTypeEntry -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType entry" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="System.Runtime.Remoting.WellKnownClientTypeEntry" />
      </Parameters>
      <Docs>
        <param name="entry">Definições de configuração para o tipo conhecido.</param>
        <summary>Registra um <see cref="T:System.Type" /> de objeto registrado no <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" /> fornecido no lado do cliente como um tipo conhecido que pode ser ativado no servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer cliente que conhece o URI de um objeto conhecido registrado pode obter um proxy para o objeto registrando-se o canal que ele prefere com <xref:System.Runtime.Remoting.Channels.ChannelServices>e ativar o objeto chamando `new` ou <xref:System.Activator.GetObject%2A?displayProperty=nameWithType>. Para ativar um objeto conhecido com `new`, você deve primeiro registrar o tipo de objeto conhecido no cliente usando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> método. Chamar o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> método fornece a infraestrutura de comunicação remota o local do objeto remoto, que permite que o `new` palavra-chave para criá-lo. Se, por outro lado, você usa o <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> método para ativar o objeto conhecido, você deve fornecê-lo com a URL do objeto como um argumento, portanto, nenhum registro anterior no lado do cliente é necessário.  
  
 Para obter uma descrição detalhada dos objetos bem conhecidos, consulte [ &#91; \<topic://cpconServerActivation >&#93;](http://msdn.microsoft.com/library/77ded6e2-4ca8-448b-acf2-562d27fd4396).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
      </Docs>
    </Member>
    <Member MemberName="RegisterWellKnownClientType">
      <MemberSignature Language="C#" Value="public static void RegisterWellKnownClientType (Type type, string objectUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterWellKnownClientType(class System.Type type, string objectUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterWellKnownClientType(Type ^ type, System::String ^ objectUrl);" />
      <MemberSignature Language="F#" Value="static member RegisterWellKnownClientType : Type * string -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType (type, objectUrl)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="objectUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">O objeto <see cref="T:System.Type" />.</param>
        <param name="objectUrl">URL de um objeto de cliente conhecido.</param>
        <summary>Registra um objeto <see cref="T:System.Type" /> na extremidade do cliente como um tipo conhecido que pode ser ativado no servidor, usando os parâmetros especificados para inicializar uma nova instância da classe <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer cliente que conhece o URI de um objeto conhecido registrado pode obter um proxy para o objeto registrando-se o canal que ele prefere com <xref:System.Runtime.Remoting.Channels.ChannelServices>e ativar o objeto chamando `new` ou <xref:System.Activator.GetObject%2A?displayProperty=nameWithType>. Para ativar um objeto conhecido com `new`, você deve primeiro registrar o tipo de objeto conhecido no cliente usando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> método. Chamar o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> método fornece a infraestrutura de comunicação remota o local do objeto remoto, que permite que o `new` palavra-chave para criá-lo. Se, por outro lado, você usa o <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> método para ativar o objeto conhecido, você deve fornecê-lo com a URL do objeto como um argumento, portanto, nenhum registro anterior no lado do cliente é necessário.  
  
 Para obter uma descrição detalhada dos objetos bem conhecidos, consulte [ &#91; \<topic://cpconServerActivation >&#93;](http://msdn.microsoft.com/library/77ded6e2-4ca8-448b-acf2-562d27fd4396).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o registro de um tipo de objeto no lado do cliente como um tipo conhecido. Para o código de servidor que corresponde ao código do cliente apresentada, consulte o exemplo para o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType%2A> método.  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/client.cpp#5)]
 [!code-csharp[RemotingConfiguration.ServerActivation1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/client.cs#5)]
 [!code-vb[RemotingConfiguration.ServerActivation1#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/client.vb#5)]  
[!code-cpp[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/client.cpp#6)]
[!code-csharp[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/client.cs#6)]
[!code-vb[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/client.vb#6)]  
[!code-cpp[RemotingConfiguration.ServerActivation1#7](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/client.cpp#7)]
[!code-csharp[RemotingConfiguration.ServerActivation1#7](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/client.cs#7)]
[!code-vb[RemotingConfiguration.ServerActivation1#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/client.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWellKnownServiceType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra um <see cref="T:System.Type" /> de objeto no lado do serviço como um tipo conhecido (chamada única ou singleton).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWellKnownServiceType">
      <MemberSignature Language="C#" Value="public static void RegisterWellKnownServiceType (System.Runtime.Remoting.WellKnownServiceTypeEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterWellKnownServiceType(class System.Runtime.Remoting.WellKnownServiceTypeEntry entry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Runtime.Remoting.WellKnownServiceTypeEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterWellKnownServiceType (entry As WellKnownServiceTypeEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterWellKnownServiceType(System::Runtime::Remoting::WellKnownServiceTypeEntry ^ entry);" />
      <MemberSignature Language="F#" Value="static member RegisterWellKnownServiceType : System.Runtime.Remoting.WellKnownServiceTypeEntry -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType entry" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="System.Runtime.Remoting.WellKnownServiceTypeEntry" />
      </Parameters>
      <Docs>
        <param name="entry">Definições de configuração para o tipo conhecido.</param>
        <summary>Registra um objeto <see cref="T:System.Type" /> registrado no <see cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" /> fornecido na extremidade do serviço como um tipo conhecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer cliente que conhece o URI de um objeto conhecido registrado pode obter um proxy para o objeto registrando-se o canal que ele prefere com <xref:System.Runtime.Remoting.Channels.ChannelServices>e ativar o objeto chamando `new` ou o <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> método. Para ativar um objeto conhecido com `new`, você deve primeiro registrar o tipo de objeto conhecido no cliente usando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> método. Chamar o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> método fornece a infraestrutura de comunicação remota o local do objeto remoto, que permite que o `new` palavra-chave para criá-lo. Se, por outro lado, você usa o <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> método para ativar o objeto conhecido, você deve fornecê-lo com a URL do objeto como um argumento, portanto, nenhum registro anterior no lado do cliente é necessário.  
  
 Quando a chamada chega ao servidor, o .NET Framework extrai o URI da mensagem, examina as tabelas de comunicação remota para localizar a referência para o objeto que corresponde ao URI e, em seguida, cria uma instância do objeto, se necessário, a chamada de método para o objeto de encaminhamento. Se o objeto for registrado como <xref:System.Runtime.Remoting.WellKnownObjectMode.SingleCall>, ele será destruído após a conclusão da chamada de método. Uma nova instância do objeto é criada para cada método chamado. A única diferença entre <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> e `new` é que a primeira opção permite que você especifique uma URL como um parâmetro e o último obtém a URL da configuração.  
  
 O objeto remoto em si não é instanciado pelo processo de registro. Isso só acontece quando um cliente tenta chamar um método no objeto ou ativa o objeto do lado do cliente.  
  
 Para obter uma descrição detalhada dos objetos bem conhecidos, consulte [ &#91; \<topic://cpconServerActivation >&#93;](http://msdn.microsoft.com/library/77ded6e2-4ca8-448b-acf2-562d27fd4396).  
  
   
  
## Examples  
 [!code-cpp[CreateObjRef2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/CreateObjRef2/CPP/example.cpp#2)]
 [!code-csharp[CreateObjRef2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/CreateObjRef2/CS/example.cs#2)]
 [!code-vb[CreateObjRef2#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/CreateObjRef2/VB/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
      </Docs>
    </Member>
    <Member MemberName="RegisterWellKnownServiceType">
      <MemberSignature Language="C#" Value="public static void RegisterWellKnownServiceType (Type type, string objectUri, System.Runtime.Remoting.WellKnownObjectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterWellKnownServiceType(class System.Type type, string objectUri, valuetype System.Runtime.Remoting.WellKnownObjectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Type,System.String,System.Runtime.Remoting.WellKnownObjectMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterWellKnownServiceType(Type ^ type, System::String ^ objectUri, System::Runtime::Remoting::WellKnownObjectMode mode);" />
      <MemberSignature Language="F#" Value="static member RegisterWellKnownServiceType : Type * string * System.Runtime.Remoting.WellKnownObjectMode -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType (type, objectUri, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="objectUri" Type="System.String" />
        <Parameter Name="mode" Type="System.Runtime.Remoting.WellKnownObjectMode" />
      </Parameters>
      <Docs>
        <param name="type">O objeto <see cref="T:System.Type" />.</param>
        <param name="objectUri">O URI do objeto.</param>
        <param name="mode">O modo de ativação do tipo de objeto conhecido que está sendo registrado. (Consulte <see cref="T:System.Runtime.Remoting.WellKnownObjectMode" />.)</param>
        <summary>Registra um <see cref="T:System.Type" /> de objeto no lado do serviço como um tipo conhecido, usando os parâmetros fornecidos para inicializar uma nova instância de <see cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer cliente que conhece o URI de um objeto conhecido registrado pode obter um proxy para o objeto registrando-se o canal que ele prefere com <xref:System.Runtime.Remoting.Channels.ChannelServices>e ativar o objeto chamando `new` ou o <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> método. Para ativar um objeto conhecido com `new`, você deve primeiro registrar o tipo de objeto conhecido no cliente usando o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> método. Chamar o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> método fornece a infraestrutura de comunicação remota o local do objeto remoto, que permite que o `new` palavra-chave para criá-lo. Se, por outro lado, você usa o <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> método para ativar o objeto conhecido, você deve fornecê-lo com a URL do objeto como um argumento, portanto, nenhum registro anterior no lado do cliente é necessário.  
  
 Quando a chamada chega ao servidor, o .NET Framework extrai o URI da mensagem, examina as tabelas de comunicação remota para localizar a referência para o objeto que corresponde ao URI e, em seguida, cria uma instância do objeto, se necessário, a chamada de método para o objeto de encaminhamento. Se o objeto for registrado como <xref:System.Runtime.Remoting.WellKnownObjectMode.SingleCall>, ele será destruído após a conclusão da chamada de método. Uma nova instância do objeto é criada para cada método chamado. A única diferença entre <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> e `new` é que a primeira opção permite que você especifique uma URL como um parâmetro e o último obtém a URL da configuração.  
  
 O objeto remoto em si não é instanciado pelo processo de registro. Isso só acontece quando um cliente tenta chamar um método no objeto ou ativa o objeto do lado do cliente.  
  
 Para obter uma descrição detalhada dos objetos bem conhecidos, consulte [ &#91; \<topic://cpconServerActivation >&#93;](http://msdn.microsoft.com/library/77ded6e2-4ca8-448b-acf2-562d27fd4396).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o registro de um tipo de objeto no servidor como um tipo de objeto conhecido. Para o código de cliente que corresponde ao código apresentado server, consulte o exemplo para o <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> método.  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/server.cpp#1)]
 [!code-csharp[RemotingConfiguration.ServerActivation1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/server.cs#1)]
 [!code-vb[RemotingConfiguration.ServerActivation1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/server.vb#1)]  
[!code-cpp[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/server.cpp#2)]
[!code-csharp[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/server.cs#2)]
[!code-vb[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/server.vb#2)]  
[!code-cpp[RemotingConfiguration.ServerActivation1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/server.cpp#3)]
[!code-csharp[RemotingConfiguration.ServerActivation1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/server.cs#3)]
[!code-vb[RemotingConfiguration.ServerActivation1#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/server.vb#3)]  
  
 O exemplo de código a seguir mostra o objeto de serviço registrado no código de exemplo acima.  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/service.cpp#4)]
 [!code-csharp[RemotingConfiguration.ServerActivation1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/service.cs#4)]
 [!code-vb[RemotingConfiguration.ServerActivation1#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/service.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
      </Docs>
    </Member>
  </Members>
</Type>