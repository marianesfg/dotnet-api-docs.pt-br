<Type Name="RemotingServices" FullName="System.Runtime.Remoting.RemotingServices">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f116e83772ad89fa2d72ace082b41f76d2be95c6" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39967253" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class RemotingServices" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed RemotingServices extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Remoting.RemotingServices" />
  <TypeSignature Language="VB.NET" Value="Public Class RemotingServices" />
  <TypeSignature Language="C++ CLI" Value="public ref class RemotingServices abstract sealed" />
  <TypeSignature Language="F#" Value="type RemotingServices = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece vários métodos para uso e publicação de objetos remotos e proxies. Essa classe não pode ser herdada.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A menos que você está lidando com problemas, como transações, ativação ou gerenciamento de tempo de vida de um provedor de serviços, você não precisa distinguir entre as referências de proxy e referências de objeto. A infraestrutura de comunicação remota usa proxies transparentes que dar a impressão de que os objetos remotos residem no espaço do cliente. Proxies de conseguir isso, encaminhando as chamadas feitas neles para os objetos reais em locais remotos.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria um proxy para um objeto conhecido.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static object Connect (Type classToProxy, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Connect(class System.Type classToProxy, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Connect (classToProxy As Type, url As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Connect(Type ^ classToProxy, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member Connect : Type * string -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Connect (classToProxy, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classToProxy" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="classToProxy">O <see cref="T:System.Type" /> de um objeto conhecido na extremidade do servidor ao qual você deseja se conectar.</param>
        <param name="url">A URL da classe de servidor.</param>
        <summary>Cria um proxy para um objeto conhecido, dados o <see cref="T:System.Type" /> e a URL.</summary>
        <returns>Um proxy para o objeto remoto que aponta para um ponto de extremidade servido pelo objeto conhecido especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O objeto proxy retornado aponta para um ponto de extremidade servido pelo objeto conhecido especificado. Não há mensagens são enviadas pela rede até que um método é chamado no proxy.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Runtime.Remoting.RemotingServices.Connect%2A> método para criar um proxy para um objeto conhecido.  
  
 [!code-cpp[RemotingServices.BasicSample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/basicclient.cpp#1)]
 [!code-csharp[RemotingServices.BasicSample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/basicclient.cs#1)]
 [!code-vb[RemotingServices.BasicSample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/basicclient.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O chamador imediato não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static object Connect (Type classToProxy, string url, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Connect(class System.Type classToProxy, string url, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Connect (classToProxy As Type, url As String, data As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Connect(Type ^ classToProxy, System::String ^ url, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member Connect : Type * string * obj -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Connect (classToProxy, url, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classToProxy" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="classToProxy">O <see cref="T:System.Type" /> do objeto conhecido ao qual você deseja se conectar.</param>
        <param name="url">A URL do objeto conhecido.</param>
        <param name="data">Dados específicos do canal. Pode ser <see langword="null" />.</param>
        <summary>Cria um proxy para um objeto conhecido, dados o <see cref="T:System.Type" />, a URL e os dados específicos do canal.</summary>
        <returns>Um proxy que aponta para um ponto de extremidade servido pelo objeto conhecido solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O objeto proxy retornado aponta para um ponto de extremidade servido pelo objeto conhecido especificado. Não há mensagens são enviadas pela rede até que um método é chamado no proxy.  
  
 O `data` objeto é usado para comunicar informações para o canal e é passado para o <xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O chamador imediato não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public static bool Disconnect (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Disconnect(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Disconnect (obj As MarshalByRefObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Disconnect(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member Disconnect : MarshalByRefObject -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.Disconnect obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto a ser desconectado de seu canal.</param>
        <summary>Interrompe um objeto de receber mensagens adicionais pelos canais de comunicação remota registrados.</summary>
        <returns>
          <see langword="true" /> se o objeto foi desconectado dos canais de comunicação remota registrados com êxito; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Runtime.Remoting.RemotingServices.Disconnect%2A> método para desconectar um objeto de canais de comunicação remota.  
  
 [!code-cpp[RemotingServices.BasicSample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/manualserver.cpp#2)]
 [!code-csharp[RemotingServices.BasicSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/manualserver.cs#2)]
 [!code-vb[RemotingServices.BasicSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/manualserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="obj" /> é um proxy.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador imediato não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteMessage">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage (MarshalByRefObject target, System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage(class System.MarshalByRefObject target, class System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExecuteMessage (target As MarshalByRefObject, reqMsg As IMethodCallMessage) As IMethodReturnMessage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Messaging::IMethodReturnMessage ^ ExecuteMessage(MarshalByRefObject ^ target, System::Runtime::Remoting::Messaging::IMethodCallMessage ^ reqMsg);" />
      <MemberSignature Language="F#" Value="static member ExecuteMessage : MarshalByRefObject * System.Runtime.Remoting.Messaging.IMethodCallMessage -&gt; System.Runtime.Remoting.Messaging.IMethodReturnMessage" Usage="System.Runtime.Remoting.RemotingServices.ExecuteMessage (target, reqMsg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMethodReturnMessage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.MarshalByRefObject" />
        <Parameter Name="reqMsg" Type="System.Runtime.Remoting.Messaging.IMethodCallMessage" />
      </Parameters>
      <Docs>
        <param name="target">O objeto remoto cujo método você deseja chamar.</param>
        <param name="reqMsg">Uma mensagem de chamada de método para o método do objeto remoto especificado.</param>
        <summary>Conecta-se ao objeto remoto especificado e executa o <see cref="T:System.Runtime.Remoting.Messaging.IMethodCallMessage" /> fornecido nele.</summary>
        <returns>A resposta do método remoto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método atual é usado em casos especiais pelo servidor para encaminhar a chamada de método especificado ao objeto de outro, possivelmente remoto. Esse método pode ser chamado apenas quando o chamador estiver no contexto apropriado.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Runtime.Remoting.RemotingServices.ExecuteMessage%2A> método para encaminhar as chamadas de método para objetos remotos.  
  
 [!code-cpp[RemotingServices.ExecuteMessage#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CPP/serviceclass.cpp#1)]
 [!code-csharp[RemotingServices.ExecuteMessage#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CS/serviceclass.cs#1)]
 [!code-vb[RemotingServices.ExecuteMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/VB/serviceclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O chamador imediato não tem permissão de infraestrutura.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">O método foi chamado em um contexto diferente do contexto nativo do objeto.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a operação com código de infraestrutura. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetEnvoyChainForProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvoyChainForProxy (obj As MarshalByRefObject) As IMessageSink" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Messaging::IMessageSink ^ GetEnvoyChainForProxy(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetEnvoyChainForProxy : MarshalByRefObject -&gt; System.Runtime.Remoting.Messaging.IMessageSink" Usage="System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessageSink</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">O proxy do objeto remoto com os quais os coletores envoy solicitados estão associados.</param>
        <summary>Retorna uma cadeia de coletores envoy que deve ser usada ao enviar mensagens para o objeto remoto representado pelo proxy especificado.</summary>
        <returns>Uma cadeia de coletores envoy associada ao proxy especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Coletores envoy são coletores enviados junto com o <xref:System.Runtime.Remoting.ObjRef> de um objeto que é usado ao retornar mensagens para esse objeto. O método atual retorna coletores envoy que são usados durante a comunicação entre o proxy do objeto e o próprio objeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O chamador imediato não tem permissão de infraestrutura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a operação com código de infraestrutura. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Remoting.IEnvoyInfo" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="GetLifetimeService">
      <MemberSignature Language="C#" Value="public static object GetLifetimeService (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLifetimeService(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLifetimeService (obj As MarshalByRefObject) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLifetimeService(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetLifetimeService : MarshalByRefObject -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.GetLifetimeService obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto cujo serviço de tempo de vida será obtido.</param>
        <summary>Retorna um objeto de serviço de tempo de vida que controla a política de tempo de vida do objeto especificado.</summary>
        <returns>O objeto que controla o tempo de vida de <paramref name="obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para o serviço de tempo de vida padrão, o objeto retornado será um objeto do tipo <xref:System.Runtime.Remoting.Lifetime.ILease>. Se o `obj` parâmetro é `null`, o método retorna `null`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Runtime.Remoting.RemotingServices.GetLifetimeService%2A> método para obter uma concessão de tempo de vida do objeto especificado.  
  
 [!code-cpp[RemotingServices.TimerSample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.TimerSample/CPP/timerclient.cpp#1)]
 [!code-csharp[RemotingServices.TimerSample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerclient.cs#1)]
 [!code-vb[RemotingServices.TimerSample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerclient.vb#1)]  
  
 Para compilar e executar esse exemplo, você precisará compilar e executar um servidor, timerserver.exe e compilar uma biblioteca compartilhada, timerservice.dll.  
  
 A fonte para timerserver.exe segue:  
  
 [!code-csharp[RemotingServices.TimerSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerserver.cs#2)]
 [!code-vb[RemotingServices.TimerSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerserver.vb#2)]  
  
 A fonte para timerservice.dll segue:  
  
 [!code-csharp[RemotingServices.TimerSample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerservice.cs#3)]
 [!code-vb[RemotingServices.TimerSample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerservice.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O chamador imediato não tem permissão de infraestrutura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a operação com código de infraestrutura. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBaseFromMethodMessage">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodBaseFromMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodBaseFromMethodMessage(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodBaseFromMethodMessage (msg As IMethodMessage) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodBaseFromMethodMessage(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member GetMethodBaseFromMethodMessage : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; System.Reflection.MethodBase" Usage="System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">A mensagem de método da qual extrair a base do método.</param>
        <summary>Retorna a base do método do determinado <see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" />.</summary>
        <returns>A base do método extraída do parâmetro <paramref name="msg" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Isso determina a base do método as <xref:System.Runtime.Remoting.Messaging.IMethodMessage.TypeName%2A>, <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodName%2A>, e <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodSignature%2A> propriedades de <xref:System.Runtime.Remoting.Messaging.IMethodMessage> e é usado por classes que implementam o <xref:System.Runtime.Remoting.Messaging.IMethodMessage> interface. Os consumidores de <xref:System.Runtime.Remoting.Messaging.IMethodMessage> classes devem fazer referência a <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodBase%2A?displayProperty=nameWithType> propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O chamador imediato não tem permissão de infraestrutura ou, pelo menos um dos chamadores mais acima na pilha de chamadas não tem permissão para recuperar as informações de tipo de membros não públicos.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a operação com código de infraestrutura. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public static void GetObjectData (object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetObjectData(object obj, class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetObjectData (obj As Object, info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetObjectData(System::Object ^ obj, System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="static member GetObjectData : obj * System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.GetObjectData (obj, info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto a ser serializado.</param>
        <param name="info">O <see cref="T:System.Runtime.Serialization.SerializationInfo" /> para o qual o objeto é serializado.</param>
        <param name="context">A origem e o destino da serialização.</param>
        <summary>Serializa o marshaling especificado pelo objeto de referência no <see cref="T:System.Runtime.Serialization.SerializationInfo" /> fornecido.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="obj" /> ou <paramref name="info" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador imediato não tem permissão de infraestrutura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a operação com código de infraestrutura. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectUri">
      <MemberSignature Language="C#" Value="public static string GetObjectUri (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetObjectUri(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectUri (obj As MarshalByRefObject) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetObjectUri(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjectUri : MarshalByRefObject -&gt; string" Usage="System.Runtime.Remoting.RemotingServices.GetObjectUri obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">O <see cref="T:System.MarshalByRefObject" /> para o qual um URI é solicitado.</param>
        <summary>Recupera o URI para o objeto especificado.</summary>
        <returns>O URI do objeto especificado se ele tiver um ou <see langword="null" /> se o objeto ainda não tiver tido o marshaling realizado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#18)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#18)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O chamador imediato não tem permissão de infraestrutura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a operação com código de infraestrutura. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjRefForProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef GetObjRefForProxy (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef GetObjRefForProxy(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjRefForProxy (obj As MarshalByRefObject) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ GetObjRefForProxy(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjRefForProxy : MarshalByRefObject -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.GetObjRefForProxy obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Um proxy conectado ao objeto para o qual você deseja criar um <see cref="T:System.Runtime.Remoting.ObjRef" />.</param>
        <summary>Retorna o <see cref="T:System.Runtime.Remoting.ObjRef" /> que representa o objeto remoto do proxy especificado.</summary>
        <returns>Um <see cref="T:System.Runtime.Remoting.ObjRef" /> que representa o objeto remoto ao qual o proxy está conectado ou <see langword="null" /> se o objeto ou o proxy não tiverem tido o marshaling realizado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Runtime.Remoting.ObjRef> é uma representação serializável de um objeto usado para transferir uma referência de objeto em um limite de domínio de aplicativo. Criando um <xref:System.Runtime.Remoting.ObjRef> para um objeto é conhecido como marshaling. O <xref:System.Runtime.Remoting.ObjRef> pode ser transferido por meio de um canal para outro domínio de aplicativo (possivelmente em outro processo ou computador). Uma vez em outro domínio do aplicativo, o <xref:System.Runtime.Remoting.ObjRef> deve ser analisado para criar um proxy para o objeto, geralmente é conectado ao objeto real. Esta operação é conhecida como unmarshaling. Durante o unmarshaling, o <xref:System.Runtime.Remoting.ObjRef> é analisado para extrair as informações do método do objeto remoto e o proxy transparente e <xref:System.Runtime.Remoting.Proxies.RealProxy> os objetos são criados.  
  
 Um <xref:System.Runtime.Remoting.ObjRef> contém informações que descrevem o <xref:System.Type> e a classe do objeto que está sendo empacotado, um URI que identifica exclusivamente a instância do objeto específico e comunicação relacionados ao obter informações sobre como acessar o aplicativo remoto onde o objeto está localizado.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como obter um <xref:System.Runtime.Remoting.ObjRef> instância para o objeto especificado.  
  
 [!code-cpp[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/CPP/client.cpp#1)]
 [!code-csharp[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/CS/client.cs#1)]
 [!code-vb[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/VB/client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O chamador imediato não tem permissão de infraestrutura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a operação com código de infraestrutura. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetRealProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Proxies.RealProxy GetRealProxy (object proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Proxies.RealProxy GetRealProxy(object proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRealProxy (proxy As Object) As RealProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Proxies::RealProxy ^ GetRealProxy(System::Object ^ proxy);" />
      <MemberSignature Language="F#" Value="static member GetRealProxy : obj -&gt; System.Runtime.Remoting.Proxies.RealProxy" Usage="System.Runtime.Remoting.RemotingServices.GetRealProxy proxy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Proxies.RealProxy</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proxy" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="proxy">Um proxy transparente.</param>
        <summary>Retorna o proxy real que dá suporte ao proxy transparente especificado.</summary>
        <returns>A instância do proxy real que dá suporte ao proxy transparente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um cliente que usa um objeto em qualquer tipo de limite de comunicação remota, na verdade, está usando um proxy transparente para o objeto. O proxy transparente dá a impressão de que o objeto real reside no espaço do cliente. Ela consegue isso encaminhando as chamadas feitas nele para o objeto real usando a infraestrutura de comunicação remota.  
  
 O proxy transparente é apoiado por uma instância de uma classe de tempo de execução gerenciado do tipo <xref:System.Runtime.Remoting.Proxies.RealProxy>. O <xref:System.Runtime.Remoting.Proxies.RealProxy> implementa uma parte das funcionalidades necessárias para encaminhar as operações do proxy transparente.  
  
 Um objeto proxy herda a semântica associada de objetos gerenciados, como coleta de lixo, o suporte para métodos e membros e pode ser estendido para novas classes de formulário. O proxy atua como um objeto da mesma classe que o objeto remoto (proxy transparente) e também é um objeto gerenciado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O chamador imediato não tem permissão de infraestrutura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a operação com código de infraestrutura. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="GetServerTypeForUri">
      <MemberSignature Language="C#" Value="public static Type GetServerTypeForUri (string URI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetServerTypeForUri(string URI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetServerTypeForUri (URI As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetServerTypeForUri(System::String ^ URI);" />
      <MemberSignature Language="F#" Value="static member GetServerTypeForUri : string -&gt; Type" Usage="System.Runtime.Remoting.RemotingServices.GetServerTypeForUri URI" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="URI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="URI">O URI do objeto cujo <see cref="T:System.Type" /> é solicitado.</param>
        <summary>Retorna o <see cref="T:System.Type" /> do objeto com o URI especificado.</summary>
        <returns>O <see cref="T:System.Type" /> do objeto com o URI especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Porque a comunicação remota identifica pontos de extremidade usando URIs, o <xref:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri%2A> método é muito útil nas partes da infraestrutura de comunicação remota (por exemplo, Coletores de canal, coletores dinâmicos e Coletores de contexto) conectáveis que usam <xref:System.Runtime.Remoting.Messaging.IMessage> objetos, porque atual método retornará o objeto do tipo associado do URI.  
  
   
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#7)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#7)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O chamador imediato não tem permissão de infraestrutura ou, pelo menos um dos chamadores mais acima na pilha de chamadas não tem permissão para recuperar as informações de tipo de membros não públicos.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a operação com código de infraestrutura. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para recuperar as informações de tipo de membros não públicos. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetSessionIdForMethodMessage">
      <MemberSignature Language="C#" Value="public static string GetSessionIdForMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetSessionIdForMethodMessage(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSessionIdForMethodMessage (msg As IMethodMessage) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetSessionIdForMethodMessage(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member GetSessionIdForMethodMessage : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; string" Usage="System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">O <see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" /> para o qual uma ID de sessão é solicitada.</param>
        <summary>Recupera uma ID de sessão para uma mensagem.</summary>
        <returns>Uma cadeia de caracteres de ID de sessão que identifica de forma exclusiva a sessão atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A mesma ID de sessão pode ser retornada para objetos no mesmo aplicativo, mas esse método nunca retornará a mesma ID de sessão para dois objetos em diferentes aplicativos remotos.  
  
 Para obter mais informações sobre como identificar sessões e IDs de sessão, consulte ASP.Net [visão geral do estado de sessão ASP.NET](http://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como obter a cadeia de caracteres de ID de sessão para a sessão atual.  
  
 [!code-cpp[RemotingServices.ExecuteMessage#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CPP/serviceclass.cpp#1)]
 [!code-csharp[RemotingServices.ExecuteMessage#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CS/serviceclass.cs#1)]
 [!code-vb[RemotingServices.ExecuteMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/VB/serviceclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O chamador imediato não tem permissão de infraestrutura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a operação com código de infraestrutura. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsMethodOverloaded">
      <MemberSignature Language="C#" Value="public static bool IsMethodOverloaded (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMethodOverloaded(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMethodOverloaded (msg As IMethodMessage) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMethodOverloaded(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member IsMethodOverloaded : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsMethodOverloaded msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">A mensagem que contém uma chamada para o método em questão.</param>
        <summary>Retorna um valor booliano que indica se o método na mensagem especificada está sobrecarregado.</summary>
        <returns>
          <see langword="true" /> se o método chamado em <paramref name="msg" /> estiver sobrecarregado, caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">O chamador imediato não tem permissão de infraestrutura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a operação com código de infraestrutura. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsObjectOutOfAppDomain">
      <MemberSignature Language="C#" Value="public static bool IsObjectOutOfAppDomain (object tp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsObjectOutOfAppDomain(object tp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsObjectOutOfAppDomain (tp As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsObjectOutOfAppDomain(System::Object ^ tp);" />
      <MemberSignature Language="F#" Value="static member IsObjectOutOfAppDomain : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain tp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tp" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tp">O objeto a ser verificado.</param>
        <summary>Retorna um valor booliano que indica se o objeto especificado pelo proxy transparente especificado está contido em um domínio do aplicativo diferente do objeto que chamou o método atual.</summary>
        <returns>
          <see langword="true" /> se o objeto estiver fora do domínio de aplicativo atual, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter informações sobre domínios de aplicativo, consulte [domínios de aplicativo](http://msdn.microsoft.com/library/39e57d07-a740-4cd4-ae82-e119ea3856c1).  
  
   
  
## Examples  
 [!code-cpp[RemotingServices IsObject Snippets#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CPP/class1.cpp#1)]
 [!code-csharp[RemotingServices IsObject Snippets#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CS/class1.cs#1)]
 [!code-vb[RemotingServices IsObject Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices IsObject Snippets/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsObjectOutOfContext">
      <MemberSignature Language="C#" Value="public static bool IsObjectOutOfContext (object tp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsObjectOutOfContext(object tp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsObjectOutOfContext (tp As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsObjectOutOfContext(System::Object ^ tp);" />
      <MemberSignature Language="F#" Value="static member IsObjectOutOfContext : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext tp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tp" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tp">O objeto a ser verificado.</param>
        <summary>Retorna um valor booliano que indica se o objeto representado pelo proxy especificado está contido em um contexto diferente do objeto que chamou o método atual.</summary>
        <returns>
          <see langword="true" /> se o objeto estiver fora do contexto atua, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um contexto é uma sequência ordenada de propriedades que definem um ambiente para os objetos que residem dentro dele. Contextos são criados durante o processo de ativação para objetos que são configurados para exigir que determinados serviços automáticos tais sincronização, transações, ativação just-in-time, segurança e assim por diante. Vários objetos podem residir em um contexto.  
  
   
  
## Examples  
 [!code-cpp[RemotingServices IsObject Snippets#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CPP/class1.cpp#1)]
 [!code-csharp[RemotingServices IsObject Snippets#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CS/class1.cs#1)]
 [!code-vb[RemotingServices IsObject Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices IsObject Snippets/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Remoting.Contexts.Context" />
      </Docs>
    </Member>
    <Member MemberName="IsOneWay">
      <MemberSignature Language="C#" Value="public static bool IsOneWay (System.Reflection.MethodBase method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsOneWay(class System.Reflection.MethodBase method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsOneWay (method As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsOneWay(System::Reflection::MethodBase ^ method);" />
      <MemberSignature Language="F#" Value="static member IsOneWay : System.Reflection.MethodBase -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsOneWay method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="method">O método em questão.</param>
        <summary>Retorna um valor booliano que indica que se o cliente que chamou o método especificado na mensagem determinada está esperando o servidor concluir o processamento do método antes de continuar a execução.</summary>
        <returns>
          <see langword="true" /> se o método for unidirecional, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um método unidirecional é chamado, o cliente não aguarda o servidor concluir o processamento da mensagem. O método de cliente retorna para o aplicativo sem o conhecimento de ou não o servidor processará com êxito a mensagem. Métodos são marcados como uma maneira de usar o <xref:System.Runtime.Remoting.Messaging.OneWayAttribute>.  
  
 Métodos unidirecionais não podem ter um valor de retorno ou os parâmetros de saída.  
  
   
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#2)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#2)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O chamador imediato não tem permissão de infraestrutura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a operação com código de infraestrutura. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsTransparentProxy">
      <MemberSignature Language="C#" Value="public static bool IsTransparentProxy (object proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsTransparentProxy(object proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsTransparentProxy (proxy As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsTransparentProxy(System::Object ^ proxy);" />
      <MemberSignature Language="F#" Value="static member IsTransparentProxy : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsTransparentProxy proxy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proxy" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="proxy">A referência para o objeto a ser verificado.</param>
        <summary>Retorna um valor booliano que indica se o objeto fornecido é um proxy transparente ou um objeto real.</summary>
        <returns>Um valor booliano que indica se o objeto especificado no parâmetro <paramref name="proxy" /> é um proxy transparente ou um objeto real.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um cliente que usa um objeto em qualquer tipo de um limite de comunicação remota, na verdade, está usando um proxy transparente para o objeto. O proxy transparente dá a impressão de que o objeto real reside no espaço do cliente. Ela consegue isso encaminhando as chamadas feitas nele para o objeto real usando a infraestrutura de comunicação remota.  
  
 O proxy transparente é hospedada por uma instância de uma classe de tempo de execução gerenciado do tipo <xref:System.Runtime.Remoting.Proxies.RealProxy>. O <xref:System.Runtime.Remoting.Proxies.RealProxy> implementa uma parte das funcionalidades necessárias para encaminhar as operações do proxy transparente. Um objeto proxy herda a semântica associada de objetos gerenciados, como coleta de lixo, o suporte para métodos e membros e pode ser estendido para novas classes de formulário. Portanto, o proxy tem uma natureza dupla; por um lado ele precisa atuar como um objeto da mesma classe que o objeto remoto (proxy transparente), e o outro é um objeto gerenciado em si.  
  
 Um objeto de proxy pode ser usado sem levar em consideração qualquer subdivisões de comunicação remota dentro de um <xref:System.AppDomain>. Aplicativos não precisam distinguir entre as referências de proxy e referências de objeto. No entanto, lidando com problemas como a ativação de provedores de serviço, gerenciamento da vida útil e transações necessário tornar essas distinções.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Runtime.Remoting.RemotingServices.IsTransparentProxy%2A> método para determinar se um objeto é um proxy ou um objeto real. Para o código de exemplo completo, consulte o exemplo para o <xref:System.Runtime.Remoting.Messaging.AsyncResult> classe.  
  
 [!code-cpp[AsyncResult.NewExamples#6](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncResult.NewExamples/CPP/ad.cpp#6)]
 [!code-csharp[AsyncResult.NewExamples#6](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncResult.NewExamples/CS/ad.cs#6)]
 [!code-vb[AsyncResult.NewExamples#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncResult.NewExamples/VB/ad.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="LogRemotingStage">
      <MemberSignature Language="C#" Value="public static void LogRemotingStage (int stage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LogRemotingStage(int32 stage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LogRemotingStage (stage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LogRemotingStage(int stage);" />
      <MemberSignature Language="F#" Value="static member LogRemotingStage : int -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.LogRemotingStage stage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.Conditional("REMOTING_PERF")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("It existed for only internal use in .NET and unimplemented in mono")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Use of this method is not recommended. The LogRemotingStage existed for internal diagnostic purposes only.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stage">Uma constante definida internamente que identifica o estágio em uma troca de comunicação remota.</param>
        <summary>Registra o estágio em uma troca de comunicação remota para um depurador externo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um `"REMOTING_PERF"` símbolo de pré-processamento é aplicado ao método usando o <xref:System.Diagnostics.ConditionalAttribute> atributo.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Marshal">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte um determinado <see cref="T:System.MarshalByRefObject" /> em uma instância da classe <see cref="T:System.Runtime.Remoting.ObjRef" />, que pode ser serializada para a transmissão entre os domínios do aplicativo e por uma rede.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal Obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="Obj">O objeto a ser convertido.</param>
        <summary>Utiliza um <see cref="T:System.MarshalByRefObject" />, registra-o com a infraestrutura de comunicação remota e o converte em uma instância da classe <see cref="T:System.Runtime.Remoting.ObjRef" />.</summary>
        <returns>Uma instância da classe <see cref="T:System.Runtime.Remoting.ObjRef" /> que representa o objeto especificado no parâmetro <paramref name="Obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Runtime.Remoting.ObjRef> é uma representação serializável de um objeto usado para transferir uma referência de objeto em um limite de domínio de aplicativo. Criando um <xref:System.Runtime.Remoting.ObjRef> para um objeto é conhecido como marshaling. O <xref:System.Runtime.Remoting.ObjRef> pode ser transferido por meio de um canal para outro domínio de aplicativo (possivelmente em outro processo ou computador). Uma vez em outro domínio do aplicativo, o <xref:System.Runtime.Remoting.ObjRef> deve ser analisado para criar um proxy para o objeto, geralmente é conectado ao objeto real. Esta operação é conhecida como unmarshaling.  
  
 Um <xref:System.Runtime.Remoting.ObjRef> contém informações que descrevem o <xref:System.Type> e a classe do objeto que está sendo empacotado, um URI que identifica exclusivamente a instância do objeto específico e comunicação de informações relacionadas sobre como contatar a subdivisão de comunicação remota em que o objeto está localizado.  
  
 Durante o marshaling, o contexto do thread atual é usado, não o contexto que estava ativa quando o objeto foi criado. Se um URI não foi explicitamente definido pelo <xref:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal%2A> método, ele é gerado automaticamente pela infraestrutura de identidade de comunicação remota.  
  
 Você não pode associar um URI com um proxy para um dos seguintes motivos: o URI gerado no lado do servidor para o objeto que representa tanto o objeto é bem conhecido, caso em que o URI é conhecido. Por esse motivo, se o `Obj` parâmetro é um proxy, uma exceção será gerada. Para proxies personalizados essa restrição é relaxada porque o proxy transparente é tratado como o objeto de servidor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">O parâmetro <paramref name="Obj" /> é um proxy de objeto.</exception>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string URI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj, string URI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject, URI As String) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj, System::String ^ URI);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject * string -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal (Obj, URI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
        <Parameter Name="URI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Obj">O objeto a ser convertido.</param>
        <param name="URI">O URI especificado com a qual inicializar o novo <see cref="T:System.Runtime.Remoting.ObjRef" />. Pode ser <see langword="null" />.</param>
        <summary>Converte um dado <see cref="T:System.MarshalByRefObject" /> em uma instância da classe <see cref="T:System.Runtime.Remoting.ObjRef" /> com o URI especificado.</summary>
        <returns>Uma instância da classe <see cref="T:System.Runtime.Remoting.ObjRef" /> que representa o objeto especificado no parâmetro <paramref name="Obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Runtime.Remoting.ObjRef> é uma representação serializável de um objeto usado para transferir uma referência de objeto em um limite de domínio de aplicativo. Criando um <xref:System.Runtime.Remoting.ObjRef> para um objeto é conhecido como marshaling. O <xref:System.Runtime.Remoting.ObjRef> pode ser transferido por meio de um canal para outro domínio de aplicativo (possivelmente em outro processo ou computador). Uma vez em outro domínio do aplicativo, o <xref:System.Runtime.Remoting.ObjRef> deve ser analisado para criar um proxy para o objeto, geralmente é conectado ao objeto real. Esta operação é conhecida como unmarshaling.  
  
 Um <xref:System.Runtime.Remoting.ObjRef> contém informações que descrevem o <xref:System.Type> e a classe do objeto que está sendo empacotado, um URI que identifica exclusivamente a instância do objeto específico e comunicação de informações relacionadas sobre como contatar a subdivisão de comunicação remota em que o objeto está localizado.  
  
 Durante o marshaling, o contexto do thread atual é usado, não o contexto que estava ativa quando o objeto foi criado.  
  
 Você não pode associar um URI com um proxy para um dos seguintes motivos: o URI gerado no lado do servidor para o objeto que representa tanto o objeto é bem conhecido, caso em que o URI é conhecido. Por esse motivo, se o `Obj` parâmetro é um proxy, uma exceção será gerada. Para proxies personalizados essa restrição é relaxada porque o proxy transparente é tratado como o objeto de servidor.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o atual <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> método para realizar marshaling de um objeto especificado.  
  
 [!code-cpp[RemotingServices.BasicSample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/manualserver.cpp#2)]
 [!code-csharp[RemotingServices.BasicSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/manualserver.cs#2)]
 [!code-vb[RemotingServices.BasicSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/manualserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="Obj" /> é um proxy do objeto e o parâmetro <paramref name="URI" /> não é <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string ObjURI, Type RequestedType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj, string ObjURI, class System.Type RequestedType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject, ObjURI As String, RequestedType As Type) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj, System::String ^ ObjURI, Type ^ RequestedType);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject * string * Type -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal (Obj, ObjURI, RequestedType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
        <Parameter Name="ObjURI" Type="System.String" />
        <Parameter Name="RequestedType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="Obj">O objeto a ser convertido em um <see cref="T:System.Runtime.Remoting.ObjRef" />.</param>
        <param name="ObjURI">O URI com o qual o objeto especificado no parâmetro <c>Obj</c> tem o marshaling realizado. Pode ser <see langword="null" />.</param>
        <param name="RequestedType">O como o qual o <see cref="T:System.Type" /><c>Obj</c> tem o marshaling realizado. Pode ser <see langword="null" />.</param>
        <summary>Seleciona um <see cref="T:System.MarshalByRefObject" /> e o converte em uma instância da classe <see cref="T:System.Runtime.Remoting.ObjRef" /> com o URI especificado e o <see cref="T:System.Type" /> fornecido.</summary>
        <returns>Uma instância da classe <see cref="T:System.Runtime.Remoting.ObjRef" /> que representa o objeto especificado no parâmetro <paramref name="Obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Runtime.Remoting.ObjRef> é uma representação serializável de um objeto usado para transferir uma referência de objeto em um limite de domínio de aplicativo. Criando um <xref:System.Runtime.Remoting.ObjRef> para um objeto é conhecido como marshaling. O <xref:System.Runtime.Remoting.ObjRef> pode ser transferido por meio de um canal para outro domínio de aplicativo (possivelmente em outro processo ou computador). Uma vez em outro domínio do aplicativo, o <xref:System.Runtime.Remoting.ObjRef> deve ser analisado para criar um proxy para o objeto, geralmente é conectado ao objeto real. Esta operação é conhecida como unmarshaling.  
  
 Um <xref:System.Runtime.Remoting.ObjRef> contém informações que descrevem o <xref:System.Type> e a classe do objeto que está sendo empacotado, um URI que identifica exclusivamente a instância do objeto específico e comunicação de informações relacionadas sobre como contatar a subdivisão de comunicação remota em que o objeto está localizado.  
  
 Especificado <xref:System.Type> é usado para limitar o escopo da hierarquia de tipo exposto pela infraestrutura de comunicação remota. Por exemplo, se o objeto um derivado de objeto B, que deriva de object C, e <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> é chamado, o cliente pode converter o proxy entre C e B, mas não a.  
  
 Durante o marshaling, o contexto do thread atual é usado, não o contexto que estava ativa quando o objeto foi criado.  
  
 Você não pode associar um URI com um proxy para um dos seguintes motivos: o URI gerado no lado do servidor para o objeto que representa tanto o objeto é bem conhecido, caso em que o URI é conhecido. Por esse motivo, se o `Obj` parâmetro é um proxy, uma exceção será gerada. Para proxies personalizados essa restrição é relaxada porque o proxy transparente é tratado como o objeto de servidor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="Obj" /> é um proxy de um objeto remoto e o parâmetro <paramref name="ObjUri" /> não é <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="SetObjectUriForMarshal">
      <MemberSignature Language="C#" Value="public static void SetObjectUriForMarshal (MarshalByRefObject obj, string uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetObjectUriForMarshal(class System.MarshalByRefObject obj, string uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetObjectUriForMarshal (obj As MarshalByRefObject, uri As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetObjectUriForMarshal(MarshalByRefObject ^ obj, System::String ^ uri);" />
      <MemberSignature Language="F#" Value="static member SetObjectUriForMarshal : MarshalByRefObject * string -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal (obj, uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
        <Parameter Name="uri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto para o qual definir um URI.</param>
        <param name="uri">O URI a ser atribuído ao objeto especificado.</param>
        <summary>Define o URI para a chamada subsequente para o método <see cref="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O URI definido pelo método atual é usado durante o marshaling do objeto especificado.  
  
 Após o empacotamento, o URI do objeto especificado é definido como a cadeia de caracteres na `uri` parâmetro acrescentado para o <xref:System.Guid> atual <xref:System.AppDomain>.  
  
 Se o aplicativo atual está escutando uma porta HTTP, a cadeia de caracteres especificado na `uri` parâmetro e o `uri` cadeia de caracteres acrescentada para o <xref:System.Guid> atual <xref:System.AppDomain> rota para o objeto especificado. Por exemplo, se o aplicativo está escutando na porta HTTP 9000, então, ambos http://localhost:9000/objectUri, e http://localhost:9000/\<appdomainguid>/objectUri rota para o objeto especificado no `obj` parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir o URI que será usado pelo <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> método durante o marshaling do objeto especificado.  
  
 [!code-cpp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CPP/source.cpp#1)]
 [!code-csharp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CS/source.cs#1)]
 [!code-vb[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="obj" /> não é um objeto local, já teve o marshaling realizado ou o método atual já foi chamado.</exception>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unmarshal">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte um determinado <see cref="T:System.Runtime.Remoting.ObjRef" /> em um objeto de proxy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unmarshal">
      <MemberSignature Language="C#" Value="public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Unmarshal(class System.Runtime.Remoting.ObjRef objectRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unmarshal (objectRef As ObjRef) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Unmarshal(System::Runtime::Remoting::ObjRef ^ objectRef);" />
      <MemberSignature Language="F#" Value="static member Unmarshal : System.Runtime.Remoting.ObjRef -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Unmarshal objectRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectRef" Type="System.Runtime.Remoting.ObjRef" />
      </Parameters>
      <Docs>
        <param name="objectRef">O <see cref="T:System.Runtime.Remoting.ObjRef" /> que representa o objeto remoto para o qual o proxy está sendo chamado.</param>
        <summary>Utiliza um <see cref="T:System.Runtime.Remoting.ObjRef" /> e cria um objeto proxy dele.</summary>
        <returns>Um proxy para o objeto que o determinado <see cref="T:System.Runtime.Remoting.ObjRef" /> representa.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Runtime.Remoting.ObjRef> é uma representação serializável de um objeto usado para transferir uma referência de objeto em um limite de domínio de aplicativo. Criando um <xref:System.Runtime.Remoting.ObjRef> para um objeto é conhecido como marshaling. O <xref:System.Runtime.Remoting.ObjRef> pode ser transferido por meio de um canal para outro domínio de aplicativo (possivelmente em outro processo ou computador). Uma vez em outro domínio do aplicativo, o <xref:System.Runtime.Remoting.ObjRef> deve ser analisado para criar um proxy para o objeto, geralmente é conectado ao objeto real. Esta operação é conhecida como unmarshaling. Durante o unmarshaling, o <xref:System.Runtime.Remoting.ObjRef> é analisado para extrair as informações do método do objeto remoto e o proxy transparente e <xref:System.Runtime.Remoting.Proxies.RealProxy> os objetos são criados. O conteúdo do analisado <xref:System.Runtime.Remoting.ObjRef> é adicionado ao proxy transparente antes que o proxy transparente é registrado com o common language runtime.  
  
 Um <xref:System.Runtime.Remoting.ObjRef> contém informações que descrevem o <xref:System.Type> e a classe do objeto que está sendo empacotado, um URI que identifica exclusivamente a instância do objeto específico e comunicação de informações relacionadas sobre como contatar a subdivisão de comunicação remota em que o objeto está localizado.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como desempacotar um objeto.  
  
 [!code-cpp[RemotingServices.Unmarshal#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.Unmarshal/CPP/client.cpp#2)]
 [!code-csharp[RemotingServices.Unmarshal#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.Unmarshal/CS/client.cs#2)]
 [!code-vb[RemotingServices.Unmarshal#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.Unmarshal/VB/client.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A instância <see cref="T:System.Runtime.Remoting.ObjRef" /> especificada no parâmetro <paramref name="objectRef" /> não é bem formada.</exception>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="Unmarshal">
      <MemberSignature Language="C#" Value="public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef, bool fRefine);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Unmarshal(class System.Runtime.Remoting.ObjRef objectRef, bool fRefine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unmarshal (objectRef As ObjRef, fRefine As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Unmarshal(System::Runtime::Remoting::ObjRef ^ objectRef, bool fRefine);" />
      <MemberSignature Language="F#" Value="static member Unmarshal : System.Runtime.Remoting.ObjRef * bool -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Unmarshal (objectRef, fRefine)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectRef" Type="System.Runtime.Remoting.ObjRef" />
        <Parameter Name="fRefine" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="objectRef">O <see cref="T:System.Runtime.Remoting.ObjRef" /> que representa o objeto remoto para o qual o proxy está sendo chamado.</param>
        <param name="fRefine">
          <see langword="true" /> para refinar o proxy para o tipo no servidor, caso contrário, <see langword="false" />.</param>
        <summary>Utiliza um <see cref="T:System.Runtime.Remoting.ObjRef" /> e cria um objeto proxy dele, refinando-o para o tipo no servidor.</summary>
        <returns>Um proxy para o objeto que o determinado <see cref="T:System.Runtime.Remoting.ObjRef" /> representa.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Runtime.Remoting.ObjRef> é uma representação serializável de um objeto usado para transferir uma referência de objeto em um limite de domínio de aplicativo. Criando um <xref:System.Runtime.Remoting.ObjRef> para um objeto é conhecido como marshaling. O <xref:System.Runtime.Remoting.ObjRef> pode ser transferido por meio de um canal para outro domínio de aplicativo (possivelmente em outro processo ou computador). Uma vez em outro domínio do aplicativo, o <xref:System.Runtime.Remoting.ObjRef> deve ser analisado para criar um proxy para o objeto, geralmente é conectado ao objeto real. Esta operação é conhecida como unmarshaling. Durante o unmarshaling, o <xref:System.Runtime.Remoting.ObjRef> é analisado para extrair as informações do método do objeto remoto e o proxy transparente e <xref:System.Runtime.Remoting.Proxies.RealProxy> os objetos são criados. O conteúdo do analisado <xref:System.Runtime.Remoting.ObjRef> é adicionado ao proxy transparente antes que o proxy transparente é registrado com o common language runtime.  
  
 Um <xref:System.Runtime.Remoting.ObjRef> contém informações que descrevem o <xref:System.Type> e a classe do objeto que está sendo empacotado, um URI que identifica exclusivamente a instância do objeto específico e comunicação de informações relacionadas sobre como contatar a subdivisão de comunicação remota em que o objeto está localizado.  
  
 Quando criado, o proxy é do tipo <xref:System.MarshalByRefObject>. Como você pode convertê-lo em tipos diferentes, a infraestrutura de comunicação remota controla de tipo mais usado para evitar o carregamento do tipo desnecessariamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A instância <see cref="T:System.Runtime.Remoting.ObjRef" /> especificada no parâmetro <paramref name="objectRef" /> não é bem formada.</exception>
        <exception cref="T:System.Security.SecurityException">Pelo menos um dos chamadores no topo da pilha de chamadas não tem permissão para configurar canais e tipos de comunicação remota.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
  </Members>
</Type>