<Type Name="WindowsPrincipal" FullName="System.Security.Principal.WindowsPrincipal">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="326ff8c734b07ad7bb077fbe984bb04d68bb6351" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37462314" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class WindowsPrincipal : System.Security.Claims.ClaimsPrincipal" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit WindowsPrincipal extends System.Security.Claims.ClaimsPrincipal" />
  <TypeSignature Language="DocId" Value="T:System.Security.Principal.WindowsPrincipal" />
  <TypeSignature Language="VB.NET" Value="Public Class WindowsPrincipal&#xA;Inherits ClaimsPrincipal" />
  <TypeSignature Language="C++ CLI" Value="public ref class WindowsPrincipal : System::Security::Claims::ClaimsPrincipal" />
  <TypeSignature Language="F#" Value="type WindowsPrincipal = class&#xA;    inherit ClaimsPrincipal" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Principal.Windows</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Claims.ClaimsPrincipal</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.Object</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Permite que o código verifique a associação de grupo do Windows de um usuário do Windows.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Security.Principal.WindowsPrincipal> classe é usada principalmente para verificar a função de um usuário do Windows. O <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A?displayProperty=nameWithType> sobrecargas do método permitem que você verifique a função de usuário usando contextos de função diferente.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> sobrecargas de método. O <xref:System.Security.Principal.WindowsBuiltInRole> enumeração é usada como a origem para os identificadores relativos (RIDs) que identificam as funções internas. Os RIDs são usados para determinar as funções da entidade de segurança atual.  
  
 [!code-cpp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CPP/source.cpp#1)]
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#1)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WindowsPrincipal (System.Security.Principal.WindowsIdentity ntIdentity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Principal.WindowsIdentity ntIdentity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.#ctor(System.Security.Principal.WindowsIdentity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ntIdentity As WindowsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WindowsPrincipal(System::Security::Principal::WindowsIdentity ^ ntIdentity);" />
      <MemberSignature Language="F#" Value="new System.Security.Principal.WindowsPrincipal : System.Security.Principal.WindowsIdentity -&gt; System.Security.Principal.WindowsPrincipal" Usage="new System.Security.Principal.WindowsPrincipal ntIdentity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ntIdentity" Type="System.Security.Principal.WindowsIdentity" />
      </Parameters>
      <Docs>
        <param name="ntIdentity">O objeto do qual a nova instância de <see cref="T:System.Security.Principal.WindowsPrincipal" /> será construída.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Security.Principal.WindowsPrincipal" /> usando o objeto <see cref="T:System.Security.Principal.WindowsIdentity" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria um novo <xref:System.Security.Principal.WindowsPrincipal> objeto atuais <xref:System.Security.Principal.WindowsIdentity> objeto.  
  
 [!code-cpp[Classic WindowsPrincipal.WindowsPrincipal Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.WindowsPrincipal Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WindowsPrincipal.WindowsPrincipal Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.WindowsPrincipal Example/CS/source.cs#1)]
 [!code-vb[Classic WindowsPrincipal.WindowsPrincipal Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic WindowsPrincipal.WindowsPrincipal Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="ntIdentity" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeviceClaims">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt; DeviceClaims { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Security.Claims.Claim&gt; DeviceClaims" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsPrincipal.DeviceClaims" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeviceClaims As IEnumerable(Of Claim)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ DeviceClaims { System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeviceClaims : seq&lt;System.Security.Claims.Claim&gt;" Usage="System.Security.Principal.WindowsPrincipal.DeviceClaims" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_DeviceClaims&gt;d__13))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém todas as declarações de dispositivo Windows dessa entidade de segurança.</summary>
        <value>Uma coleção de todas as declarações de dispositivo do Windows dessa entidade de segurança.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Identity">
      <MemberSignature Language="C#" Value="public override System.Security.Principal.IIdentity Identity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IIdentity Identity" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsPrincipal.Identity" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Identity As IIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Principal::IIdentity ^ Identity { System::Security::Principal::IIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Identity : System.Security.Principal.IIdentity" Usage="System.Security.Principal.WindowsPrincipal.Identity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a identidade da entidade de segurança atual.</summary>
        <value>O objeto <see cref="T:System.Security.Principal.WindowsIdentity" /> da entidade de segurança atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir recupera o nome do usuário usando o <xref:System.Security.Principal.WindowsPrincipal.Identity%2A> propriedade do <xref:System.Security.Principal.WindowsPrincipal> objeto.  
  
 [!code-cpp[Classic WindowsPrincipal.Identity Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.Identity Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WindowsPrincipal.Identity Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.Identity Example/CS/source.cs#1)]
 [!code-vb[Classic WindowsPrincipal.Identity Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic WindowsPrincipal.Identity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsInRole">
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se a entidade de segurança atual pertence a um grupo de usuário do Windows especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Há quatro sobrecargas desse método. Por motivos de desempenho, o <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> sobrecarga é altamente recomendável.  
  
> [!IMPORTANT]
>  O <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> método não é suportado no Windows 98 ou Windows Millennium Edition.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public virtual bool IsInRole (int rid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInRole(int32 rid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInRole (rid As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInRole(int rid);" />
      <MemberSignature Language="F#" Value="override this.IsInRole : int -&gt; bool" Usage="windowsPrincipal.IsInRole rid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rid" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rid">O RID do grupo de usuários do Windows no qual o status de associação da entidade de segurança deve ser verificado.</param>
        <summary>Determina se a entidade de segurança atual pertence ao grupo de usuários do Windows com o RID (identificador relativo) especificado.</summary>
        <returns>
          <see langword="true" /> se a entidade de segurança atual for membro do grupo de usuários do Windows especificado, ou seja, em uma função específica, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durante o teste de informações de função recém-criada, como um novo usuário ou um novo grupo, é importante fazer logoff e fazer logon para forçar a propagação das informações de função dentro do domínio. Isso pode fazer com que o <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> teste retornar `false`. Esse método não é compatível com o Windows 98 nem com o Windows Millennium Edition.  
  
 Por motivos de desempenho, o <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> sobrecarga é recomendável que a sobrecarga preferível para determinar a função do usuário.  
  
> [!NOTE]
>  No Windows Vista, o controle de conta de usuário (UAC) determina os privilégios de um usuário. Se for um membro do grupo Administradores Internos, você receberá dois tokens de acesso do tempo de execução: um token de acesso do usuário padrão e um token de acesso do administrador. Por padrão, você está na função de usuário padrão. Quando você tenta executar uma tarefa que requer privilégios administrativos, você pode elevar dinamicamente sua função usando a caixa de diálogo de consentimento. O código que executa o <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> método não exibe a caixa de diálogo de consentimento. O código retorna false se você estiver na função de usuário padrão, mesmo se você estiver no grupo de administradores internos. Você pode elevar seus privilégios antes de executar o código clicando duas vezes no ícone do aplicativo e que indica que você deseja executar como administrador.  
  
 Identificadores relativos (RIDs) são componentes de identificador de segurança de um grupo usuário de Windows (SID) e têm suporte para ajudar a evitar problemas de localização de plataforma cruzada. Muitas contas de usuário, grupos locais e grupos globais têm um valor RID padrão que é constante em todas as versões do Windows.  
  
 Por exemplo, o RID para a função de BUILTIN\Administradores é 0x220. Usando 0x220 como o parâmetro de entrada para o <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> método resulta em `true` sendo retornado se a entidade atual é um administrador.  
  
 As tabelas a seguir listam os valores RID padrão.  
  
|Usuários internos|RID|  
|---------------------|---------|  
|DOMAINNAME\Administrator|0x1F4|  
|DOMAINNAME\Guest|0x1F5|  
  
|Grupos globais embutidos|RID|  
|-----------------------------|---------|  
|Domínio \ Administradores|0x200|  
|Usuários DOMAINNAME\Domain|0x201|  
|DOMAINNAME\Domain convidados|0x202|  
  
|Grupos locais internos|RID|  
|----------------------------|---------|  
|BUILTIN\Administrators|0x220|  
|BUILTIN \ usuários|0x221|  
|BUILTIN\Guests|0x222|  
|Operadores de conta\interna|0x224|  
|Builtin\operadores de servidor|0x225|  
|Operadores de BUILTIN\Print|0x226|  
|Builtin\operadores de backup|0x227|  
|BUILTIN\Replicator|0x228|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> métodos. O <xref:System.Security.Principal.WindowsBuiltInRole> enumeração é usada como a origem para os RIDs que identificam as funções internas. Os RIDs são usados para determinar as funções da entidade de segurança atual.  
  
 [!code-cpp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CPP/source.cpp#1)]
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#1)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public virtual bool IsInRole (System.Security.Principal.SecurityIdentifier sid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInRole(class System.Security.Principal.SecurityIdentifier sid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.Security.Principal.SecurityIdentifier)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInRole (sid As SecurityIdentifier) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInRole(System::Security::Principal::SecurityIdentifier ^ sid);" />
      <MemberSignature Language="F#" Value="override this.IsInRole : System.Security.Principal.SecurityIdentifier -&gt; bool" Usage="windowsPrincipal.IsInRole sid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sid" Type="System.Security.Principal.SecurityIdentifier" />
      </Parameters>
      <Docs>
        <param name="sid">Um <see cref="T:System.Security.Principal.SecurityIdentifier" /> que identifica exclusivamente um grupo de usuários do Windows.</param>
        <summary>Determina se a entidade de segurança atual pertence ao grupo de usuários do Windows com o SID (identificador de segurança) especificado.</summary>
        <returns>
          <see langword="true" /> se a entidade de segurança atual for membro do grupo de usuários do Windows especificado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Security.Principal.SecurityIdentifier> identifica exclusivamente um usuário ou grupo em implementações do Windows 2000, Windows Server e Windows XP. Durante o teste de informações de função recém-criada, como um novo usuário ou um novo grupo, é importante fazer logoff e fazer logon para forçar a propagação das informações de função dentro do domínio. Isso pode fazer com que o <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> teste retornar `false`. Esse método não é compatível com o Windows 98 nem com o Windows Millennium Edition.  
  
> [!NOTE]
>  No Windows Vista, o controle de conta de usuário (UAC) determina os privilégios de um usuário. Se for um membro do grupo Administradores Internos, você receberá dois tokens de acesso do tempo de execução: um token de acesso do usuário padrão e um token de acesso do administrador. Por padrão, você está na função de usuário padrão. Quando você tenta executar uma tarefa que requer privilégios administrativos, você pode elevar dinamicamente sua função usando a caixa de diálogo de consentimento. O código que executa o <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> método não exibe a caixa de diálogo de consentimento. O código retorna false se você estiver na função de usuário padrão, mesmo se você estiver no grupo de administradores internos. Você pode elevar seus privilégios antes de executar o código clicando duas vezes no ícone do aplicativo e que indica que você deseja executar como administrador.  
  
 Por motivos de desempenho, isso é a melhor sobrecarga para determinar uma função de usuário.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29?displayProperty=nameWithType> método. O <xref:System.Security.Principal.WellKnownSidType.BuiltinAdministratorsSid> valor de enumeração é usado para determinar se a entidade atual é um administrador. No exemplo de código completo, consulte o <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Int32%29?displayProperty=nameWithType> método.  
  
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#5)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sid" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">O Windows retornou um erro do Win32.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public virtual bool IsInRole (System.Security.Principal.WindowsBuiltInRole role);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInRole(valuetype System.Security.Principal.WindowsBuiltInRole role) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.Security.Principal.WindowsBuiltInRole)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInRole (role As WindowsBuiltInRole) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInRole(System::Security::Principal::WindowsBuiltInRole role);" />
      <MemberSignature Language="F#" Value="override this.IsInRole : System.Security.Principal.WindowsBuiltInRole -&gt; bool" Usage="windowsPrincipal.IsInRole role" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="role" Type="System.Security.Principal.WindowsBuiltInRole" />
      </Parameters>
      <Docs>
        <param name="role">Um dos valores de <see cref="T:System.Security.Principal.WindowsBuiltInRole" />.</param>
        <summary>Determina se a entidade atual pertence ao grupo de usuários do Windows com o <see cref="T:System.Security.Principal.WindowsBuiltInRole" /> especificado.</summary>
        <returns>
          <see langword="true" /> se a entidade de segurança atual for membro do grupo de usuários do Windows especificado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durante o teste de informações de função recém-criada, como um novo usuário ou um novo grupo, é importante fazer logoff e fazer logon para forçar a propagação das informações de função dentro do domínio. Isso pode fazer com que o <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> teste retornar `false`. Esse método não é compatível com o Windows 98 nem com o Windows Millennium Edition.  
  
 Por motivos de desempenho, o <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> sobrecarga é recomendável que a sobrecarga preferível para determinar a função do usuário.  
  
> [!NOTE]
>  No Windows Vista, o controle de conta de usuário (UAC) determina os privilégios de um usuário. Se for um membro do grupo Administradores Internos, você receberá dois tokens de acesso do tempo de execução: um token de acesso do usuário padrão e um token de acesso do administrador. Por padrão, você está na função de usuário padrão. Quando você tenta executar uma tarefa que requer privilégios administrativos, você pode elevar dinamicamente sua função usando a caixa de diálogo de consentimento. O código que executa o <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> método não exibe a caixa de diálogo de consentimento. O código retorna false se você estiver na função de usuário padrão, mesmo se você estiver no grupo de administradores internos. Você pode elevar seus privilégios antes de executar o código clicando duas vezes no ícone do aplicativo e que indica que você deseja executar como administrador.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Security.Principal.WindowsBuiltInRole> enumeração é usada para determinar se a entidade atual é um <xref:System.Security.Principal.WindowsBuiltInRole.Administrator>. No exemplo de código completo, consulte o <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Int32%29?displayProperty=nameWithType> método.  
  
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#4)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="role" /> não é um valor <see cref="T:System.Security.Principal.WindowsBuiltInRole" /> válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public override bool IsInRole (string role);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsInRole(string role) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsInRole (role As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsInRole(System::String ^ role);" />
      <MemberSignature Language="F#" Value="override this.IsInRole : string -&gt; bool" Usage="windowsPrincipal.IsInRole role" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="role" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="role">O nome do grupo de usuários do Windows para o qual verificar a associação.</param>
        <summary>Determina se a entidade de segurança atual pertence ao grupo de usuários do Windows com o nome especificado.</summary>
        <returns>
          <see langword="true" /> se a entidade de segurança atual for membro do grupo de usuários do Windows especificado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durante o teste de informações de função recém-criada, como um novo usuário ou um novo grupo, é importante fazer logoff e fazer logon para forçar a propagação das informações de função dentro do domínio. Isso pode fazer com que o <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> teste retornar `false`. Esse método não é compatível com o Windows 98 nem com o Windows Millennium Edition.  
  
 Por motivos de desempenho, o <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> sobrecarga é recomendável que a sobrecarga preferível para determinar a função do usuário.  
  
> [!NOTE]
>  No Windows Vista, o controle de conta de usuário (UAC) determina os privilégios de um usuário. Se for um membro do grupo Administradores Internos, você receberá dois tokens de acesso do tempo de execução: um token de acesso do usuário padrão e um token de acesso do administrador. Por padrão, você está na função de usuário padrão. Quando você tenta executar uma tarefa que requer privilégios administrativos, você pode elevar dinamicamente sua função usando a caixa de diálogo de consentimento. O código que executa o <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> método não exibe a caixa de diálogo de consentimento. O código retorna false se você estiver na função de usuário padrão, mesmo se você estiver no grupo de administradores internos. Você pode elevar seus privilégios antes de executar o código clicando duas vezes no ícone do aplicativo e que indica que você deseja executar como administrador.  
  
 Para as funções internas, o `role` cadeia de caracteres deve estar no formato "BUILTIN\\*RoleNameHere*". Por exemplo, para testar a associação na função de administrador do Windows, a cadeia de caracteres que representa a função deve ser "BUILTIN\Administrators". Observe que a barra invertida talvez precisem ser substituídos. A tabela a seguir lista as funções internas.  
  
> [!NOTE]
>  A ortografia para as funções internas no formato de cadeia de caracteres é diferente da ortografia usada no <xref:System.Security.Principal.WindowsBuiltInRole> enumeração. Por exemplo, a ortografia de um administrador na enumeração é "Administrador", não "administradores". Ao usar essa sobrecarga, use a ortografia para a função da tabela a seguir.  
  
|Grupos locais internos|  
|----------------------------|  
|BUILTIN\Administrators|  
|BUILTIN \ usuários|  
|BUILTIN\Guests|  
|Operadores de conta\interna|  
|Builtin\operadores de servidor|  
|Operadores de BUILTIN\Print|  
|Builtin\operadores de backup|  
|BUILTIN\Replicator|  
  
 Para funções específicas do computador, o `role` cadeia de caracteres deve estar no formato "MachineName\\*RoleNameHere*".  
  
 Para funções específicas do domínio, o `role` cadeia de caracteres deve estar no formato "nome_do_domínio\\*RoleNameHere*"; por exemplo, `"SomeDomain\Domain Users`".  
  
> [!NOTE]
>  No .NET Framework versão 1.0, o `role` parâmetro diferencia maiusculas de minúsculas. No .NET Framework versão 1.1 e posterior, o `role` parâmetro diferencia maiusculas de minúsculas.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.String%29?displayProperty=nameWithType> método.  
  
 As cadeias de caracteres `BUILTIN\Administrators` e `BUILTIN\Users` são usados para determinar se a entidade atual é um administrador ou um usuário. No exemplo de código completo, consulte o <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Int32%29?displayProperty=nameWithType> método.  
  
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#3)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de manipular o objeto principal. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
        <altmember cref="T:System.Security.Principal.WindowsBuiltInRole" />
      </Docs>
    </Member>
    <Member MemberName="UserClaims">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt; UserClaims { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Security.Claims.Claim&gt; UserClaims" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsPrincipal.UserClaims" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property UserClaims As IEnumerable(Of Claim)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ UserClaims { System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserClaims : seq&lt;System.Security.Claims.Claim&gt;" Usage="System.Security.Principal.WindowsPrincipal.UserClaims" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_UserClaims&gt;d__11))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém todas as declarações de usuário do Windows dessa entidade de segurança.</summary>
        <value>Uma coleção de todas as declarações de usuário do Windows dessa entidade de segurança.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>