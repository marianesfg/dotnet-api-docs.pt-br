<Type Name="AccessText" FullName="System.Windows.Controls.AccessText">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f2248fdd42dbdb2dd6f42ad16c7b8fff5b421360" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30620050" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class AccessText : System.Windows.FrameworkElement, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit AccessText extends System.Windows.FrameworkElement implements class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.AccessText" />
  <TypeSignature Language="VB.NET" Value="Public Class AccessText&#xA;Inherits FrameworkElement&#xA;Implements IAddChild" />
  <TypeSignature Language="C++ CLI" Value="public ref class AccessText : System::Windows::FrameworkElement, System::Windows::Markup::IAddChild" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Text")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Especifica com um sublinhado o caractere usado como a tecla de acesso.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o conteúdo tiver vários caracteres de sublinhado, somente o primeiro deles é convertido em um <xref:System.Windows.Controls.AccessText.AccessKey%2A>; os outros sublinhados aparecem como texto normal. Se o caractere de sublinhado que você deseja convertido para a chave de acesso não for o primeiro caractere de sublinhado, use dois sublinhados consecutivos para qualquer sublinhados anteriores que você deseja converter. Por exemplo, o código a seguir contém uma chave de acesso e exibe como _Hello**W**World:  
  
```  
<AccessText>__Hello_World</AccessText>   
```  
  
 Como o sublinhado que precede H é um duplo, a chave W registra como a chave de acesso.  
  
 Para usar <xref:System.Windows.Controls.AccessText> como um host de conteúdo em um estilo de controle, configure <xref:System.Windows.Controls.ContentPresenter.RecognizesAccessKey%2A> no <xref:System.Windows.Controls.ContentPresenter>, como mostra este exemplo:  
  
```  
<ContentPresenter RecognizesAccessKey="True"/>   
```  
  
   
  
## Examples  
 Você pode usar o <xref:System.Windows.Controls.AccessText> marca para criar um <xref:System.Windows.Controls.AccessText.AccessKey%2A>; no entanto, uma marca não é necessária. O exemplo a seguir mostra como criar uma chave de acesso com e sem o <xref:System.Windows.Controls.AccessText> marca.  
  
 [!code-xaml[AccessText#2](~/samples/snippets/csharp/VS_Snippets_Wpf/AccessText/CS/pane1.xaml#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AccessText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.AccessText.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AccessText();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.Controls.AccessText" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessKey">
      <MemberSignature Language="C#" Value="public char AccessKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char AccessKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.AccessText.AccessKey" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessKey As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char AccessKey { char get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Fornece acesso somente leitura para o caractere que segue o primeiro caractere de sublinhado.</summary>
        <value>O caractere de retorno.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Windows.Controls.AccessText.AccessKey%2A> propriedade para determinar programaticamente qual caractere é analisada pelo <xref:System.Windows.Controls.AccessText>.  
  
 O <xref:System.Windows.Input.AccessKeyManager> registra o <xref:System.Windows.Controls.AccessText.AccessKey%2A> caractere e gera o <xref:System.Windows.Input.AccessKeyManager.AccessKeyPressed> evento quando os usuários pressionam a tecla.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Size ArrangeOverride (System.Windows.Size arrangeSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.AccessText.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function ArrangeOverride (arrangeSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeSize">O tamanho calculado que é usado para organizar o conteúdo.</param>
        <summary>Organiza e dimensiona o conteúdo de um objeto <see cref="T:System.Windows.Controls.AccessText" />.</summary>
        <returns>O tamanho do conteúdo.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Background">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Background { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Background" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.AccessText.Background" />
      <MemberSignature Language="VB.NET" Value="Public Property Background As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Background { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o <see cref="T:System.Windows.Media.Brush" /> que preenche a área de conteúdo.</summary>
        <value>O <see cref="T:System.Windows.Media.Brush" /> que preenche a área de conteúdo. O padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_Background"></a>   
## <a name="dependency-property-information"></a>Informações da propriedade de dependência  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.AccessText.BackgroundProperty>|  
|Propriedades de metadados é definido como `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 O exemplo a seguir mostra como definir propriedades para alterar a aparência do texto em uma <xref:System.Windows.Controls.AccessText> controle.  
  
 [!code-xaml[AccessText#AccessTextProps](~/samples/snippets/csharp/VS_Snippets_Wpf/AccessText/CS/pane1.xaml#accesstextprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.TextBlock" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BackgroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BackgroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.AccessText.BackgroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BackgroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BackgroundProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade de dependência <see cref="P:System.Windows.Controls.AccessText.Background" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaselineOffset">
      <MemberSignature Language="C#" Value="public double BaselineOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 BaselineOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.AccessText.BaselineOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property BaselineOffset As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double BaselineOffset { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que ajusta a posição de deslocamento da linha de base do texto em um elemento <see cref="T:System.Windows.Controls.AccessText" />.</summary>
        <value>O valor para ajustar a linha de base de deslocamento da posição.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], esse valor é verdadeiro duplo. Você não pode qualificar esse valor usando unidades de medida como picas ou pontos.  
  
<a name="dependencyPropertyInfo_BaselineOffset"></a>   
## <a name="dependency-property-information"></a>Informações da propriedade de dependência  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.AccessText.BaselineOffsetProperty>|  
|Propriedades de metadados é definido como `true`|Nenhum|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.TextBlock" />
      </Docs>
    </Member>
    <Member MemberName="BaselineOffsetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BaselineOffsetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BaselineOffsetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.AccessText.BaselineOffsetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BaselineOffsetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BaselineOffsetProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade de dependência <see cref="P:System.Windows.Controls.AccessText.BaselineOffset" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamily">
      <MemberSignature Language="C#" Value="public System.Windows.Media.FontFamily FontFamily { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.FontFamily FontFamily" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.AccessText.FontFamily" />
      <MemberSignature Language="VB.NET" Value="Public Property FontFamily As FontFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::FontFamily ^ FontFamily { System::Windows::Media::FontFamily ^ get(); void set(System::Windows::Media::FontFamily ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Font, Modifiability=System.Windows.Modifiability.Unmodifiable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.FontFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a família de fontes a ser usada com o elemento <see cref="T:System.Windows.Controls.AccessText" />.</summary>
        <value>A família de fontes para usar. O padrão é a fonte que é determinada pelo <see cref="P:System.Windows.SystemFonts.MessageFontFamily" /> métrica.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_FontFamily"></a>   
## <a name="dependency-property-information"></a>Informações da propriedade de dependência  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.AccessText.FontFamilyProperty>|  
|Propriedades de metadados é definido como `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 O exemplo a seguir mostra como definir propriedades para alterar a aparência do texto em uma <xref:System.Windows.Controls.AccessText> controle.  
  
 [!code-xaml[AccessText#AccessTextProps](~/samples/snippets/csharp/VS_Snippets_Wpf/AccessText/CS/pane1.xaml#accesstextprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.TextBlock" />
      </Docs>
    </Member>
    <Member MemberName="FontFamilyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontFamilyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontFamilyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.AccessText.FontFamilyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontFamilyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontFamilyProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade de dependência <see cref="P:System.Windows.Controls.AccessText.FontFamily" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSize">
      <MemberSignature Language="C#" Value="public double FontSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 FontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.AccessText.FontSize" />
      <MemberSignature Language="VB.NET" Value="Public Property FontSize As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double FontSize { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.FontSizeConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tamanho da fonte a ser usado com o elemento <see cref="T:System.Windows.Controls.AccessText" />.</summary>
        <value>O tamanho da fonte a ser usado. O padrão é o que é determinado pelo tamanho da fonte de <see cref="P:System.Windows.SystemFonts.MessageFontSize" /> métrica.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_FontSize"></a>   
## <a name="dependency-property-information"></a>Informações da propriedade de dependência  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.AccessText.FontSizeProperty>|  
|Propriedades de metadados é definido como `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
<a name="xamlAttributeUsage_FontSize"></a>   
## <a name="xaml-attribute-usage"></a>Uso do Atributo XAML  
  
```  
<object FontSize="double"/>  
- or –  
<object FontSize ="qualifiedDouble"/>  
```  
  
<a name="xamlValues_FontSize"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *Duplo*  
 <xref:System.Double>  
  
 Uma representação de cadeia de caracteres de uma <xref:System.Double> valor. Esse valor é interpretado como um [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] medida. Cadeias de caracteres não precisam explicitamente incluir pontos decimais. Por exemplo, você pode especificar um valor de `1`.  
  
 *qualifiedDouble*  
 Um *duplo* valor que é seguido por uma destas cadeias de caracteres de declaração de unidade: `px`, `in`, `cm`, `pt`.  
  
 `px` é (padrão) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm` centímetros; 1cm==(96/2.54) px  
  
 `pt` pontos; 1pt==(96/72) px  
  
 **Observação** em muitos casos, você pode definir um dobro para `Auto`; no entanto, você não pode definir essa propriedade `Auto`.  
  
   
  
## Examples  
 O exemplo a seguir mostra como definir propriedades para alterar a aparência do texto em uma <xref:System.Windows.Controls.AccessText> controle.  
  
 [!code-xaml[AccessText#AccessTextProps](~/samples/snippets/csharp/VS_Snippets_Wpf/AccessText/CS/pane1.xaml#accesstextprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.TextBlock" />
      </Docs>
    </Member>
    <Member MemberName="FontSizeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontSizeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontSizeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.AccessText.FontSizeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontSizeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontSizeProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade de dependência <see cref="P:System.Windows.Controls.AccessText.FontSize" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStretch">
      <MemberSignature Language="C#" Value="public System.Windows.FontStretch FontStretch { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FontStretch FontStretch" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.AccessText.FontStretch" />
      <MemberSignature Language="VB.NET" Value="Public Property FontStretch As FontStretch" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FontStretch FontStretch { System::Windows::FontStretch get(); void set(System::Windows::FontStretch value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontStretch</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define uma propriedade <see cref="T:System.Windows.FontStretch" /> que seleciona uma fonte normal, condensada ou expandida de um <see cref="T:System.Windows.Media.FontFamily" />.</summary>
        <value>O grau relativo que a fonte é estendida. O padrão é <see cref="P:System.Windows.FontStretches.Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_FontStretch"></a>   
## <a name="dependency-property-information"></a>Informações da propriedade de dependência  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.AccessText.FontStretchProperty>|  
|Propriedades de metadados é definido como `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.TextBlock" />
      </Docs>
    </Member>
    <Member MemberName="FontStretchProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontStretchProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontStretchProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.AccessText.FontStretchProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontStretchProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontStretchProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade de dependência <see cref="P:System.Windows.Controls.AccessText.FontStretch" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStyle">
      <MemberSignature Language="C#" Value="public System.Windows.FontStyle FontStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FontStyle FontStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.AccessText.FontStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FontStyle As FontStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FontStyle FontStyle { System::Windows::FontStyle get(); void set(System::Windows::FontStyle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o estilo da fonte a ser usado com o elemento <see cref="T:System.Windows.Controls.AccessText" />.</summary>
        <value>O estilo da fonte a ser usado; Por exemplo, normal, itálico ou oblíquo. O padrão é determinado pelo <see cref="P:System.Windows.SystemFonts.MessageFontStyle" /> métrica.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações e uma lista de estilos de fonte, consulte <xref:System.Windows.FontStyle>.  
  
<a name="dependencyPropertyInfo_FontStyle"></a>   
## <a name="dependency-property-information"></a>Informações da propriedade de dependência  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.AccessText.FontStyleProperty>|  
|Propriedades de metadados é definido como `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 O exemplo a seguir mostra como definir propriedades para alterar a aparência do texto em uma <xref:System.Windows.Controls.AccessText> controle.  
  
 [!code-xaml[AccessText#AccessTextProps](~/samples/snippets/csharp/VS_Snippets_Wpf/AccessText/CS/pane1.xaml#accesstextprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.TextBlock" />
      </Docs>
    </Member>
    <Member MemberName="FontStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.AccessText.FontStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontStyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade de dependência <see cref="P:System.Windows.Controls.AccessText.FontStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontWeight">
      <MemberSignature Language="C#" Value="public System.Windows.FontWeight FontWeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FontWeight FontWeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.AccessText.FontWeight" />
      <MemberSignature Language="VB.NET" Value="Public Property FontWeight As FontWeight" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FontWeight FontWeight { System::Windows::FontWeight get(); void set(System::Windows::FontWeight value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontWeight</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a espessura da fonte a ser usada com o elemento <see cref="T:System.Windows.Controls.AccessText" />.</summary>
        <value>A espessura da fonte a ser usado. O padrão é determinado pelo <see cref="P:System.Windows.SystemFonts.MessageFontWeight" /> métrica.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_FontWeight"></a>   
## <a name="dependency-property-information"></a>Informações da propriedade de dependência  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.AccessText.FontWeightProperty>|  
|Propriedades de metadados é definido como `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 O exemplo a seguir mostra como definir propriedades para alterar a aparência do texto em uma <xref:System.Windows.Controls.AccessText> controle.  
  
 [!code-xaml[AccessText#AccessTextProps](~/samples/snippets/csharp/VS_Snippets_Wpf/AccessText/CS/pane1.xaml#accesstextprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.TextBlock" />
      </Docs>
    </Member>
    <Member MemberName="FontWeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontWeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontWeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.AccessText.FontWeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontWeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontWeightProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade de dependência <see cref="P:System.Windows.Controls.AccessText.FontWeight" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Foreground">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Foreground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Foreground" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.AccessText.Foreground" />
      <MemberSignature Language="VB.NET" Value="Public Property Foreground As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Foreground { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o <see cref="T:System.Windows.Media.Brush" /> que desenha o conteúdo do texto do elemento.</summary>
        <value>O <see cref="T:System.Windows.Media.Brush" /> que desenha o texto. O padrão é <see cref="P:System.Windows.Media.Brushes.Black" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_Foreground"></a>   
## <a name="dependency-property-information"></a>Informações da propriedade de dependência  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.AccessText.ForegroundProperty>|  
|Propriedades de metadados é definido como `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 O exemplo a seguir mostra como definir propriedades para alterar a aparência do texto em uma <xref:System.Windows.Controls.AccessText> controle.  
  
 [!code-xaml[AccessText#AccessTextProps](~/samples/snippets/csharp/VS_Snippets_Wpf/AccessText/CS/pane1.xaml#accesstextprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.TextBlock" />
      </Docs>
    </Member>
    <Member MemberName="ForegroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForegroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForegroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.AccessText.ForegroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForegroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForegroundProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade de dependência <see cref="P:System.Windows.Controls.AccessText.Foreground" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.AccessText.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">O índice do elemento filho visual a ser retornado.</param>
        <summary>Obtém o índice de um elemento filho visual.</summary>
        <returns>Retorna um inteiro que representa o índice de um elemento filho visual.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineHeight">
      <MemberSignature Language="C#" Value="public double LineHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 LineHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.AccessText.LineHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property LineHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double LineHeight { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a altura de cada caixa de linha.</summary>
        <value>Um duplo que especifica a altura de cada caixa de linha. Esse valor deve ser maior ou igual a <c>0.0034</c> e igual ou menor, em seguida, <c>160000</c>. Um valor de <see cref="F:System.Double.NaN" /> (equivalente a um valor de atributo <c>automática</c>) faz com que a altura da linha ser determinado automaticamente das características da fonte atual. O padrão é <see cref="F:System.Double.NaN" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A alteração desse valor não altera a altura do texto associado; em vez disso, ele altera a caixa que o contém. Para alterar o tamanho do texto, use o <xref:System.Windows.Controls.AccessText.FontSize%2A> propriedade.  
  
<a name="dependencyPropertyInfo_LineHeight"></a>   
## <a name="dependency-property-information"></a>Informações da propriedade de dependência  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.AccessText.LineHeightProperty>|  
|Propriedades de metadados é definido como `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
<a name="xamlAttributeUsage_LineHeight"></a>   
## <a name="xaml-attribute-usage"></a>Uso do Atributo XAML  
  
```  
<object LineHeight="double"/>  
- or –  
<object LineHeight ="qualifiedDouble"/>  
- or –  
<object LineHeight ="Auto"/>  
```  
  
<a name="xamlValues_LineHeight"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *double*  
 <xref:System.Double>  
  
 Uma representação de cadeia de caracteres de uma <xref:System.Double> valor. Esse valor é interpretado como um [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] medida. Cadeias de caracteres não precisam explicitamente incluir pontos decimais. Por exemplo, você pode especificar um valor de `1`.  
  
 O mesmo <xref:System.Double> restrições de intervalo conforme mencionado na seção do valor da propriedade se aplicam aqui.  
  
 *qualifiedDouble*  
 Um *duplo* valor que é seguido por uma destas cadeias de caracteres de declaração de unidade: `px`, `in`, `cm`, `pt`.  
  
 `px` é (padrão) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm` centímetros; 1cm==(96/2.54) px  
  
 `pt` pontos; 1pt==(96/72) px  
  
 *Auto*  
 Uma determinação de altura de linha automática. Se você definir programaticamente o *automática* valor, seu valor corresponde à <xref:System.Double.NaN?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.TextBlock" />
        <altmember cref="P:System.Windows.Controls.AccessText.LineStackingStrategy" />
      </Docs>
    </Member>
    <Member MemberName="LineHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LineHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LineHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.AccessText.LineHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LineHeightProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade de dependência <see cref="P:System.Windows.Controls.AccessText.LineHeight" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineStackingStrategy">
      <MemberSignature Language="C#" Value="public System.Windows.LineStackingStrategy LineStackingStrategy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.LineStackingStrategy LineStackingStrategy" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.AccessText.LineStackingStrategy" />
      <MemberSignature Language="VB.NET" Value="Public Property LineStackingStrategy As LineStackingStrategy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::LineStackingStrategy LineStackingStrategy { System::Windows::LineStackingStrategy get(); void set(System::Windows::LineStackingStrategy value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LineStackingStrategy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define como a propriedade <see cref="P:System.Windows.Controls.AccessText.LineHeight" /> é imposta.</summary>
        <value>Um <see cref="T:System.Windows.LineStackingStrategy" /> valor que determina o comportamento do <see cref="P:System.Windows.Controls.AccessText.LineHeight" /> propriedade.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.AccessText.LineHeight%2A> Propriedades de controle de caixa de linha que é reservada para texto. <xref:System.Windows.Controls.AccessText.LineHeight%2A> permite que os usuários definam uma sugestão de altura. <xref:System.Windows.LineStackingStrategy> define como o <xref:System.Windows.Controls.AccessText.LineHeight%2A> é imposta.  
  
 Você pode definir o <xref:System.Windows.Controls.AccessText.LineStackingStrategy%2A> propriedade <xref:System.Windows.LineStackingStrategy.MaxHeight> ou <xref:System.Windows.LineStackingStrategy.BlockLineHeight>.  
  
-   O <xref:System.Windows.LineStackingStrategy.MaxHeight> valor aumenta a linha para o objeto mais alto na linha. Garante que nenhum item overdraws ou é cortado.  
  
-   O <xref:System.Windows.LineStackingStrategy.BlockLineHeight> valor impõe uma <xref:System.Windows.Controls.AccessText.LineHeight%2A> valor em todas as linhas. Se o <xref:System.Windows.Controls.AccessText.LineHeight%2A> propriedade não tem espaço suficiente, o texto está sacados a descoberto ou cortado. O que ocorre depende do <xref:System.Windows.UIElement.ClipProperty> valor.  
  
<a name="dependencyPropertyInfo_LineStackingStrategy"></a>   
## <a name="dependency-property-information"></a>Informações da propriedade de dependência  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.AccessText.LineStackingStrategyProperty>|  
|Propriedades de metadados é definido como `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LineStackingStrategyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LineStackingStrategyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LineStackingStrategyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.AccessText.LineStackingStrategyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineStackingStrategyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LineStackingStrategyProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade de dependência <see cref="P:System.Windows.Controls.AccessText.LineStackingStrategy" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.AccessText.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um enumerador que itera os elementos filho lógicos do elemento <see cref="T:System.Windows.Controls.AccessText" />.</summary>
        <value>Um enumerador que itera os elementos filho desse elemento.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.AccessText.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function MeasureOverride (constraint As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size constraint);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">O limite de tamanho máximo para o controle. O valor retornado não pode exceder este tamanho.</param>
        <summary>Mede o controle novamente.</summary>
        <returns>O tamanho do controle. Não é possível exceder o limite de tamanho máximo para o controle.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.AccessText.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O objeto a ser adicionado ao <see cref="T:System.Windows.Controls.AccessText" />.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Windows.Markup.IAddChild.AddChild(System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Windows.Controls.AccessText> é convertida em uma interface de <xref:System.Windows.Markup.IAddChild>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.AccessText.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (text As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ text) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">O texto a ser adicionado ao objeto.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Windows.Markup.IAddChild.AddText(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Windows.Controls.AccessText> é convertida em uma interface de <xref:System.Windows.Markup.IAddChild>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.AccessText.Text" />
      <MemberSignature Language="VB.NET" Value="Public Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o texto exibido pelo elemento <see cref="T:System.Windows.Controls.AccessText" />.</summary>
        <value>O texto sem o primeiro caractere de sublinhado. O padrão é uma cadeia de caracteres vazia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma chave de acesso não será criada se você usar o <xref:System.Windows.Controls.AccessText.Text%2A> propriedade para fornecer texto para um <xref:System.Windows.Controls.AccessText> elemento. Essa propriedade é usada internamente para determinar o texto que é exibido, a chave de acesso. Você pode usar essa propriedade para definir o texto adicional que não contêm o mnemônico (caractere de sublinhado) ou para recuperar o texto da tecla de acesso.  
  
<a name="xamlObjectElementUsage_Text"></a>   
## <a name="xaml-object-element-usage"></a>Uso de elemento Object do XAML  
  
```  
<object>_accessText</object>  
- or -   
<object><accessTextObject>_accessText</accessTextObject></object>  
  
```  
  
<a name="xamlValues_Text"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *_accessText*  
 Uma cadeia de caracteres que contém o caractere de sublinhado. Esse valor se torna um <xref:System.Windows.Controls.AccessText> identificadores acessar chaves para o *objeto*. A chave de acesso é o caractere que segue imediatamente o caractere de sublinhado.  
  
 *accessTextObject*  
 O <xref:System.Windows.Controls.AccessText>.  
  
<a name="dependencyPropertyInfo_Text"></a>   
## <a name="dependency-property-information"></a>Informações da propriedade de dependência  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.AccessText.TextProperty>|  
|Propriedades de metadados é definido como `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 O exemplo a seguir cria uma chave de acesso que personaliza a primeira letra da chave de acesso, que contém o mnemônico e, em seguida, define o restante do texto usando o <xref:System.Windows.Controls.AccessText.Text%2A> propriedade.  
  
 [!code-xaml[AccessTextProps_snip#AccessTextText](~/samples/snippets/csharp/VS_Snippets_Wpf/AccessTextProps_snip/CS/pane1.xaml#accesstexttext)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.TextBlock" />
      </Docs>
    </Member>
    <Member MemberName="TextAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.TextAlignment TextAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.TextAlignment TextAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.AccessText.TextAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property TextAlignment As TextAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TextAlignment TextAlignment { System::Windows::TextAlignment get(); void set(System::Windows::TextAlignment value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o alinhamento horizontal do conteúdo.</summary>
        <value>O alinhamento horizontal do texto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter uma lista de alinhamentos consulte <xref:System.Windows.TextAlignment>.  
  
<a name="dependencyPropertyInfo_TextAlignment"></a>   
## <a name="dependency-property-information"></a>Informações da propriedade de dependência  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.AccessText.TextAlignmentProperty>|  
|Propriedades de metadados é definido como `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.AccessText.TextAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextAlignmentProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade de dependência <see cref="P:System.Windows.Controls.AccessText.TextAlignment" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextDecorations">
      <MemberSignature Language="C#" Value="public System.Windows.TextDecorationCollection TextDecorations { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TextDecorationCollection TextDecorations" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.AccessText.TextDecorations" />
      <MemberSignature Language="VB.NET" Value="Public Property TextDecorations As TextDecorationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TextDecorationCollection ^ TextDecorations { System::Windows::TextDecorationCollection ^ get(); void set(System::Windows::TextDecorationCollection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextDecorationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define as decorações adicionadas ao texto de um elemento <see cref="T:System.Windows.Controls.AccessText" />.</summary>
        <value>O <see cref="T:System.Windows.TextDecorations" /> aplicada ao texto de um <see cref="T:System.Windows.Controls.AccessText" />. O padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre a decoração de texto, consulte <xref:System.Windows.TextDecorations>.  
  
 Essa propriedade normalmente não é definida, usando marcação ou código.  
  
 Essa propriedade expõe a decoração de padrão para uma chave de acesso (sublinhado na mesma cor do texto como texto) para obter possíveis estilo ou alterar através de programação. Como os usuários esperam que os identificadores de chave de acesso para ter uma aparência de determinados no [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)], a melhor opção é alterar essa propriedade por meio de mecanismos de todo o aplicativo, como estilos de aplicativo ou de temas personalizados.  
  
<a name="xamlPropertyElementUsage_TextDecorations"></a>   
## <a name="xaml-property-element-usage"></a>Uso do elemento propriedade XAML  
  
```  
<object>  
  <object.TextDecorations>  
    OneOrMoreTextDecorations  
  </object.TextDecorations>  
</object>  
```  
  
<a name="xamlValues_TextDecorations"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *OneOrMoreTextDecorations*  
 Um ou mais <xref:System.Windows.TextDecoration> elementos. Use essa sintaxe, se você estiver definindo a decoração de texto personalizado. Para obter detalhes, consulte [como: criar uma decoração de texto](~/docs/framework/wpf/advanced/how-to-create-a-text-decoration.md).  
  
<a name="dependencyPropertyInfo_TextDecorations"></a>   
## <a name="dependency-property-information"></a>Informações da propriedade de dependência  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.AccessText.TextDecorationsProperty>|  
|Propriedades de metadados é definido como `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.TextBlock" />
      </Docs>
    </Member>
    <Member MemberName="TextDecorationsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextDecorationsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextDecorationsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.AccessText.TextDecorationsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextDecorationsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextDecorationsProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade de dependência <see cref="P:System.Windows.Controls.AccessText.TextDecorations" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextEffects">
      <MemberSignature Language="C#" Value="public System.Windows.Media.TextEffectCollection TextEffects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.TextEffectCollection TextEffects" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.AccessText.TextEffects" />
      <MemberSignature Language="VB.NET" Value="Public Property TextEffects As TextEffectCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::TextEffectCollection ^ TextEffects { System::Windows::Media::TextEffectCollection ^ get(); void set(System::Windows::Media::TextEffectCollection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.TextEffectCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define os efeitos adicionados ao texto de um elemento <see cref="T:System.Windows.Controls.AccessText" />.</summary>
        <value>O <see cref="T:System.Windows.Media.TextEffectCollection" />. O padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade normalmente não é definida, usando marcação ou código.  
  
 Essa propriedade expõe os efeitos de padrão para uma chave de acesso para obter possíveis estilo ou alterar através de programação.  
  
 Como os usuários esperam que os identificadores de chave de acesso para ter uma aparência de determinados no [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)], a melhor opção é alterar essa propriedade por meio de mecanismos de todo o aplicativo, como estilos de aplicativo ou de temas personalizados.  
  
<a name="xamlPropertyElementUsage_TextEffects"></a>   
## <a name="xaml-property-element-usage"></a>Uso do elemento propriedade XAML  
  
```  
<object>  
  <object.TextEffects>  
    OneOrMoreTextEffects  
  </object.TextEffects>  
</object>  
  
```  
  
<a name="xamlValues_TextEffects"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *OneOrMoreTextEffects*  
 Um ou mais <xref:System.Windows.Media.TextEffect> elementos.  
  
<a name="dependencyPropertyInfo_TextEffects"></a>   
## <a name="dependency-property-information"></a>Informações da propriedade de dependência  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.AccessText.TextEffectsProperty>|  
|Propriedades de metadados é definido como `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.TextBlock" />
      </Docs>
    </Member>
    <Member MemberName="TextEffectsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextEffectsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextEffectsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.AccessText.TextEffectsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextEffectsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextEffectsProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade de dependência <see cref="P:System.Windows.Controls.AccessText.TextEffects" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.AccessText.TextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade de dependência <see cref="P:System.Windows.Controls.AccessText.Text" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextTrimming">
      <MemberSignature Language="C#" Value="public System.Windows.TextTrimming TextTrimming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.TextTrimming TextTrimming" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.AccessText.TextTrimming" />
      <MemberSignature Language="VB.NET" Value="Public Property TextTrimming As TextTrimming" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TextTrimming TextTrimming { System::Windows::TextTrimming get(); void set(System::Windows::TextTrimming value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextTrimming</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define como o conteúdo textual de um elemento <see cref="T:System.Windows.Controls.AccessText" /> é recortado se ele estoura a caixa de linha.</summary>
        <value>O comportamento da aparagem de usar. O padrão é <see cref="F:System.Windows.TextTrimming.None" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações e para obter uma lista das opções de quebra de texto, consulte <xref:System.Windows.TextTrimming>.  
  
<a name="dependencyPropertyInfo_TextTrimming"></a>   
## <a name="dependency-property-information"></a>Informações da propriedade de dependência  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.AccessText.TextTrimmingProperty>|  
|Propriedades de metadados é definido como `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.TextBlock" />
      </Docs>
    </Member>
    <Member MemberName="TextTrimmingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextTrimmingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextTrimmingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.AccessText.TextTrimmingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextTrimmingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextTrimmingProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade de dependência <see cref="P:System.Windows.Controls.AccessText.TextTrimming" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextWrapping">
      <MemberSignature Language="C#" Value="public System.Windows.TextWrapping TextWrapping { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.TextWrapping TextWrapping" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.AccessText.TextWrapping" />
      <MemberSignature Language="VB.NET" Value="Public Property TextWrapping As TextWrapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TextWrapping TextWrapping { System::Windows::TextWrapping get(); void set(System::Windows::TextWrapping value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextWrapping</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define se o conteúdo textual de um elemento <see cref="T:System.Windows.Controls.AccessText" /> é encapsulado se ele estoura a caixa de linha.</summary>
        <value>O comportamento de quebra automática de usar. O padrão é <see cref="F:System.Windows.TextWrapping.NoWrap" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_TextWrapping"></a>   
## <a name="dependency-property-information"></a>Informações da propriedade de dependência  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.AccessText.TextWrappingProperty>|  
|Propriedades de metadados é definido como `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Windows.Controls.AccessText.TextWrapping%2A> propriedade <xref:System.Windows.Controls.AccessText> para criar um rótulo de várias linhas.  
  
 [!code-xaml[LabelSnippet#4](~/samples/snippets/csharp/VS_Snippets_Wpf/LabelSnippet/CS/Pane1.xaml#4)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.TextBlock" />
      </Docs>
    </Member>
    <Member MemberName="TextWrappingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextWrappingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextWrappingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.AccessText.TextWrappingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextWrappingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextWrappingProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade de dependência <see cref="P:System.Windows.Controls.AccessText.TextWrapping" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.AccessText.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de elementos filho que são visuais.</summary>
        <value>Retorna um inteiro que representa o número de elementos filho que são visíveis.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Controls.TextBlock" />
      </Docs>
    </Member>
  </Members>
</Type>