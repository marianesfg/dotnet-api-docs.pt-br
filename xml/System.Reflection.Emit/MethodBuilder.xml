<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="MethodBuilder.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5c93c1a358d5c177a5835b41cbeaeae252a6af730.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c93c1a358d5c177a5835b41cbeaeae252a6af730</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Defines and represents a method (or constructor) on a dynamic class.</source>
          <target state="translated">Define e representa um método (ou construtor) em uma classe dinâmica.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> class is used to fully describe a method in Microsoft intermediate language (MSIL), including the name, attributes, signature, and method body.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> classe é usada para descrever completamente um método na Microsoft intermediate language (MSIL), incluindo o corpo de nome, atributos, assinatura e método.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>It is used in conjunction with the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class to create classes at runtime.</source>
          <target state="translated">Ele é usado em conjunto com o <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> classe para criar classes em tempo de execução.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Global methods and methods as type members</source>
          <target state="translated">Os métodos globais e como membros de tipo</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>You can use reflection emit to define global methods and to define methods as type members.</source>
          <target state="translated">Você pode usar reflexão emitir para definir métodos globais e para definir métodos como membros de tipo.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The APIs that define methods return <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> objects.</source>
          <target state="translated">As APIs que definem métodos retornam <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Global methods</source>
          <target state="translated">Métodos globais</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>A global method is defined by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A?displayProperty=nameWithType&gt;</ph> method, which returns a <bpt id="p1">**</bpt>MethodBuilder<ept id="p1">**</ept> object.</source>
          <target state="translated">Um método global é definido usando o <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A?displayProperty=nameWithType&gt;</ph> método, que retorna um <bpt id="p1">**</bpt>MethodBuilder<ept id="p1">**</ept> objeto.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Global methods must be static.</source>
          <target state="translated">Métodos globais devem ser estáticos.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>If a dynamic module contains global methods, the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A?displayProperty=nameWithType&gt;</ph> method must be called before persisting the dynamic module or the containing dynamic assembly because the common language runtime postpones fixing up the dynamic module until all global functions have been defined.</source>
          <target state="translated">Se um módulo dinâmico contém métodos globais, o <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A?displayProperty=nameWithType&gt;</ph> método deve ser chamado antes de persistir o módulo dinâmico ou o assembly dinâmico contendo porque o common language runtime adia corrigir o módulo dinâmico até que todas as funções globais foram definidas.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>A global native method is defined by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Um método nativo global é definido usando o <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Platform invoke (PInvoke) methods must not be declared abstract or virtual.</source>
          <target state="translated">Invocação de plataforma (PInvoke) não devem ser declarados métodos abstract ou virtual.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The runtime sets the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.PinvokeImpl?displayProperty=nameWithType&gt;</ph> attribute for a platform invoke method.</source>
          <target state="translated">Define o tempo de execução de <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.PinvokeImpl?displayProperty=nameWithType&gt;</ph> atributo para uma plataforma de invocação de método.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Methods as members of types</source>
          <target state="translated">Métodos como membros de tipos</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>A method is defined as a type member by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> method, which returns a <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> object.</source>
          <target state="translated">Um método é definido como um membro de tipo usando o <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> método, que retorna um <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineParameter%2A&gt;</ph> method is used to set the name and parameter attributes of a parameter, or of the return value.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineParameter%2A&gt;</ph> método é usado para definir os atributos de nome e o parâmetro de um parâmetro ou do valor de retorno.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph> object returned by this method represents a parameter or the return value.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph> objeto retornado por este método representa um parâmetro ou valor de retorno.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph> object can be used to set the marshaling, to set the constant value, and to apply custom attributes.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph> objeto pode ser usado para definir o empacotamento, para definir o valor da constante e aplicar os atributos personalizados.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Attributes</source>
          <target state="translated">Atributos</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Members of the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph> enumeration define the precise character of a dynamic method:</source>
          <target state="translated">Membros de <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph> enumeração definem o caractere preciso de um método dinâmico:</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Static methods are specified using the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">Métodos estáticos são especificados usando o <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph> atributo.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Final methods (methods that cannot be overridden) are specified using the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Final?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">Métodos finais (os métodos não podem ser substituídos) são especificados usando o <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Final?displayProperty=nameWithType&gt;</ph> atributo.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Virtual methods are specified using the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Virtual?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">Métodos virtuais são especificados usando o <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Virtual?displayProperty=nameWithType&gt;</ph> atributo.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Abstract methods are specified using the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Abstract?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">Métodos abstratos são especificados usando o <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Abstract?displayProperty=nameWithType&gt;</ph> atributo.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Several attributes determine method visibility.</source>
          <target state="translated">Vários atributos determinam a visibilidade do método.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>See the description of the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph> enumeration.</source>
          <target state="translated">Consulte a descrição do <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph> enumeração.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Methods that implement overloaded operators must set the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">Métodos que implementam operadores sobrecarregados devem definir o <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType&gt;</ph> atributo.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Finalizers must set the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">Os finalizadores devem definir o <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType&gt;</ph> atributo.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Known Issues</source>
          <target state="translated">Problemas Conhecidos</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Although <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> is derived from <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, some of the abstract methods defined in the <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> class are not fully implemented in <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>.</source>
          <target state="translated">Embora <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> é derivado de <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, alguns dos métodos abstratos definidos no <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> classe não são totalmente implementado em <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>These <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> methods throw the <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Essas <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> métodos lançam a <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>For example the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.Invoke%2A?displayProperty=nameWithType&gt;</ph> method is not fully implemented.</source>
          <target state="translated">Por exemplo o <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.Invoke%2A?displayProperty=nameWithType&gt;</ph> método não é totalmente implementado.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>You can reflect on these methods by retrieving the enclosing type using the <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Você pode refletir sobre esses métodos, recuperando o tipo de delimitador usando o <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> ou <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Custom modifiers are supported starting with the .NET Framework version 2.0.</source>
          <target state="translated">Modificadores personalizadas têm suporte, iniciando com o .NET Framework versão 2.0.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>They are not supported in earlier versions.</source>
          <target state="translated">Eles não têm suporte em versões anteriores.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> class to create a method within a dynamic type.</source>
          <target state="translated">O exemplo a seguir usa a <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> classe para criar um método em um tipo dinâmico.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The security action to be taken (Demand, Assert, and so on).</source>
          <target state="translated">A ação de segurança a ser executada (Demand, Assert e assim por diante).</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The set of permissions the action applies to.</source>
          <target state="translated">O conjunto de permissões ao qual a ação se aplica.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>Adds declarative security to this method.</source>
          <target state="translated">Adiciona a segurança declarativa a este método.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A&gt;</ph> can be called several times, with each call specifying a security action (such as <ph id="ph2">`Demand`</ph>, <ph id="ph3">`Assert`</ph>, and <ph id="ph4">`Deny`</ph>) and a set of permissions that the action applies to.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A&gt;</ph> pode ser chamado várias vezes, com cada chamada especificando uma ação de segurança (como <ph id="ph2">`Demand`</ph>, <ph id="ph3">`Assert`</ph>, e <ph id="ph4">`Deny`</ph>) e um conjunto de permissões que se aplica a ação.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a method by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A&gt;</ph> method are stored in the old XML metadata format.</source>
          <target state="translated">Nas versões do .NET Framework 1.0, 1.1 e 2.0, os atributos de segurança declarativa aplicados a um método usando o <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A&gt;</ph> método são armazenados no formato de metadados XML antigo.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>See Emitting Declarative Security Attributes.</source>
          <target state="translated">Consulte a emissão de atributos de segurança declarativa.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The code sample below illustrates the contextual use of <ph id="ph1">`AddDeclarativeSecurity`</ph> to require the caller of a method to have unrestricted permissions.</source>
          <target state="translated">O exemplo de código a seguir ilustra o uso contextual de <ph id="ph1">`AddDeclarativeSecurity`</ph> para exigir que o chamador de um método de permissões irrestrito.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> is invalid (<ph id="ph2">&lt;see langword="RequestMinimum" /&gt;</ph>, <ph id="ph3">&lt;see langword="RequestOptional" /&gt;</ph>, and <ph id="ph4">&lt;see langword="RequestRefuse" /&gt;</ph> are invalid).</source>
          <target state="translated">O <ph id="ph1">&lt;paramref name="action" /&gt;</ph> é inválido (<ph id="ph2">&lt;see langword="RequestMinimum" /&gt;</ph>, <ph id="ph3">&lt;see langword="RequestOptional" /&gt;</ph> e <ph id="ph4">&lt;see langword="RequestRefuse" /&gt;</ph> são inválidos).</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The containing type has been created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">O tipo recipiente foi criado usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The permission set <ph id="ph1">&lt;paramref name="pset" /&gt;</ph> contains an action that was added earlier by <ph id="ph2">&lt;see cref="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" /&gt;</ph>.</source>
          <target state="translated">O conjunto de permissões <ph id="ph1">&lt;paramref name="pset" /&gt;</ph> contém uma ação que foi adicionada anteriormente por <ph id="ph2">&lt;see cref="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Para o método atual, a propriedade <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> é <ph id="ph2">&lt;see langword="true" /&gt;</ph>, mas a propriedade <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> é <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;paramref name="pset" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pset" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.Attributes">
          <source>Retrieves the attributes for this method.</source>
          <target state="translated">Recupera os atributos para este método.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Attributes">
          <source>Read-only.</source>
          <target state="translated">Somente leitura.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Attributes">
          <source>Retrieves the <ph id="ph1">&lt;see langword="MethodAttributes" /&gt;</ph> for this method.</source>
          <target state="translated">Recupera o <ph id="ph1">&lt;see langword="MethodAttributes" /&gt;</ph> para este método.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.CallingConvention">
          <source>Returns the calling convention of the method.</source>
          <target state="translated">Retorna a convenção de chamada do método.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.CallingConvention">
          <source>Read-only.</source>
          <target state="translated">Somente leitura.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.CallingConvention">
          <source>The calling convention of the method.</source>
          <target state="translated">A convenção de chamada do método.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
          <source>Not supported for this type.</source>
          <target state="translated">Não tem suporte para esse tipo.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
          <source>Not supported.</source>
          <target state="translated">Sem suporte.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> always represents a generic method definition, and thus cannot be invoked.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> sempre representa uma definição de método genérico e, portanto, não pode ser invocado.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para obter mais informações, consulte <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
          <source>For information on generic types, see <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para obter informações sobre tipos genéricos, consulte <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">O método chamado não é suportado na classe base.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>An array containing valid MSIL instructions.</source>
          <target state="translated">Uma matriz que contém instruções do MSIL válidas.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>If this parameter is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the method's body is cleared.</source>
          <target state="translated">Se esse parâmetro for <ph id="ph1">&lt;see langword="null" /&gt;</ph>, o corpo do método será limpo.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>The number of valid bytes in the MSIL array.</source>
          <target state="translated">O número de bytes válidos na matriz do MSIL.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>This value is ignored if MSIL is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Este valor será ignorado se MSIL for <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>Creates the body of the method using a supplied byte array of Microsoft intermediate language (MSIL) instructions.</source>
          <target state="translated">Cria o corpo do método usando uma matriz de bytes fornecida de instruções do MSIL (Microsoft Intermediate Language).</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>This method creates the method's body from <ph id="ph1">`il`</ph>, an array containing MSIL instructions as opcodes.</source>
          <target state="translated">Esse método cria o corpo do método de <ph id="ph1">`il`</ph>, uma matriz que contém instruções da MSIL como opcodes.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>The number of bytes of valid MSIL is given by count.</source>
          <target state="translated">O número de bytes de MSIL válido é fornecido por contagem.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>This is currently not fully supported.</source>
          <target state="translated">Isso não é totalmente suportado atualmente.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>The user cannot supply the location of token fix ups and exception handlers.</source>
          <target state="translated">O usuário não pode fornecer o local do token de correções e manipuladores de exceção.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>In the example provided below, a simple method that adds two integers is generated via opcode using <ph id="ph1">`CreateMethodBody`</ph>.</source>
          <target state="translated">No exemplo abaixo, um método simples que adiciona dois números inteiros é gerado por meio de opcode usando <ph id="ph1">`CreateMethodBody`</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="count" /&gt;</ph> is not within the range of indexes of the supplied MSIL instruction array and <ph id="ph2">&lt;paramref name="il" /&gt;</ph> is not <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;paramref name="count" /&gt;</ph> não está dentro do intervalo de índices da matriz de instruções do MSIL fornecida e <ph id="ph2">&lt;paramref name="il" /&gt;</ph> não é <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>The containing type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">O tipo recipiente foi criado anteriormente usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>This method was called previously on this <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph> with an <ph id="ph2">&lt;paramref name="il" /&gt;</ph> argument that was not <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Esse método foi chamado anteriormente neste <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph> com um argumento <ph id="ph2">&lt;paramref name="il" /&gt;</ph> que não era <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Para o método atual, a propriedade <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> é <ph id="ph2">&lt;see langword="true" /&gt;</ph>, mas a propriedade <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> é <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.DeclaringType">
          <source>Returns the type that declares this method.</source>
          <target state="translated">Retorna o tipo que declara a este método.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.DeclaringType">
          <source>Read-only.</source>
          <target state="translated">Somente leitura.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.DeclaringType">
          <source>The type that declares this method.</source>
          <target state="translated">O tipo que declara a este método.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.DeclaringType">
          <source>The following code illustrates the use of the <ph id="ph1">`Type`</ph> property.</source>
          <target state="translated">O código a seguir ilustra o uso do <ph id="ph1">`Type`</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>An array of strings that represent the names of the generic type parameters.</source>
          <target state="translated">Uma matriz de cadeias de caracteres que representa os nomes dos parâmetros de tipo genérico.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>Sets the number of generic type parameters for the current method, specifies their names, and returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> objects that can be used to define their constraints.</source>
          <target state="translated">Define o número de parâmetros de tipo genérico para o método atual, especifica seus nomes e retorna uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> que pode ser usada para definir suas restrições.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> objects representing the type parameters of the generic method.</source>
          <target state="translated">Uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> que representam os parâmetros de tipo do método genérico.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>Calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method makes the current method generic.</source>
          <target state="translated">Chamar o <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> método faz com que o método atual genérico.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>There is no way to undo this change.</source>
          <target state="translated">Não é possível desfazer essa alteração.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>Calling this method a second time causes an <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">Uma segunda vez ao chamar este método faz com que um <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>The type parameters of the generic method can be retrieved later by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.GetGenericArguments%2A&gt;</ph> method.</source>
          <target state="translated">Os parâmetros de tipo do método genérico podem ser recuperados posteriormente usando o <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.GetGenericArguments%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>By convention, a type parameter name is a single uppercase letter.</source>
          <target state="translated">Por convenção, um nome de parâmetro de tipo é uma única letra maiuscula.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para obter mais informações, consulte <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>For information on generic types, see <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para obter informações sobre tipos genéricos, consulte <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>The following code example creates a dynamic type, <ph id="ph1">`DemoType`</ph>, which contains the dynamic generic method <ph id="ph2">`DemoMethod`</ph>.</source>
          <target state="translated">O exemplo de código a seguir cria um tipo dinâmico, <ph id="ph1">`DemoType`</ph>, que contém o método genérico dinâmico <ph id="ph2">`DemoMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>This method has two generic type parameters, one of which is used as a parameter, and the other as the return type.</source>
          <target state="translated">Esse método tem dois parâmetros de tipo genérico, um dos quais é usado como um parâmetro e o outro como o tipo de retorno.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>When the code is executed, the dynamic assembly is saved as DemoGenericMethod1.dll, and can be examined using the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</source>
          <target state="translated">Quando o código é executado, o assembly dinâmico é salvo como DemoGenericMethod1.dll e pode ser examinado usando o <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>This code example generates a simple method body that merely returns a null reference.</source>
          <target state="translated">Este exemplo de código gera um corpo de método simples que retorna apenas uma referência nula.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>For a code example with a more fully developed method body that creates and uses generic types, see <bpt id="p1">[</bpt>How to: Define a Generic Method with Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md)</ept>.</source>
          <target state="translated">Para obter um exemplo de código com um corpo de método totalmente desenvolvida mais que cria e usa os tipos genéricos, consulte <bpt id="p1">[</bpt>como: definir um método genérico com emissão de reflexão<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>Generic type parameters have already been defined for this method.</source>
          <target state="translated">Parâmetros de tipo genérico já foram definidos para este método.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>The method has been completed already.</source>
          <target state="translated">O método já foi concluído.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>The <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" /&gt;</ph> method has been called for the current method.</source>
          <target state="translated">O método <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" /&gt;</ph> foi chamado para o método atual.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source><ph id="ph1">&lt;paramref name="names" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="names" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>An element of <ph id="ph1">&lt;paramref name="names" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Um elemento de <ph id="ph1">&lt;paramref name="names" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source><ph id="ph1">&lt;paramref name="names" /&gt;</ph> is an empty array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="names" /&gt;</ph> é uma matriz vazia.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The position of the parameter in the parameter list.</source>
          <target state="translated">A posição do parâmetro na lista de parâmetros.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Parameters are indexed beginning with the number 1 for the first parameter; the number 0 represents the return value of the method.</source>
          <target state="translated">Parâmetros são indexados começando com o número 1 para o primeiro parâmetro; o número 0 representa o valor retornado do método.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The parameter attributes of the parameter.</source>
          <target state="translated">Os atributos de parâmetro do parâmetro.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The name of the parameter.</source>
          <target state="translated">O nome do parâmetro.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The name can be the null string.</source>
          <target state="translated">O nome pode ser a cadeia de caracteres nula.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Sets the parameter attributes and the name of a parameter of this method, or of the return value of this method.</source>
          <target state="translated">Define os atributos de parâmetro e o nome de um parâmetro deste método, ou do valor retornado deste método.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Returns a ParameterBuilder that can be used to apply custom attributes.</source>
          <target state="translated">Retorna um ParameterBuilder que pode ser usado para aplicar os atributos personalizados.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Returns a <ph id="ph1">&lt;see langword="ParameterBuilder" /&gt;</ph> object that represents a parameter of this method or the return value of this method.</source>
          <target state="translated">Retorna um objeto <ph id="ph1">&lt;see langword="ParameterBuilder" /&gt;</ph> que representa um parâmetro deste método ou o valor retornado deste método.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph> object returned by this method can be used to set the default value for a parameter or to apply custom attributes.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph> objeto retornado por esse método pode ser usado para definir o valor padrão para um parâmetro ou aplicar atributos personalizados.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Parameter numbering begins with 1, so <ph id="ph1">`position`</ph> is 1 for the first parameter.</source>
          <target state="translated">Parâmetro numeração começa com 1, portanto <ph id="ph1">`position`</ph> é 1 para o primeiro parâmetro.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>If <ph id="ph1">`position`</ph> is zero, this method affects the return value.</source>
          <target state="translated">Se <ph id="ph1">`position`</ph> for zero, este método afeta o valor de retorno.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>In the .NET Framework versions 1.0 and 1.1, an exception is thrown if <ph id="ph1">`position`</ph> is zero, so this method cannot be used to modify attributes of the return value in those versions.</source>
          <target state="translated">Nas versões do .NET Framework 1.0 e 1.1, uma exceção será lançada se <ph id="ph1">`position`</ph> é zero, portanto, esse método não pode ser usado para modificar os atributos do valor de retorno nessas versões.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The method has no parameters.</source>
          <target state="translated">O método não tem parâmetros.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source><ph id="ph1">&lt;paramref name="position" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="position" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source><ph id="ph1">&lt;paramref name="position" /&gt;</ph> is greater than the number of the method's parameters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="position" /&gt;</ph> é maior que o número de parâmetros do método.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The containing type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">O tipo recipiente foi criado anteriormente usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Para o método atual, a propriedade <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> é <ph id="ph2">&lt;see langword="true" /&gt;</ph>, mas a propriedade <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> é <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)">
          <source>The object to compare with this <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph> instance.</source>
          <target state="translated">O objeto a ser comparado com essa instância <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)">
          <source>Determines whether the given object is equal to this instance.</source>
          <target state="translated">Determina se o objeto especificado é igual a esta instância.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> is an instance of <ph id="ph3">&lt;see langword="MethodBuilder" /&gt;</ph> and is equal to this object; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> for uma instância de <ph id="ph3">&lt;see langword="MethodBuilder" /&gt;</ph> e for igual a este objeto; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)">
          <source>Equality is determined by having the same name, attributes, and signature.</source>
          <target state="translated">Igualdade é determinada por ter o mesmo nome, atributos e assinatura.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition">
          <source>Return the base implementation for a method.</source>
          <target state="translated">Retorna a implementação de base para um método.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition">
          <source>The base implementation of this method.</source>
          <target state="translated">A implementação de base deste método.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition">
          <source>This always returns the current <ph id="ph1">`MethodBuilder`</ph> object.</source>
          <target state="translated">Isso sempre retorna atual <ph id="ph1">`MethodBuilder`</ph> objeto.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Returns the custom attributes defined for this method.</source>
          <target state="translated">Retorna os atributos personalizados definidos para esse método.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
          <source>Specifies whether to search this member's inheritance chain to find the custom attributes.</source>
          <target state="translated">Especifica se deve-se pesquisar na cadeia de herança deste membro para localizar os atributos personalizados.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
          <source>Returns all the custom attributes defined for this method.</source>
          <target state="translated">Retorna todos os atributos personalizados definidos para esse método.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
          <source>Returns an array of objects representing all the custom attributes of this method.</source>
          <target state="translated">Retorna uma matriz de objetos que representam todos os atributos personalizados desse método.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
          <source>This method is not currently supported.</source>
          <target state="translated">Não há suporte para este método atualmente.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
          <source>Retrieve the method using <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</source>
          <target state="translated">Recupere o método usando <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> e chame <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> no <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> retornado.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The custom attribute type.</source>
          <target state="translated">O tipo de atributo personalizado.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Specifies whether to search this member's inheritance chain to find the custom attributes.</source>
          <target state="translated">Especifica se deve-se pesquisar na cadeia de herança deste membro para localizar os atributos personalizados.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Returns the custom attributes identified by the given type.</source>
          <target state="translated">Retorna os atributos personalizados identificados pelo tipo determinado.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Returns an array of objects representing the attributes of this method that are of type <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph>.</source>
          <target state="translated">Retorna uma matriz de objetos que representam os atributos desse método que são do tipo <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This method is not currently supported.</source>
          <target state="translated">Não há suporte para este método atualmente.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Retrieve the method using <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</source>
          <target state="translated">Recupere o método usando <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> e chame <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> no <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> retornado.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> objects that represent the type parameters of the method, if it is generic.</source>
          <target state="translated">Retorna uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> que representam os parâmetros de tipo do método, se for genérico.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> objects representing the type parameters, if the method is generic, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method is not generic.</source>
          <target state="translated">Uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> que representam os parâmetros de tipo, se o método for genérico ou <ph id="ph2">&lt;see langword="null" /&gt;</ph>, se o método não for genérico.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
          <source>The type parameters of a generic method also are returned by the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method that is used to define them.</source>
          <target state="translated">Os parâmetros de tipo de um método genérico também são retornados pelo <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> método que é usado para defini-los.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para obter mais informações, consulte <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
          <source>For information on generic types, see <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para obter informações sobre tipos genéricos, consulte <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>Returns this method.</source>
          <target state="translated">Retorna este método.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>The current instance of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>.</source>
          <target state="translated">A instância atual do <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> cannot be used to emit a constructed generic method directly.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> não pode ser usado para emitir um método genérico construído diretamente.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>The emitted method is a generic method definition.</source>
          <target state="translated">O método emitido é uma definição de método genérico.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para obter mais informações, consulte <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>For information on generic types, see <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para obter informações sobre tipos genéricos, consulte <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>The current method is not generic.</source>
          <target state="translated">O método atual não é genérico.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Ou seja, a propriedade <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> do método retorna <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetHashCode">
          <source>Gets the hash code for this method.</source>
          <target state="translated">Obtém o código hash para este método.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetHashCode">
          <source>The hash code for this method.</source>
          <target state="translated">O código hash para este método.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Returns an <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> for this method.</source>
          <target state="translated">Retorna um <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> para este método.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>Returns an <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> for this method with a default Microsoft intermediate language (MSIL) stream size of 64 bytes.</source>
          <target state="translated">Retorna um <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> para esse método com um tamanho de fluxo MSIL (linguagem intermediária da Microsoft) padrão de 64 bytes.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>Returns an <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> object for this method.</source>
          <target state="translated">Retorna um objeto <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> para este método.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>The code sample below demonstrates the contextual usage of the <ph id="ph1">`GetILGenerator`</ph> method, creating and emitting a dynamic assembly that will calculate the dot product of two points in 3D space.</source>
          <target state="translated">O exemplo de código a seguir demonstra o uso contextual do <ph id="ph1">`GetILGenerator`</ph> método, criar e emitir um assembly dinâmico que calcula o produto dos dois pontos no espaço 3D.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>The method should not have a body because of its <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> flags, for example because it has the <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /&gt;</ph> flag.</source>
          <target state="translated">O método não deve ter um corpo devido aos seus sinalizadores <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> ou <ph id="ph2">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph>, por exemplo, porque ele tem o sinalizador <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>The method is a generic method, but not a generic method definition.</source>
          <target state="translated">O método é genérico, mas não é uma definição de método genérico.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Ou seja, a propriedade <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> é <ph id="ph2">&lt;see langword="true" /&gt;</ph>, mas a propriedade <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> é <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>The size of the MSIL stream, in bytes.</source>
          <target state="translated">O tamanho do fluxo MSIL, em bytes.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>Returns an <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> for this method with the specified Microsoft intermediate language (MSIL) stream size.</source>
          <target state="translated">Retorna um <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> pra esse método com o tamanho de fluxo MSIL (linguagem intermediária da Microsoft) especificado.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>Returns an <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> object for this method.</source>
          <target state="translated">Retorna um objeto <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> para este método.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>The code sample below demonstrates the contextual usage of the <ph id="ph1">`GetILGenerator`</ph> method, creating and emitting a dynamic assembly that will calculate the dot product of two points in 3D space.</source>
          <target state="translated">O exemplo de código a seguir demonstra o uso contextual do <ph id="ph1">`GetILGenerator`</ph> método, criar e emitir um assembly dinâmico que calcula o produto dos dois pontos no espaço 3D.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>The method should not have a body because of its <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> flags, for example because it has the <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /&gt;</ph> flag.</source>
          <target state="translated">O método não deve ter um corpo devido aos seus sinalizadores <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> ou <ph id="ph2">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph>, por exemplo, porque ele tem o sinalizador <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>The method is a generic method, but not a generic method definition.</source>
          <target state="translated">O método é genérico, mas não é uma definição de método genérico.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Ou seja, a propriedade <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> é <ph id="ph2">&lt;see langword="true" /&gt;</ph>, mas a propriedade <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> é <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags">
          <source>Returns the implementation flags for the method.</source>
          <target state="translated">Retorna os sinalizadores de implementação para o método.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags">
          <source>Returns the implementation flags for the method.</source>
          <target state="translated">Retorna os sinalizadores de implementação para o método.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetModule">
          <source>Returns a reference to the module that contains this method.</source>
          <target state="translated">Retorna uma referência para o módulo que contém este método.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetModule">
          <source>Returns a reference to the module that contains this method.</source>
          <target state="translated">Retorna uma referência para o módulo que contém este método.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetModule">
          <source>The sample code below illustrates the usage of the <ph id="ph1">`GetModule`</ph> method to retrieve information about a dynamically-generated module.</source>
          <target state="translated">O código de exemplo a seguir ilustra o uso de <ph id="ph1">`GetModule`</ph> método para recuperar informações sobre um módulo gerado dinamicamente.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetParameters">
          <source>Returns the parameters of this method.</source>
          <target state="translated">Retorna os parâmetros deste método.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetParameters">
          <source>An array of <ph id="ph1">&lt;see langword="ParameterInfo" /&gt;</ph> objects that represent the parameters of the method.</source>
          <target state="translated">Uma matriz de objetos <ph id="ph1">&lt;see langword="ParameterInfo" /&gt;</ph> que representam os parâmetros do método.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetParameters">
          <source>The code sample below illustrates the use of <ph id="ph1">`GetParameters`</ph> to discover information on the parameters passed to a dynamically-generated method.</source>
          <target state="translated">O exemplo de código a seguir ilustra o uso de <ph id="ph1">`GetParameters`</ph> para descobrir informações sobre os parâmetros passados para um método gerado dinamicamente.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetParameters">
          <source>This method is not currently supported.</source>
          <target state="translated">Não há suporte para este método atualmente.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetParameters">
          <source>Retrieve the method using <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> and call <ph id="ph2">&lt;see langword="GetParameters" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</source>
          <target state="translated">Recupere o método usando <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> e chame <ph id="ph2">&lt;see langword="GetParameters" /&gt;</ph> no <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> retornado.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetToken">
          <source>Returns the <ph id="ph1">&lt;see langword="MethodToken" /&gt;</ph> that represents the token for this method.</source>
          <target state="translated">Retorna o <ph id="ph1">&lt;see langword="MethodToken" /&gt;</ph> que representa o token para este método.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetToken">
          <source>Returns the <ph id="ph1">&lt;see langword="MethodToken" /&gt;</ph> of this method.</source>
          <target state="translated">Retorna o <ph id="ph1">&lt;see langword="MethodToken" /&gt;</ph> deste método.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source>Gets or sets a Boolean value that specifies whether the local variables in this method are zero initialized.</source>
          <target state="translated">Obtém ou define um valor booliano que especifica se as variáveis locais nesse método são inicializadas em zero.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source>The default value of this property is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">O valor padrão dessa propriedade é <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the local variables in this method should be zero initialized; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se as variáveis locais em que esse método devem ser zero inicializado; Caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source>If this property is set to <ph id="ph1">`true`</ph>, the emitted MSIL includes initialization of local variables.</source>
          <target state="translated">Se essa propriedade é definida como <ph id="ph1">`true`</ph>, emitido MSIL inclui a inicialização de variáveis locais.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source>If it is set to <ph id="ph1">`false`</ph>, local variables are not initialized and the generated code is unverifiable.</source>
          <target state="translated">Se for definido como <ph id="ph1">`false`</ph>, variáveis locais não foram inicializadas e o código gerado não é verificável.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Para o método atual, a propriedade <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> é <ph id="ph2">&lt;see langword="true" /&gt;</ph>, mas a propriedade <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> é <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source>(Get or set.)</source>
          <target state="translated">(Get ou set.)</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The object on which to invoke the specified method.</source>
          <target state="translated">O objeto no qual invocar o método especificado.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the method is static, this parameter is ignored.</source>
          <target state="translated">Se o método for estático, esse parâmetro será ignorado.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> : <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">Isso deve ser um sinalizador de bit de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> e assim por diante.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of MemberInfo objects via reflection.</source>
          <target state="translated">Um objeto que permite a associação, a coerção de tipos de argumentos, a invocação de membros e a recuperação de objetos MemberInfo por meio de reflexão.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If binder is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">Se o associador for <ph id="ph1">&lt;see langword="null" /&gt;</ph>, o associador padrão será usado.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For more details, see <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</source>
          <target state="translated">Para obter mais detalhes, consulte <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An argument list.</source>
          <target state="translated">Uma lista de argumentos.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This is an array of arguments with the same number, order, and type as the parameters of the method to be invoked.</source>
          <target state="translated">Essa é uma matriz de argumentos com o mesmo número, ordem e tipo que os parâmetros do método a ser invocado.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If there are no parameters this should be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Se não houver nenhum parâmetro, isso deverá ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An instance of <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> used to govern the coercion of types.</source>
          <target state="translated">Uma instância de <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> usada para determinar a coerção de tipos.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If this is null, the <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Se isso for nulo, será usado o <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> do thread atual.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>(Note that this is necessary to, for example, convert a <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that represents 1000 to a <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph> value, since 1000 is represented differently by different cultures.)</source>
          <target state="translated">(Observe que isso é necessário para, por exemplo, converter um <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> que represente 1000 para um valor <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph>, desde que 1000 seja representado de maneira diferente por diferentes culturas.)</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Dynamically invokes the method reflected by this instance on the given object, passing along the specified parameters, and under the constraints of the given binder.</source>
          <target state="translated">Invoca dinamicamente o método refletido por esta instância no objeto fornecido, passando os parâmetros especificados e sob as restrições do associador determinado.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Returns an object containing the return value of the invoked method.</source>
          <target state="translated">Retorna um objeto que contém o valor retornado do método invocado.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the method is static, the <ph id="ph1">`obj`</ph> parameter is ignored.</source>
          <target state="translated">Se o método é estático, o <ph id="ph1">`obj`</ph> parâmetro é ignorado.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For non-static methods, <ph id="ph1">`obj`</ph> should be an instance of a class that inherits or declares the method and must be the same type as this class.</source>
          <target state="translated">Para métodos de não-estático, <ph id="ph1">`obj`</ph> deve ser uma instância de uma classe que herda ou declara o método e deve ser o mesmo tipo que essa classe.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the method has no parameters, the value of <ph id="ph1">`parameters`</ph> should be <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Se o método não tem parâmetros, o valor de <ph id="ph1">`parameters`</ph> devem ser <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Otherwise the number, type, and order of elements in the parameters array should be identical to the number, type, and order of parameters for the method reflected by this instance.</source>
          <target state="translated">Caso contrário, o número, tipo e ordem de elementos na matriz de parâmetros devem ser idênticos de número, tipo e ordem de parâmetros para o método refletido por esta instância.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Access restrictions are ignored for fully-trusted code.</source>
          <target state="translated">Restrições de acesso são ignoradas por código totalmente confiável.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>That is, private constructors, methods, fields, and properties can be accessed and invoked using Reflection whenever the code is fully-trusted.</source>
          <target state="translated">Ou seja, propriedades, métodos, campos e construtores privados podem ser acessadas e invocados usando reflexão sempre que o código é totalmente confiável.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This method is not currently supported.</source>
          <target state="translated">Não há suporte para este método atualmente.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Retrieve the method using <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</source>
          <target state="translated">Recupere o método usando <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> e chame <ph id="ph2">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph> no <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> retornado.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
          <source>The custom attribute type.</source>
          <target state="translated">O tipo de atributo personalizado.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Specifies whether to search this member's inheritance chain to find the custom attributes.</source>
          <target state="translated">Especifica se deve-se pesquisar na cadeia de herança deste membro para localizar os atributos personalizados.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Checks if the specified custom attribute type is defined.</source>
          <target state="translated">Verifica se o tipo de atributo personalizado especificado é definido.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified custom attribute type is defined; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o tipo de atributo personalizado especificado estiver definido, caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
          <source>This method is not currently supported.</source>
          <target state="translated">Não há suporte para este método atualmente.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Retrieve the method using <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</source>
          <target state="translated">Recupere o método usando <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> e chame <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph> no <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> retornado.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source>Gets a value indicating whether the method is a generic method.</source>
          <target state="translated">Obtém um valor que indica se o método é um método genérico.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the method is generic; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se o método é genérico; Caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source>A method is generic if it has type parameters.</source>
          <target state="translated">Um método é genérico se ele tem parâmetros de tipo.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source>You can make a method generic by calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method to add type parameters.</source>
          <target state="translated">Você pode fazer um método genérico ao chamar o <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> método para adicionar parâmetros de tipo.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source>This change cannot be reversed.</source>
          <target state="translated">Essa alteração não pode ser revertida.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source>The following code example displays the status of a method.</source>
          <target state="translated">O exemplo de código a seguir exibe o status de um método.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">Esse código é parte de um exemplo maior fornecido para o <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> object represents the definition of a generic method.</source>
          <target state="translated">Obtém um valor que indica se o objeto <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> atual representa a definição de um método genérico.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> object represents the definition of a generic method; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se o atual <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> objeto representa a definição de um método genérico; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> can only be used to create generic method definitions; it cannot be used to create a constructed generic method directly.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> só pode ser usado para criar definições de método genérico; ele não pode ser usado para criar um método genérico construído diretamente.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
          <source>However, a subclass of <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> might represent a constructed generic method.</source>
          <target state="translated">No entanto, uma subclasse de <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> pode representar um método genérico construído.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
          <source>The following code example displays the status of a method.</source>
          <target state="translated">O exemplo de código a seguir exibe o status de um método.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">Esse código é parte de um exemplo maior fornecido para o <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
          <source>Throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in all cases.</source>
          <target state="translated">Gera um <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> em todos os casos.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
          <source>Throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in all cases.</source>
          <target state="translated">Gera um <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> em todos os casos.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
          <source>To determine whether a method in a dynamic assembly is security-critical, complete the type by calling <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method on the completed type, and get the <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph> property on the resulting <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">Para determinar se um método em um assembly dinâmico é crítico de segurança, concluir o tipo chamando <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph>, chame o <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> método no tipo concluído e obter o <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph> propriedade resultante <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
          <source>In all cases.</source>
          <target state="translated">Em todos os casos.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
          <source>This property is not supported in dynamic assemblies.</source>
          <target state="translated">Não há suporte para essa propriedade em assemblies dinâmicos.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
          <source>Throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in all cases.</source>
          <target state="translated">Gera um <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> em todos os casos.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
          <source>Throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in all cases.</source>
          <target state="translated">Gera um <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> em todos os casos.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
          <source>To determine whether a method in a dynamic assembly is security-safe-critical, complete the type by calling <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method on the completed type, and get the <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph> property on the resulting <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">Para determinar se um método em um assembly dinâmico é safe-crítico de segurança, concluir o tipo chamando <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph>, chame o <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> método no tipo concluído e obter o <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph> propriedade resultante <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
          <source>In all cases.</source>
          <target state="translated">Em todos os casos.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
          <source>This property is not supported in dynamic assemblies.</source>
          <target state="translated">Não há suporte para essa propriedade em assemblies dinâmicos.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
          <source>Throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in all cases.</source>
          <target state="translated">Gera um <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> em todos os casos.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
          <source>Throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in all cases.</source>
          <target state="translated">Gera um <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> em todos os casos.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
          <source>To determine whether a method in a dynamic assembly is security-transparent, complete the type by calling <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method on the completed type, and get the <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> property on the resulting <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">Para determinar se um método em um assembly dinâmico é transparente de segurança, concluir o tipo chamando <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph>, chame o <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> método no tipo concluído e obter o <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> propriedade resultante <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
          <source>In all cases.</source>
          <target state="translated">Em todos os casos.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
          <source>This property is not supported in dynamic assemblies.</source>
          <target state="translated">Não há suporte para essa propriedade em assemblies dinâmicos.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments for the generic method.</source>
          <target state="translated">Uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representam os argumentos de tipo para o método genérico.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>Returns a generic method constructed from the current generic method definition using the specified generic type arguments.</source>
          <target state="translated">Retorna um método genérico construído da definição de método genérico atual usando os argumentos de tipo genérico especificados.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> representing the generic method constructed from the current generic method definition using the specified generic type arguments.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> que representa o método genérico construído com base na definição de método genérico atual usando os argumentos de tipo genérico especificados.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>When you are emitting dynamic code, you might need to emit a call to a method constructed from the generic method definition represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, before the enclosing type has been completed.</source>
          <target state="translated">Quando você estiver emitindo código dinâmico, talvez seja necessário emitir uma chamada para um método construído da definição de método genérico representada por um <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, antes do tipo de delimitador foi concluído.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>You can use the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> method to create a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> for such a constructed method, and use the <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> in the emitted call.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> método para criar um <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> para tal um método construído e use o <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> na chamada emitida.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>The following code example creates a constructed method from an incomplete generic method definition in an incomplete type.</source>
          <target state="translated">O exemplo de código a seguir cria um método construído de uma definição de método genérico incompleta em um tipo incompleto.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>The example creates a transient assembly and module with a single type, adds a method <ph id="ph1">`M`</ph>, and makes the method generic by adding a type parameter T using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">O exemplo cria um assembly temporário e o módulo com um único tipo, adiciona um método <ph id="ph1">`M`</ph>e faz com que o método genérico com a adição de um tipo de parâmetro T usando o <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>The type parameter is used as the type of the method's parameter, and also as its return type.</source>
          <target state="translated">O parâmetro de tipo é usado como o tipo de parâmetro do método e também como seu tipo de retorno.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>The generic method definition is not given a body, and the enclosing type is not completed.</source>
          <target state="translated">A definição de método genérico não for fornecida um corpo e o tipo de delimitador não foi concluído.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> method is then used to make the constructed method <ph id="ph2">`M&lt;String&gt;`</ph> (<ph id="ph3">`M(Of String)`</ph> in Visual Basic).</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> método é usado para que o método construído <ph id="ph2">`M&lt;String&gt;`</ph> (<ph id="ph3">`M(Of String)`</ph> no Visual Basic).</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>The example code has no output, because the subclass of <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> method does not allow reflection over its parameters.</source>
          <target state="translated">O código de exemplo não tem saída, porque a subclasse de <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> retornado pelo <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> método não permite a reflexão sobre seus parâmetros.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>For another code example that uses <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph>, see <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph>.</source>
          <target state="translated">Outro exemplo de código que usa <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph>, consulte <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> is also used extensively when emitting code that uses generic types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> também é usado extensivamente ao emitir o código que usa tipos genéricos.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>See <bpt id="p1">[</bpt>How to: Define a Generic Method with Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md)</ept>.</source>
          <target state="translated">Consulte <bpt id="p1">[</bpt>como: definir um método genérico com reflexão emitir<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>Retrieves the internal handle for the method.</source>
          <target state="translated">Recupera o identificador interno para o método.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>Use this handle to access the underlying metadata handle.</source>
          <target state="translated">Use esse identificador para acessar o identificador de metadados subjacente.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>Read-only.</source>
          <target state="translated">Somente leitura.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>The internal handle for the method.</source>
          <target state="translated">O identificador interno para o método.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>Use this handle to access the underlying metadata handle.</source>
          <target state="translated">Use esse identificador para acessar o identificador de metadados subjacente.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>This method is not currently supported.</source>
          <target state="translated">Não há suporte para este método atualmente.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>Retrieve the method using <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> and call <ph id="ph2">&lt;see cref="P:System.Reflection.MethodBase.MethodHandle" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</source>
          <target state="translated">Recupere o método usando <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> e chame <ph id="ph2">&lt;see cref="P:System.Reflection.MethodBase.MethodHandle" /&gt;</ph> no <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> retornado.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.Module">
          <source>Gets the module in which the current method is being defined.</source>
          <target state="translated">Obtém o módulo no qual o método atual está sendo definido.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Module">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> in which the member represented by the current <ph id="ph2">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> is being defined.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> no qual o membro representado pelo atual <ph id="ph2">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> está sendo definido.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Module">
          <source>This property is provided as a convenience.</source>
          <target state="translated">Esta propriedade é fornecida como uma conveniência.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Module">
          <source>It is equivalent to using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DeclaringType%2A&gt;</ph> property to get the type in which the method is being declared, and then calling the <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> property of the resulting <ph id="ph3">&lt;xref:System.Type&gt;</ph> object.</source>
          <target state="translated">É equivalente a usar o <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DeclaringType%2A&gt;</ph> propriedade para obter o tipo no qual o método for declarado e, em seguida, chamar o <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> propriedade resultante <ph id="ph3">&lt;xref:System.Type&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Module">
          <source>This property is also equivalent to calling <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.GetModule%2A&gt;</ph>.</source>
          <target state="translated">Esta propriedade também é equivalente a chamar <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.GetModule%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.Name">
          <source>Retrieves the name of this method.</source>
          <target state="translated">Recupera o nome desse método.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Name">
          <source>Read-only.</source>
          <target state="translated">Somente leitura.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Name">
          <source>Retrieves a string containing the simple name of this method.</source>
          <target state="translated">Recupera uma cadeia de caracteres que contém o nome simple desse método.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ReflectedType">
          <source>Retrieves the class that was used in reflection to obtain this object.</source>
          <target state="translated">Recupera a classe que foi usada em reflexão para obter esse objeto.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReflectedType">
          <source>Read-only.</source>
          <target state="translated">Somente leitura.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReflectedType">
          <source>The type used to obtain this method.</source>
          <target state="translated">O tipo usado para obter esse método.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ReturnParameter">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> object that contains information about the return type of the method, such as whether the return type has custom modifiers.</source>
          <target state="translated">Obtém um objeto <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> que contém informações sobre o tipo de retorno do método, como se o tipo de retorno tem modificadores personalizados.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnParameter">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> object that contains information about the return type.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> que contém informações sobre o tipo de retorno.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnParameter">
          <source>Compiler designers can use the <ph id="ph1">&lt;xref:System.Reflection.ParameterInfo&gt;</ph> object returned by this property to discover whether custom modifiers, such as <ph id="ph2">&lt;xref:Microsoft.VisualC.IsConstModifier&gt;</ph>, have been applied to the return type.</source>
          <target state="translated">Designers de compilador podem usar o <ph id="ph1">&lt;xref:System.Reflection.ParameterInfo&gt;</ph> objeto retornado por essa propriedade para descobrir se personalizado modificadores, como <ph id="ph2">&lt;xref:Microsoft.VisualC.IsConstModifier&gt;</ph>, foram aplicadas ao tipo de retorno.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ReturnParameter">
          <source>The declaring type has not been created.</source>
          <target state="translated">O tipo de declaração não foi criado.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ReturnType">
          <source>Gets the return type of the method represented by this <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>.</source>
          <target state="translated">Obtém o tipo de retorno do método representado por esse <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnType">
          <source>The return type of the method.</source>
          <target state="translated">O tipo de retorno do método.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnType">
          <source>Starting with the .NET Framework 2.0 and the .NET Compact Framework 2.0, this member is inherited from the base class, <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">Começando com o .NET Framework 2.0 e o .NET Compact Framework 2.0, este membro é herdado da classe base, <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnType">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.ReturnType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Consulte <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.ReturnType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
          <source>Returns the custom attributes of the method's return type.</source>
          <target state="translated">Retorna os atributos personalizados do tipo de retorno do método.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
          <source>Read-only.</source>
          <target state="translated">Somente leitura.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
          <source>The custom attributes of the method's return type.</source>
          <target state="translated">Os atributos personalizados do tipo de retorno do método.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
          <source>This method always returns <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Esse método sempre retorna <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
          <source>Get the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> after the containing <ph id="ph2">&lt;xref:System.Type&gt;</ph> has been created and invoked <ph id="ph3">&lt;xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A&gt;</ph> on the <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">Obter o <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> depois que o contém <ph id="ph2">&lt;xref:System.Type&gt;</ph> foi criado e chamado <ph id="ph3">&lt;xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A&gt;</ph> no <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Sets a custom attribute.</source>
          <target state="translated">Define um atributo personalizado.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>An instance of a helper class to describe the custom attribute.</source>
          <target state="translated">Uma instância de uma classe auxiliar para descrever o atributo personalizado.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>Sets a custom attribute using a custom attribute builder.</source>
          <target state="translated">Define um atributo personalizado usando um construtor de atributos personalizados.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> method can interact with the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method when the two methods are used in combination.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> método pode interagir com o <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> método quando os dois métodos são usados em combinação.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>See the Remarks section of the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method for details.</source>
          <target state="translated">Consulte a seção comentários a <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> método para obter detalhes.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source><ph id="ph1">&lt;paramref name="customBuilder" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="customBuilder" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Para o método atual, a propriedade <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> é <ph id="ph2">&lt;see langword="true" /&gt;</ph>, mas a propriedade <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> é <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The constructor for the custom attribute.</source>
          <target state="translated">O construtor do atributo personalizado.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>A byte blob representing the attributes.</source>
          <target state="translated">Um blob de bytes que representa os atributos.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>Sets a custom attribute using a specified custom attribute blob.</source>
          <target state="translated">Define um atributo personalizado usando um blob de atributo personalizado especificado.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>For details on how to format <ph id="ph1">`binaryAttribute`</ph>, see the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Para obter detalhes sobre como formatar <ph id="ph1">`binaryAttribute`</ph>, consulte a documentação de infra-estrutura de linguagem comum (CLI), especialmente "partição II: metadados definição e semântica".</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">A documentação está disponível online; confira <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept>, no MSDN, e <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept>, no site internacional da Ecma.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> method can interact with the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method when the two methods are used in combination.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> método pode interagir com o <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> método quando os dois métodos são usados em combinação.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>See the Remarks section of the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method for details.</source>
          <target state="translated">Consulte a seção comentários a <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> método para obter detalhes.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="con" /&gt;</ph> or <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="con" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph> é <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Para o método atual, a propriedade <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> é <ph id="ph2">&lt;see langword="true" /&gt;</ph>, mas a propriedade <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> é <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>The implementation flags to set.</source>
          <target state="translated">Os sinalizadores de implementação a definir.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>Sets the implementation flags for this method.</source>
          <target state="translated">Define os sinalizadores de implementação para este método.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>When you use the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method in combination with the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> method, be aware of potential interactions.</source>
          <target state="translated">Quando você usa o <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> método em combinação com o <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> método, lembre-se de interações potenciais.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>For example, using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> method to add the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph> attribute also sets the <ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Por exemplo, usando o <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> método para adicionar o <ph id="ph2">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph> atributo também define o <ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>If you subsequently call the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method, the <ph id="ph2">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig&gt;</ph> flag is overwritten.</source>
          <target state="translated">Se você chamar subsequentemente o <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> método, o <ph id="ph2">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig&gt;</ph> sinalizador será substituído.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>There are two ways to avoid this:</source>
          <target state="translated">Há duas maneiras de evitar isso:</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>Call the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method before you call the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> method.</source>
          <target state="translated">Chamar o <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> método antes de chamar o <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> method always respects existing method implementation flags.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> método sempre respeita sinalizadores de implementação de método existente.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>When you set implementation flags, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A&gt;</ph> method to retrieve the existing flags, use bitwise OR to add your flag, and then call the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method.</source>
          <target state="translated">Quando você definir sinalizadores de implementação, chame o <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A&gt;</ph> método para recuperar os sinalizadores existentes, use o bit a bit ou para adicionar o sinalizador e, em seguida, chamar o <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>The code sample below illustrates the contextual use of the <ph id="ph1">`SetImplementationFlags`</ph> method to describe the implementation of MSIL in a method body.</source>
          <target state="translated">O exemplo de código a seguir ilustra o uso contextual do <ph id="ph1">`SetImplementationFlags`</ph> método para descrever a implementação do MSIL em um corpo de método.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>The containing type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">O tipo recipiente foi criado anteriormente usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Para o método atual, a propriedade <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> é <ph id="ph2">&lt;see langword="true" /&gt;</ph>, mas a propriedade <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> é <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)">
          <source>Marshaling information for the return type of this method.</source>
          <target state="translated">Informações de marshaling para o tipo retornado deste método.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)">
          <source>Sets marshaling information for the return type of this method.</source>
          <target state="translated">Define informações de marshaling para o tipo retornado desse método.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)">
          <source>The code sample below illustrates the contextual usage of the <ph id="ph1">`SetMarshal`</ph> method to marshal the results of a method call as a different type.</source>
          <target state="translated">O exemplo de código a seguir ilustra o uso contextual o <ph id="ph1">`SetMarshal`</ph> método para empacotar os resultados de uma chamada de método como um tipo diferente.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)">
          <source>The containing type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">O tipo recipiente foi criado anteriormente usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Para o método atual, a propriedade <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> é <ph id="ph2">&lt;see langword="true" /&gt;</ph>, mas a propriedade <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> é <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>An array that contains valid MSIL instructions.</source>
          <target state="translated">Uma matriz que contém instruções MSIL válidas.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>The maximum stack evaluation depth.</source>
          <target state="translated">A profundidade máxima de avaliação da pilha.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>An array of bytes that contain the serialized local variable structure.</source>
          <target state="translated">Uma matriz de bytes que contêm a estrutura de variável local serializada.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>Specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the method has no local variables.</source>
          <target state="translated">Especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph> se o método não tiver variáveis locais.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>A collection that contains the exception handlers for the method.</source>
          <target state="translated">Uma coleção que contém os manipuladores de exceção para o método.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>Specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the method has no exception handlers.</source>
          <target state="translated">Especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph> se o método não tiver manipuladores de exceção.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>A collection of values that represent offsets in <bpt id="p1">&lt;c&gt;</bpt>il<ept id="p1">&lt;/c&gt;</ept>, each of which specifies the beginning of a token that may be modified.</source>
          <target state="translated">Uma coleção de valores que representam deslocamentos em <bpt id="p1">&lt;c&gt;</bpt>il<ept id="p1">&lt;/c&gt;</ept>, cada uma deles especifica o início de um token que pode ser modificado.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>Specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the method has no tokens that have to be modified.</source>
          <target state="translated">Especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph> se o método não tiver nenhum token que precise ser modificado.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>Creates the body of the method by using a specified byte array of Microsoft intermediate language (MSIL) instructions.</source>
          <target state="translated">Cria o corpo do método usando uma matriz de bytes especificada de instruções MSIL (linguagem intermediária da Microsoft).</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source><ph id="ph1">&lt;paramref name="il" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="il" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source><ph id="ph1">&lt;paramref name="maxStack" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maxStack" /&gt;</ph> é negativo.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>One of <ph id="ph1">&lt;paramref name="exceptionHandlers" /&gt;</ph> specifies an offset outside of <ph id="ph2">&lt;paramref name="il" /&gt;</ph>.</source>
          <target state="translated">Um dos <ph id="ph1">&lt;paramref name="exceptionHandlers" /&gt;</ph> especifica um deslocamento fora do <ph id="ph2">&lt;paramref name="il" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>One of <ph id="ph1">&lt;paramref name="tokenFixups" /&gt;</ph> specifies an offset that is outside the <ph id="ph2">&lt;paramref name="il" /&gt;</ph> array.</source>
          <target state="translated">Um dos <ph id="ph1">&lt;paramref name="tokenFixups" /&gt;</ph> especifica um deslocamento que está fora da matriz <ph id="ph2">&lt;paramref name="il" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>The containing type was previously created using the <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method.</source>
          <target state="translated">O tipo recipiente foi criado anteriormente usando o método <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>This method was called previously on this <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> object.</source>
          <target state="translated">Esse método foi chamado anteriormente usando o objeto <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the parameter types.</source>
          <target state="translated">Uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representam os tipos de parâmetro.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>Sets the number and types of parameters for a method.</source>
          <target state="translated">Define o número e tipos de parâmetros para um método.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>If the number and types of the parameters are known when the method is defined, they can be set using any overload of the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> method that accepts an array of parameter types.</source>
          <target state="translated">Se o número e tipos dos parâmetros são conhecidos quando o método é definido, eles podem ser definidos usando qualquer sobrecarga de <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> método que aceita uma matriz de tipos de parâmetro.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>However, a generic method can have parameters whose types are specified by one or more of its own generic type parameters, which cannot be defined until after the method has been defined.</source>
          <target state="translated">No entanto, um método genérico pode ter parâmetros cujos tipos são especificados por um ou mais dos seus próprios parâmetros de tipo genérico, que não podem ser definidos até depois que o método foi definido.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>Use this method to set the parameter types in that case.</source>
          <target state="translated">Use esse método para definir os tipos de parâmetro nesse caso.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>If the return type has optional or required custom modifiers, such as <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IsConst&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29&gt;</ph> method overload.</source>
          <target state="translated">Se o tipo de retorno tem modificadores de personalizadas necessárias ou opcionais, como <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IsConst&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29&gt;</ph> sobrecarga do método.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>Calling this method replaces any parameter types that were set using the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Chamar esse método substitui quaisquer tipos de parâmetro que foram definidos usando o <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method to make a method generic.</source>
          <target state="translated">O seguinte exemplo de código usa o <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> método para fazer um método genérico.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A&gt;</ph> method is used to give the method one parameter, whose type will be specified by the first generic type parameter.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A&gt;</ph> método é usado para dar o um parâmetro de método cujo tipo será especificado pelo primeiro parâmetro de tipo genérico.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A&gt;</ph> method is used to give the method a return type, specified by the second generic type parameter.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A&gt;</ph> método é usado para fornecer o método de um tipo de retorno especificado pelo segundo parâmetro de tipo genérico.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">Esse código é parte de um exemplo maior fornecido para o <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>The current method is generic, but is not a generic method definition.</source>
          <target state="translated">O método atual é genérico, mas não é uma definição de método genérico.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Ou seja, a propriedade <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> é <ph id="ph2">&lt;see langword="true" /&gt;</ph>, mas a propriedade <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> é <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the return type of the method.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa o tipo de retorno do método.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>Sets the return type of the method.</source>
          <target state="translated">Define o tipo retornado do método.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>Use this method to set the return type of a generic method, when the return type is specified by one of the generic type parameters of the method.</source>
          <target state="translated">Use esse método para definir o tipo de retorno de um método genérico, quando o tipo de retorno é especificado por um dos parâmetros do método de tipo genérico.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>If the return type has optional or required custom modifiers, such as <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IsConst&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29&gt;</ph> method overload.</source>
          <target state="translated">Se o tipo de retorno tem modificadores de personalizadas necessárias ou opcionais, como <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IsConst&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29&gt;</ph> sobrecarga do método.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>Calling this method replaces a return type established using the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Chamar esse método substitui um tipo de retorno estabelecido usando o <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method to make a method generic.</source>
          <target state="translated">O seguinte exemplo de código usa o <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> método para fazer um método genérico.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A&gt;</ph> method is used to give the method one parameter, whose type will be specified by the first generic type parameter.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A&gt;</ph> método é usado para dar o um parâmetro de método cujo tipo será especificado pelo primeiro parâmetro de tipo genérico.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A&gt;</ph> method is used to give the method a return type, specified by the second generic type parameter.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A&gt;</ph> método é usado para fornecer o método de um tipo de retorno especificado pelo segundo parâmetro de tipo genérico.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">Esse código é parte de um exemplo maior fornecido para o <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>The current method is generic, but is not a generic method definition.</source>
          <target state="translated">O método atual é genérico, mas não é uma definição de método genérico.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Ou seja, a propriedade <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> é <ph id="ph2">&lt;see langword="true" /&gt;</ph>, mas a propriedade <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> é <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The return type of the method.</source>
          <target state="translated">O tipo de retorno do método.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">Uma matriz de tipos que representam os modificadores personalizados obrigatórios, por exemplo <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, para o tipo de retorno do método.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Se o tipo de retorno não tiver modificadores personalizados obrigatórios, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">Uma matriz de tipos que representam os modificadores personalizados opcionais, por exemplo <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, para o tipo de retorno do método.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Se o tipo de retorno não tiver modificadores personalizados opcionais, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The types of the parameters of the method.</source>
          <target state="translated">Os tipos dos parâmetros do método.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Uma matriz de matrizes de tipos.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Cada matriz de tipos representa os modificadores personalizados obrigatórios para o parâmetro correspondente, por exemplo <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Se um determinado parâmetro tiver não modificadores personalizados obrigatórios, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph> em vez de uma matriz de tipos.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Se nenhum dos parâmetros tiver modificadores personalizados obrigatórios, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph> em vez de uma matriz de matrizes.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Uma matriz de matrizes de tipos.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Cada matriz de tipos representa os modificadores personalizados opcionais para o parâmetro correspondente, por exemplo <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Se um determinado parâmetro tiver não modificadores personalizados opcionais, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph> em vez de uma matriz de tipos.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Se nenhum dos parâmetros tiver modificadores personalizados opcionais, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph> em vez de uma matriz de matrizes.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Sets the method signature, including the return type, the parameter types, and the required and optional custom modifiers of the return type and parameter types.</source>
          <target state="translated">Define a assinatura do método, incluindo o tipo retornado, os tipos de parâmetro e os modificadores personalizados obrigatórios e opcionais do tipo retornado e dos tipos de parâmetro.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type and the number and types of the parameters are known when the method is defined, they can be established using any overload of the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> method that accepts an array of parameter types.</source>
          <target state="translated">Se o tipo de retorno e o número e tipos dos parâmetros são conhecidos quando o método é definido, ele podem ser estabelecidos com nenhuma sobrecarga do <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> método que aceita uma matriz de tipos de parâmetro.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>However, a generic method can have parameters whose types are specified by one or more of its own generic type parameters, which cannot be defined until after the method has been defined.</source>
          <target state="translated">No entanto, um método genérico pode ter parâmetros cujos tipos são especificados por um ou mais dos seus próprios parâmetros de tipo genérico, que não podem ser definidos até depois que o método foi definido.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Use this method to set the parameter types in that case.</source>
          <target state="translated">Use esse método para definir os tipos de parâmetro nesse caso.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If neither the return type nor the parameter types have optional or required custom modifiers, such as <ph id="ph1">&lt;xref:Microsoft.VisualC.IsConstModifier&gt;</ph>, you can use the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A&gt;</ph> methods.</source>
          <target state="translated">Se o tipo de retorno, nem os tipos de parâmetro têm modificadores de personalizadas necessárias ou opcionais, como <ph id="ph1">&lt;xref:Microsoft.VisualC.IsConstModifier&gt;</ph>, você pode usar o <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A&gt;</ph> e <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Calling this method replaces the parameters and return type established using the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Chamar esse método substitui os parâmetros e o tipo de retorno estabelecida usando o <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The following code example contains source code for a generic class named Sample that has a type parameter <ph id="ph1">`T`</ph>.</source>
          <target state="translated">O exemplo de código a seguir contém o código-fonte para uma classe genérica de exemplo que tem um parâmetro de tipo nomeado <ph id="ph1">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The class has a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, and a generic method <ph id="ph3">`GM`</ph> with its own type parameter, <ph id="ph4">`U`</ph>.</source>
          <target state="translated">A classe tem um campo chamado <ph id="ph1">`Field`</ph>, do tipo <ph id="ph2">`T`</ph>e um método genérico <ph id="ph3">`GM`</ph> com seu próprio parâmetro de tipo <ph id="ph4">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Method <ph id="ph1">`GM`</ph> creates an instance of Sample, substituting its own type parameter <ph id="ph2">`U`</ph> for the type parameter of Sample, and stores its input parameter in <ph id="ph3">`Field`</ph>.</source>
          <target state="translated">Método <ph id="ph1">`GM`</ph> cria uma instância de exemplo, substituindo seu próprio parâmetro de tipo <ph id="ph2">`U`</ph> para o parâmetro de tipo de amostra e armazena seu parâmetro de entrada em <ph id="ph3">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>This source code is compiled but not used; you can view it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, and compare it to the code emitted by class <ph id="ph1">`Example`</ph>.</source>
          <target state="translated">Este código-fonte é compilado, mas não utilizado; Você pode exibi-lo com o <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>e compará-lo com o código emitido pela classe <ph id="ph1">`Example`</ph>.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The code in class <ph id="ph1">`Example`</ph> demonstrates the use of the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A&gt;</ph> method in emitting generic code.</source>
          <target state="translated">O código na classe <ph id="ph1">`Example`</ph> demonstra o uso do <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A&gt;</ph> método emitindo código genérico.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The <ph id="ph1">`Main`</ph> method of class <ph id="ph2">`Example`</ph> creates a dynamic assembly containing a class named <ph id="ph3">`Sample`</ph>, and uses the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> method to make it generic by adding a type parameter named <ph id="ph5">`T`</ph>.</source>
          <target state="translated">O <ph id="ph1">`Main`</ph> método da classe <ph id="ph2">`Example`</ph> cria um assembly dinâmico que contém uma classe denominada <ph id="ph3">`Sample`</ph>e usa o <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> método torná-la genérica adicionando um parâmetro de tipo denominado <ph id="ph5">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>A default constructor and a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, are added to class <ph id="ph3">`Sample`</ph>.</source>
          <target state="translated">Um construtor padrão e um campo denominado <ph id="ph1">`Field`</ph>, do tipo <ph id="ph2">`T`</ph>, são adicionados à classe <ph id="ph3">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>A method <ph id="ph1">`GM`</ph> is added, and turned into a generic method using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">Um método <ph id="ph1">`GM`</ph> é adicionada e transformada em um método genérico usando o <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The type parameter of <ph id="ph1">`GM`</ph> is named <ph id="ph2">`U`</ph>.</source>
          <target state="translated">O parâmetro de tipo de <ph id="ph1">`GM`</ph> chamado <ph id="ph2">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Once the type parameter is defined, the signature of <ph id="ph1">`GM`</ph> is added, using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A&gt;</ph> method.</source>
          <target state="translated">Quando o parâmetro de tipo é definido, a assinatura de <ph id="ph1">`GM`</ph> é adicionado, usando o <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>There is no return type, and no required or custom modifiers, so all the parameters of this method are <ph id="ph1">`null`</ph> except <ph id="ph2">`parameterTypes`</ph>, which sets the type of the only parameter of the method; this is set to the method's type parameter, <ph id="ph3">`U`</ph>.</source>
          <target state="translated">Há nenhum tipo de retorno e nenhum modificador necessária ou personalizado, portanto, todos os parâmetros desse método são <ph id="ph1">`null`</ph> exceto <ph id="ph2">`parameterTypes`</ph>, que define o tipo do parâmetro do método apenas; isso é definido como parâmetro de tipo do método, <ph id="ph3">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The body of the method creates an instance of the constructed type <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> in Visual Basic), assigns the method's parameter to <ph id="ph3">`Field`</ph>, and then prints the value of <ph id="ph4">`Field`</ph>.</source>
          <target state="translated">O corpo do método cria uma instância do tipo construído <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> no Visual Basic), atribui o parâmetro do método para <ph id="ph3">`Field`</ph>e imprime o valor de <ph id="ph4">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>A dummy type is defined, to hold the entry point method <ph id="ph1">`Main`</ph>.</source>
          <target state="translated">Um tipo fictício é definido, para manter o método de ponto de entrada <ph id="ph1">`Main`</ph>.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>In the body of <ph id="ph1">`Main`</ph>, the static <ph id="ph2">`GM`</ph> method is invoked on the constructed generic type <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> in Visual Basic), with type <ph id="ph5">&lt;xref:System.String&gt;</ph> substituted for <ph id="ph6">`U`</ph>.</source>
          <target state="translated">No corpo da <ph id="ph1">`Main`</ph>, estático <ph id="ph2">`GM`</ph> método é invocado no tipo genérico construído <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> no Visual Basic), com o tipo <ph id="ph5">&lt;xref:System.String&gt;</ph> substituídos por <ph id="ph6">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A?displayProperty=nameWithType&gt;</ph> method is used to create a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> for the static <ph id="ph3">`GM`</ph> method of the constructed generic type <ph id="ph4">`Sample&lt;U&gt;`</ph>, and the <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> method is then used to create a <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that can emitted in a method call.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A?displayProperty=nameWithType&gt;</ph> método é usado para criar um <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> para estático <ph id="ph3">`GM`</ph> método do tipo genérico construído <ph id="ph4">`Sample&lt;U&gt;`</ph>e o <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> método é usado para criar um <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> que pode ser emitido em uma chamada de método.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</source>
          <target state="translated">Quando o exemplo de código é executado, ele salva o assembly emitido como TypeBuilderGetFieldExample.exe.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>You can run TypeBuilderGetFieldExample.exe, and you can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to compare the emitted code with the code for the <ph id="ph1">`Sample`</ph> class that is compiled into the code example itself.</source>
          <target state="translated">Você pode executar TypeBuilderGetFieldExample.exe, e você pode usar o <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> para comparar o código emitido com o código para o <ph id="ph1">`Sample`</ph> classe que é compilado para o exemplo de código.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The current method is generic, but is not a generic method definition.</source>
          <target state="translated">O método atual é genérico, mas não é uma definição de método genérico.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Ou seja, a propriedade <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> é <ph id="ph2">&lt;see langword="true" /&gt;</ph>, mas a propriedade <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> é <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The name of the symbolic custom attribute.</source>
          <target state="translated">O nome do atributo personalizado simbólico.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The byte blob that represents the value of the symbolic custom attribute.</source>
          <target state="translated">O blob de byte que representa o valor do atributo personalizado simbólico.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>Set a symbolic custom attribute using a blob.</source>
          <target state="translated">Define um atributo personalizado simbólico usando um blob.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>Unlike the metadata custom attribute, this custom attribute is associated with a symbol writer.</source>
          <target state="translated">Ao contrário do atributo personalizado de metadados, este atributo personalizado está associado um gravador de símbolo.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The code sample below illustrates the contextual usage of the <ph id="ph1">`SetSymCustomAttribute`</ph> method to set the byte values for the name and key of a custom attribute attached to a method.</source>
          <target state="translated">O exemplo de código a seguir ilustra o uso contextual o <ph id="ph1">`SetSymCustomAttribute`</ph> método para definir os valores de byte para o nome e a chave de um atributo personalizado anexado a um método.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The containing type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">O tipo recipiente foi criado anteriormente usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The module that contains this method is not a debug module.</source>
          <target state="translated">O módulo que contém esse método não é um módulo de depuração.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Para o método atual, a propriedade <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> é <ph id="ph2">&lt;see langword="true" /&gt;</ph>, mas a propriedade <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> é <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.Signature">
          <source>Retrieves the signature of the method.</source>
          <target state="translated">Recupera a assinatura do método.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Signature">
          <source>Read-only.</source>
          <target state="translated">Somente leitura.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Signature">
          <source>A String containing the signature of the method reflected by this <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> instance.</source>
          <target state="translated">Uma cadeia de caracteres que contém a assinatura do método refletido por isso <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> instância.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para uso futuro.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Deve ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Matriz passada de nomes a serem mapeados.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Contagem dos nomes a serem mapeados.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">O contexto de localidade no qual interpretar os nomes.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array that receives the IDs corresponding to the names.</source>
          <target state="translated">Matriz alocada pelo chamador que recebe os IDs correspondentes aos nomes.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Mapeia um conjunto de nomes para um conjunto correspondente de identificadores de expedição.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, consulte a Biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Não há suporte para acesso com associação tardia usando a interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">As informações de tipo a serem retornadas.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">O identificador de localidade das informações do tipo.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Recebe um ponteiro para o objeto de informações de tipo solicitado.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Recupera as informações do tipo de um objeto, que podem ser usadas para obter informações de tipo para uma interface.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, consulte a Biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Não há suporte para acesso com associação tardia usando a interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Aponta para um local que recebe o número de interfaces de informações de tipo fornecido pelo objeto.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Retorna o número de interfaces de informações do tipo que um objeto fornece (0 ou 1).</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, consulte a Biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Não há suporte para acesso com associação tardia usando a interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Identifica o membro.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para uso futuro.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Deve ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">O contexto de localidade no qual interpretar argumentos.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Sinalizadores que descrevem o contexto da chamada.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DispIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Ponteiro para uma estrutura que contém uma matriz de argumentos, uma matriz de DispIDs de argumentos para argumentos nomeados e contas para o número de elementos nas matrizes.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Ponteiro para o local onde o resultado deve ser armazenado.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Ponteiro para uma estrutura que contém informações de exceção.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">O índice do primeiro argumento que tem um erro.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Fornece acesso a propriedades e métodos expostos por um objeto.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::Invoke`</ph>, consulte a Biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Não há suporte para acesso com associação tardia usando a interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.ToString">
          <source>Returns this <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph> instance as a string.</source>
          <target state="translated">Retorna esta instância <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph> como uma cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.ToString">
          <source>Returns a string containing the name, attributes, method signature, exceptions, and local signature of this method followed by the current Microsoft intermediate language (MSIL) stream.</source>
          <target state="translated">Retorna uma cadeia de caracteres que contém o nome, os atributos, a assinatura do método, as exceções e a assinatura local desse método seguidos pelo fluxo MSIL (linguagem intermediária da Microsoft) atual.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>