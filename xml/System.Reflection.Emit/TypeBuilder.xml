<Type Name="TypeBuilder" FullName="System.Reflection.Emit.TypeBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0a3d455de9bd4fc2bafe3221ec13aeb7bd4ade87" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class TypeBuilder : System.Reflection.TypeInfo, System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit TypeBuilder extends System.Reflection.TypeInfo implements class System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.TypeBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class TypeBuilder&#xA;Inherits TypeInfo&#xA;Implements _TypeBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeBuilder sealed : System::Reflection::TypeInfo, System::Runtime::InteropServices::_TypeBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.TypeInfo</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netcore-2.0">System.Type</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._TypeBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._TypeBuilder))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="6096a-101">Define e cria novas instâncias de classes no tempo de execução.</span>
      <span class="sxs-lookup">
        <span data-stu-id="6096a-101">Defines and creates new instances of classes during run time.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-102"><xref:System.Reflection.Emit.TypeBuilder> a classe raiz é usada para controlar a criação de classes dinâmicas em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="6096a-102"><xref:System.Reflection.Emit.TypeBuilder> is the root class used to control the creation of dynamic classes in the runtime.</span></span> <span data-ttu-id="6096a-103">Ele fornece um conjunto de rotinas que são usados para definir classes, adicionar os métodos e campos e criar a classe dentro de um módulo.</span><span class="sxs-lookup"><span data-stu-id="6096a-103">It provides a set of routines that are used to define classes, add methods and fields, and create the class inside a module.</span></span> <span data-ttu-id="6096a-104">Um novo <xref:System.Reflection.Emit.TypeBuilder> podem ser criados a partir de um módulo dinâmico chamando o <xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType> método, que retorna um <xref:System.Reflection.Emit.TypeBuilder> objeto.</span><span class="sxs-lookup"><span data-stu-id="6096a-104">A new <xref:System.Reflection.Emit.TypeBuilder> can be created from a dynamic module by calling the <xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType> method, which returns a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="6096a-105">Emissão de reflexão fornece as seguintes opções para definir tipos:</span><span class="sxs-lookup"><span data-stu-id="6096a-105">Reflection emit provides the following options for defining types:</span></span>  
  
-   <span data-ttu-id="6096a-106">Defina uma classe ou interface com o nome fornecido.</span><span class="sxs-lookup"><span data-stu-id="6096a-106">Define a class or interface with the given name.</span></span>  
  
-   <span data-ttu-id="6096a-107">Defina uma classe ou interface com o nome e atributos.</span><span class="sxs-lookup"><span data-stu-id="6096a-107">Define a class or interface with the given name and attributes.</span></span>  
  
-   <span data-ttu-id="6096a-108">Defina uma classe com o nome fornecido, atributos e classe base.</span><span class="sxs-lookup"><span data-stu-id="6096a-108">Define a class with the given name, attributes, and base class.</span></span>  
  
-   <span data-ttu-id="6096a-109">Defina uma classe com o nome fornecido, atributos, a classe base e o conjunto de interfaces que a classe implementa.</span><span class="sxs-lookup"><span data-stu-id="6096a-109">Define a class with the given name, attributes, base class, and the set of interfaces that the class implements.</span></span>  
  
-   <span data-ttu-id="6096a-110">Defina uma classe com o nome fornecido, atributos, a classe base e tamanho de pacote.</span><span class="sxs-lookup"><span data-stu-id="6096a-110">Define a class with the given name, attributes, base class, and packing size.</span></span>  
  
-   <span data-ttu-id="6096a-111">Defina uma classe com o nome fornecido, atributos, a classe base e o tamanho de classe como um todo.</span><span class="sxs-lookup"><span data-stu-id="6096a-111">Define a class with the given name, attributes, base class, and the class size as a whole.</span></span>  
  
-   <span data-ttu-id="6096a-112">Defina uma classe com o nome fornecido, atributos, a classe base, tamanho de pacote e o tamanho de classe como um todo.</span><span class="sxs-lookup"><span data-stu-id="6096a-112">Define a class with the given name, attributes, base class, packing size, and the class size as a whole.</span></span>  
  
 <span data-ttu-id="6096a-113">Para criar um tipo de matriz, um tipo de ponteiro ou um tipo byref para um tipo incompleto é representado por um <xref:System.Reflection.Emit.TypeBuilder> de objeto, use o <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> método <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> método, ou <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> método, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="6096a-113">To create an array type, pointer type, or byref type for an incomplete type that is represented by a <xref:System.Reflection.Emit.TypeBuilder> object, use the <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> method, <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> method, or <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> method, respectively.</span></span>  
  
 <span data-ttu-id="6096a-114">Antes de um tipo é usado, o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> método deve ser chamado.</span><span class="sxs-lookup"><span data-stu-id="6096a-114">Before a type is used, the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> method must be called.</span></span> <span data-ttu-id="6096a-115">**CreateType** concluir a criação do tipo.</span><span class="sxs-lookup"><span data-stu-id="6096a-115">**CreateType** completes the creation of the type.</span></span> <span data-ttu-id="6096a-116">Após a chamada ao **CreateType**, o chamador pode instanciar o tipo usando o <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método e chamar membros do tipo usando o <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="6096a-116">Following the call to **CreateType**, the caller can instantiate the type by using the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and invoke members of the type by using the <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="6096a-117">É um erro para invocar métodos que alteram a implementação de um tipo após **CreateType** foi chamado.</span><span class="sxs-lookup"><span data-stu-id="6096a-117">It is an error to invoke methods that change the implementation of a type after **CreateType** has been called.</span></span> <span data-ttu-id="6096a-118">Por exemplo, o common language runtime gera uma exceção se o chamador tenta adicionar novos membros a um tipo.</span><span class="sxs-lookup"><span data-stu-id="6096a-118">For example, the common language runtime throws an exception if the caller tries to add new members to a type.</span></span>  
  
 <span data-ttu-id="6096a-119">Um inicializador de classe é criado usando o <xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="6096a-119">A class initializer is created by using the <xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="6096a-120">**DefineTypeInitializer** retorna um <xref:System.Reflection.Emit.ConstructorBuilder> objeto.</span><span class="sxs-lookup"><span data-stu-id="6096a-120">**DefineTypeInitializer** returns a <xref:System.Reflection.Emit.ConstructorBuilder> object.</span></span>  
  
 <span data-ttu-id="6096a-121">Tipos aninhados são definidos chamando um do <xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType> métodos.</span><span class="sxs-lookup"><span data-stu-id="6096a-121">Nested types are defined by calling one of the <xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType> methods.</span></span>  
  
## <a name="attributes"></a><span data-ttu-id="6096a-122">Atributos</span><span class="sxs-lookup"><span data-stu-id="6096a-122">Attributes</span></span>  
 <span data-ttu-id="6096a-123">O <xref:System.Reflection.Emit.TypeBuilder> classe usa a <xref:System.Reflection.TypeAttributes> enumeração para especificar as características do tipo a ser criado:</span><span class="sxs-lookup"><span data-stu-id="6096a-123">The <xref:System.Reflection.Emit.TypeBuilder> class uses the <xref:System.Reflection.TypeAttributes> enumeration to further specify the characteristics of the type to be created:</span></span>  
  
-   <span data-ttu-id="6096a-124">Interfaces são especificadas usando o <xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType> e <xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType> atributos.</span><span class="sxs-lookup"><span data-stu-id="6096a-124">Interfaces are specified using the <xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType> and <xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType> attributes.</span></span>  
  
-   <span data-ttu-id="6096a-125">Classes concretas (classes que não podem ser estendidos) são especificados usando o <xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType> atributo.</span><span class="sxs-lookup"><span data-stu-id="6096a-125">Concrete classes (classes that cannot be extended) are specified using the <xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType> attribute.</span></span>  
  
-   <span data-ttu-id="6096a-126">Vários atributos determinam a visibilidade do tipo.</span><span class="sxs-lookup"><span data-stu-id="6096a-126">Several attributes determine type visibility.</span></span> <span data-ttu-id="6096a-127">Consulte a descrição do <xref:System.Reflection.TypeAttributes> enumeração.</span><span class="sxs-lookup"><span data-stu-id="6096a-127">See the description of the <xref:System.Reflection.TypeAttributes> enumeration.</span></span>  
  
-   <span data-ttu-id="6096a-128">Se <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> for especificado, o carregador de classe dispõe campos na ordem em que elas são de leitura de metadados.</span><span class="sxs-lookup"><span data-stu-id="6096a-128">If <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> is specified, the class loader lays out fields in the order they are read from metadata.</span></span> <span data-ttu-id="6096a-129">O carregador de classe considera o tamanho de pacote especificado, mas ignora qualquer deslocamentos de campo especificado.</span><span class="sxs-lookup"><span data-stu-id="6096a-129">The class loader considers the specified packing size but ignores any specified field offsets.</span></span> <span data-ttu-id="6096a-130">Os metadados preserva a ordem em que as definições de campo são emitidas.</span><span class="sxs-lookup"><span data-stu-id="6096a-130">The metadata preserves the order in which the field definitions are emitted.</span></span> <span data-ttu-id="6096a-131">Mesmo em uma mesclagem, os metadados não reorganizará as definições de campo.</span><span class="sxs-lookup"><span data-stu-id="6096a-131">Even across a merge, the metadata will not reorder the field definitions.</span></span> <span data-ttu-id="6096a-132">O carregador respeitará de deslocamentos de campo especificado somente se <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> for especificado.</span><span class="sxs-lookup"><span data-stu-id="6096a-132">The loader will honor the specified field offsets only if <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> is specified.</span></span>  
  
## <a name="known-issues"></a><span data-ttu-id="6096a-133">Problemas Conhecidos</span><span class="sxs-lookup"><span data-stu-id="6096a-133">Known Issues</span></span>  
  
-   <span data-ttu-id="6096a-134">Emissão de reflexão não verifica se uma classe não abstrata que implementa uma interface implementou todos os métodos declarados na interface.</span><span class="sxs-lookup"><span data-stu-id="6096a-134">Reflection emit does not verify whether a non-abstract class that implements an interface has implemented all the methods declared in the interface.</span></span> <span data-ttu-id="6096a-135">No entanto, se a classe não implementa todos os métodos declarados em uma interface, o tempo de execução não carregar a classe.</span><span class="sxs-lookup"><span data-stu-id="6096a-135">However, if the class does not implement all the methods declared in an interface, the runtime does not load the class.</span></span>  
  
-   <span data-ttu-id="6096a-136">Embora <xref:System.Reflection.Emit.TypeBuilder> é derivado do <xref:System.Type>, alguns dos métodos abstratos definidos no <xref:System.Type> classe não são totalmente implementado o <xref:System.Reflection.Emit.TypeBuilder> classe.</span><span class="sxs-lookup"><span data-stu-id="6096a-136">Although <xref:System.Reflection.Emit.TypeBuilder> is derived from <xref:System.Type>, some of the abstract methods defined in the <xref:System.Type> class are not fully implemented in the <xref:System.Reflection.Emit.TypeBuilder> class.</span></span> <span data-ttu-id="6096a-137">Chamadas para esses <xref:System.Reflection.Emit.TypeBuilder> métodos lançam uma <xref:System.NotSupportedException> exceção.</span><span class="sxs-lookup"><span data-stu-id="6096a-137">Calls to these <xref:System.Reflection.Emit.TypeBuilder> methods throw a <xref:System.NotSupportedException> exception.</span></span> <span data-ttu-id="6096a-138">A funcionalidade desejada pode ser obtida por recuperar o tipo criado usando o <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e refletir o tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="6096a-138">The desired functionality can be obtained by retrieving the created type using the <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and reflecting on the retrieved type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6096a-139">Esta seção contém dois exemplos de código.</span><span class="sxs-lookup"><span data-stu-id="6096a-139">This section contains two code examples.</span></span> <span data-ttu-id="6096a-140">O primeiro exemplo mostra como criar um tipo dinâmico com um campo, construtor, propriedade e método.</span><span class="sxs-lookup"><span data-stu-id="6096a-140">The first example shows how to create a dynamic type with a field, constructor, property, and method.</span></span> <span data-ttu-id="6096a-141">O segundo exemplo cria um método dinamicamente da entrada do usuário.</span><span class="sxs-lookup"><span data-stu-id="6096a-141">The second example builds a method dynamically from user input.</span></span>  
  
 <span data-ttu-id="6096a-142">**Exemplo de um**</span><span class="sxs-lookup"><span data-stu-id="6096a-142">**Example one**</span></span>  
  
 <span data-ttu-id="6096a-143">O exemplo de código a seguir mostra como definir um assembly dinâmico com um módulo.</span><span class="sxs-lookup"><span data-stu-id="6096a-143">The following code example shows how to define a dynamic assembly with one module.</span></span> <span data-ttu-id="6096a-144">O módulo no assembly de exemplo contém um tipo, `MyDynamicType`, que tem um campo particular, uma propriedade que obtém e define o campo privado, construtores que inicializar o campo privado e um método que multiplica um número fornecido pelo usuário pelo campo particular valor e retorna o resultado.</span><span class="sxs-lookup"><span data-stu-id="6096a-144">The module in the example assembly contains one type, `MyDynamicType`, which has a private field, a property that gets and sets the private field, constructors that initialize the private field, and a method that multiplies a user-supplied number by the private field value and returns the result.</span></span>  
  
 <span data-ttu-id="6096a-145">O <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType> campo for especificado quando o assembly é criado.</span><span class="sxs-lookup"><span data-stu-id="6096a-145">The <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType> field is specified when the assembly is created.</span></span> <span data-ttu-id="6096a-146">O código do assembly é usado imediatamente, e o assembly também é salvas em disco para que ele pode ser examinado com [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) ou usado em outro programa.</span><span class="sxs-lookup"><span data-stu-id="6096a-146">The assembly code is used immediately, and the assembly is also saved to disk so that it can be examined with [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) or used in another program.</span></span>  
  
 [!code-cpp[AssemblyBuilderClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilderClass/cpp/24895.cpp#1)]
 [!code-csharp[AssemblyBuilderClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilderClass/cs/24895.cs#1)]
 [!code-vb[AssemblyBuilderClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilderClass/vb/24895.vb#1)]  
  
 <span data-ttu-id="6096a-147">**Exemplo de dois**</span><span class="sxs-lookup"><span data-stu-id="6096a-147">**Example two**</span></span>  
  
 <span data-ttu-id="6096a-148">O exemplo de código a seguir demonstra como criar um tipo dinâmico usando `TypeBuilder`.</span><span class="sxs-lookup"><span data-stu-id="6096a-148">The following code sample demonstrates how to build a dynamic type by using `TypeBuilder`.</span></span>  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TypeBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDeclarativeSecurity">
      <MemberSignature Language="C#" Value="public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDeclarativeSecurity(valuetype System.Security.Permissions.SecurityAction action, class System.Security.PermissionSet pset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDeclarativeSecurity (action As SecurityAction, pset As PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDeclarativeSecurity(System::Security::Permissions::SecurityAction action, System::Security::PermissionSet ^ pset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Security.Permissions.SecurityAction" />
        <Parameter Name="pset" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="action">
          <span data-ttu-id="6096a-149">A ação de segurança a ser executada como Demand, Assert e assim por diante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-149">The security action to be taken such as Demand, Assert, and so on.</span>
          </span>
        </param>
        <param name="pset">
          <span data-ttu-id="6096a-150">O conjunto de permissões ao qual a ação se aplica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-150">The set of permissions the action applies to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-151">Adiciona segurança declarativa a este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-151">Adds declarative security to this type.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-152">`AddDeclarativeSecurity` pode ser chamado várias vezes com cada chamada especificando uma ação de segurança (como a demanda, Assert ou negar) e um conjunto de permissões que se aplicam à ação.</span><span class="sxs-lookup"><span data-stu-id="6096a-152">`AddDeclarativeSecurity` may be called several times with each call specifying a security action (such as Demand, Assert, or Deny) and a set of permissions that apply to the action.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6096a-153">Nas versões do .NET Framework 1.0, 1.1 e 2.0, os atributos de segurança declarativa aplicados a um tipo usando esse método são armazenados no formato de metadados XML antigo.</span><span class="sxs-lookup"><span data-stu-id="6096a-153">In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a type by using this method are stored in the old XML metadata format.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6096a-154">O exemplo a seguir demonstra o uso do `AddDeclarativeSecurity` método para adicionar uma exigência de segurança para <xref:System.Security.Permissions.SecurityPermission> com o <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> sinalizador para um tipo dinâmico chamado `MyDynamicClass`, em um assembly nomeado EmittedExample.dll.</span><span class="sxs-lookup"><span data-stu-id="6096a-154">The following example demonstrates the use of the `AddDeclarativeSecurity` method to add a security demand for <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag to a dynamic type named `MyDynamicClass`, in an assembly named EmittedExample.dll.</span></span> <span data-ttu-id="6096a-155">O exemplo não produz nenhuma saída do console; Depois que você executá-lo, você pode usar [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar EmittedExample.dll.</span><span class="sxs-lookup"><span data-stu-id="6096a-155">The example produces no console output; after you run it, you can use [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine EmittedExample.dll.</span></span> <span data-ttu-id="6096a-156">Em `MyDynamicClass`, abra o `.class public auto ansi` instrução para verificar a permissão declarativa.</span><span class="sxs-lookup"><span data-stu-id="6096a-156">In `MyDynamicClass`, open the `.class public auto ansi` statement to see the declarative permission.</span></span>  
  
 [!code-cpp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CPP/typebuilder_adddeclarativesecurity.cpp#1)]
 [!code-csharp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CS/typebuilder_adddeclarativesecurity.cs#1)]
 [!code-vb[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/VB/typebuilder_adddeclarativesecurity.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="6096a-157">O <paramref name="action" /> é inválido (<see langword="RequestMinimum" />, <see langword="RequestOptional" /> e <see langword="RequestRefuse" /> são inválidos).</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-157">The <paramref name="action" /> is invalid (<see langword="RequestMinimum" />, <see langword="RequestOptional" />, and <see langword="RequestRefuse" /> are invalid).</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-158">O tipo recipiente foi criado usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-158">The containing type has been created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="6096a-159">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-159">-or-</span>
          </span>
          <span data-ttu-id="6096a-160">O conjunto de permissões <paramref name="pset" /> contém uma ação que foi adicionada anteriormente por <see langword="AddDeclarativeSecurity" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-160">The permission set <paramref name="pset" /> contains an action that was added earlier by <see langword="AddDeclarativeSecurity" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-161">
            <paramref name="pset" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-161">
              <paramref name="pset" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AddInterfaceImplementation">
      <MemberSignature Language="C#" Value="public void AddInterfaceImplementation (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddInterfaceImplementation(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddInterfaceImplementation (interfaceType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddInterfaceImplementation(Type ^ interfaceType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">
          <span data-ttu-id="6096a-162">A interface implementada por esse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-162">The interface that this type implements.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-163">Adiciona uma interface implementada por esse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-163">Adds an interface that this type implements.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="6096a-164">O exemplo de código a seguir demonstra a implementação de uma interface em um tipo criado dinamicamente usando `AddInterfaceImplementation`.</span><span class="sxs-lookup"><span data-stu-id="6096a-164">The following code sample demonstrates the implementation of an interface on a dynamically created type using `AddInterfaceImplementation`.</span></span>  
  
 [!code-cpp[TypeBuilder_Sample_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#3)]
 [!code-csharp[TypeBuilder_Sample_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#3)]
 [!code-vb[TypeBuilder_Sample_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-165">
            <paramref name="interfaceType" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-165">
              <paramref name="interfaceType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-166">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-166">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-167">Recupera o assembly dinâmico que contém essa definição de tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-167">Retrieves the dynamic assembly that contains this type definition.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6096a-168">Somente leitura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-168">Read-only.</span>
          </span>
          <span data-ttu-id="6096a-169">Recupera o assembly dinâmico que contém essa definição de tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-169">Retrieves the dynamic assembly that contains this type definition.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public override string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-170">Retorna o nome completo desse tipo qualificado pelo nome de exibição do assembly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-170">Returns the full name of this type qualified by the display name of the assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6096a-171">Somente leitura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-171">Read-only.</span>
          </span>
          <span data-ttu-id="6096a-172">O nome completo deste tipo qualificado pelo nome de exibição do assembly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-172">The full name of this type qualified by the display name of the assembly.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-173">O formato de cadeia de caracteres retornada é a concatenação do nome completo do tipo (<xref:System.Reflection.Emit.TypeBuilder.FullName%2A>) e o nome para exibição do assembly (<xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType>), separados por uma vírgula e um espaço.</span><span class="sxs-lookup"><span data-stu-id="6096a-173">The format of the returned string is the concatenation of the full name of the type (<xref:System.Reflection.Emit.TypeBuilder.FullName%2A>) and the display name of the assembly (<xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType>), separated by a comma and a space.</span></span>  
  
 <span data-ttu-id="6096a-174">Consulte <xref:System.Reflection.AssemblyName> para obter uma descrição do formato do nome para exibição de um assembly.</span><span class="sxs-lookup"><span data-stu-id="6096a-174">See <xref:System.Reflection.AssemblyName> for a description of the format of the display name of an assembly.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="6096a-175">Informações de versão</span><span class="sxs-lookup"><span data-stu-id="6096a-175">Version Information</span></span>  
 <span data-ttu-id="6096a-176">Nas versões do .NET Framework 1.0 e 1.1, o valor dessa propriedade não inclui a cultura ou chave pública.</span><span class="sxs-lookup"><span data-stu-id="6096a-176">In the .NET Framework versions 1.0 and 1.1, the value of this property does not include the culture or public key.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public override Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ BaseType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-177">Recupera o tipo base deste tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-177">Retrieves the base type of this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6096a-178">Somente leitura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-178">Read-only.</span>
          </span>
          <span data-ttu-id="6096a-179">Recupera o tipo base deste tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-179">Retrieves the base type of this type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public override bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateType">
      <MemberSignature Language="C#" Value="public Type CreateType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type CreateType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateType" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ CreateType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="6096a-180">Cria um objeto <see cref="T:System.Type" /> para a classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-180">Creates a <see cref="T:System.Type" /> object for the class.</span>
          </span>
          <span data-ttu-id="6096a-181">Depois de definir campos e métodos na classe, <see langword="CreateType" /> é chamado para carregar seu objeto <see langword="Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-181">After defining fields and methods on the class, <see langword="CreateType" /> is called in order to load its <see langword="Type" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-182">Retorna o novo objeto <see cref="T:System.Type" /> dessa classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-182">Returns the new <see cref="T:System.Type" /> object for this class.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-183">Se esse tipo é um tipo aninhado, a <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método deve ser chamado em um tipo delimitador antes do tipo aninhado for chamado.</span><span class="sxs-lookup"><span data-stu-id="6096a-183">If this type is a nested type, the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method must be called on the enclosing type before it is called on the nested type.</span></span>  
  
 <span data-ttu-id="6096a-184">Se o tipo atual deriva de um tipo incompleto ou implementa as interfaces incompletas, chame o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método no tipo de pai e os tipos de interface antes de ele chamar o tipo atual.</span><span class="sxs-lookup"><span data-stu-id="6096a-184">If the current type derives from an incomplete type or implements incomplete interfaces, call the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method on the parent type and the interface types before calling it on the current type.</span></span>  
  
 <span data-ttu-id="6096a-185">Se o tipo de delimitador contém um campo que é um tipo de valor definido como um tipo aninhado (por exemplo, um campo que é uma enumeração definida como um tipo aninhado), chamando o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método do tipo delimitador gerará um <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> eventos.</span><span class="sxs-lookup"><span data-stu-id="6096a-185">If the enclosing type contains a field that is a value type defined as a nested type (for example, a field that is an enumeration defined as a nested type), calling the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method on the enclosing type will generate a <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="6096a-186">Isso ocorre porque o carregador não é possível determinar o tamanho do tipo delimitador até que o tipo aninhado foi concluído.</span><span class="sxs-lookup"><span data-stu-id="6096a-186">This is because the loader cannot determine the size of the enclosing type until the nested type has been completed.</span></span> <span data-ttu-id="6096a-187">O chamador deve definir um manipulador para o <xref:System.AppDomain.TypeResolve> evento para concluir a definição do tipo aninhado chamando <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> no <xref:System.Reflection.Emit.TypeBuilder> objeto que representa o tipo aninhado.</span><span class="sxs-lookup"><span data-stu-id="6096a-187">The caller should define a handler for the <xref:System.AppDomain.TypeResolve> event to complete the definition of the nested type by calling <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> on the <xref:System.Reflection.Emit.TypeBuilder> object that represents the nested type.</span></span> <span data-ttu-id="6096a-188">O exemplo de código para este tópico mostra como definir essa um manipulador de eventos.</span><span class="sxs-lookup"><span data-stu-id="6096a-188">The code example for this topic shows how to define such an event handler.</span></span>  
  
 <span data-ttu-id="6096a-189">Um tipo é criado apenas uma vez, não importa como quantas vezes o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método é chamado.</span><span class="sxs-lookup"><span data-stu-id="6096a-189">A type is created only once, no matter how many times the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method is called.</span></span> <span data-ttu-id="6096a-190">Todas as chamadas retornam o mesmo <xref:System.Type> objeto.</span><span class="sxs-lookup"><span data-stu-id="6096a-190">All calls return the same <xref:System.Type> object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6096a-191">O exemplo de código a seguir mostra como definir um manipulador de eventos para o <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> eventos, para chamar o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método em um tipo aninhado durante um <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> ligar o tipo de delimitador.</span><span class="sxs-lookup"><span data-stu-id="6096a-191">The following code example shows how to define an event handler for the <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> event, in order to call the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method on a nested type during a <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> call on the enclosing type.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CPP/nestedenum.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CS/nestedenum.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/VB/nestedenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-192">O tipo delimitador não foi criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-192">The enclosing type has not been created.</span>
          </span>
          <span data-ttu-id="6096a-193">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-193">-or-</span>
          </span>
          <span data-ttu-id="6096a-194">Esse tipo é não abstrato e contém um método abstrato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-194">This type is non-abstract and contains an abstract method.</span>
          </span>
          <span data-ttu-id="6096a-195">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-195">-or-</span>
          </span>
          <span data-ttu-id="6096a-196">Esse tipo não é uma classe abstrata nem uma interface e tem um método sem um corpo do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-196">This type is not an abstract class or an interface and has a method without a method body.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="6096a-197">O tipo contém código MSIL (Microsoft Intermediate Language) inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-197">The type contains invalid Microsoft intermediate language (MSIL) code.</span>
          </span>
          <span data-ttu-id="6096a-198">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-198">-or-</span>
          </span>
          <span data-ttu-id="6096a-199">O destino da ramificação é especificado usando um deslocamento de 1 byte, mas está em uma distância maior que 127 bytes da ramificação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-199">The branch target is specified using a 1-byte offset, but the target is at a distance greater than 127 bytes from the branch.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="6096a-200">O tipo não pode ser carregado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-200">The type cannot be loaded.</span>
          </span>
          <span data-ttu-id="6096a-201">Por exemplo, contém um método <see langword="static" /> com a convenção de chamada <see cref="F:System.Reflection.CallingConventions.HasThis" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-201">For example, it contains a <see langword="static" /> method that has the calling convention <see cref="F:System.Reflection.CallingConventions.HasThis" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CreateTypeInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeInfo CreateTypeInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.TypeInfo CreateTypeInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateTypeInfo () As TypeInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::TypeInfo ^ CreateTypeInfo();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="6096a-202">Obtém um objeto <see cref="T:System.Reflection.TypeInfo" /> que representa esse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-202">Gets a <see cref="T:System.Reflection.TypeInfo" /> object that represents this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-203">Um objeto que representa esse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-203">An object that represents this type.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-204">Obtém o método que declarou o parâmetro de tipo genérico atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-204">Gets the method that declared the current generic type parameter.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6096a-205">Um <see cref="T:System.Reflection.MethodBase" /> que representa o método que é declarado como tipo atual, se o tipo atual é um parâmetro de tipo genérico; caso contrário, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-205">A <see cref="T:System.Reflection.MethodBase" /> that represents the method that declared the current type, if the current type is a generic type parameter; otherwise, <see langword="null" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="6096a-206">Ao emitir código, um parâmetro de tipo genérico é representado por um <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto em vez de um <xref:System.Reflection.Emit.TypeBuilder> objeto.</span><span class="sxs-lookup"><span data-stu-id="6096a-206">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-207">Retorna o tipo que declarou esse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-207">Returns the type that declared this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6096a-208">Somente leitura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-208">Read-only.</span>
          </span>
          <span data-ttu-id="6096a-209">O tipo que este tipo declarado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-209">The type that declared this type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineConstructor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-210">Adiciona um novo construtor ao tipo dinâmico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-210">Adds a new constructor to the dynamic type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineConstructor (attributes As MethodAttributes, callingConvention As CallingConventions, parameterTypes As Type()) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineConstructor(System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="attributes">
          <span data-ttu-id="6096a-211">Os atributos do construtor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-211">The attributes of the constructor.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="6096a-212">A convenção de chamada do construtor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-212">The calling convention of the constructor.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="6096a-213">Os tipos de parâmetro do construtor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-213">The parameter types of the constructor.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-214">Adiciona um novo construtor ao tipo, com a assinatura e os atributos determinados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-214">Adds a new constructor to the type, with the given attributes and signature.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-215">O construtor definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-215">The defined constructor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-216">Se você não definir um construtor para o tipo dinâmico, um construtor padrão é fornecido automaticamente, e ele chama o construtor padrão da classe base.</span><span class="sxs-lookup"><span data-stu-id="6096a-216">If you do not define a constructor for your dynamic type, a default constructor is provided automatically, and it calls the default constructor of the base class.</span></span>  
  
 <span data-ttu-id="6096a-217">Se você definir um construtor para o tipo dinâmico, não é fornecido um construtor padrão.</span><span class="sxs-lookup"><span data-stu-id="6096a-217">If you define a constructor for your dynamic type, a default constructor is not provided.</span></span> <span data-ttu-id="6096a-218">Você tem as seguintes opções para fornecer um construtor padrão, além de construtor definido:</span><span class="sxs-lookup"><span data-stu-id="6096a-218">You have the following options for providing a default constructor in addition to the constructor you defined:</span></span>  
  
-   <span data-ttu-id="6096a-219">Se você quiser um construtor padrão que simplesmente chama o construtor padrão da classe base, você pode usar o <xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A> método para criar um (e opcionalmente restringir o acesso a ele).</span><span class="sxs-lookup"><span data-stu-id="6096a-219">If you want a default constructor that simply calls the default constructor of the base class, you can use the <xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A> method to create one (and optionally restrict access to it).</span></span> <span data-ttu-id="6096a-220">Não fornece uma implementação para esse construtor padrão.</span><span class="sxs-lookup"><span data-stu-id="6096a-220">Do not provide an implementation for this default constructor.</span></span> <span data-ttu-id="6096a-221">Se você fizer isso, uma exceção é lançada quando você tentar usar o construtor.</span><span class="sxs-lookup"><span data-stu-id="6096a-221">If you do, an exception is thrown when you try to use the constructor.</span></span> <span data-ttu-id="6096a-222">Nenhuma exceção é lançada quando o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método é chamado.</span><span class="sxs-lookup"><span data-stu-id="6096a-222">No exception is thrown when the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method is called.</span></span>  
  
-   <span data-ttu-id="6096a-223">Se você quiser um construtor padrão que não algo mais do que simplesmente chamar o construtor padrão da classe base, ou que chama outro construtor de classe base ou que faz outra coisa totalmente, você deve usar o <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType> método para criar um e fornecer sua própria implementação.</span><span class="sxs-lookup"><span data-stu-id="6096a-223">If you want a default constructor that does something more than simply calling the default constructor of the base class, or that calls another constructor of the base class, or that does something else entirely, you must use the <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType> method to create one, and provide your own implementation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6096a-224">O exemplo de código a seguir demonstra o uso de `DefineConstructor` para definir um construtor determinada assinatura e atributos em um tipo dinâmico e retornar correspondente <xref:System.Reflection.Emit.ConstructorBuilder> para população MSIL.</span><span class="sxs-lookup"><span data-stu-id="6096a-224">The following code sample demonstrates the use of `DefineConstructor` to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <xref:System.Reflection.Emit.ConstructorBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-225">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-225">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes, class System.Type[][] requiredCustomModifiers, class System.Type[][] optionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineConstructor (attributes As MethodAttributes, callingConvention As CallingConventions, parameterTypes As Type(), requiredCustomModifiers As Type()(), optionalCustomModifiers As Type()()) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineConstructor(System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ requiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ optionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="attributes">
          <span data-ttu-id="6096a-226">Os atributos do construtor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-226">The attributes of the constructor.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="6096a-227">A convenção de chamada do construtor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-227">The calling convention of the constructor.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="6096a-228">Os tipos de parâmetro do construtor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-228">The parameter types of the constructor.</span>
          </span>
        </param>
        <param name="requiredCustomModifiers">
          <span data-ttu-id="6096a-229">Uma matriz de matrizes de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-229">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="6096a-230">Cada matriz de tipos representa os modificadores personalizados obrigatórios para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-230">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="6096a-231">Se um determinado parâmetro tiver não modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-231">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="6096a-232">Se nenhum dos parâmetros tiver modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de matrizes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-232">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <param name="optionalCustomModifiers">
          <span data-ttu-id="6096a-233">Uma matriz de matrizes de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-233">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="6096a-234">Cada matriz de tipos representa os modificadores personalizados opcionais para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-234">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="6096a-235">Se um determinado parâmetro tiver não modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-235">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="6096a-236">Se nenhum dos parâmetros tiver modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de matrizes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-236">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-237">Adiciona um novo construtor ao tipo, com os atributos, a assinatura e os modificadores personalizados determinados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-237">Adds a new constructor to the type, with the given attributes, signature, and custom modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-238">O construtor definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-238">The defined constructor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-239">Essa sobrecarga é fornecida para os designers de compiladores gerenciados.</span><span class="sxs-lookup"><span data-stu-id="6096a-239">This overload is provided for designers of managed compilers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6096a-240">Para obter mais informações sobre modificadores personalizados, consulte a documentação de metadados da ECMA partição II.</span><span class="sxs-lookup"><span data-stu-id="6096a-240">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="6096a-241">A documentação está disponível online; confira [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212), no MSDN, e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552), no site internacional da Ecma.</span><span class="sxs-lookup"><span data-stu-id="6096a-241">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-242">O tamanho de <paramref name="requiredCustomModifiers" /> ou <paramref name="optionalCustomModifiers" /> não é igual ao tamanho de <paramref name="parameterTypes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-242">The size of <paramref name="requiredCustomModifiers" /> or <paramref name="optionalCustomModifiers" /> does not equal the size of <paramref name="parameterTypes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-243">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-243">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="6096a-244">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-244">-or-</span>
          </span>
          <span data-ttu-id="6096a-245">Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-245">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDefaultConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor (System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor(valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDefaultConstructor (attributes As MethodAttributes) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineDefaultConstructor(System::Reflection::MethodAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="attributes">
          <span data-ttu-id="6096a-246">Um objeto <see langword="MethodAttributes" /> que representa os atributos a serem aplicados ao construtor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-246">A <see langword="MethodAttributes" /> object representing the attributes to be applied to the constructor.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-247">Define o construtor padrão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-247">Defines the default constructor.</span>
          </span>
          <span data-ttu-id="6096a-248">O construtor definido aqui simplesmente chamará o construtor padrão do pai.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-248">The constructor defined here will simply call the default constructor of the parent.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-249">Retorna o construtor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-249">Returns the constructor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-250">Como o construtor padrão é definido automaticamente, é necessário chamar esse método somente nas seguintes situações:</span><span class="sxs-lookup"><span data-stu-id="6096a-250">Because the default constructor is automatically defined, it is necessary to call this method only in the following situations:</span></span>  
  
-   <span data-ttu-id="6096a-251">Você definiu outro construtor e você deseja que um construtor padrão que simplesmente chama o construtor de classe base.</span><span class="sxs-lookup"><span data-stu-id="6096a-251">You have defined another constructor and you also want a default constructor that simply calls the base class constructor.</span></span>  
  
-   <span data-ttu-id="6096a-252">Para definir os atributos em que o construtor padrão para algo diferente de <xref:System.Reflection.MethodAttributes.PrivateScope>, <xref:System.Reflection.MethodAttributes.Public>, <xref:System.Reflection.MethodAttributes.HideBySig>, <xref:System.Reflection.MethodAttributes.SpecialName>, e <xref:System.Reflection.MethodAttributes.RTSpecialName>.</span><span class="sxs-lookup"><span data-stu-id="6096a-252">You want to set the attributes on the default constructor to something other than <xref:System.Reflection.MethodAttributes.PrivateScope>, <xref:System.Reflection.MethodAttributes.Public>, <xref:System.Reflection.MethodAttributes.HideBySig>, <xref:System.Reflection.MethodAttributes.SpecialName>, and <xref:System.Reflection.MethodAttributes.RTSpecialName>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6096a-253">O exemplo de código a seguir demonstra o uso de `DefineConstructor` para definir um construtor determinada assinatura e atributos em um tipo dinâmico e retornar correspondente <xref:System.Reflection.Emit.ConstructorBuilder> para população MSIL.</span><span class="sxs-lookup"><span data-stu-id="6096a-253">The following code sample demonstrates the use of `DefineConstructor` to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <xref:System.Reflection.Emit.ConstructorBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="6096a-254">O tipo pai (tipo base) não tem um construtor padrão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-254">The parent type (base type) does not have a default constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-255">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-255">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="6096a-256">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-256">-or-</span>
          </span>
          <span data-ttu-id="6096a-257">Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-257">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.EventBuilder DefineEvent (string name, System.Reflection.EventAttributes attributes, Type eventtype);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.EventBuilder DefineEvent(string name, valuetype System.Reflection.EventAttributes attributes, class System.Type eventtype) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineEvent (name As String, attributes As EventAttributes, eventtype As Type) As EventBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::EventBuilder ^ DefineEvent(System::String ^ name, System::Reflection::EventAttributes attributes, Type ^ eventtype);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.EventBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.EventAttributes" />
        <Parameter Name="eventtype" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-258">O nome do evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-258">The name of the event.</span>
          </span>
          <span data-ttu-id="6096a-259">
            <c>name</c> não pode conter nulos inseridos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-259">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="6096a-260">Os atributos do evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-260">The attributes of the event.</span>
          </span>
        </param>
        <param name="eventtype">
          <span data-ttu-id="6096a-261">O tipo do evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-261">The type of the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-262">Adiciona um novo evento ao tipo, com o nome, os atributos e o tipo de evento determinados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-262">Adds a new event to the type, with the given name, attributes and event type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-263">O evento definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-263">The defined event.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-264">O comprimento de <paramref name="name" /> é zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-264">The length of <paramref name="name" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-265">
            <paramref name="name" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-265">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="6096a-266">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-266">-or-</span>
          </span>
          <span data-ttu-id="6096a-267">
            <paramref name="eventtype" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-267">
              <paramref name="eventtype" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-268">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-268">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineField">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-269">Adiciona um novo campo ao tipo dinâmico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-269">Adds a new field to the dynamic type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineField(System::String ^ fieldName, Type ^ type, System::Reflection::FieldAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName">
          <span data-ttu-id="6096a-270">O nome do campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-270">The name of the field.</span>
          </span>
          <span data-ttu-id="6096a-271">
            <c>fieldName</c> não pode conter nulos inseridos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-271">
              <c>fieldName</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="6096a-272">O tipo do campo</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-272">The type of the field</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="6096a-273">Os atributos do campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-273">The attributes of the field.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-274">Adiciona um novo campo ao tipo, com o nome, os atributos e o tipo de campo determinados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-274">Adds a new field to the type, with the given name, attributes, and field type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-275">O campo definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-275">The defined field.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-276">O comprimento de <paramref name="fieldName" /> é zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-276">The length of <paramref name="fieldName" /> is zero.</span>
          </span>
          <span data-ttu-id="6096a-277">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-277">-or-</span>
          </span>
          <span data-ttu-id="6096a-278">
            <paramref name="type" /> é System.Void.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-278">
              <paramref name="type" /> is System.Void.</span>
          </span>
          <span data-ttu-id="6096a-279">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-279">-or-</span>
          </span>
          <span data-ttu-id="6096a-280">Um tamanho total foi especificado para a classe pai desse campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-280">A total size was specified for the parent class of this field.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-281">
            <paramref name="fieldName" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-281">
              <paramref name="fieldName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-282">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-282">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, class System.Type[] requiredCustomModifiers, class System.Type[] optionalCustomModifiers, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineField(System::String ^ fieldName, Type ^ type, cli::array &lt;Type ^&gt; ^ requiredCustomModifiers, cli::array &lt;Type ^&gt; ^ optionalCustomModifiers, System::Reflection::FieldAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName">
          <span data-ttu-id="6096a-283">O nome do campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-283">The name of the field.</span>
          </span>
          <span data-ttu-id="6096a-284">
            <c>fieldName</c> não pode conter nulos inseridos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-284">
              <c>fieldName</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="6096a-285">O tipo do campo</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-285">The type of the field</span>
          </span>
        </param>
        <param name="requiredCustomModifiers">
          <span data-ttu-id="6096a-286">Uma matriz de tipos que representa os modificadores personalizados obrigatórios para o campo, como <see cref="T:Microsoft.VisualC.IsConstModifier" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-286">An array of types representing the required custom modifiers for the field, such as <see cref="T:Microsoft.VisualC.IsConstModifier" />.</span>
          </span>
        </param>
        <param name="optionalCustomModifiers">
          <span data-ttu-id="6096a-287">Uma matriz de tipos que representa os modificadores personalizados opcionais para o campo, como <see cref="T:Microsoft.VisualC.IsConstModifier" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-287">An array of types representing the optional custom modifiers for the field, such as <see cref="T:Microsoft.VisualC.IsConstModifier" />.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="6096a-288">Os atributos do campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-288">The attributes of the field.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-289">Adiciona um novo campo ao tipo, com o nome, os atributos, o tipo de campo e os modificadores personalizados determinados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-289">Adds a new field to the type, with the given name, attributes, field type, and custom modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-290">O campo definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-290">The defined field.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-291">Essa sobrecarga é fornecida para os designers de compiladores gerenciados.</span><span class="sxs-lookup"><span data-stu-id="6096a-291">This overload is provided for designers of managed compilers.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-292">O comprimento de <paramref name="fieldName" /> é zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-292">The length of <paramref name="fieldName" /> is zero.</span>
          </span>
          <span data-ttu-id="6096a-293">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-293">-or-</span>
          </span>
          <span data-ttu-id="6096a-294">
            <paramref name="type" /> é System.Void.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-294">
              <paramref name="type" /> is System.Void.</span>
          </span>
          <span data-ttu-id="6096a-295">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-295">-or-</span>
          </span>
          <span data-ttu-id="6096a-296">Um tamanho total foi especificado para a classe pai desse campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-296">A total size was specified for the parent class of this field.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-297">
            <paramref name="fieldName" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-297">
              <paramref name="fieldName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-298">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-298">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGenericParameters">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (params string[] names);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters(string[] names) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGenericParameters (ParamArray names As String()) As GenericTypeParameterBuilder()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Emit::GenericTypeParameterBuilder ^&gt; ^ DefineGenericParameters(... cli::array &lt;System::String ^&gt; ^ names);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.GenericTypeParameterBuilder[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="names">
          <span data-ttu-id="6096a-299">Uma matriz de nomes para os parâmetros de tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-299">An array of names for the generic type parameters.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-300">Define os parâmetros de tipo genérico do tipo atual, especificando seus números e nomes, e retorna uma matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que podem ser usados para definir suas restrições.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-300">Defines the generic type parameters for the current type, specifying their number and their names, and returns an array of <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objects that can be used to set their constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-301">Uma matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que podem ser usados para definir as restrições dos parâmetros de tipo genérico do tipo atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-301">An array of <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objects that can be used to define the constraints of the generic type parameters for the current type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-302">Chamar esse método torna o tipo atual em um tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="6096a-302">Calling this method makes the current type a generic type.</span></span> <span data-ttu-id="6096a-303">Se o método é chamado novamente do mesmo tipo, um <xref:System.InvalidOperationException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="6096a-303">If the method is called again on the same type, an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6096a-304">O exemplo de código a seguir cria um tipo genérico com dois parâmetros de tipo e salva-os no assembly GenericEmitExample1.dll.</span><span class="sxs-lookup"><span data-stu-id="6096a-304">The following code example creates a generic type with two type parameters and saves them in the assembly GenericEmitExample1.dll.</span></span> <span data-ttu-id="6096a-305">Você pode usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para exibir os tipos gerados.</span><span class="sxs-lookup"><span data-stu-id="6096a-305">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to view the generated types.</span></span> <span data-ttu-id="6096a-306">Para obter uma explicação mais detalhada das etapas envolvidas na definição de um tipo genérico dinâmico, consulte [como: definir um tipo genérico com emissão de reflexão](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md).</span><span class="sxs-lookup"><span data-stu-id="6096a-306">For a more detailed explanation of the steps involved in defining a dynamic generic type, see [How to: Define a Generic Type with Reflection Emit](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md).</span></span>  
  
 [!code-cpp[EmitGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#1)]
 [!code-csharp[EmitGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#1)]
 [!code-vb[EmitGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-307">Os parâmetros de tipo genérico já foram definidos para esse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-307">Generic type parameters have already been defined for this type.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-308">
            <paramref name="names" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-308">
              <paramref name="names" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="6096a-309">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-309">-or-</span>
          </span>
          <span data-ttu-id="6096a-310">Um elemento de <paramref name="names" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-310">An element of <paramref name="names" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-311">
            <paramref name="names" /> é uma matriz vazia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-311">
              <paramref name="names" /> is an empty array.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="DefineInitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineInitializedData (string name, byte[] data, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineInitializedData(string name, unsigned int8[] data, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineInitializedData (name As String, data As Byte(), attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineInitializedData(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data, System::Reflection::FieldAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-312">O nome usado para fazer referência aos dados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-312">The name used to refer to the data.</span>
          </span>
          <span data-ttu-id="6096a-313">
            <c>name</c> não pode conter nulos inseridos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-313">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="data">
          <span data-ttu-id="6096a-314">O blob de dados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-314">The blob of data.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="6096a-315">Os atributos do campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-315">The attributes for the field.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-316">Define o campo de dados inicializado na seção .sdata do arquivo PE (executável portátil).</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-316">Defines initialized data field in the .sdata section of the portable executable (PE) file.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-317">Um campo para fazer referência aos dados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-317">A field to reference the data.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-318">O campo que você criar com esse método será `static`, mesmo se você não incluir `FieldAttributes.Static` no `attributes` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="6096a-318">The field that you create with this method will be `static`, even if you do not include `FieldAttributes.Static` in the `attributes` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-319">O tamanho de <paramref name="name" /> é zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-319">Length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="6096a-320">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-320">-or-</span>
          </span>
          <span data-ttu-id="6096a-321">O tamanho dos dados é menor que ou igual a zero, ou maior que ou igual a 0x3f0000.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-321">The size of the data is less than or equal to zero, or greater than or equal to 0x3f0000.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-322">
            <paramref name="name" /> ou <paramref name="data" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-322">
              <paramref name="name" /> or <paramref name="data" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-323">
            <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> foi chamado anteriormente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-323">
              <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> has been previously called.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-324">Adiciona um método ao tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-324">Adds a method to the type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-325">O nome do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-325">The name of the method.</span>
          </span>
          <span data-ttu-id="6096a-326">
            <c>name</c> não pode conter nulos inseridos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-326">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="6096a-327">Os atributos do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-327">The attributes of the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-328">Adiciona um novo método ao tipo, com o nome e os atributos de método especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-328">Adds a new method to the type, with the specified name and method attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-329">Um <see cref="T:System.Reflection.Emit.MethodBuilder" /> representando o método recém-definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-329">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the newly defined method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-330">Use essa sobrecarga de método quando você não souber a assinatura do método no momento em que você definir o método.</span><span class="sxs-lookup"><span data-stu-id="6096a-330">Use this method overload when you do not know the method signature at the time you define the method.</span></span> <span data-ttu-id="6096a-331">Por exemplo, os tipos de parâmetro e tipo de retorno de um método genérico podem ser especificados pelos parâmetros de tipo genérico do método, que devem ser definidos depois que o método foi adicionado para o tipo.</span><span class="sxs-lookup"><span data-stu-id="6096a-331">For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type.</span></span> <span data-ttu-id="6096a-332">Os parâmetros e o tipo de retorno do método podem ser definidos mais tarde usando o <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="6096a-332">The parameters and return type of the method can be set later using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="6096a-333">Essa sobrecarga de método define um método com <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="6096a-333">This method overload defines a method with <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.</span></span> <span data-ttu-id="6096a-334">Se você precisa definir um método sem uma assinatura, com uma convenção de chamada diferente, use o <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> sobrecarga do método.</span><span class="sxs-lookup"><span data-stu-id="6096a-334">If you need to define a method without a signature, with a different calling convention, use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6096a-335">O exemplo de código a seguir define um método genérico chamado `DemoMethod` cujo tipo de parâmetro e tipo de retorno são especificados por seus parâmetros de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="6096a-335">The following code example defines a generic method named `DemoMethod` whose parameter type and return type are specified by its generic type parameters.</span></span> <span data-ttu-id="6096a-336">O método está definido sem uma assinatura, usando a convenção de chamada padrão.</span><span class="sxs-lookup"><span data-stu-id="6096a-336">The method is defined without a signature, using the standard calling convention.</span></span> <span data-ttu-id="6096a-337">O <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> método é usado para fazer `DemoMethod` um método genérico e os parâmetros de tipo definidos recentemente são usados para a assinatura e tipo de retorno.</span><span class="sxs-lookup"><span data-stu-id="6096a-337">The <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method is used to make `DemoMethod` a generic method, and the newly defined type parameters are then used for the signature and return type.</span></span>  
  
 <span data-ttu-id="6096a-338">Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> método.</span><span class="sxs-lookup"><span data-stu-id="6096a-338">This code example is part of a larger example provided for the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method.</span></span>  
  
 [!code-cpp[GenericMethodBuilder#4](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#4)]
 [!code-csharp[GenericMethodBuilder#4](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#4)]
 [!code-vb[GenericMethodBuilder#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#4)]  
[!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
[!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
[!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-339">O comprimento de <paramref name="name" /> é zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-339">The length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="6096a-340">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-340">-or-</span>
          </span>
          <span data-ttu-id="6096a-341">O tipo de pai desse método é uma interface e esse método não é virtual (<see langword="Overridable" /> no Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-341">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-342">
            <paramref name="name" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-342">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-343">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-343">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="6096a-344">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-344">-or-</span>
          </span>
          <span data-ttu-id="6096a-345">Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-345">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-346">O nome do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-346">The name of the method.</span>
          </span>
          <span data-ttu-id="6096a-347">
            <c>name</c> não pode conter nulos inseridos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-347">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="6096a-348">Os atributos do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-348">The attributes of the method.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="6096a-349">A convenção de chamada do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-349">The calling convention of the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-350">Adiciona um novo método ao tipo, com o nome, os atributos de método e a convenção de chamada especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-350">Adds a new method to the type, with the specified name, method attributes, and calling convention.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-351">Um <see cref="T:System.Reflection.Emit.MethodBuilder" /> representando o método recém-definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-351">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the newly defined method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-352">Use essa sobrecarga de método quando você não souber a assinatura do método no momento em que você definir o método.</span><span class="sxs-lookup"><span data-stu-id="6096a-352">Use this method overload when you do not know the method signature at the time you define the method.</span></span> <span data-ttu-id="6096a-353">Por exemplo, os tipos de parâmetro e tipo de retorno de um método genérico podem ser especificados pelos parâmetros de tipo genérico do método, que devem ser definidos depois que o método foi adicionado para o tipo.</span><span class="sxs-lookup"><span data-stu-id="6096a-353">For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type.</span></span> <span data-ttu-id="6096a-354">Os parâmetros e o tipo de retorno do método podem ser definidos mais tarde usando o <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="6096a-354">The parameters and return type of the method can be set later using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-355">O comprimento de <paramref name="name" /> é zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-355">The length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="6096a-356">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-356">-or-</span>
          </span>
          <span data-ttu-id="6096a-357">O tipo de pai desse método é uma interface e esse método não é virtual (<see langword="Overridable" /> no Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-357">The type of the parent of this method is an interface and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-358">
            <paramref name="name" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-358">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-359">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-359">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="6096a-360">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-360">-or-</span>
          </span>
          <span data-ttu-id="6096a-361">Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-361">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-362">O nome do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-362">The name of the method.</span>
          </span>
          <span data-ttu-id="6096a-363">
            <c>name</c> não pode conter nulos inseridos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-363">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="6096a-364">Os atributos do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-364">The attributes of the method.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="6096a-365">O tipo de retorno do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-365">The return type of the method.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="6096a-366">Os tipos dos parâmetros do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-366">The types of the parameters of the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-367">Adiciona um novo método ao tipo, com o nome, os atributos de método e a assinatura de método especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-367">Adds a new method to the type, with the specified name, method attributes, and method signature.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-368">O método definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-368">The defined method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="6096a-369">O exemplo de código a seguir demonstra o uso de `DefineMethod` para definir um construtor determinada assinatura e atributos em um tipo dinâmico e retornar um correspondente <xref:System.Reflection.Emit.MethodBuilder> para população MSIL.</span><span class="sxs-lookup"><span data-stu-id="6096a-369">The following code sample demonstrates the use of `DefineMethod` to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <xref:System.Reflection.Emit.MethodBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-370">O comprimento de <paramref name="name" /> é zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-370">The length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="6096a-371">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-371">-or-</span>
          </span>
          <span data-ttu-id="6096a-372">O tipo de pai desse método é uma interface e esse método não é virtual (<see langword="Overridable" /> no Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-372">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-373">
            <paramref name="name" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-373">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-374">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-374">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="6096a-375">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-375">-or-</span>
          </span>
          <span data-ttu-id="6096a-376">Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-376">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-377">O nome do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-377">The name of the method.</span>
          </span>
          <span data-ttu-id="6096a-378">
            <c>name</c> não pode conter nulos inseridos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-378">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="6096a-379">Os atributos do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-379">The attributes of the method.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="6096a-380">A convenção de chamada do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-380">The calling convention of the method.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="6096a-381">O tipo de retorno do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-381">The return type of the method.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="6096a-382">Os tipos dos parâmetros do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-382">The types of the parameters of the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-383">Adiciona um novo método ao tipo, com o nome, atributos de método, convenção de chamada e assinatura de método especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-383">Adds a new method to the type, with the specified name, method attributes, calling convention, and method signature.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-384">Um <see cref="T:System.Reflection.Emit.MethodBuilder" /> representando o método recém-definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-384">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the newly defined method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="6096a-385">O exemplo de código a seguir demonstra o uso de `DefineMethod` para definir um construtor determinada assinatura e atributos em um tipo dinâmico e retornar um correspondente <xref:System.Reflection.Emit.MethodBuilder> para população MSIL.</span><span class="sxs-lookup"><span data-stu-id="6096a-385">The following code sample demonstrates the use of `DefineMethod` to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <xref:System.Reflection.Emit.MethodBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-386">O comprimento de <paramref name="name" /> é zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-386">The length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="6096a-387">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-387">-or-</span>
          </span>
          <span data-ttu-id="6096a-388">O tipo de pai desse método é uma interface e esse método não é virtual (<see langword="Overridable" /> no Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-388">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-389">
            <paramref name="name" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-389">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-390">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-390">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="6096a-391">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-391">-or-</span>
          </span>
          <span data-ttu-id="6096a-392">Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-392">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-393">O nome do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-393">The name of the method.</span>
          </span>
          <span data-ttu-id="6096a-394">
            <c>name</c> não pode conter nulos inseridos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-394">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="6096a-395">Os atributos do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-395">The attributes of the method.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="6096a-396">A convenção de chamada do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-396">The calling convention of the method.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="6096a-397">O tipo de retorno do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-397">The return type of the method.</span>
          </span>
        </param>
        <param name="returnTypeRequiredCustomModifiers">
          <span data-ttu-id="6096a-398">Uma matriz de tipos que representam os modificadores personalizados obrigatórios, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-398">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span>
          </span>
          <span data-ttu-id="6096a-399">Se o tipo de retorno não tiver modificadores personalizados obrigatórios, especifique <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-399">If the return type has no required custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="returnTypeOptionalCustomModifiers">
          <span data-ttu-id="6096a-400">Uma matriz de tipos que representam os modificadores personalizados opcionais, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-400">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span>
          </span>
          <span data-ttu-id="6096a-401">Se o tipo de retorno não tiver modificadores personalizados opcionais, especifique <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-401">If the return type has no optional custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="6096a-402">Os tipos dos parâmetros do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-402">The types of the parameters of the method.</span>
          </span>
        </param>
        <param name="parameterTypeRequiredCustomModifiers">
          <span data-ttu-id="6096a-403">Uma matriz de matrizes de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-403">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="6096a-404">Cada matriz de tipos representa os modificadores personalizados obrigatórios para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-404">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="6096a-405">Se um determinado parâmetro tiver não modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-405">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="6096a-406">Se nenhum dos parâmetros tiver modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de matrizes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-406">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <param name="parameterTypeOptionalCustomModifiers">
          <span data-ttu-id="6096a-407">Uma matriz de matrizes de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-407">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="6096a-408">Cada matriz de tipos representa os modificadores personalizados opcionais para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-408">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="6096a-409">Se um determinado parâmetro tiver não modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-409">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="6096a-410">Se nenhum dos parâmetros tiver modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de matrizes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-410">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-411">Adiciona um novo método ao tipo, com o nome, os atributos de método, a convenção de chamada, a assinatura de método e os modificadores personalizados especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-411">Adds a new method to the type, with the specified name, method attributes, calling convention, method signature, and custom modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-412">Um objeto <see cref="T:System.Reflection.Emit.MethodBuilder" /> que representa o método recém-adicionado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-412">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> object representing the newly added method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-413">Use essa sobrecarga se você precisar especificar modificadores personalizados.</span><span class="sxs-lookup"><span data-stu-id="6096a-413">Use this overload if you need to specify custom modifiers.</span></span> <span data-ttu-id="6096a-414">Se você precisa especificar modificadores personalizados depois que o método tiver sido criado, como, por exemplo, com um método genérico cujos tipos de parâmetro são especificados por seus parâmetros de tipo genérico, você pode usar o <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> ou <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> sobrecargas do método para definir o método e, em seguida, use o <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> método para definir o parâmetro e retornar tipos com modificadores personalizados.</span><span class="sxs-lookup"><span data-stu-id="6096a-414">If you need to specify custom modifiers after the method has been created, as you would, for example, with a generic method whose parameter types are specified by its generic type parameters, you can use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> or <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> method overloads to define the method and then use the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method to define the parameter and return types with custom modifiers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6096a-415">Para obter mais informações sobre modificadores personalizados, consulte a documentação de metadados da ECMA partição II.</span><span class="sxs-lookup"><span data-stu-id="6096a-415">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="6096a-416">A documentação está disponível online; confira [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212), no MSDN, e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552), no site internacional da Ecma.</span><span class="sxs-lookup"><span data-stu-id="6096a-416">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-417">O comprimento de <paramref name="name" /> é zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-417">The length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="6096a-418">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-418">-or-</span>
          </span>
          <span data-ttu-id="6096a-419">O tipo de pai desse método é uma interface e esse método não é virtual (<see langword="Overridable" /> no Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-419">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span>
          </span>
          <span data-ttu-id="6096a-420">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-420">-or-</span>
          </span>
          <span data-ttu-id="6096a-421">O tamanho de <paramref name="parameterTypeRequiredCustomModifiers" /> ou <paramref name="parameterTypeOptionalCustomModifiers" /> não é igual ao tamanho de <paramref name="parameterTypes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-421">The size of <paramref name="parameterTypeRequiredCustomModifiers" /> or <paramref name="parameterTypeOptionalCustomModifiers" /> does not equal the size of <paramref name="parameterTypes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-422">
            <paramref name="name" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-422">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-423">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-423">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="6096a-424">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-424">-or-</span>
          </span>
          <span data-ttu-id="6096a-425">Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-425">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethodOverride">
      <MemberSignature Language="C#" Value="public void DefineMethodOverride (System.Reflection.MethodInfo methodInfoBody, System.Reflection.MethodInfo methodInfoDeclaration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineMethodOverride(class System.Reflection.MethodInfo methodInfoBody, class System.Reflection.MethodInfo methodInfoDeclaration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DefineMethodOverride (methodInfoBody As MethodInfo, methodInfoDeclaration As MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineMethodOverride(System::Reflection::MethodInfo ^ methodInfoBody, System::Reflection::MethodInfo ^ methodInfoDeclaration);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodInfoBody" Type="System.Reflection.MethodInfo" />
        <Parameter Name="methodInfoDeclaration" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="methodInfoBody">
          <span data-ttu-id="6096a-426">O corpo do método a ser usado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-426">The method body to be used.</span>
          </span>
          <span data-ttu-id="6096a-427">Isso deve ser um objeto <see langword="MethodBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-427">This should be a <see langword="MethodBuilder" /> object.</span>
          </span>
        </param>
        <param name="methodInfoDeclaration">
          <span data-ttu-id="6096a-428">O método cuja declaração deve ser usada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-428">The method whose declaration is to be used.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-429">Especifica um corpo de um determinado método que implementa uma declaração do mesmo, possivelmente com um nome diferente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-429">Specifies a given method body that implements a given method declaration, potentially with a different name.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-430">Não use esse método para emitir substituições de método ou implementações de interface.</span><span class="sxs-lookup"><span data-stu-id="6096a-430">Do not use this method to emit method overrides or interface implementations.</span></span> <span data-ttu-id="6096a-431">Para substituir um método de uma classe base ou para implementar um método de uma interface, simplesmente emita um método com o mesmo nome e assinatura como o método a ser substituído ou implementada, conforme demonstrado no exemplo de código.</span><span class="sxs-lookup"><span data-stu-id="6096a-431">To override a method of a base class or to implement a method of an interface, simply emit a method with the same name and signature as the method to be overridden or implemented, as demonstrated in the code example.</span></span>  
  
 <span data-ttu-id="6096a-432">O <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> método é usado quando um corpo de método e uma declaração de método têm nomes diferentes.</span><span class="sxs-lookup"><span data-stu-id="6096a-432">The <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method is used when a method body and a method declaration have different names.</span></span> <span data-ttu-id="6096a-433">Por exemplo, uma classe pode substituir um método de classe base e também fornecem uma implementação separada para um membro de interface com o mesmo nome, conforme demonstrado no exemplo de código.</span><span class="sxs-lookup"><span data-stu-id="6096a-433">For example, a class might override a base class method and also provide a separate implementation for an interface member with the same name, as demonstrated in the code example.</span></span>  
  
 <span data-ttu-id="6096a-434">`DefineMethodOverride` define um `methodimpl`, que consiste em um par de tokens de metadados.</span><span class="sxs-lookup"><span data-stu-id="6096a-434">`DefineMethodOverride` defines a `methodimpl`, which consists of a pair of metadata tokens.</span></span> <span data-ttu-id="6096a-435">Um token aponta para uma implementação e os outros pontos de token para uma declaração que implementa o corpo.</span><span class="sxs-lookup"><span data-stu-id="6096a-435">One token points to an implementation, and the other token points to a declaration that the body implements.</span></span> <span data-ttu-id="6096a-436">O corpo deve ser definido no tipo de implementação de método é definida em e o corpo deve ser virtual (`Overridable` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="6096a-436">The body must be defined on the type the method impl is defined on, and the body must be virtual (`Overridable` in Visual Basic).</span></span> <span data-ttu-id="6096a-437">A declaração pode ser feita para um método definido em uma interface implementada por um método definido no tipo, um método em uma classe derivada ou o tipo.</span><span class="sxs-lookup"><span data-stu-id="6096a-437">The declaration can be made to a method defined on an interface implemented by the type, a method on a derived class, or a method defined in the type.</span></span> <span data-ttu-id="6096a-438">Se a declaração estiver em apenas uma interface, o slot definido para a interface é alterado.</span><span class="sxs-lookup"><span data-stu-id="6096a-438">If the declaration is on an interface only, the slot defined for the interface is altered.</span></span> <span data-ttu-id="6096a-439">Se a declaração é feita para um método em um tipo base, o slot para o método é substituído e todas as duplicatas para o método substituído também são substituídas.</span><span class="sxs-lookup"><span data-stu-id="6096a-439">If the declaration is made to a method on a base type, the slot for the method is overridden and any duplicates for the overridden method are also replaced.</span></span> <span data-ttu-id="6096a-440">O método substituído não pode ser o método real que é declarado.</span><span class="sxs-lookup"><span data-stu-id="6096a-440">The overridden method cannot be the actual method that is declared.</span></span> <span data-ttu-id="6096a-441">Se o método é do mesmo tipo, o slot é substituído e todas as duplicatas para os métodos substituídos são substituídas.</span><span class="sxs-lookup"><span data-stu-id="6096a-441">If the method is on the same type, the slot is replaced and any duplicates for the replaced methods are overridden.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6096a-442">Para obter mais informações sobre o método impls, consulte `MethodImpl` na documentação do ECMA partição II metadados.</span><span class="sxs-lookup"><span data-stu-id="6096a-442">For more information about method impls, see `MethodImpl` in the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="6096a-443">A documentação está disponível online; confira [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212), no MSDN, e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552), no site internacional da Ecma.</span><span class="sxs-lookup"><span data-stu-id="6096a-443">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="6096a-444">Após o <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> método é chamado, alguns recursos do `methodInfoBody` não pode ser alterado.</span><span class="sxs-lookup"><span data-stu-id="6096a-444">After the <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method is called, some features of `methodInfoBody` cannot be changed.</span></span> <span data-ttu-id="6096a-445">Por exemplo, você não pode aplicar um atributo a um parâmetro de tipo genérico do `methodInfoBody` usando o <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> método.</span><span class="sxs-lookup"><span data-stu-id="6096a-445">For example, you cannot apply an attribute to a generic type parameter of `methodInfoBody` by using the <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> method.</span></span> <span data-ttu-id="6096a-446">Se você deve usar o <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> método, fazer isso depois de todas as características de `methodInfoBody` foram definidas.</span><span class="sxs-lookup"><span data-stu-id="6096a-446">If you must use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method, do so after all characteristics of `methodInfoBody` have been defined.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6096a-447">O exemplo de código a seguir contém uma interface `I` com um método `M()`, uma classe base `A` que implementa a interface e uma classe derivada `C` que substitui a implementação da classe base `M()` e também Fornece uma implementação explícita separada de `I.M()`.</span><span class="sxs-lookup"><span data-stu-id="6096a-447">The following code example contains an interface `I` with a method `M()`, a base class `A` that implements the interface, and a derived class `C` that overrides the base class implementation of `M()` and also provides a separate explicit implementation of `I.M()`.</span></span>  
  
 <span data-ttu-id="6096a-448">O `main()` método do exemplo de código mostra como emissão de classe derivada `C`.</span><span class="sxs-lookup"><span data-stu-id="6096a-448">The `main()` method of the code example shows how to emit the derived class `C`.</span></span> <span data-ttu-id="6096a-449">A substituição de `A.M()` é obtida simplesmente pela emissão de um método `M()` com a mesma assinatura.</span><span class="sxs-lookup"><span data-stu-id="6096a-449">The override of `A.M()` is accomplished simply by emitting a method `M()` with the same signature.</span></span> <span data-ttu-id="6096a-450">No entanto, para fornecer uma implementação separada de `I.M()`, você deve definir um corpo de método e, em seguida, usar o <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> método associar esse corpo de método com um <xref:System.Reflection.MethodInfo> representando `I.M()`.</span><span class="sxs-lookup"><span data-stu-id="6096a-450">However, to provide a separate implementation of `I.M()`, you must define a method body and then use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method to associate that method body with a <xref:System.Reflection.MethodInfo> representing `I.M()`.</span></span> <span data-ttu-id="6096a-451">O nome do corpo do método não importa.</span><span class="sxs-lookup"><span data-stu-id="6096a-451">The name of the method body does not matter.</span></span>  
  
 <span data-ttu-id="6096a-452">O exemplo de código cria uma instância da classe emitida.</span><span class="sxs-lookup"><span data-stu-id="6096a-452">The code example creates an instance of the emitted class.</span></span> <span data-ttu-id="6096a-453">Obtém um <xref:System.Reflection.MethodInfo> de objeto para `I.M()`, e a implementação de interface usos para chamar a classe emitida 's explícita.</span><span class="sxs-lookup"><span data-stu-id="6096a-453">It obtains a <xref:System.Reflection.MethodInfo> object for `I.M()`, and uses it to invoke the emitted class's explicit interface implementation.</span></span> <span data-ttu-id="6096a-454">Em seguida, obtém um <xref:System.Reflection.MethodInfo> de objeto para `A.M()`e o usa para invocar a substituição da classe emitido desse método.</span><span class="sxs-lookup"><span data-stu-id="6096a-454">It then obtains a <xref:System.Reflection.MethodInfo> object for `A.M()`, and uses it to invoke the emitted class's override of that method.</span></span>  
  
 [!code-cpp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cpp/source.cpp#1)]
 [!code-csharp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cs/source.cs#1)]
 [!code-vb[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-455">
            <paramref name="methodInfoBody" /> não pertence a esta classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-455">
              <paramref name="methodInfoBody" /> does not belong to this class.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-456">
            <paramref name="methodInfoBody" /> ou <paramref name="methodInfoDeclaration" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-456">
              <paramref name="methodInfoBody" /> or <paramref name="methodInfoDeclaration" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-457">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-457">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="6096a-458">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-458">-or-</span>
          </span>
          <span data-ttu-id="6096a-459">O tipo de declaração de <paramref name="methodInfoBody" /> não é do tipo representado por este <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-459">The declaring type of <paramref name="methodInfoBody" /> is not the type represented by this <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineNestedType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-460">Define um tipo aninhado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-460">Defines a nested type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-461">O nome curto do tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-461">The short name of the type.</span>
          </span>
          <span data-ttu-id="6096a-462">
            <c>name</c> não pode conter nulos inseridos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-462">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-463">Define um tipo aninhado, após ser informado seu nome.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-463">Defines a nested type, given its name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-464">O tipo aninhado definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-464">The defined nested type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-465">Esse método pode ser usado para criar aninhada tipos após o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método foi chamado no tipo de delimitador.</span><span class="sxs-lookup"><span data-stu-id="6096a-465">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="6096a-466">O tipo aninhado deve ser concluída antes de você pode refletir nele usando <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, ou <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="6096a-466">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="6096a-467">Consulte a descrição de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> para a ordem em que devem ser concluídos tipos aninhados e tipos de aninhamento.</span><span class="sxs-lookup"><span data-stu-id="6096a-467">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="6096a-468">Um nome duplicado não é necessariamente criado se `name` é idêntico ao nome de um tipo definido anteriormente ou tipo aninhado.</span><span class="sxs-lookup"><span data-stu-id="6096a-468">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="6096a-469">Para ser duplicados, os nomes completos devem ser o mesmo, incluindo o namespace e todos os tipos de aninhamento.</span><span class="sxs-lookup"><span data-stu-id="6096a-469">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-470">O comprimento de <paramref name="name" /> é zero ou maior que 1023.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-470">Length of <paramref name="name" /> is zero or greater than 1023.</span>
          </span>
          <span data-ttu-id="6096a-471">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-471">-or-</span>
          </span>
          <span data-ttu-id="6096a-472">Essa operação criaria um tipo com um <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado no assembly atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-472">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-473">
            <paramref name="name" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-473">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-474">O nome curto do tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-474">The short name of the type.</span>
          </span>
          <span data-ttu-id="6096a-475">
            <c>name</c> não pode conter nulos inseridos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-475">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attr">
          <span data-ttu-id="6096a-476">Os atributos do tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-476">The attributes of the type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-477">Define um tipo aninhado, após serem informados seu nome e atributos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-477">Defines a nested type, given its name and attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-478">O tipo aninhado definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-478">The defined nested type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-479">Esse método pode ser usado para criar aninhada tipos após o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método foi chamado no tipo de delimitador.</span><span class="sxs-lookup"><span data-stu-id="6096a-479">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="6096a-480">O tipo aninhado deve ser concluída antes de você pode refletir nele usando <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, ou <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="6096a-480">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="6096a-481">Consulte a descrição de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> para a ordem em que devem ser concluídos tipos aninhados e tipos de aninhamento.</span><span class="sxs-lookup"><span data-stu-id="6096a-481">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="6096a-482">Um nome duplicado não é necessariamente criado se `name` é idêntico ao nome de um tipo definido anteriormente ou tipo aninhado.</span><span class="sxs-lookup"><span data-stu-id="6096a-482">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="6096a-483">Para ser duplicados, os nomes completos devem ser o mesmo, incluindo o namespace e todos os tipos de aninhamento.</span><span class="sxs-lookup"><span data-stu-id="6096a-483">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-484">O atributo aninhado não é especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-484">The nested attribute is not specified.</span>
          </span>
          <span data-ttu-id="6096a-485">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-485">-or-</span>
          </span>
          <span data-ttu-id="6096a-486">Esse tipo está lacrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-486">This type is sealed.</span>
          </span>
          <span data-ttu-id="6096a-487">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-487">-or-</span>
          </span>
          <span data-ttu-id="6096a-488">Esse tipo é uma matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-488">This type is an array.</span>
          </span>
          <span data-ttu-id="6096a-489">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-489">-or-</span>
          </span>
          <span data-ttu-id="6096a-490">Esse tipo é uma interface, mas o tipo aninhado não é uma interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-490">This type is an interface, but the nested type is not an interface.</span>
          </span>
          <span data-ttu-id="6096a-491">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-491">-or-</span>
          </span>
          <span data-ttu-id="6096a-492">O comprimento de <paramref name="name" /> é zero ou maior que 1023.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-492">The length of <paramref name="name" /> is zero or greater than 1023.</span>
          </span>
          <span data-ttu-id="6096a-493">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-493">-or-</span>
          </span>
          <span data-ttu-id="6096a-494">Essa operação criaria um tipo com um <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado no assembly atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-494">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-495">
            <paramref name="name" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-495">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-496">O nome curto do tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-496">The short name of the type.</span>
          </span>
          <span data-ttu-id="6096a-497">
            <c>name</c> não pode conter nulos inseridos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-497">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attr">
          <span data-ttu-id="6096a-498">Os atributos do tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-498">The attributes of the type.</span>
          </span>
        </param>
        <param name="parent">
          <span data-ttu-id="6096a-499">O tipo que o tipo aninhado estende.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-499">The type that the nested type extends.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-500">Define um tipo aninhado, após serem informados seu nome, atributos e o tipo que ele estende.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-500">Defines a nested type, given its name, attributes, and the type that it extends.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-501">O tipo aninhado definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-501">The defined nested type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-502">Esse método pode ser usado para criar aninhada tipos após o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método foi chamado no tipo de delimitador.</span><span class="sxs-lookup"><span data-stu-id="6096a-502">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="6096a-503">O tipo aninhado deve ser concluída antes de você pode refletir nele usando <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, ou <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="6096a-503">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="6096a-504">Consulte a descrição de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> para a ordem em que devem ser concluídos tipos aninhados e tipos de aninhamento.</span><span class="sxs-lookup"><span data-stu-id="6096a-504">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="6096a-505">Um nome duplicado não é necessariamente criado se `name` é idêntico ao nome de um tipo definido anteriormente ou tipo aninhado.</span><span class="sxs-lookup"><span data-stu-id="6096a-505">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="6096a-506">Para ser duplicados, os nomes completos devem ser o mesmo, incluindo o namespace e todos os tipos de aninhamento.</span><span class="sxs-lookup"><span data-stu-id="6096a-506">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-507">O atributo aninhado não é especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-507">The nested attribute is not specified.</span>
          </span>
          <span data-ttu-id="6096a-508">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-508">-or-</span>
          </span>
          <span data-ttu-id="6096a-509">Esse tipo está lacrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-509">This type is sealed.</span>
          </span>
          <span data-ttu-id="6096a-510">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-510">-or-</span>
          </span>
          <span data-ttu-id="6096a-511">Esse tipo é uma matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-511">This type is an array.</span>
          </span>
          <span data-ttu-id="6096a-512">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-512">-or-</span>
          </span>
          <span data-ttu-id="6096a-513">Esse tipo é uma interface, mas o tipo aninhado não é uma interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-513">This type is an interface, but the nested type is not an interface.</span>
          </span>
          <span data-ttu-id="6096a-514">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-514">-or-</span>
          </span>
          <span data-ttu-id="6096a-515">O comprimento de <paramref name="name" /> é zero ou maior que 1023.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-515">The length of <paramref name="name" /> is zero or greater than 1023.</span>
          </span>
          <span data-ttu-id="6096a-516">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-516">-or-</span>
          </span>
          <span data-ttu-id="6096a-517">Essa operação criaria um tipo com um <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado no assembly atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-517">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-518">
            <paramref name="name" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-518">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, typeSize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, int typeSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-519">O nome curto do tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-519">The short name of the type.</span>
          </span>
          <span data-ttu-id="6096a-520">
            <c>name</c> não pode conter nulos inseridos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-520">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attr">
          <span data-ttu-id="6096a-521">Os atributos do tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-521">The attributes of the type.</span>
          </span>
        </param>
        <param name="parent">
          <span data-ttu-id="6096a-522">O tipo que o tipo aninhado estende.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-522">The type that the nested type extends.</span>
          </span>
        </param>
        <param name="typeSize">
          <span data-ttu-id="6096a-523">O tamanho total do tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-523">The total size of the type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-524">Define um tipo aninhado, após serem informados seu nome, atributos, tamanho total do tipo e o tipo que ele estende.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-524">Defines a nested type, given its name, attributes, the total size of the type, and the type that it extends.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-525">O tipo aninhado definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-525">The defined nested type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-526">Esse método pode ser usado para criar aninhada tipos após o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método foi chamado no tipo de delimitador.</span><span class="sxs-lookup"><span data-stu-id="6096a-526">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="6096a-527">O tipo aninhado deve ser concluída antes de você pode refletir nele usando <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, ou <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="6096a-527">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="6096a-528">Consulte a descrição de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> para a ordem em que devem ser concluídos tipos aninhados e tipos de aninhamento.</span><span class="sxs-lookup"><span data-stu-id="6096a-528">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="6096a-529">Um nome duplicado não é necessariamente criado se `name` é idêntico ao nome de um tipo definido anteriormente ou tipo aninhado.</span><span class="sxs-lookup"><span data-stu-id="6096a-529">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="6096a-530">Para ser duplicados, os nomes completos devem ser o mesmo, incluindo o namespace e todos os tipos de aninhamento.</span><span class="sxs-lookup"><span data-stu-id="6096a-530">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-531">O atributo aninhado não é especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-531">The nested attribute is not specified.</span>
          </span>
          <span data-ttu-id="6096a-532">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-532">-or-</span>
          </span>
          <span data-ttu-id="6096a-533">Esse tipo está lacrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-533">This type is sealed.</span>
          </span>
          <span data-ttu-id="6096a-534">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-534">-or-</span>
          </span>
          <span data-ttu-id="6096a-535">Esse tipo é uma matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-535">This type is an array.</span>
          </span>
          <span data-ttu-id="6096a-536">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-536">-or-</span>
          </span>
          <span data-ttu-id="6096a-537">Esse tipo é uma interface, mas o tipo aninhado não é uma interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-537">This type is an interface, but the nested type is not an interface.</span>
          </span>
          <span data-ttu-id="6096a-538">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-538">-or-</span>
          </span>
          <span data-ttu-id="6096a-539">O comprimento de <paramref name="name" /> é zero ou maior que 1023.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-539">The length of <paramref name="name" /> is zero or greater than 1023.</span>
          </span>
          <span data-ttu-id="6096a-540">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-540">-or-</span>
          </span>
          <span data-ttu-id="6096a-541">Essa operação criaria um tipo com um <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado no assembly atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-541">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-542">
            <paramref name="name" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-542">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, packSize As PackingSize) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-543">O nome curto do tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-543">The short name of the type.</span>
          </span>
          <span data-ttu-id="6096a-544">
            <c>name</c> não pode conter nulos inseridos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-544">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attr">
          <span data-ttu-id="6096a-545">Os atributos do tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-545">The attributes of the type.</span>
          </span>
        </param>
        <param name="parent">
          <span data-ttu-id="6096a-546">O tipo que o tipo aninhado estende.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-546">The type that the nested type extends.</span>
          </span>
        </param>
        <param name="packSize">
          <span data-ttu-id="6096a-547">O tamanho de empacotamento do tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-547">The packing size of the type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-548">Define um tipo aninhado, após serem informados seu nome, atributos, tipo que ele estende e tamanho de empacotamento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-548">Defines a nested type, given its name, attributes, the type that it extends, and the packing size.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-549">O tipo aninhado definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-549">The defined nested type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-550">Esse método pode ser usado para criar aninhada tipos após o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método foi chamado no tipo de delimitador.</span><span class="sxs-lookup"><span data-stu-id="6096a-550">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="6096a-551">O tipo aninhado deve ser concluída antes de você pode refletir nele usando <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, ou <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="6096a-551">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="6096a-552">Consulte a descrição de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> para a ordem em que devem ser concluídos tipos aninhados e tipos de aninhamento.</span><span class="sxs-lookup"><span data-stu-id="6096a-552">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="6096a-553">Um nome duplicado não é necessariamente criado se `name` é idêntico ao nome de um tipo definido anteriormente ou tipo aninhado.</span><span class="sxs-lookup"><span data-stu-id="6096a-553">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="6096a-554">Para ser duplicados, os nomes completos devem ser o mesmo, incluindo o namespace e todos os tipos de aninhamento.</span><span class="sxs-lookup"><span data-stu-id="6096a-554">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-555">O atributo aninhado não é especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-555">The nested attribute is not specified.</span>
          </span>
          <span data-ttu-id="6096a-556">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-556">-or-</span>
          </span>
          <span data-ttu-id="6096a-557">Esse tipo está lacrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-557">This type is sealed.</span>
          </span>
          <span data-ttu-id="6096a-558">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-558">-or-</span>
          </span>
          <span data-ttu-id="6096a-559">Esse tipo é uma matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-559">This type is an array.</span>
          </span>
          <span data-ttu-id="6096a-560">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-560">-or-</span>
          </span>
          <span data-ttu-id="6096a-561">Esse tipo é uma interface, mas o tipo aninhado não é uma interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-561">This type is an interface, but the nested type is not an interface.</span>
          </span>
          <span data-ttu-id="6096a-562">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-562">-or-</span>
          </span>
          <span data-ttu-id="6096a-563">O comprimento de <paramref name="name" /> é zero ou maior que 1023.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-563">The length of <paramref name="name" /> is zero or greater than 1023.</span>
          </span>
          <span data-ttu-id="6096a-564">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-564">-or-</span>
          </span>
          <span data-ttu-id="6096a-565">Essa operação criaria um tipo com um <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado no assembly atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-565">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-566">
            <paramref name="name" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-566">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, Type[] interfaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, class System.Type[] interfaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, interfaces As Type()) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, cli::array &lt;Type ^&gt; ^ interfaces);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="interfaces" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-567">O nome curto do tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-567">The short name of the type.</span>
          </span>
          <span data-ttu-id="6096a-568">
            <c>name</c> não pode conter nulos inseridos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-568">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attr">
          <span data-ttu-id="6096a-569">Os atributos do tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-569">The attributes of the type.</span>
          </span>
        </param>
        <param name="parent">
          <span data-ttu-id="6096a-570">O tipo que o tipo aninhado estende.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-570">The type that the nested type extends.</span>
          </span>
        </param>
        <param name="interfaces">
          <span data-ttu-id="6096a-571">As interface implementadas pelo tipo aninhado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-571">The interfaces that the nested type implements.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-572">Define um tipo aninhado, após serem informados seu nome, atributos, tipo que ele estende e as interfaces implementadas por ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-572">Defines a nested type, given its name, attributes, the type that it extends, and the interfaces that it implements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-573">O tipo aninhado definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-573">The defined nested type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-574">Esse método pode ser usado para criar aninhada tipos após o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método foi chamado no tipo de delimitador.</span><span class="sxs-lookup"><span data-stu-id="6096a-574">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="6096a-575">O tipo aninhado deve ser concluída antes de você pode refletir nele usando <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, ou <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="6096a-575">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="6096a-576">Consulte a descrição de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> para a ordem em que devem ser concluídos tipos aninhados e tipos de aninhamento.</span><span class="sxs-lookup"><span data-stu-id="6096a-576">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="6096a-577">Um nome duplicado não é necessariamente criado se `name` é idêntico ao nome de um tipo definido anteriormente ou tipo aninhado.</span><span class="sxs-lookup"><span data-stu-id="6096a-577">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="6096a-578">Para ser duplicados, os nomes completos devem ser o mesmo, incluindo o namespace e todos os tipos de aninhamento.</span><span class="sxs-lookup"><span data-stu-id="6096a-578">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-579">O atributo aninhado não é especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-579">The nested attribute is not specified.</span>
          </span>
          <span data-ttu-id="6096a-580">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-580">-or-</span>
          </span>
          <span data-ttu-id="6096a-581">Esse tipo está lacrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-581">This type is sealed.</span>
          </span>
          <span data-ttu-id="6096a-582">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-582">-or-</span>
          </span>
          <span data-ttu-id="6096a-583">Esse tipo é uma matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-583">This type is an array.</span>
          </span>
          <span data-ttu-id="6096a-584">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-584">-or-</span>
          </span>
          <span data-ttu-id="6096a-585">Esse tipo é uma interface, mas o tipo aninhado não é uma interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-585">This type is an interface, but the nested type is not an interface.</span>
          </span>
          <span data-ttu-id="6096a-586">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-586">-or-</span>
          </span>
          <span data-ttu-id="6096a-587">O comprimento de <paramref name="name" /> é zero ou maior que 1023.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-587">The length of <paramref name="name" /> is zero or greater than 1023.</span>
          </span>
          <span data-ttu-id="6096a-588">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-588">-or-</span>
          </span>
          <span data-ttu-id="6096a-589">Essa operação criaria um tipo com um <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado no assembly atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-589">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-590">
            <paramref name="name" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-590">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="6096a-591">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-591">-or-</span>
          </span>
          <span data-ttu-id="6096a-592">Um elemento da matriz <paramref name="interfaces" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-592">An element of the <paramref name="interfaces" /> array is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, packSize As PackingSize, typeSize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packSize, int typeSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-593">O nome curto do tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-593">The short name of the type.</span>
          </span>
          <span data-ttu-id="6096a-594">
            <c>name</c> não pode conter valores nulos inseridos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-594">
              <c>name</c> cannot contain embedded null values.</span>
          </span>
        </param>
        <param name="attr">
          <span data-ttu-id="6096a-595">Os atributos do tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-595">The attributes of the type.</span>
          </span>
        </param>
        <param name="parent">
          <span data-ttu-id="6096a-596">O tipo que o tipo aninhado estende.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-596">The type that the nested type extends.</span>
          </span>
        </param>
        <param name="packSize">
          <span data-ttu-id="6096a-597">O tamanho de empacotamento do tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-597">The packing size of the type.</span>
          </span>
        </param>
        <param name="typeSize">
          <span data-ttu-id="6096a-598">O tamanho total do tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-598">The total size of the type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-599">Define um tipo aninhado, após serem informados seu nome, atributos, tamanho e o tipo que ele estende.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-599">Defines a nested type, given its name, attributes, size, and the type that it extends.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-600">O tipo aninhado definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-600">The defined nested type.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefinePInvokeMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-601">Define um método <see langword="PInvoke" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-601">Defines a <see langword="PInvoke" /> method.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-602">O nome do método <see langword="PInvoke" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-602">The name of the <see langword="PInvoke" /> method.</span>
          </span>
          <span data-ttu-id="6096a-603">
            <c>name</c> não pode conter nulos inseridos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-603">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="dllName">
          <span data-ttu-id="6096a-604">O nome da DLL na qual o método <see langword="PInvoke" /> é definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-604">The name of the DLL in which the <see langword="PInvoke" /> method is defined.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="6096a-605">Os atributos do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-605">The attributes of the method.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="6096a-606">A convenção de chamada do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-606">The method's calling convention.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="6096a-607">O tipo de retorno do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-607">The method's return type.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="6096a-608">Os tipos de parâmetros do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-608">The types of the method's parameters.</span>
          </span>
        </param>
        <param name="nativeCallConv">
          <span data-ttu-id="6096a-609">A convenção de chamada nativa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-609">The native calling convention.</span>
          </span>
        </param>
        <param name="nativeCharSet">
          <span data-ttu-id="6096a-610">O conjunto de caracteres nativos do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-610">The method's native character set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-611">Define um método <see langword="PInvoke" /> após serem informados seu nome, o nome da DLL em que o método é definido, os atributos do método, a convenção de chamada do método, o tipo de retorno do método, os tipos dos parâmetros do método e os sinalizadores <see langword="PInvoke" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-611">Defines a <see langword="PInvoke" /> method given its name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <see langword="PInvoke" /> flags.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-612">O método <see langword="PInvoke" /> definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-612">The defined <see langword="PInvoke" /> method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-613">Alguns DLL importar atributos (consulte a descrição da <xref:System.Runtime.InteropServices.DllImportAttribute>) não podem ser especificados como argumentos para esse método.</span><span class="sxs-lookup"><span data-stu-id="6096a-613">Some DLL import attributes (see the description of <xref:System.Runtime.InteropServices.DllImportAttribute>) cannot be specified as arguments to this method.</span></span> <span data-ttu-id="6096a-614">Por exemplo, o atributo de importação de DLL <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> deve ser adicionado após o `PInvoke` método é criado, caso o método retorna um valor.</span><span class="sxs-lookup"><span data-stu-id="6096a-614">For example, the DLL import attribute <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> must be added after the `PInvoke` method is created, if the method returns a value.</span></span> <span data-ttu-id="6096a-615">O exemplo mostra como fazer isso.</span><span class="sxs-lookup"><span data-stu-id="6096a-615">The example shows how to do this.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6096a-616">O exemplo a seguir demonstra como usar o <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> método para criar um `PInvoke` método e como adicionar o <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> sinalizador para os sinalizadores de implementação de método depois de criar o <xref:System.Reflection.Emit.MethodBuilder>, usando o <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> e <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType>métodos.</span><span class="sxs-lookup"><span data-stu-id="6096a-616">The following example demonstrates how to use the <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> method to create a `PInvoke` method, and how to add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag to the method implementation flags after you create the <xref:System.Reflection.Emit.MethodBuilder>, by using the <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> and <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> methods.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="6096a-617">Para obter um valor de retorno diferente de zero, você deve adicionar o <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> sinalizador.</span><span class="sxs-lookup"><span data-stu-id="6096a-617">To get a non-zero return value, you must add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="6096a-618">O exemplo cria um assembly dinâmico com um módulo dinâmico e um único tipo, `MyType`, que contém o `PInvoke` método.</span><span class="sxs-lookup"><span data-stu-id="6096a-618">The example creates a dynamic assembly with one dynamic module and a single type, `MyType`, that contains the `PInvoke` method.</span></span> <span data-ttu-id="6096a-619">O `PInvoke` método representa o Win32 `GetTickCount` função.</span><span class="sxs-lookup"><span data-stu-id="6096a-619">The `PInvoke` method represents the Win32 `GetTickCount` function.</span></span>  
  
 <span data-ttu-id="6096a-620">Quando o exemplo for executado, ele executa o `PInvoke` método.</span><span class="sxs-lookup"><span data-stu-id="6096a-620">When the example is run, it executes the `PInvoke` method.</span></span> <span data-ttu-id="6096a-621">Ele também salva o assembly dinâmico como PInvokeTest.dll.</span><span class="sxs-lookup"><span data-stu-id="6096a-621">It also saves the dynamic assembly as PInvokeTest.dll.</span></span> <span data-ttu-id="6096a-622">Você pode usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o `MyType` classe e o `static` (`Shared` no Visual Basic) `PInvoke` método nele.</span><span class="sxs-lookup"><span data-stu-id="6096a-622">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the `MyType` class and the `static` (`Shared` in Visual Basic) `PInvoke` method it contains.</span></span> <span data-ttu-id="6096a-623">Você pode compilar um programa Visual Basic ou c# que usa estático `MyType.GetTickCount` método, incluindo uma referência para a DLL ao executar csc.exe ou vbc.exe; por exemplo, `/r:PInvokeTest.dll`.</span><span class="sxs-lookup"><span data-stu-id="6096a-623">You can compile a Visual Basic or C# program that uses the static `MyType.GetTickCount` method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, `/r:PInvokeTest.dll`.</span></span>  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-624">O método não é estático.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-624">The method is not static.</span>
          </span>
          <span data-ttu-id="6096a-625">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-625">-or-</span>
          </span>
          <span data-ttu-id="6096a-626">O tipo pai é uma interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-626">The parent type is an interface.</span>
          </span>
          <span data-ttu-id="6096a-627">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-627">-or-</span>
          </span>
          <span data-ttu-id="6096a-628">O método é abstrato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-628">The method is abstract.</span>
          </span>
          <span data-ttu-id="6096a-629">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-629">-or-</span>
          </span>
          <span data-ttu-id="6096a-630">O método foi definido anteriormente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-630">The method was previously defined.</span>
          </span>
          <span data-ttu-id="6096a-631">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-631">-or-</span>
          </span>
          <span data-ttu-id="6096a-632">O comprimento de <paramref name="name" /> ou <paramref name="dllName" /> é zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-632">The length of <paramref name="name" /> or <paramref name="dllName" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-633">
            <paramref name="name" /> ou <paramref name="dllName" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-633">
              <paramref name="name" /> or <paramref name="dllName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-634">O tipo recipiente foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-634">The containing type has been previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-635">O nome do método <see langword="PInvoke" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-635">The name of the <see langword="PInvoke" /> method.</span>
          </span>
          <span data-ttu-id="6096a-636">
            <c>name</c> não pode conter nulos inseridos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-636">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="dllName">
          <span data-ttu-id="6096a-637">O nome da DLL na qual o método <see langword="PInvoke" /> é definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-637">The name of the DLL in which the <see langword="PInvoke" /> method is defined.</span>
          </span>
        </param>
        <param name="entryName">
          <span data-ttu-id="6096a-638">O nome do ponto de entrada na DLL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-638">The name of the entry point in the DLL.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="6096a-639">Os atributos do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-639">The attributes of the method.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="6096a-640">A convenção de chamada do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-640">The method's calling convention.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="6096a-641">O tipo de retorno do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-641">The method's return type.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="6096a-642">Os tipos de parâmetros do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-642">The types of the method's parameters.</span>
          </span>
        </param>
        <param name="nativeCallConv">
          <span data-ttu-id="6096a-643">A convenção de chamada nativa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-643">The native calling convention.</span>
          </span>
        </param>
        <param name="nativeCharSet">
          <span data-ttu-id="6096a-644">O conjunto de caracteres nativos do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-644">The method's native character set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-645">Define um método <see langword="PInvoke" /> após serem informados seu nome, o nome da DLL no qual o método é definido, o nome do ponto de entrada, os atributos do método, a convenção de chamada do método, o tipo de retorno do método, os tipos dos parâmetros do método, os sinalizadores <see langword="PInvoke" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-645">Defines a <see langword="PInvoke" /> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <see langword="PInvoke" /> flags.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-646">O método <see langword="PInvoke" /> definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-646">The defined <see langword="PInvoke" /> method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-647">Alguns DLL importar atributos (consulte a descrição da <xref:System.Runtime.InteropServices.DllImportAttribute>) não podem ser especificados como argumentos para esse método.</span><span class="sxs-lookup"><span data-stu-id="6096a-647">Some DLL import attributes (see the description of <xref:System.Runtime.InteropServices.DllImportAttribute>) cannot be specified as arguments to this method.</span></span> <span data-ttu-id="6096a-648">Por exemplo, o atributo de importação de DLL <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> deve ser adicionado após o `PInvoke` método é criado, caso o método retorna um valor.</span><span class="sxs-lookup"><span data-stu-id="6096a-648">For example, the DLL import attribute <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> must be added after the `PInvoke` method is created, if the method returns a value.</span></span> <span data-ttu-id="6096a-649">O exemplo mostra como fazer isso.</span><span class="sxs-lookup"><span data-stu-id="6096a-649">The example shows how to do this.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6096a-650">O exemplo de código a seguir demonstra como usar o <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> método para criar um `PInvoke` método e como adicionar o <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> sinalizador para os sinalizadores de implementação de método depois de criar o <xref:System.Reflection.Emit.MethodBuilder>, usando o <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> e <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> métodos.</span><span class="sxs-lookup"><span data-stu-id="6096a-650">The following code example demonstrates how to use the <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> method to create a `PInvoke` method, and how to add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag to the method implementation flags after you create the <xref:System.Reflection.Emit.MethodBuilder>, by using the <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> and <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> methods.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="6096a-651">Para obter um valor de retorno diferente de zero, você deve adicionar o <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> sinalizador.</span><span class="sxs-lookup"><span data-stu-id="6096a-651">To get a non-zero return value, you must add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="6096a-652">O exemplo cria um assembly dinâmico com um módulo dinâmico e um único tipo, `MyType`, que contém o `PInvoke` método.</span><span class="sxs-lookup"><span data-stu-id="6096a-652">The example creates a dynamic assembly with one dynamic module and a single type, `MyType`, that contains the `PInvoke` method.</span></span> <span data-ttu-id="6096a-653">O `PInvoke` método representa o Win32 `GetTickCount` função.</span><span class="sxs-lookup"><span data-stu-id="6096a-653">The `PInvoke` method represents the Win32 `GetTickCount` function.</span></span>  
  
 <span data-ttu-id="6096a-654">Quando o exemplo for executado, ele executa o `PInvoke` método.</span><span class="sxs-lookup"><span data-stu-id="6096a-654">When the example is run, it executes the `PInvoke` method.</span></span> <span data-ttu-id="6096a-655">Ele também salva o assembly dinâmico como PInvokeTest.dll.</span><span class="sxs-lookup"><span data-stu-id="6096a-655">It also saves the dynamic assembly as PInvokeTest.dll.</span></span> <span data-ttu-id="6096a-656">Você pode usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o `MyType` classe e o `static` (`Shared` no Visual Basic) `PInvoke` método nele.</span><span class="sxs-lookup"><span data-stu-id="6096a-656">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the `MyType` class and the `static` (`Shared` in Visual Basic) `PInvoke` method it contains.</span></span> <span data-ttu-id="6096a-657">Você pode compilar um programa Visual Basic ou c# que usa estático `MyType.GetTickCount` método, incluindo uma referência para a DLL ao executar csc.exe ou vbc.exe; por exemplo, `/r:PInvokeTest.dll`.</span><span class="sxs-lookup"><span data-stu-id="6096a-657">You can compile a Visual Basic or C# program that uses the static `MyType.GetTickCount` method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, `/r:PInvokeTest.dll`.</span></span>  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-658">O método não é estático.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-658">The method is not static.</span>
          </span>
          <span data-ttu-id="6096a-659">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-659">-or-</span>
          </span>
          <span data-ttu-id="6096a-660">O tipo pai é uma interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-660">The parent type is an interface.</span>
          </span>
          <span data-ttu-id="6096a-661">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-661">-or-</span>
          </span>
          <span data-ttu-id="6096a-662">O método é abstrato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-662">The method is abstract.</span>
          </span>
          <span data-ttu-id="6096a-663">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-663">-or-</span>
          </span>
          <span data-ttu-id="6096a-664">O método foi definido anteriormente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-664">The method was previously defined.</span>
          </span>
          <span data-ttu-id="6096a-665">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-665">-or-</span>
          </span>
          <span data-ttu-id="6096a-666">O comprimento de <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> é zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-666">The length of <paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-667">
            <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-667">
              <paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-668">O tipo recipiente foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-668">The containing type has been previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-669">O nome do método <see langword="PInvoke" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-669">The name of the <see langword="PInvoke" /> method.</span>
          </span>
          <span data-ttu-id="6096a-670">
            <c>name</c> não pode conter nulos inseridos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-670">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="dllName">
          <span data-ttu-id="6096a-671">O nome da DLL na qual o método <see langword="PInvoke" /> é definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-671">The name of the DLL in which the <see langword="PInvoke" /> method is defined.</span>
          </span>
        </param>
        <param name="entryName">
          <span data-ttu-id="6096a-672">O nome do ponto de entrada na DLL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-672">The name of the entry point in the DLL.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="6096a-673">Os atributos do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-673">The attributes of the method.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="6096a-674">A convenção de chamada do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-674">The method's calling convention.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="6096a-675">O tipo de retorno do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-675">The method's return type.</span>
          </span>
        </param>
        <param name="returnTypeRequiredCustomModifiers">
          <span data-ttu-id="6096a-676">Uma matriz de tipos que representam os modificadores personalizados obrigatórios, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-676">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span>
          </span>
          <span data-ttu-id="6096a-677">Se o tipo de retorno não tiver modificadores personalizados obrigatórios, especifique <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-677">If the return type has no required custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="returnTypeOptionalCustomModifiers">
          <span data-ttu-id="6096a-678">Uma matriz de tipos que representam os modificadores personalizados opcionais, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-678">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span>
          </span>
          <span data-ttu-id="6096a-679">Se o tipo de retorno não tiver modificadores personalizados opcionais, especifique <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-679">If the return type has no optional custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="6096a-680">Os tipos de parâmetros do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-680">The types of the method's parameters.</span>
          </span>
        </param>
        <param name="parameterTypeRequiredCustomModifiers">
          <span data-ttu-id="6096a-681">Uma matriz de matrizes de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-681">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="6096a-682">Cada matriz de tipos representa os modificadores personalizados obrigatórios para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-682">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="6096a-683">Se um determinado parâmetro tiver não modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-683">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="6096a-684">Se nenhum dos parâmetros tiver modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de matrizes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-684">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <param name="parameterTypeOptionalCustomModifiers">
          <span data-ttu-id="6096a-685">Uma matriz de matrizes de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-685">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="6096a-686">Cada matriz de tipos representa os modificadores personalizados opcionais para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-686">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="6096a-687">Se um determinado parâmetro tiver não modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-687">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="6096a-688">Se nenhum dos parâmetros tiver modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de matrizes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-688">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <param name="nativeCallConv">
          <span data-ttu-id="6096a-689">A convenção de chamada nativa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-689">The native calling convention.</span>
          </span>
        </param>
        <param name="nativeCharSet">
          <span data-ttu-id="6096a-690">O conjunto de caracteres nativos do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-690">The method's native character set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-691">Define um método <see langword="PInvoke" /> após serem informados seu nome, o nome da DLL no qual o método é definido, o nome do ponto de entrada, os atributos do método, a convenção de chamada do método, o tipo de retorno do método, os tipos dos parâmetros do método, os sinalizadores <see langword="PInvoke" /> e os modificadores personalizados para os parâmetros e o tipo de retorno.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-691">Defines a <see langword="PInvoke" /> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, the <see langword="PInvoke" /> flags, and custom modifiers for the parameters and return type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-692">Um <see cref="T:System.Reflection.Emit.MethodBuilder" /> representando o método <see langword="PInvoke" /> definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-692">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the defined <see langword="PInvoke" /> method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-693">Alguns DLL importar atributos (consulte a descrição da <xref:System.Runtime.InteropServices.DllImportAttribute>) não podem ser especificados como argumentos para esse método.</span><span class="sxs-lookup"><span data-stu-id="6096a-693">Some DLL import attributes (see the description of <xref:System.Runtime.InteropServices.DllImportAttribute>) cannot be specified as arguments to this method.</span></span> <span data-ttu-id="6096a-694">Por exemplo, o atributo de importação de DLL <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> deve ser adicionado após o `PInvoke` método é criado, caso o método retorna um valor.</span><span class="sxs-lookup"><span data-stu-id="6096a-694">For example, the DLL import attribute <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> must be added after the `PInvoke` method is created, if the method returns a value.</span></span> <span data-ttu-id="6096a-695">O exemplo mostra como fazer isso.</span><span class="sxs-lookup"><span data-stu-id="6096a-695">The example shows how to do this.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6096a-696">Para obter mais informações sobre modificadores personalizados, consulte a documentação de metadados da ECMA partição II.</span><span class="sxs-lookup"><span data-stu-id="6096a-696">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="6096a-697">A documentação está disponível online; confira [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212), no MSDN, e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552), no site internacional da Ecma.</span><span class="sxs-lookup"><span data-stu-id="6096a-697">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6096a-698">O exemplo de código a seguir demonstra como usar o [\], tipo\[\], tipo\[\], tipo\[\]\[\], tipo\[ \] \<xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A > método para criar um `PInvoke` método e como adicionar o <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> sinalizador para os sinalizadores de implementação de método depois de criar o <xref:System.Reflection.Emit.MethodBuilder>, usando o <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> e <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> métodos.</span><span class="sxs-lookup"><span data-stu-id="6096a-698">The following code example demonstrates how to use the [\], Type\[\], Type\[\], Type\[\]\[\], Type\[\]\<xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> method to create a `PInvoke` method, and how to add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag to the method implementation flags after you create the <xref:System.Reflection.Emit.MethodBuilder>, by using the <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> and <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="6096a-699">O exemplo cria um assembly dinâmico com um módulo dinâmico e um único tipo, `MyType`, que contém o `PInvoke` método.</span><span class="sxs-lookup"><span data-stu-id="6096a-699">The example creates a dynamic assembly with one dynamic module and a single type, `MyType`, that contains the `PInvoke` method.</span></span> <span data-ttu-id="6096a-700">O `PInvoke` método representa o Win32 `GetTickCount` função.</span><span class="sxs-lookup"><span data-stu-id="6096a-700">The `PInvoke` method represents the Win32 `GetTickCount` function.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="6096a-701">Para obter um valor de retorno diferente de zero, você deve adicionar o <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> sinalizador.</span><span class="sxs-lookup"><span data-stu-id="6096a-701">To get a non-zero return value, you must add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6096a-702">O exemplo usa uma sobrecarga que não especifica modificadores personalizados.</span><span class="sxs-lookup"><span data-stu-id="6096a-702">The example uses an overload that does not specify custom modifiers.</span></span> <span data-ttu-id="6096a-703">Para especificar modificadores personalizados, altere o código de exemplo para usar essa sobrecarga de método em vez disso.</span><span class="sxs-lookup"><span data-stu-id="6096a-703">To specify custom modifiers, change the example code to use this method overload instead.</span></span>  
  
 <span data-ttu-id="6096a-704">Quando o exemplo for executado, ele executa o `PInvoke` método.</span><span class="sxs-lookup"><span data-stu-id="6096a-704">When the example is run, it executes the `PInvoke` method.</span></span> <span data-ttu-id="6096a-705">Ele também salva o assembly dinâmico como PInvokeTest.dll.</span><span class="sxs-lookup"><span data-stu-id="6096a-705">It also saves the dynamic assembly as PInvokeTest.dll.</span></span> <span data-ttu-id="6096a-706">Você pode usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o `MyType` classe e o `static` (`Shared` no Visual Basic) `PInvoke` método nele.</span><span class="sxs-lookup"><span data-stu-id="6096a-706">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the `MyType` class and the `static` (`Shared` in Visual Basic) `PInvoke` method it contains.</span></span> <span data-ttu-id="6096a-707">Você pode compilar um programa Visual Basic ou c# que usa estático `MyType.GetTickCount` método, incluindo uma referência para a DLL ao executar csc.exe ou vbc.exe; por exemplo, `/r:PInvokeTest.dll`.</span><span class="sxs-lookup"><span data-stu-id="6096a-707">You can compile a Visual Basic or C# program that uses the static `MyType.GetTickCount` method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, `/r:PInvokeTest.dll`.</span></span>  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-708">O método não é estático.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-708">The method is not static.</span>
          </span>
          <span data-ttu-id="6096a-709">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-709">-or-</span>
          </span>
          <span data-ttu-id="6096a-710">O tipo pai é uma interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-710">The parent type is an interface.</span>
          </span>
          <span data-ttu-id="6096a-711">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-711">-or-</span>
          </span>
          <span data-ttu-id="6096a-712">O método é abstrato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-712">The method is abstract.</span>
          </span>
          <span data-ttu-id="6096a-713">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-713">-or-</span>
          </span>
          <span data-ttu-id="6096a-714">O método foi definido anteriormente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-714">The method was previously defined.</span>
          </span>
          <span data-ttu-id="6096a-715">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-715">-or-</span>
          </span>
          <span data-ttu-id="6096a-716">O comprimento de <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> é zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-716">The length of <paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is zero.</span>
          </span>
          <span data-ttu-id="6096a-717">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-717">-or-</span>
          </span>
          <span data-ttu-id="6096a-718">O tamanho de <paramref name="parameterTypeRequiredCustomModifiers" /> ou <paramref name="parameterTypeOptionalCustomModifiers" /> não é igual ao tamanho de <paramref name="parameterTypes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-718">The size of <paramref name="parameterTypeRequiredCustomModifiers" /> or <paramref name="parameterTypeOptionalCustomModifiers" /> does not equal the size of <paramref name="parameterTypes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-719">
            <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-719">
              <paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-720">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-720">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="6096a-721">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-721">-or-</span>
          </span>
          <span data-ttu-id="6096a-722">Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-722">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineProperty">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-723">Adiciona uma nova propriedade ao tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-723">Adds a new property to the type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, returnType As Type, parameterTypes As Type()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-724">O nome da propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-724">The name of the property.</span>
          </span>
          <span data-ttu-id="6096a-725">
            <c>name</c> não pode conter nulos inseridos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-725">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="6096a-726">Os atributos da propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-726">The attributes of the property.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="6096a-727">O tipo de retorno da propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-727">The return type of the property.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="6096a-728">Os tipos dos parâmetros da propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-728">The types of the parameters of the property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-729">Adiciona uma nova propriedade ao tipo, com o nome e assinatura de propriedade fornecidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-729">Adds a new property to the type, with the given name and property signature.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-730">A propriedade definida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-730">The defined property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="6096a-731">O exemplo de código a seguir demonstra como definir uma propriedade dinâmica e obter um <xref:System.Reflection.Emit.PropertyBuilder> para especificação.</span><span class="sxs-lookup"><span data-stu-id="6096a-731">The following code sample demonstrates how to define a dynamic property and obtain a <xref:System.Reflection.Emit.PropertyBuilder> for specification.</span></span> <span data-ttu-id="6096a-732">Observe que uma `PropertyBuilder` também deve ter um correspondente <xref:System.Reflection.Emit.MethodBuilder>, que armazenará a lógica de IL para a propriedade.</span><span class="sxs-lookup"><span data-stu-id="6096a-732">Note that a `PropertyBuilder` must also have a corresponding <xref:System.Reflection.Emit.MethodBuilder>, which will house the IL logic for the property.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-733">O comprimento de <paramref name="name" /> é zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-733">The length of <paramref name="name" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-734">
            <paramref name="name" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-734">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="6096a-735">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-735">-or-</span>
          </span>
          <span data-ttu-id="6096a-736">Qualquer um dos elementos da matriz de <paramref name="parameterTypes" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-736">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-737">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-737">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-738">O nome da propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-738">The name of the property.</span>
          </span>
          <span data-ttu-id="6096a-739">
            <c>name</c> não pode conter nulos inseridos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-739">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="6096a-740">Os atributos da propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-740">The attributes of the property.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="6096a-741">A convenção de chamada dos acessadores de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-741">The calling convention of the property accessors.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="6096a-742">O tipo de retorno da propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-742">The return type of the property.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="6096a-743">Os tipos dos parâmetros da propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-743">The types of the parameters of the property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-744">Adiciona uma nova propriedade ao tipo, com o nome, os atributos, a convenção de chamada e assinatura de propriedade fornecidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-744">Adds a new property to the type, with the given name, attributes, calling convention, and property signature.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-745">A propriedade definida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-745">The defined property.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-746">O comprimento de <paramref name="name" /> é zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-746">The length of <paramref name="name" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-747">
            <paramref name="name" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-747">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="6096a-748">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-748">-or-</span>
          </span>
          <span data-ttu-id="6096a-749">Qualquer um dos elementos da matriz de <paramref name="parameterTypes" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-749">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-750">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-750">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-751">O nome da propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-751">The name of the property.</span>
          </span>
          <span data-ttu-id="6096a-752">
            <c>name</c> não pode conter nulos inseridos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-752">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="6096a-753">Os atributos da propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-753">The attributes of the property.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="6096a-754">O tipo de retorno da propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-754">The return type of the property.</span>
          </span>
        </param>
        <param name="returnTypeRequiredCustomModifiers">
          <span data-ttu-id="6096a-755">Uma matriz de tipos que representa os modificadores personalizados obrigatórios, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno da propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-755">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span>
          </span>
          <span data-ttu-id="6096a-756">Se o tipo de retorno não tiver modificadores personalizados obrigatórios, especifique <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-756">If the return type has no required custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="returnTypeOptionalCustomModifiers">
          <span data-ttu-id="6096a-757">Uma matriz de tipos que representa os modificadores personalizados opcionais, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno da propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-757">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span>
          </span>
          <span data-ttu-id="6096a-758">Se o tipo de retorno não tiver modificadores personalizados opcionais, especifique <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-758">If the return type has no optional custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="6096a-759">Os tipos dos parâmetros da propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-759">The types of the parameters of the property.</span>
          </span>
        </param>
        <param name="parameterTypeRequiredCustomModifiers">
          <span data-ttu-id="6096a-760">Uma matriz de matrizes de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-760">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="6096a-761">Cada matriz de tipos representa os modificadores personalizados obrigatórios para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-761">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="6096a-762">Se um determinado parâmetro tiver não modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-762">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="6096a-763">Se nenhum dos parâmetros tiver modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de matrizes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-763">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <param name="parameterTypeOptionalCustomModifiers">
          <span data-ttu-id="6096a-764">Uma matriz de matrizes de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-764">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="6096a-765">Cada matriz de tipos representa os modificadores personalizados opcionais para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-765">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="6096a-766">Se um determinado parâmetro tiver não modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-766">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="6096a-767">Se nenhum dos parâmetros tiver modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de matrizes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-767">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-768">Adiciona uma nova propriedade ao tipo, com o nome, a assinatura de propriedade e os modificadores personalizado fornecidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-768">Adds a new property to the type, with the given name, property signature, and custom modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-769">A propriedade definida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-769">The defined property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-770">Essa sobrecarga é fornecida para os designers de compiladores gerenciados.</span><span class="sxs-lookup"><span data-stu-id="6096a-770">This overload is provided for designers of managed compilers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6096a-771">Para obter mais informações sobre modificadores personalizados, consulte a documentação de metadados da ECMA partição II.</span><span class="sxs-lookup"><span data-stu-id="6096a-771">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="6096a-772">A documentação está disponível online; confira [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212), no MSDN, e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552), no site internacional da Ecma.</span><span class="sxs-lookup"><span data-stu-id="6096a-772">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-773">O comprimento de <paramref name="name" /> é zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-773">The length of <paramref name="name" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-774">
            <paramref name="name" /> é <see langword="null" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-774">
              <paramref name="name" /> is <see langword="null" /></span>
          </span>
          <span data-ttu-id="6096a-775">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-775">-or-</span>
          </span>
          <span data-ttu-id="6096a-776">Qualquer um dos elementos da matriz de <paramref name="parameterTypes" /> é <see langword="null" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-776">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" /></span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-777">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-777">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, callingConvention As CallingConventions, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-778">O nome da propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-778">The name of the property.</span>
          </span>
          <span data-ttu-id="6096a-779">
            <c>name</c> não pode conter nulos inseridos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-779">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="6096a-780">Os atributos da propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-780">The attributes of the property.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="6096a-781">A convenção de chamada dos acessadores de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-781">The calling convention of the property accessors.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="6096a-782">O tipo de retorno da propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-782">The return type of the property.</span>
          </span>
        </param>
        <param name="returnTypeRequiredCustomModifiers">
          <span data-ttu-id="6096a-783">Uma matriz de tipos que representa os modificadores personalizados obrigatórios, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno da propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-783">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span>
          </span>
          <span data-ttu-id="6096a-784">Se o tipo de retorno não tiver modificadores personalizados obrigatórios, especifique <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-784">If the return type has no required custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="returnTypeOptionalCustomModifiers">
          <span data-ttu-id="6096a-785">Uma matriz de tipos que representa os modificadores personalizados opcionais, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno da propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-785">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span>
          </span>
          <span data-ttu-id="6096a-786">Se o tipo de retorno não tiver modificadores personalizados opcionais, especifique <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-786">If the return type has no optional custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="6096a-787">Os tipos dos parâmetros da propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-787">The types of the parameters of the property.</span>
          </span>
        </param>
        <param name="parameterTypeRequiredCustomModifiers">
          <span data-ttu-id="6096a-788">Uma matriz de matrizes de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-788">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="6096a-789">Cada matriz de tipos representa os modificadores personalizados obrigatórios para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-789">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="6096a-790">Se um determinado parâmetro tiver não modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-790">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="6096a-791">Se nenhum dos parâmetros tiver modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de matrizes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-791">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <param name="parameterTypeOptionalCustomModifiers">
          <span data-ttu-id="6096a-792">Uma matriz de matrizes de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-792">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="6096a-793">Cada matriz de tipos representa os modificadores personalizados opcionais para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-793">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="6096a-794">Se um determinado parâmetro tiver não modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-794">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="6096a-795">Se nenhum dos parâmetros tiver modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de matrizes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-795">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-796">Adiciona uma nova propriedade ao tipo, com o nome, a convenção de chamada, a assinatura de propriedade e os modificadores personalizados fornecidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-796">Adds a new property to the type, with the given name, calling convention, property signature, and custom modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-797">A propriedade definida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-797">The defined property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-798">Essa sobrecarga é fornecida para os designers de compiladores gerenciados.</span><span class="sxs-lookup"><span data-stu-id="6096a-798">This overload is provided for designers of managed compilers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6096a-799">Para obter mais informações sobre modificadores personalizados, consulte a documentação de metadados da ECMA partição II.</span><span class="sxs-lookup"><span data-stu-id="6096a-799">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="6096a-800">A documentação está disponível online; confira [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212), no MSDN, e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552), no site internacional da Ecma.</span><span class="sxs-lookup"><span data-stu-id="6096a-800">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 <span data-ttu-id="6096a-801">Essa sobrecarga de método foi introduzida no [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.</span><span class="sxs-lookup"><span data-stu-id="6096a-801">This method overload is introduced in the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-802">O comprimento de <paramref name="name" /> é zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-802">The length of <paramref name="name" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-803">
            <paramref name="name" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-803">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="6096a-804">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-804">-or-</span>
          </span>
          <span data-ttu-id="6096a-805">Qualquer um dos elementos da matriz de <paramref name="parameterTypes" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-805">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-806">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-806">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineTypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineTypeInitializer () As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineTypeInitializer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="6096a-807">Define o inicializador desse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-807">Defines the initializer for this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-808">Retorna um inicializador de tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-808">Returns a type initializer.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-809">O inicializador criado sempre é público.</span><span class="sxs-lookup"><span data-stu-id="6096a-809">The initializer created is always public.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6096a-810">O exemplo de código a seguir demonstra como criar um construtor de inicialização usando `DefineTypeInitializer`.</span><span class="sxs-lookup"><span data-stu-id="6096a-810">The following code sample demonstrates how to create an initialization constructor using `DefineTypeInitializer`.</span></span>  
  
 [!code-cpp[TypeBuilder_Properties1#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Properties1/CPP/typebuilder_properties.cpp#3)]
 [!code-csharp[TypeBuilder_Properties1#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Properties1/CS/typebuilder_properties.cs#3)]
 [!code-vb[TypeBuilder_Properties1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Properties1/VB/typebuilder_properties.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-811">O tipo recipiente foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-811">The containing type has been previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUninitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineUninitializedData (string name, int size, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineUninitializedData(string name, int32 size, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineUninitializedData (name As String, size As Integer, attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineUninitializedData(System::String ^ name, int size, System::Reflection::FieldAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-812">O nome usado para fazer referência aos dados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-812">The name used to refer to the data.</span>
          </span>
          <span data-ttu-id="6096a-813">
            <c>name</c> não pode conter nulos inseridos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-813">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="6096a-814">O tamanho do campo de dados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-814">The size of the data field.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="6096a-815">Os atributos do campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-815">The attributes for the field.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-816">Define um campo de dados não inicializado na seção <see langword=".sdata" /> do arquivo PE (executável portátil).</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-816">Defines an uninitialized data field in the <see langword=".sdata" /> section of the portable executable (PE) file.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-817">Um campo para fazer referência aos dados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-817">A field to reference the data.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-818">O campo que você criar com esse método será `static`, mesmo se você não incluir `FieldAttributes.Static` no `attributes` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="6096a-818">The field that you create with this method will be `static`, even if you do not include `FieldAttributes.Static` in the `attributes` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6096a-819">O exemplo de código a seguir demonstra o uso de `DefineUninitializedData` para criar um campo de dados não inicializados em um tipo dinâmico:</span><span class="sxs-lookup"><span data-stu-id="6096a-819">The following code sample demonstrates the use of `DefineUninitializedData` to create an uninitialized data field in a dynamic type:</span></span>  
  
 [!code-cpp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CPP/typebuilder_defineuninitializeddata.cpp#1)]
 [!code-csharp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CS/typebuilder_defineuninitializeddata.cs#1)]
 [!code-vb[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/VB/typebuilder_defineuninitializeddata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-820">O tamanho de <paramref name="name" /> é zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-820">Length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="6096a-821">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-821">-or-</span>
          </span>
          <span data-ttu-id="6096a-822">
            <paramref name="size" /> é menor que ou igual a zero, ou maior que ou igual a 0x003f0000.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-822">
              <paramref name="size" /> is less than or equal to zero, or greater than or equal to 0x003f0000.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-823">
            <paramref name="name" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-823">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-824">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-824">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-825">Recupera o caminho completo desse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-825">Retrieves the full path of this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6096a-826">Somente leitura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-826">Read-only.</span>
          </span>
          <span data-ttu-id="6096a-827">Recupera o caminho completo desse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-827">Retrieves the full path of this type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-828">O formato retornado é "enclosingTypeFullName + nestedTypeName" para "typeName" para tipos não aninhada e de tipos aninhados.</span><span class="sxs-lookup"><span data-stu-id="6096a-828">The returned format is "enclosingTypeFullName+nestedTypeName" for nested types and "typeName" for non-nested types.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-829">Obtém um valor que indica a covariância e as restrições especiais do parâmetro de tipo genérico atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-829">Gets a value that indicates the covariance and special constraints of the current generic type parameter.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6096a-830">Uma combinação bit a bit de valores <see cref="T:System.Reflection.GenericParameterAttributes" /> que descrevem a covariância e restrições especiais do parâmetro de tipo genérico atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-830">A bitwise combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> values that describes the covariance and special constraints of the current generic type parameter.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="6096a-831">Ao emitir código, um parâmetro de tipo genérico é representado por um <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto em vez de um <xref:System.Reflection.Emit.TypeBuilder> objeto.</span><span class="sxs-lookup"><span data-stu-id="6096a-831">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public override int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-832">Obtém a posição de um parâmetro de tipo na lista de parâmetros de tipo do tipo genérico declarado no parâmetro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-832">Gets the position of a type parameter in the type parameter list of the generic type that declared the parameter.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6096a-833">Se o atual <see cref="T:System.Reflection.Emit.TypeBuilder" /> objeto representa um parâmetro de tipo genérico, a posição do parâmetro de tipo na lista de parâmetros de tipo do tipo genérico que declarou o parâmetro; caso contrário, indefinido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-833">If the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> object represents a generic type parameter, the position of the type parameter in the type parameter list of the generic type that declared the parameter; otherwise, undefined.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="6096a-834">Ao emitir código, um parâmetro de tipo genérico é representado por um <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto em vez de um <xref:System.Reflection.Emit.TypeBuilder> objeto.</span><span class="sxs-lookup"><span data-stu-id="6096a-834">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="6096a-835">Se o atual <xref:System.Reflection.Emit.TypeBuilder> não representa um parâmetro de tipo genérico, o valor dessa propriedade é indefinido.</span><span class="sxs-lookup"><span data-stu-id="6096a-835">If the current <xref:System.Reflection.Emit.TypeBuilder> does not represent a generic type parameter, the value of this property is undefined.</span></span> <span data-ttu-id="6096a-836">Use o <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> propriedade para determinar se o atual <xref:System.Reflection.Emit.TypeBuilder> representa um parâmetro de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="6096a-836">Use the <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> property to determine whether the current <xref:System.Reflection.Emit.TypeBuilder> represents a generic type parameter.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public override Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public override int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetArrayRank();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public static System.Reflection.ConstructorInfo GetConstructor (Type type, System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.ConstructorInfo GetConstructor(class System.Type type, class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::ConstructorInfo ^ GetConstructor(Type ^ type, System::Reflection::ConstructorInfo ^ constructor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="6096a-837">O tipo genérico construído cujo construtor será retornado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-837">The constructed generic type whose constructor is returned.</span>
          </span>
        </param>
        <param name="constructor">
          <span data-ttu-id="6096a-838">Um construtor na definição de tipo genérico de <c>tipo</c> que especifica qual construtor de <c>tipo</c> deve ser retornado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-838">A constructor on the generic type definition of <c>type</c>, which specifies which constructor of <c>type</c> to return.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-839">Retorna o construtor do tipo genérico construído especificado que corresponde ao construtor especificado da definição de tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-839">Returns the constructor of the specified constructed generic type that corresponds to the specified constructor of the generic type definition.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-840">Um objeto <see cref="T:System.Reflection.ConstructorInfo" /> que representa o construtor de <paramref name="type" /> correspondente a <paramref name="constructor" />, que especifica um construtor pertencente à definição de tipo genérico de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-840">A <see cref="T:System.Reflection.ConstructorInfo" /> object that represents the constructor of <paramref name="type" /> corresponding to <paramref name="constructor" />, which specifies a constructor belonging to the generic type definition of <paramref name="type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-841">O <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> método fornece uma maneira de obter um <xref:System.Reflection.ConstructorInfo> objeto que representa um construtor de um tipo genérico construído cuja definição de tipo genérico é representada por um <xref:System.Reflection.Emit.TypeBuilder> objeto.</span><span class="sxs-lookup"><span data-stu-id="6096a-841">The <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method provides a way to get a <xref:System.Reflection.ConstructorInfo> object that represents a constructor of a constructed generic type whose generic type definition is represented by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="6096a-842">Por exemplo, suponha que você tenha um <xref:System.Reflection.Emit.TypeBuilder> objeto que representa o tipo `G<T>` na sintaxe do c# (`G(Of T)` no Visual Basic, `generic <T> ref class G` em C++) e um <xref:System.Reflection.Emit.ConstructorBuilder> objeto que representa um construtor de `G<T>`.</span><span class="sxs-lookup"><span data-stu-id="6096a-842">For example, suppose you have a <xref:System.Reflection.Emit.TypeBuilder> object that represents the type `G<T>` in C# syntax (`G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) and a <xref:System.Reflection.Emit.ConstructorBuilder> object that represents a constructor of `G<T>`.</span></span> <span data-ttu-id="6096a-843">Suponha que `G<T>` tem um método genérico com parâmetro de tipo `U` que cria uma instância do tipo construído `G<U>`.</span><span class="sxs-lookup"><span data-stu-id="6096a-843">Suppose that `G<T>` has a generic method with type parameter `U` that creates an instance of the constructed type `G<U>`.</span></span> <span data-ttu-id="6096a-844">Para emitir o código para criar uma instância do tipo construído, é necessário um <xref:System.Reflection.ConstructorInfo> tipo de objeto que representa o construtor deste construído — em outras palavras, que cria uma instância de `G<U>`.</span><span class="sxs-lookup"><span data-stu-id="6096a-844">In order to emit the code to create an instance of the constructed type, you need a <xref:System.Reflection.ConstructorInfo> object that represents the constructor of this constructed type — in other words, that creates an instance of `G<U>`.</span></span> <span data-ttu-id="6096a-845">Para fazer isso, primeiro chame o <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método o <xref:System.Reflection.Emit.TypeBuilder> do objeto, especificando o <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto que representa `U` como o argumento de tipo.</span><span class="sxs-lookup"><span data-stu-id="6096a-845">To do this, first call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on the <xref:System.Reflection.Emit.TypeBuilder> object, specifying the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object that represents `U` as the type argument.</span></span> <span data-ttu-id="6096a-846">Em seguida, chame o <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> método com o valor de retorno a <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método como parâmetro `type` e o <xref:System.Reflection.Emit.ConstructorBuilder> objeto que representa o construtor de `G<U>` como parâmetro `constructor`.</span><span class="sxs-lookup"><span data-stu-id="6096a-846">Then call the <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method with the return value of the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method as parameter `type` and the <xref:System.Reflection.Emit.ConstructorBuilder> object that represents the constructor of `G<U>` as parameter `constructor`.</span></span> <span data-ttu-id="6096a-847">O valor de retorno é a <xref:System.Reflection.ConstructorInfo> precisar emitir a chamada de função do objeto.</span><span class="sxs-lookup"><span data-stu-id="6096a-847">The return value is the <xref:System.Reflection.ConstructorInfo> object you need to emit the function call.</span></span> <span data-ttu-id="6096a-848">O exemplo de código demonstra esse cenário.</span><span class="sxs-lookup"><span data-stu-id="6096a-848">The code example demonstrates this scenario.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6096a-849">O exemplo de código a seguir contém o código-fonte para uma classe genérica denominado `Sample` que tem um parâmetro de tipo denominado `T`.</span><span class="sxs-lookup"><span data-stu-id="6096a-849">The following code example contains source code for a generic class named `Sample` that has a type parameter named `T`.</span></span> <span data-ttu-id="6096a-850">A classe tem um campo chamado `Field`, do tipo `T`e um método genérico chamado `GM` com seu próprio parâmetro de tipo, denominado `U`.</span><span class="sxs-lookup"><span data-stu-id="6096a-850">The class has a field named `Field`, of type `T`, and a generic method named `GM` with its own type parameter, named `U`.</span></span> <span data-ttu-id="6096a-851">Método `GM` cria uma instância de `Sample`, substituindo seu próprio parâmetro de tipo `U` para o parâmetro de tipo de `Sample`e armazena seu parâmetro de entrada em `Field`.</span><span class="sxs-lookup"><span data-stu-id="6096a-851">Method `GM` creates an instance of `Sample`, substituting its own type parameter `U` for the type parameter of `Sample`, and stores its input parameter in `Field`.</span></span> <span data-ttu-id="6096a-852">Este código-fonte é compilado, mas não utilizado; Você pode exibi-lo com o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) e compará-lo com o código emitido pela classe `Example`.</span><span class="sxs-lookup"><span data-stu-id="6096a-852">This source code is compiled but not used; you can view it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) and compare it to the code emitted by class `Example`.</span></span>  
  
 <span data-ttu-id="6096a-853">O código na classe `Example` demonstra o uso de <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> método emitir código genérico.</span><span class="sxs-lookup"><span data-stu-id="6096a-853">The code in class `Example` demonstrates the use of the <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method to emit generic code.</span></span> <span data-ttu-id="6096a-854">O `Main` método da classe `Example` cria um assembly dinâmico que contém uma classe denominada `Sample` e usa o <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> método torná-la genérica adicionando um parâmetro de tipo denominado `T`.</span><span class="sxs-lookup"><span data-stu-id="6096a-854">The `Main` method of class `Example` creates a dynamic assembly containing a class named `Sample` and uses the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method to make it generic by adding a type parameter named `T`.</span></span> <span data-ttu-id="6096a-855">Um construtor padrão e um campo denominado `Field`, do tipo `T`, são adicionados à classe `Sample`.</span><span class="sxs-lookup"><span data-stu-id="6096a-855">A default constructor and a field named `Field`, of type `T`, are added to class `Sample`.</span></span> <span data-ttu-id="6096a-856">Um método `GM` é adicionada e convertido em um método genérico, usando o <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="6096a-856">A method `GM` is added and turned into a generic method by using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="6096a-857">O parâmetro de tipo de `GM` chamado `U`.</span><span class="sxs-lookup"><span data-stu-id="6096a-857">The type parameter of `GM` is named `U`.</span></span> <span data-ttu-id="6096a-858">Depois que o parâmetro de tipo é definido, a assinatura de `GM` é adicionado usando o <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="6096a-858">After the type parameter is defined, the signature of `GM` is added by using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="6096a-859">Não há nenhum tipo de retorno e sem a necessidade de ou modificadores personalizados, então todos os parâmetros desse método são `null` exceto `parameterTypes`; `parameterTypes` define o tipo de um único parâmetro do método para `U`, o parâmetro de tipo genérico do método.</span><span class="sxs-lookup"><span data-stu-id="6096a-859">There is no return type and no required or custom modifiers, so all the parameters of this method are `null` except `parameterTypes`; `parameterTypes` sets the type of the method's only parameter to `U`, the method's generic type parameter.</span></span> <span data-ttu-id="6096a-860">O corpo do método cria uma instância do tipo construído `Sample<U>` (`Sample(Of U)` no Visual Basic), atribui o parâmetro do método para `Field`e imprime o valor de `Field`.</span><span class="sxs-lookup"><span data-stu-id="6096a-860">The body of the method creates an instance of the constructed type `Sample<U>` (`Sample(Of U)` in Visual Basic), assigns the method's parameter to `Field`, and then prints the value of `Field`.</span></span> <span data-ttu-id="6096a-861">O <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> método é usado para criar um <xref:System.Reflection.ConstructorInfo> que representa o construtor padrão do tipo genérico construído `Sample<U>` no <xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType> instrução que cria a instância.</span><span class="sxs-lookup"><span data-stu-id="6096a-861">The <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method is used to create a <xref:System.Reflection.ConstructorInfo> that represents the default constructor of the constructed generic type `Sample<U>` in the <xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType> instruction that creates the instance.</span></span>  
  
 <span data-ttu-id="6096a-862">Um tipo fictício está definido para conter o método de ponto de entrada `Main`.</span><span class="sxs-lookup"><span data-stu-id="6096a-862">A dummy type is defined to hold the entry-point method `Main`.</span></span> <span data-ttu-id="6096a-863">No corpo da `Main`, estático `GM` método é invocado no tipo genérico construído `Sample<int>` (`Sample(Of Integer)` no Visual Basic), com o tipo <xref:System.String> substituídos por `U`.</span><span class="sxs-lookup"><span data-stu-id="6096a-863">In the body of `Main`, the static `GM` method is invoked on the constructed generic type `Sample<int>` (`Sample(Of Integer)` in Visual Basic), with type <xref:System.String> substituted for `U`.</span></span>  
  
 <span data-ttu-id="6096a-864">Quando o exemplo de código é executado, ele salva o assembly emitido como TypeBuilderGetFieldExample.exe.</span><span class="sxs-lookup"><span data-stu-id="6096a-864">When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</span></span> <span data-ttu-id="6096a-865">Você pode executar TypeBuilderGetFieldExample.exe, e você pode usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para comparar o código emitido com o código para o `Sample` classe que é compilado para o exemplo de código.</span><span class="sxs-lookup"><span data-stu-id="6096a-865">You can run TypeBuilderGetFieldExample.exe, and you can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to compare the emitted code with the code for the `Sample` class that is compiled into the code example itself.</span></span>  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-866">
            <paramref name="type" /> não representa um tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-866">
              <paramref name="type" /> does not represent a generic type.</span>
          </span>
          <span data-ttu-id="6096a-867">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-867">-or-</span>
          </span>
          <span data-ttu-id="6096a-868">
            <paramref name="type" /> não é do tipo <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-868">
              <paramref name="type" /> is not of type <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          </span>
          <span data-ttu-id="6096a-869">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-869">-or-</span>
          </span>
          <span data-ttu-id="6096a-870">O tipo declarativo de <paramref name="constructor" /> não é uma definição de tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-870">The declaring type of <paramref name="constructor" /> is not a generic type definition.</span>
          </span>
          <span data-ttu-id="6096a-871">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-871">-or-</span>
          </span>
          <span data-ttu-id="6096a-872">O tipo declarativo de <paramref name="constructor" /> não é a definição de tipo genérico de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-872">The declaring type of <paramref name="constructor" /> is not the generic type definition of <paramref name="type" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public override System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="6096a-873">Esse deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como em <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-873">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-874">Retorna uma matriz de objetos <see cref="T:System.Reflection.ConstructorInfo" /> que representam os construtores público e não público definidos para essa classe, conforme especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-874">Returns an array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing the public and non-public constructors defined for this class, as specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-875">Retorna uma matriz de objetos <see cref="T:System.Reflection.ConstructorInfo" /> que representam os construtores especificados definidos para esta classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-875">Returns an array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing the specified constructors defined for this class.</span>
          </span>
          <span data-ttu-id="6096a-876">Se nenhum construtor for definido, uma matriz vazia será retornada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-876">If no constructors are defined, an empty array is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-877">Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="6096a-877">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="6096a-878">Esse método não está implementado para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-878">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-879">Retorna os atributos personalizados definidos para esse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-879">Returns the custom attributes defined for this type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">
          <span data-ttu-id="6096a-880">Especifica se deve-se pesquisar ou não a cadeia de herança desse membro para localizar os atributos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-880">Specifies whether to search this member's inheritance chain to find the attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-881">Retorna todos os atributos personalizados definidos para esse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-881">Returns all the custom attributes defined for this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-882">Retorna uma matriz de objetos que representa todos os atributos personalizados desse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-882">Returns an array of objects representing all the custom attributes of this type.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="6096a-883">Não há suporte para tipos incompletos nesse método atualmente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-883">This method is not currently supported for incomplete types.</span>
          </span>
          <span data-ttu-id="6096a-884">Recupere o tipo usando <see cref="M:System.Type.GetType" /> e chame <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> no <see cref="T:System.Type" /> retornado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-884">Retrieve the type using <see cref="M:System.Type.GetType" /> and call <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> on the returned <see cref="T:System.Type" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <span data-ttu-id="6096a-885">O tipo de atributo a ser pesquisado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-885">The type of attribute to search for.</span>
          </span>
          <span data-ttu-id="6096a-886">Somente os atributos que podem ser atribuídos a esse tipo são retornados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-886">Only attributes that are assignable to this type are returned.</span>
          </span>
        </param>
        <param name="inherit">
          <span data-ttu-id="6096a-887">Especifica se deve-se pesquisar ou não a cadeia de herança desse membro para localizar os atributos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-887">Specifies whether to search this member's inheritance chain to find the attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-888">Retorna todos os atributos personalizados do tipo atual que podem ser atribuídos a um tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-888">Returns all the custom attributes of the current type that are assignable to a specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-889">Uma matriz de atributos personalizados definida no tipo atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-889">An array of custom attributes defined on the current type.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="6096a-890">Não há suporte para tipos incompletos nesse método atualmente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-890">This method is not currently supported for incomplete types.</span>
          </span>
          <span data-ttu-id="6096a-891">Recupere o tipo usando <see cref="M:System.Type.GetType" /> e chame <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> no <see cref="T:System.Type" /> retornado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-891">Retrieve the type using <see cref="M:System.Type.GetType" /> and call <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> on the returned <see cref="T:System.Type" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-892">
            <paramref name="attributeType" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-892">
              <paramref name="attributeType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-893">O tipo deve ser um tipo fornecido pelo sistema de tempo de execução subjacente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-893">The type must be a type provided by the underlying runtime system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public override Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetElementType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="6096a-894">A chamada desse método sempre lança <see cref="T:System.NotSupportedException" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-894">Calling this method always throws <see cref="T:System.NotSupportedException" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-895">Não há suporte para o método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-895">This method is not supported.</span>
          </span>
          <span data-ttu-id="6096a-896">Nenhum valor é retornado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-896">No value is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-897">Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="6096a-897">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="6096a-898">Não há suporte para o método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-898">This method is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-899">O nome do evento a ser pesquisado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-899">The name of the event to search for.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="6096a-900">Uma combinação bit a bit de valores <see cref="T:System.Reflection.BindingFlags" /> que limita a pesquisa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-900">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limits the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-901">Retorna o evento com o nome especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-901">Returns the event with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-902">Um objeto <see cref="T:System.Reflection.EventInfo" /> que representa o evento declarado ou herdado por esse tipo com o nome especificado ou <see langword="null" /> se não houver correspondências.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-902">An <see cref="T:System.Reflection.EventInfo" /> object representing the event declared or inherited by this type with the specified name, or <see langword="null" /> if there are no matches.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-903">Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="6096a-903">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="6096a-904">Esse método não está implementado para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-904">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-905">Retorna os eventos definidos pelo <see cref="T:System.Reflection.Emit.TypeBuilder" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-905">Returns the events defined by the current <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="6096a-906">Retorna os eventos públicos declarados ou herdados por esse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-906">Returns the public events declared or inherited by this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-907">Retorna uma matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representa os eventos públicos declarados ou herdados por esse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-907">Returns an array of <see cref="T:System.Reflection.EventInfo" /> objects representing the public events declared or inherited by this type.</span>
          </span>
          <span data-ttu-id="6096a-908">Uma matriz vazia será retornada se não houver eventos públicos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-908">An empty array is returned if there are no public events.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-909">Recuperar o tipo usando <xref:System.Type.GetType%2A> ou <xref:System.Reflection.Assembly.GetType%2A> e usar reflexão no tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="6096a-909">Retrieve the type using <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetType%2A> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="6096a-910">Esse método não está implementado para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-910">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="6096a-911">Uma combinação bit a bit de valores <see cref="T:System.Reflection.BindingFlags" /> que limita a pesquisa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-911">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limits the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-912">Retorna os eventos públicos e não públicos que são declarados por esse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-912">Returns the public and non-public events that are declared by this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-913">Retorna uma matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representa os eventos declarados ou herdados por esse tipo que correspondem aos sinalizadores de associação especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-913">Returns an array of <see cref="T:System.Reflection.EventInfo" /> objects representing the events declared or inherited by this type that match the specified binding flags.</span>
          </span>
          <span data-ttu-id="6096a-914">Uma matriz vazia será retornada se não houver eventos correspondentes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-914">An empty array is returned if there are no matching events.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-915">Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="6096a-915">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="6096a-916">Esse método não está implementado para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-916">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-917">Retorna um campo definido pelo <see cref="T:System.Reflection.Emit.TypeBuilder" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-917">Returns a field defined by the current <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-918">O nome do campo a ser obtido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-918">The name of the field to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="6096a-919">Esse deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como em <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-919">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-920">Retorna o campo especificado pelo nome fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-920">Returns the field specified by the given name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-921">Retorna o objeto <see cref="T:System.Reflection.FieldInfo" /> que representa o campo declarado ou herdado por esse tipo com o nome especificado e o modificador público ou não público.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-921">Returns the <see cref="T:System.Reflection.FieldInfo" /> object representing the field declared or inherited by this type with the specified name and public or non-public modifier.</span>
          </span>
          <span data-ttu-id="6096a-922">Se não houver correspondências, <see langword="null" /> será retornado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-922">If there are no matches then <see langword="null" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-923">Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="6096a-923">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="6096a-924">Esse método não está implementado para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-924">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public static System.Reflection.FieldInfo GetField (Type type, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.FieldInfo GetField(class System.Type type, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::FieldInfo ^ GetField(Type ^ type, System::Reflection::FieldInfo ^ field);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="6096a-925">O tipo genérico construído cujo campo será retornado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-925">The constructed generic type whose field is returned.</span>
          </span>
        </param>
        <param name="field">
          <span data-ttu-id="6096a-926">Um campo na definição de tipo genérico de <c>tipo</c> que especifica qual campo de <c>tipo</c> será retornado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-926">A field on the generic type definition of <c>type</c>, which specifies which field of <c>type</c> to return.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-927">Retorna o campo de tipo genérico construído especificado que corresponde ao campo especificado da definição de tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-927">Returns the field of the specified constructed generic type that corresponds to the specified field of the generic type definition.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-928">Um objeto <see cref="T:System.Reflection.FieldInfo" /> que representa o campo de <paramref name="type" /> correspondente a <paramref name="field" />, que especifica um campo pertencente à definição de tipo genérico de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-928">A <see cref="T:System.Reflection.FieldInfo" /> object that represents the field of <paramref name="type" /> corresponding to <paramref name="field" />, which specifies a field belonging to the generic type definition of <paramref name="type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-929">O <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> método fornece uma maneira de obter um <xref:System.Reflection.FieldInfo> objeto que representa um campo de um tipo genérico construído cuja definição de tipo genérico é representada por um <xref:System.Reflection.Emit.TypeBuilder> objeto.</span><span class="sxs-lookup"><span data-stu-id="6096a-929">The <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method provides a way to get a <xref:System.Reflection.FieldInfo> object that represents a field of a constructed generic type whose generic type definition is represented by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="6096a-930">Por exemplo, suponha que você tenha um <xref:System.Reflection.Emit.TypeBuilder> objeto que representa o tipo `G<T>` na sintaxe do c# (`G(Of T)` no Visual Basic, `generic <T> ref class G` em C++) e um <xref:System.Reflection.Emit.FieldBuilder> objeto que representa um campo `public T F` na sintaxe do c# (`Public F As T` no Visual Basic, `public: T F` em C++) que é definido por `G<T>`.</span><span class="sxs-lookup"><span data-stu-id="6096a-930">For example, suppose you have a <xref:System.Reflection.Emit.TypeBuilder> object that represents the type `G<T>` in C# syntax (`G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) and a <xref:System.Reflection.Emit.FieldBuilder> object that represents a field `public T F` in C# syntax (`Public F As T` in Visual Basic, `public: T F` in C++) that is defined by `G<T>`.</span></span> <span data-ttu-id="6096a-931">Suponha que `G<T>` tem um método genérico com parâmetro de tipo `U` que cria uma instância do tipo construído `G<U>` e o campo de chamadas `F` nessa instância.</span><span class="sxs-lookup"><span data-stu-id="6096a-931">Suppose that `G<T>` has a generic method with type parameter `U` that creates an instance of the constructed type `G<U>` and calls field `F` on that instance.</span></span> <span data-ttu-id="6096a-932">Para emitir a chamada de função, é necessário um <xref:System.Reflection.FieldInfo> objeto que representa `F` no tipo construído — em outras palavras, que é do tipo `U` em vez do tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="6096a-932">In order to emit the function call, you need a <xref:System.Reflection.FieldInfo> object that represents `F` on the constructed type — in other words, that is of type `U` rather than type `T`.</span></span> <span data-ttu-id="6096a-933">Para fazer isso, primeiro chame o <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método o <xref:System.Reflection.Emit.TypeBuilder> do objeto, especificando o <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto que representa `U` como o argumento de tipo.</span><span class="sxs-lookup"><span data-stu-id="6096a-933">To do this, first call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on the <xref:System.Reflection.Emit.TypeBuilder> object, specifying the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object that represents `U` as the type argument.</span></span> <span data-ttu-id="6096a-934">Em seguida, chame o <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> método com o valor de retorno a <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método como parâmetro `type` e o <xref:System.Reflection.Emit.FieldBuilder> objeto que representa `F` como parâmetro `field`.</span><span class="sxs-lookup"><span data-stu-id="6096a-934">Then call the <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method with the return value of the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method as parameter `type` and the <xref:System.Reflection.Emit.FieldBuilder> object that represents `F` as parameter `field`.</span></span> <span data-ttu-id="6096a-935">O valor de retorno é a <xref:System.Reflection.FieldInfo> precisar emitir a chamada de função do objeto.</span><span class="sxs-lookup"><span data-stu-id="6096a-935">The return value is the <xref:System.Reflection.FieldInfo> object you need to emit the function call.</span></span> <span data-ttu-id="6096a-936">O exemplo de código demonstra esse cenário.</span><span class="sxs-lookup"><span data-stu-id="6096a-936">The code example demonstrates this scenario.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6096a-937">O exemplo de código a seguir contém o código-fonte para uma classe genérica denominado exemplo que tem um parâmetro de tipo denominado `T`.</span><span class="sxs-lookup"><span data-stu-id="6096a-937">The following code example contains source code for a generic class named Sample that has a type parameter named `T`.</span></span> <span data-ttu-id="6096a-938">A classe tem um campo chamado `Field`, do tipo `T`e um método genérico chamado `GM` com seu próprio parâmetro de tipo, denominado `U`.</span><span class="sxs-lookup"><span data-stu-id="6096a-938">The class has a field named `Field`, of type `T`, and a generic method named `GM` with its own type parameter, named `U`.</span></span> <span data-ttu-id="6096a-939">Método `GM` cria uma instância de `Sample`, substituindo seu próprio parâmetro de tipo `U` para o parâmetro de tipo de `Sample`e armazena seu parâmetro de entrada em `Field`.</span><span class="sxs-lookup"><span data-stu-id="6096a-939">Method `GM` creates an instance of `Sample`, substituting its own type parameter `U` for the type parameter of `Sample`, and stores its input parameter in `Field`.</span></span> <span data-ttu-id="6096a-940">Este código-fonte é compilado, mas não utilizado; Você pode exibi-lo com o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) e compará-lo com o código emitido pela classe `Example`.</span><span class="sxs-lookup"><span data-stu-id="6096a-940">This source code is compiled but not used; you can view it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) and compare it to the code emitted by class `Example`.</span></span>  
  
 <span data-ttu-id="6096a-941">O código na classe `Example` demonstra o uso de <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> método emitir código genérico.</span><span class="sxs-lookup"><span data-stu-id="6096a-941">The code in class `Example` demonstrates the use of the <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method to emit generic code.</span></span> <span data-ttu-id="6096a-942">O `Main` método da classe `Example` cria um assembly dinâmico que contém uma classe denominada `Sample`e usa o <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> método torná-la genérica adicionando um parâmetro de tipo denominado `T`.</span><span class="sxs-lookup"><span data-stu-id="6096a-942">The `Main` method of class `Example` creates a dynamic assembly containing a class named `Sample`, and uses the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method to make it generic by adding a type parameter named `T`.</span></span> <span data-ttu-id="6096a-943">Um construtor padrão e um campo denominado `Field`, do tipo `T`, são adicionados à classe `Sample`.</span><span class="sxs-lookup"><span data-stu-id="6096a-943">A default constructor and a field named `Field`, of type `T`, are added to class `Sample`.</span></span> <span data-ttu-id="6096a-944">Um método `GM` é adicionada e convertido em um método genérico, usando o <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="6096a-944">A method `GM` is added and turned into a generic method by using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="6096a-945">O parâmetro de tipo de `GM` chamado `U`.</span><span class="sxs-lookup"><span data-stu-id="6096a-945">The type parameter of `GM` is named `U`.</span></span> <span data-ttu-id="6096a-946">Depois que o parâmetro de tipo é definido, a assinatura de `GM` é adicionado usando o <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="6096a-946">After the type parameter is defined, the signature of `GM` is added by using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="6096a-947">Não há nenhum tipo de retorno e sem a necessidade de ou modificadores personalizados, então todos os parâmetros desse método são `null` exceto `parameterTypes`; `parameterTypes` define o tipo de um único parâmetro do método para `U`, o parâmetro de tipo genérico do método.</span><span class="sxs-lookup"><span data-stu-id="6096a-947">There is no return type and no required or custom modifiers, so all the parameters of this method are `null` except `parameterTypes`; `parameterTypes` sets the type of the method's only parameter to `U`, the method's generic type parameter.</span></span> <span data-ttu-id="6096a-948">O corpo do método cria uma instância do tipo construído `Sample<U>` (`Sample(Of U)` no Visual Basic), atribui o parâmetro do método para `Field`e imprime o valor de `Field`.</span><span class="sxs-lookup"><span data-stu-id="6096a-948">The body of the method creates an instance of the constructed type `Sample<U>` (`Sample(Of U)` in Visual Basic), assigns the method's parameter to `Field`, and then prints the value of `Field`.</span></span> <span data-ttu-id="6096a-949">O <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> método é usado para criar um <xref:System.Reflection.FieldInfo> que representa o campo do tipo genérico construído `Sample<U>` no <xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType> e <xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType> instruções.</span><span class="sxs-lookup"><span data-stu-id="6096a-949">The <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method is used to create a <xref:System.Reflection.FieldInfo> that represents the field of the constructed generic type `Sample<U>` in the <xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType> and <xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType> instructions.</span></span>  
  
 <span data-ttu-id="6096a-950">Um tipo fictício está definido para conter o método de ponto de entrada `Main`.</span><span class="sxs-lookup"><span data-stu-id="6096a-950">A dummy type is defined to hold the entry-point method `Main`.</span></span> <span data-ttu-id="6096a-951">No corpo da `Main`, estático `GM` método é invocado no tipo genérico construído `Sample<int>` (`Sample(Of Integer)` no Visual Basic), com o tipo <xref:System.String> substituídos por `U`.</span><span class="sxs-lookup"><span data-stu-id="6096a-951">In the body of `Main`, the static `GM` method is invoked on the constructed generic type `Sample<int>` (`Sample(Of Integer)` in Visual Basic), with type <xref:System.String> substituted for `U`.</span></span>  
  
 <span data-ttu-id="6096a-952">Quando o exemplo de código é executado, ele salva o assembly emitido como TypeBuilderGetFieldExample.exe.</span><span class="sxs-lookup"><span data-stu-id="6096a-952">When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</span></span> <span data-ttu-id="6096a-953">Você pode executar TypeBuilderGetFieldExample.exe, e você pode usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para comparar o código emitido com o código para o `Sample` classe que é compilado para o exemplo de código.</span><span class="sxs-lookup"><span data-stu-id="6096a-953">You can run TypeBuilderGetFieldExample.exe, and you can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to compare the emitted code with the code for the `Sample` class that is compiled into the code example itself.</span></span>  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-954">
            <paramref name="type" /> não representa um tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-954">
              <paramref name="type" /> does not represent a generic type.</span>
          </span>
          <span data-ttu-id="6096a-955">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-955">-or-</span>
          </span>
          <span data-ttu-id="6096a-956">
            <paramref name="type" /> não é do tipo <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-956">
              <paramref name="type" /> is not of type <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          </span>
          <span data-ttu-id="6096a-957">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-957">-or-</span>
          </span>
          <span data-ttu-id="6096a-958">O tipo declarativo de <paramref name="field" /> não é uma definição de tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-958">The declaring type of <paramref name="field" /> is not a generic type definition.</span>
          </span>
          <span data-ttu-id="6096a-959">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-959">-or-</span>
          </span>
          <span data-ttu-id="6096a-960">O tipo declarativo de <paramref name="field" /> não é a definição de tipo genérico de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-960">The declaring type of <paramref name="field" /> is not the generic type definition of <paramref name="type" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="6096a-961">Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-961">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-962">Retorna os campos públicos e não públicos que são declarados por esse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-962">Returns the public and non-public fields that are declared by this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-963">Retorna uma matriz de objetos <see cref="T:System.Reflection.FieldInfo" /> que representam os campos públicos e não públicos declarados ou herdados por esse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-963">Returns an array of <see cref="T:System.Reflection.FieldInfo" /> objects representing the public and non-public fields declared or inherited by this type.</span>
          </span>
          <span data-ttu-id="6096a-964">Se não há campos, uma matriz vazia é retornada, conforme especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-964">An empty array is returned if there are no fields, as specified.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-965">O <xref:System.Reflection.Emit.TypeBuilder.GetFields%2A> método não retornar campos em uma ordem específica, como em ordem alfabética ou ordem de declaração.</span><span class="sxs-lookup"><span data-stu-id="6096a-965">The <xref:System.Reflection.Emit.TypeBuilder.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="6096a-966">Seu código deve não dependam da ordem na qual os campos são retornados, como ordem pode variar.</span><span class="sxs-lookup"><span data-stu-id="6096a-966">Your code must not depend on the order in which fields are returned, because that order can vary.</span></span>  
  
 <span data-ttu-id="6096a-967">Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="6096a-967">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="6096a-968">Esse método não está implementado para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-968">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="6096a-969">Retorna uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo de um tipo genérico ou os parâmetros de tipo de uma definição de tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-969">Returns an array of <see cref="T:System.Type" /> objects representing the type arguments of a generic type or the type parameters of a generic type definition.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-970">Uma matriz de objetos de <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-970">An array of <see cref="T:System.Type" /> objects.</span>
          </span>
          <span data-ttu-id="6096a-971">Os elementos da matriz representam os argumentos de tipo de um tipo genérico ou os parâmetros de tipo de uma definição de tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-971">The elements of the array represent the type arguments of a generic type or the type parameters of a generic type definition.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-972">Os elementos da matriz retornada estão na ordem em que aparecem na lista de parâmetros de tipo para a definição de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="6096a-972">The elements of the returned array are in the order in which they appear in the list of type parameters for the generic type definition.</span></span>  
  
 <span data-ttu-id="6096a-973">Um <xref:System.Reflection.Emit.TypeBuilder> objeto representa uma definição de tipo genérico se o <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> método foi usado para que ela tenha parâmetros de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="6096a-973">A <xref:System.Reflection.Emit.TypeBuilder> object represents a generic type definition if the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method has been used to give it generic type parameters.</span></span> <span data-ttu-id="6096a-974">Esse método recupera o <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objetos que representam os parâmetros de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="6096a-974">This method retrieves the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objects that represent the generic type parameters.</span></span>  
  
 <span data-ttu-id="6096a-975">Para obter mais informações sobre tipos genéricos em reflexão e uma lista de condições invariáveis para termos usados na reflexão genérico, consulte o <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="6096a-975">For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericArguments" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetGenericTypeDefinition();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="6096a-976">Retorna um objeto <see cref="T:System.Type" /> que representa uma definição de tipo genérico da qual o tipo atual pode ser obtido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-976">Returns a <see cref="T:System.Type" /> object that represents a generic type definition from which the current type can be obtained.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-977">Um objeto <see cref="T:System.Type" /> que representa uma definição de tipo genérico da qual o tipo atual pode ser obtido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-977">A <see cref="T:System.Type" /> object representing a generic type definition from which the current type can be obtained.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-978">Se você chamar o <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> método em um <xref:System.Reflection.Emit.TypeBuilder> objeto para o qual o <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> propriedade retorna `true`, o <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> propriedade retorna a instância atual.</span><span class="sxs-lookup"><span data-stu-id="6096a-978">If you call the <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> method on a <xref:System.Reflection.Emit.TypeBuilder> object for which the <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> property returns `true`, the <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> property returns the current instance.</span></span> <span data-ttu-id="6096a-979">Um <xref:System.Reflection.Emit.TypeBuilder> que representa um tipo genérico é sempre uma definição de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="6096a-979">A <xref:System.Reflection.Emit.TypeBuilder> that represents a generic type is always a generic type definition.</span></span>  
  
 <span data-ttu-id="6096a-980">Se você usou o <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método para construir um tipo genérico de um <xref:System.Reflection.Emit.TypeBuilder> objeto que representa uma definição de tipo genérico, usando o <xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType> método do tipo construído obtém de volta a <xref:System.Reflection.Emit.TypeBuilder> objeto que representa a definição de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="6096a-980">If you used the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method to construct a generic type from a <xref:System.Reflection.Emit.TypeBuilder> object that represents a generic type definition, using the <xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType> method on the constructed type gets back the <xref:System.Reflection.Emit.TypeBuilder> object that represents the generic type definition.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-981">O tipo atual não é genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-981">The current type is not generic.</span>
          </span>
          <span data-ttu-id="6096a-982">Ou seja, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> retorna <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-982">That is, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> returns <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public override Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-983">O nome da interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-983">The name of the interface.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="6096a-984">Se <see langword="true" />, a pesquisa não diferenciará maiúsculas de minúsculas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-984">If <see langword="true" />, the search is case-insensitive.</span>
          </span>
          <span data-ttu-id="6096a-985">Se <see langword="false" />, a pesquisa diferenciará maiúsculas de minúsculas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-985">If <see langword="false" />, the search is case-sensitive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-986">Retorna a interface implementada (direta ou indiretamente) por essa classe com o nome totalmente qualificado correspondente ao nome de interface fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-986">Returns the interface implemented (directly or indirectly) by this class with the fully qualified name matching the given interface name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-987">Retorna um objeto <see cref="T:System.Type" /> que representa a interface implementada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-987">Returns a <see cref="T:System.Type" /> object representing the implemented interface.</span>
          </span>
          <span data-ttu-id="6096a-988">Retorna nulo se nenhum nome de interface correspondente for encontrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-988">Returns null if no interface matching name is found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-989">Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="6096a-989">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="6096a-990">Esse método não está implementado para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-990">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public override System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">
          <span data-ttu-id="6096a-991">O <see cref="T:System.Type" /> da interface para a qual o mapeamento deve ser recuperado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-991">The <see cref="T:System.Type" /> of the interface for which the mapping is to be retrieved.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-992">Retorna um mapeamento de interface para a interface solicitada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-992">Returns an interface mapping for the requested interface.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-993">Retorna o mapeamento de interface solicitado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-993">Returns the requested interface mapping.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-994">Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="6096a-994">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="6096a-995">Esse método não está implementado para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-995">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public override Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="6096a-996">Retorna uma matriz de todas as interfaces implementadas nesse tipo e seus tipos base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-996">Returns an array of all the interfaces implemented on this type and its base types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-997">Retorna uma matriz de objetos <see cref="T:System.Type" /> que representam as interfaces implementadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-997">Returns an array of <see cref="T:System.Type" /> objects representing the implemented interfaces.</span>
          </span>
          <span data-ttu-id="6096a-998">Se nenhum deles for definido, uma matriz vazia será retornada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-998">If none are defined, an empty array is returned.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-999">O nome do membro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-999">The name of the member.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="6096a-1000">O tipo do membro a se retornar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1000">The type of the member to return.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="6096a-1001">Esse deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como em <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1001">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" />, as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-1002">Retorna todos os membros públicos e não públicos declarados ou herdados por esse tipo, conforme especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1002">Returns all the public and non-public members declared or inherited by this type, as specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-1003">Retorna uma matriz de <see cref="T:System.Reflection.MemberInfo" /> objetos que representam os membros públicos e não públicos definidos nesse tipo se <paramref name="nonPublic" /> for usado; caso contrário, somente os membros públicos serão retornados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1003">Returns an array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public and non-public members defined on this type if <paramref name="nonPublic" /> is used; otherwise, only the public members are returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1004">Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="6096a-1004">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="6096a-1005">Esse método não está implementado para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1005">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="6096a-1006">Esse deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1006">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" />, such as <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-1007">Retorna os membros dos membros públicos e não públicos declarados ou herdados por esse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1007">Returns the members for the public and non-public members declared or inherited by this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-1008">Retorna uma matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representam os membros públicos e não públicos declarados ou herdados por esse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1008">Returns an array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public and non-public members declared or inherited by this type.</span>
          </span>
          <span data-ttu-id="6096a-1009">Se não houver membros correspondentes, uma matriz vazia será retornada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1009">An empty array is returned if there are no matching members.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1010">Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="6096a-1010">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="6096a-1011">Esse método não está implementado para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1011">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodInfo GetMethod (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodInfo GetMethod(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodInfo ^ GetMethod(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="6096a-1012">O tipo genérico construído cujo método será retornado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1012">The constructed generic type whose method is returned.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="6096a-1013">Um método na definição de tipo genérico de <c>tipo</c> que especifica qual método de <c>tipo</c> será retornado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1013">A method on the generic type definition of <c>type</c>, which specifies which method of <c>type</c> to return.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-1014">Retorna o método do tipo genérico construído especificado que corresponde ao método especificado da definição de tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1014">Returns the method of the specified constructed generic type that corresponds to the specified method of the generic type definition.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-1015">Um objeto <see cref="T:System.Reflection.MethodInfo" /> que representa o método de <paramref name="type" /> correspondente a <paramref name="method" />, que especifica um método pertencente à definição de tipo genérico de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1015">A <see cref="T:System.Reflection.MethodInfo" /> object that represents the method of <paramref name="type" /> corresponding to <paramref name="method" />, which specifies a method belonging to the generic type definition of <paramref name="type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1016">O <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> método fornece uma maneira de obter um <xref:System.Reflection.MethodInfo> objeto que representa um método de um tipo genérico construído cuja definição de tipo genérico é representada por um <xref:System.Reflection.Emit.TypeBuilder> objeto.</span><span class="sxs-lookup"><span data-stu-id="6096a-1016">The <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method provides a way to get a <xref:System.Reflection.MethodInfo> object that represents a method of a constructed generic type whose generic type definition is represented by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="6096a-1017">Por exemplo, suponha que você tenha um <xref:System.Reflection.Emit.TypeBuilder> objeto que representa o tipo `G<T>` na sintaxe do c# (`G(Of T)` no Visual Basic, `generic <T> ref class G` em C++) e um <xref:System.Reflection.Emit.MethodBuilder> objeto que representa um método `T M()` na sintaxe do c# (`Function M() As T` no Visual Basic, `T M()` em C++) que é definido por `G<T>`.</span><span class="sxs-lookup"><span data-stu-id="6096a-1017">For example, suppose you have a <xref:System.Reflection.Emit.TypeBuilder> object that represents the type `G<T>` in C# syntax (`G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) and a <xref:System.Reflection.Emit.MethodBuilder> object that represents a method `T M()` in C# syntax (`Function M() As T` in Visual Basic, `T M()` in C++) that is defined by `G<T>`.</span></span> <span data-ttu-id="6096a-1018">Suponha que `G<T>` tem um método genérico com parâmetro de tipo `U` que cria uma instância do tipo construído `G<U>` e chama o método `M` nessa instância.</span><span class="sxs-lookup"><span data-stu-id="6096a-1018">Suppose that `G<T>` has a generic method with type parameter `U` that creates an instance of the constructed type `G<U>` and calls method `M` on that instance.</span></span> <span data-ttu-id="6096a-1019">Para emitir a chamada de função, é necessário um <xref:System.Reflection.MethodInfo> objeto que representa `M` no tipo construído — em outras palavras, que retorna tipo `U` em vez do tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="6096a-1019">In order to emit the function call, you need a <xref:System.Reflection.MethodInfo> object that represents `M` on the constructed type — in other words, that returns type `U` rather than type `T`.</span></span> <span data-ttu-id="6096a-1020">Para fazer isso, primeiro chame o <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método o <xref:System.Reflection.Emit.TypeBuilder> do objeto, especificando o <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto que representa `U` como o argumento de tipo.</span><span class="sxs-lookup"><span data-stu-id="6096a-1020">To do this, first call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on the <xref:System.Reflection.Emit.TypeBuilder> object, specifying the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object that represents `U` as the type argument.</span></span> <span data-ttu-id="6096a-1021">Em seguida, chame o <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> método com o valor de retorno a <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método como parâmetro `type` e o <xref:System.Reflection.Emit.MethodBuilder> objeto que representa `T M()` como parâmetro `method`.</span><span class="sxs-lookup"><span data-stu-id="6096a-1021">Then call the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method with the return value of the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method as parameter `type` and the <xref:System.Reflection.Emit.MethodBuilder> object that represents `T M()` as parameter `method`.</span></span> <span data-ttu-id="6096a-1022">O valor de retorno é a <xref:System.Reflection.MethodInfo> precisar emitir a chamada de função do objeto.</span><span class="sxs-lookup"><span data-stu-id="6096a-1022">The return value is the <xref:System.Reflection.MethodInfo> object you need to emit the function call.</span></span> <span data-ttu-id="6096a-1023">O exemplo de código demonstra um cenário semelhante a este.</span><span class="sxs-lookup"><span data-stu-id="6096a-1023">The code example demonstrates a scenario similar to this.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6096a-1024">O exemplo de código a seguir contém o código-fonte para uma classe genérica denominado `Sample` que tem um parâmetro de tipo denominado `T`.</span><span class="sxs-lookup"><span data-stu-id="6096a-1024">The following code example contains source code for a generic class named `Sample` that has a type parameter named `T`.</span></span> <span data-ttu-id="6096a-1025">A classe tem um campo chamado `Field`, do tipo `T`e um método genérico chamado `GM` com seu próprio parâmetro de tipo, denominado `U`.</span><span class="sxs-lookup"><span data-stu-id="6096a-1025">The class has a field named `Field`, of type `T`, and a generic method named `GM` with its own type parameter, named `U`.</span></span> <span data-ttu-id="6096a-1026">Método `GM` cria uma instância de `Sample`, substituindo seu próprio parâmetro de tipo `U` para o parâmetro de tipo de `Sample`e armazena seu parâmetro de entrada em `Field`.</span><span class="sxs-lookup"><span data-stu-id="6096a-1026">Method `GM` creates an instance of `Sample`, substituting its own type parameter `U` for the type parameter of `Sample`, and stores its input parameter in `Field`.</span></span> <span data-ttu-id="6096a-1027">Este código-fonte é compilado, mas não utilizado; Você pode exibi-lo com o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) e compará-lo com o código emitido pela classe `Example`.</span><span class="sxs-lookup"><span data-stu-id="6096a-1027">This source code is compiled but not used; you can view it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) and compare it to the code emitted by class `Example`.</span></span>  
  
 <span data-ttu-id="6096a-1028">O código na classe `Example` demonstra o uso de <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> método emitir código genérico.</span><span class="sxs-lookup"><span data-stu-id="6096a-1028">The code in class `Example` demonstrates the use of the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method to emit generic code.</span></span> <span data-ttu-id="6096a-1029">O `Main` método da classe `Example` cria um assembly dinâmico que contém uma classe denominada `Sample` e usa o <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> método torná-la genérica adicionando um parâmetro de tipo denominado `T`.</span><span class="sxs-lookup"><span data-stu-id="6096a-1029">The `Main` method of class `Example` creates a dynamic assembly containing a class named `Sample` and uses the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method to make it generic by adding a type parameter named `T`.</span></span> <span data-ttu-id="6096a-1030">Um construtor padrão e um campo denominado `Field`, do tipo `T`, são adicionados à classe `Sample`.</span><span class="sxs-lookup"><span data-stu-id="6096a-1030">A default constructor and a field named `Field`, of type `T`, are added to class `Sample`.</span></span> <span data-ttu-id="6096a-1031">Um método `GM` é adicionada e convertido em um método genérico, usando o <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="6096a-1031">A method `GM` is added and turned into a generic method by using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="6096a-1032">O parâmetro de tipo de `GM` chamado `U`.</span><span class="sxs-lookup"><span data-stu-id="6096a-1032">The type parameter of `GM` is named `U`.</span></span> <span data-ttu-id="6096a-1033">Depois que o parâmetro de tipo é definido, a assinatura de `GM` é adicionado usando o <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="6096a-1033">After the type parameter is defined, the signature of `GM` is added by using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="6096a-1034">Não há nenhum tipo de retorno e sem a necessidade de ou modificadores personalizados, então todos os parâmetros desse método são `null` exceto `parameterTypes`; `parameterTypes` define o tipo de um único parâmetro do método para `U`, o parâmetro de tipo genérico do método.</span><span class="sxs-lookup"><span data-stu-id="6096a-1034">There is no return type and no required or custom modifiers, so all the parameters of this method are `null` except `parameterTypes`; `parameterTypes` sets the type of the method's only parameter to `U`, the method's generic type parameter.</span></span> <span data-ttu-id="6096a-1035">O corpo do método cria uma instância do tipo construído `Sample<U>` (`Sample(Of U)` no Visual Basic), atribui o parâmetro do método para `Field`e imprime o valor de `Field`.</span><span class="sxs-lookup"><span data-stu-id="6096a-1035">The body of the method creates an instance of the constructed type `Sample<U>` (`Sample(Of U)` in Visual Basic), assigns the method's parameter to `Field`, and then prints the value of `Field`.</span></span> <span data-ttu-id="6096a-1036">Um tipo fictício está definido para conter o método de ponto de entrada `Main`.</span><span class="sxs-lookup"><span data-stu-id="6096a-1036">A dummy type is defined to hold the entry-point method `Main`.</span></span> <span data-ttu-id="6096a-1037">No corpo da `Main`, estático `GM` método é invocado no tipo genérico construído `Sample<int>` (`Sample(Of Integer)` no Visual Basic), com o tipo <xref:System.String> substituídos por `U`.</span><span class="sxs-lookup"><span data-stu-id="6096a-1037">In the body of `Main`, the static `GM` method is invoked on the constructed generic type `Sample<int>` (`Sample(Of Integer)` in Visual Basic), with type <xref:System.String> substituted for `U`.</span></span> <span data-ttu-id="6096a-1038">O <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> método é usado para criar um <xref:System.Reflection.MethodInfo> para estático `GM` método do tipo genérico construído `Sample<U>`e o <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> método é usado para criar um <xref:System.Reflection.MethodInfo> que pode ser emitido em uma chamada de método.</span><span class="sxs-lookup"><span data-stu-id="6096a-1038">The <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method is used to create a <xref:System.Reflection.MethodInfo> for the static `GM` method of the constructed generic type `Sample<U>`, and the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> method is then used to create a <xref:System.Reflection.MethodInfo> that can emitted in a method call.</span></span>  
  
 <span data-ttu-id="6096a-1039">Quando o exemplo de código é executado, ele salva o assembly emitido como TypeBuilderGetFieldExample.exe.</span><span class="sxs-lookup"><span data-stu-id="6096a-1039">When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</span></span> <span data-ttu-id="6096a-1040">Você pode executar TypeBuilderGetFieldExample.exe, e você pode usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para comparar o código emitido com o código para o `Sample` classe que é compilado para o exemplo de código.</span><span class="sxs-lookup"><span data-stu-id="6096a-1040">You can run TypeBuilderGetFieldExample.exe, and you can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to compare the emitted code with the code for the `Sample` class that is compiled into the code example itself.</span></span>  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-1041">
            <paramref name="method" /> é um método genérico que não é uma definição de método genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1041">
              <paramref name="method" /> is a generic method that is not a generic method definition.</span>
          </span>
          <span data-ttu-id="6096a-1042">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1042">-or-</span>
          </span>
          <span data-ttu-id="6096a-1043">
            <paramref name="type" /> não representa um tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1043">
              <paramref name="type" /> does not represent a generic type.</span>
          </span>
          <span data-ttu-id="6096a-1044">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1044">-or-</span>
          </span>
          <span data-ttu-id="6096a-1045">
            <paramref name="type" /> não é do tipo <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1045">
              <paramref name="type" /> is not of type <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          </span>
          <span data-ttu-id="6096a-1046">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1046">-or-</span>
          </span>
          <span data-ttu-id="6096a-1047">O tipo declarativo de <paramref name="method" /> não é uma definição de tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1047">The declaring type of <paramref name="method" /> is not a generic type definition.</span>
          </span>
          <span data-ttu-id="6096a-1048">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1048">-or-</span>
          </span>
          <span data-ttu-id="6096a-1049">O tipo declarativo de <paramref name="method" /> não é a definição de tipo genérico de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1049">The declaring type of <paramref name="method" /> is not the generic type definition of <paramref name="type" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="6096a-1050">Esse deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como em <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1050">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-1051">Retorna todos os métodos públicos e não públicos declarados ou herdados por esse tipo, conforme especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1051">Returns all the public and non-public methods declared or inherited by this type, as specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-1052">Retorna uma matriz de objetos <see cref="T:System.Reflection.MethodInfo" /> que representam os métodos públicos e não públicos definidos neste tipo se <paramref name="nonPublic" /> for usado; caso contrário, somente os métodos públicos serão retornados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1052">Returns an array of <see cref="T:System.Reflection.MethodInfo" /> objects representing the public and non-public methods defined on this type if <paramref name="nonPublic" /> is used; otherwise, only the public methods are returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1053">Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="6096a-1053">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="6096a-1054">Esse método não está implementado para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1054">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public override Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-1055">O <see cref="T:System.String" /> que contém o nome do tipo aninhado a ser obtido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1055">The <see cref="T:System.String" /> containing the name of the nested type to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="6096a-1056">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1056">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="6096a-1057">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1057">-or-</span>
          </span>
          <span data-ttu-id="6096a-1058">Zero, para realizar uma pesquisa que diferencia maiúsculas de minúsculas para métodos públicos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1058">Zero, to conduct a case-sensitive search for public methods.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-1059">Retorna os tipos aninhados públicos e não públicos declarados por esse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1059">Returns the public and non-public nested types that are declared by this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-1060">Um objeto <see cref="T:System.Type" /> que representa o tipo aninhado que corresponde aos requisitos especificados, se encontrado; caso contrário, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1060">A <see cref="T:System.Type" /> object representing the nested type that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1061">Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="6096a-1061">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 <span data-ttu-id="6096a-1062">Se esse tipo é concluído, por exemplo, se `CreateType` foi chamado neste tipo, mas há tipos aninhados que não estão concluídos, em seguida, `GetNestedTypes` retornará apenas os tipos aninhados para o qual `CreateType` foi chamado.</span><span class="sxs-lookup"><span data-stu-id="6096a-1062">If this type is complete, for example, if `CreateType` has been called on this type, but there are nested types that are not complete, then `GetNestedTypes` will only return those nested types for which `CreateType` has been called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="6096a-1063">Esse método não está implementado para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1063">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="6096a-1064">Esse deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, tal como em <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1064">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" />, as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-1065">Retorna os tipos aninhados públicos e não públicos que são declarados ou herdados por esse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1065">Returns the public and non-public nested types that are declared or inherited by this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-1066">Uma matriz de objetos <see cref="T:System.Type" /> que representa todos os tipos aninhados no <see cref="T:System.Type" /> atual que correspondem às restrições de associação especificadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1066">An array of <see cref="T:System.Type" /> objects representing all the types nested within the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="6096a-1067">Uma matriz vazia do tipo <see cref="T:System.Type" /> se nenhum tipo estiver aninhado no <see cref="T:System.Type" /> atual ou se nenhum dos tipos aninhados corresponderem às restrições de associação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1067">An empty array of type <see cref="T:System.Type" />, if no types are nested within the current <see cref="T:System.Type" />, or if none of the nested types match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1068">Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="6096a-1068">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 <span data-ttu-id="6096a-1069">Se esse tipo é concluído, por exemplo, se `CreateType` foi chamado neste tipo, mas há tipos aninhados que não estão concluídos, em seguida, `GetNestedTypes` retornará apenas os tipos aninhados para o qual `CreateType` foi chamado.</span><span class="sxs-lookup"><span data-stu-id="6096a-1069">If this type is complete, for example, if `CreateType` has been called on this type, but there are nested types that are not complete, then `GetNestedTypes` will only return those nested types for which `CreateType` has been called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="6096a-1070">Esse método não está implementado para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1070">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public override System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="6096a-1071">Esse atributo de invocação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1071">This invocation attribute.</span>
          </span>
          <span data-ttu-id="6096a-1072">Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> e assim por diante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1072">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-1073">Retorna todas as propriedades públicas e não públicas declaradas ou herdadas por esse tipo, conforme especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1073">Returns all the public and non-public properties declared or inherited by this type, as specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-1074">Retorna uma matriz de objetos <see langword="PropertyInfo" /> que representam as propriedades públicas e não públicas definidas nesse tipo se <paramref name="nonPublic" /> for usado; caso contrário, somente as propriedades públicas serão retornadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1074">Returns an array of <see langword="PropertyInfo" /> objects representing the public and non-public properties defined on this type if <paramref name="nonPublic" /> is used; otherwise, only the public properties are returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1075">Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="6096a-1075">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="6096a-1076">Esse método não está implementado para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1076">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="returnType">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public override Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GUID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid GUID { Guid get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-1077">Recupera o GUID desse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1077">Retrieves the GUID of this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6096a-1078">Somente leitura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1078">Read-only.</span>
          </span>
          <span data-ttu-id="6096a-1079">Recupera o GUID desse tipo</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1079">Retrieves the GUID of this type</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1080">Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="6096a-1080">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="6096a-1081">Não há suporte para tipos incompletos nesse método atualmente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1081">This method is not currently supported for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool HasElementTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public override object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="6096a-1082">O nome do membro a ser invocado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1082">The name of the member to invoke.</span>
          </span>
          <span data-ttu-id="6096a-1083">Isso pode ser um construtor, um método, uma propriedade ou um campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1083">This can be a constructor, method, property, or field.</span>
          </span>
          <span data-ttu-id="6096a-1084">É necessário especificar um atributo de invocação adequado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1084">A suitable invocation attribute must be specified.</span>
          </span>
          <span data-ttu-id="6096a-1085">Observe que é possível invocar o membro padrão de uma classe, passando uma cadeia de caracteres vazia como o nome do membro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1085">Note that it is possible to invoke the default member of a class by passing an empty string as the name of the member.</span>
          </span>
        </param>
        <param name="invokeAttr">
          <span data-ttu-id="6096a-1086">O atributo de invocação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1086">The invocation attribute.</span>
          </span>
          <span data-ttu-id="6096a-1087">Isso deve ser um sinalizador de bit de <see langword="BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1087">This must be a bit flag from <see langword="BindingFlags" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="6096a-1088">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see langword="MemberInfo" /> usando reflexão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1088">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects using reflection.</span>
          </span>
          <span data-ttu-id="6096a-1089">Se o associador for <see langword="null" />, o associador padrão será usado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1089">If binder is <see langword="null" />, the default binder is used.</span>
          </span>
          <span data-ttu-id="6096a-1090">Consulte <see cref="T:System.Reflection.Binder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1090">See <see cref="T:System.Reflection.Binder" />.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="6096a-1091">O objeto no qual invocar o membro especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1091">The object on which to invoke the specified member.</span>
          </span>
          <span data-ttu-id="6096a-1092">Se o membro é estático, esse parâmetro é ignorado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1092">If the member is static, this parameter is ignored.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="6096a-1093">Uma lista de argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1093">An argument list.</span>
          </span>
          <span data-ttu-id="6096a-1094">Essa é uma matriz de objetos que contém o número, a ordem e o tipo dos parâmetros do membro a ser invocado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1094">This is an array of Objects that contains the number, order, and type of the parameters of the member to be invoked.</span>
          </span>
          <span data-ttu-id="6096a-1095">Se não houver nenhum parâmetro, isso deverá ser nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1095">If there are no parameters this should be null.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="6096a-1096">Uma matriz do mesmo comprimento que <c>args</c> com elementos que representam os atributos associados com os argumentos do membro a ser invocado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1096">An array of the same length as <c>args</c> with elements that represent the attributes associated with the arguments of the member to be invoked.</span>
          </span>
          <span data-ttu-id="6096a-1097">Um parâmetro com atributos associados a ele nos metadados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1097">A parameter has attributes associated with it in the metadata.</span>
          </span>
          <span data-ttu-id="6096a-1098">Eles são usados por diversos serviços de interoperabilidade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1098">They are used by various interoperability services.</span>
          </span>
          <span data-ttu-id="6096a-1099">Consulte as especificações de metadados para obter mais detalhes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1099">See the metadata specs for more details.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="6096a-1100">Uma instância de <see langword="CultureInfo" /> usada para determinar a coerção de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1100">An instance of <see langword="CultureInfo" /> used to govern the coercion of types.</span>
          </span>
          <span data-ttu-id="6096a-1101">Se isso for nulo, será usado o <see langword="CultureInfo" /> do thread atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1101">If this is null, the <see langword="CultureInfo" /> for the current thread is used.</span>
          </span>
          <span data-ttu-id="6096a-1102">(Por exemplo, isso é necessário para converter uma cadeia de caracteres que representa 1000 para um valor de tipo double, uma vez que 1000 é representado de forma diferente por diferentes culturas.)</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1102">(Note that this is necessary to, for example, convert a String that represents 1000 to a Double value, since 1000 is represented differently by different cultures.)</span>
          </span>
        </param>
        <param name="namedParameters">
          <span data-ttu-id="6096a-1103">Cada parâmetro na matriz <c>namedParameters</c> obtém o valor do elemento correspondente na matriz <c>args</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1103">Each parameter in the <c>namedParameters</c> array gets the value in the corresponding element in the <c>args</c> array.</span>
          </span>
          <span data-ttu-id="6096a-1104">Se o comprimento de <c>args</c> for maior que o de <c>namedParameters</c>, os valores de argumento restantes serão passados em ordem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1104">If the length of <c>args</c> is greater than the length of <c>namedParameters</c>, the remaining argument values are passed in order.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-1105">Invoca o membro especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1105">Invokes the specified member.</span>
          </span>
          <span data-ttu-id="6096a-1106">O método a ser invocado deve ser acessível e fornecer a correspondência mais específica com a lista de argumentos especificada, sob as restrições dos atributos associadores e de invocação especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1106">The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the constraints of the specified binder and invocation attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-1107">Retorna o valor retornado do membro invocado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1107">Returns the return value of the invoked member.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1108">Um método será chamado se o número de parâmetros na declaração de método é igual ao número de argumentos na lista de argumentos especificada e o tipo de cada argumento pode ser convertido pelo associador para o tipo do parâmetro.</span><span class="sxs-lookup"><span data-stu-id="6096a-1108">A method will be invoked if the number of parameters in the method declaration equals the number of arguments in the specified argument list, and the type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="6096a-1109">O associador encontrará todos os métodos correspondentes.</span><span class="sxs-lookup"><span data-stu-id="6096a-1109">The binder will find all of the matching methods.</span></span> <span data-ttu-id="6096a-1110">Esses métodos são encontrados com base no tipo de associação solicitada (BindingFlags, BindingFlags.GetProperties, etc.).</span><span class="sxs-lookup"><span data-stu-id="6096a-1110">These methods are found based on the type of binding requested (BindingFlags.InvokeMethod, BindingFlags.GetProperties, and so on.).</span></span> <span data-ttu-id="6096a-1111">O conjunto de métodos é filtrado pelo nome, número de argumentos e um conjunto de modificadores de pesquisa definidos associador.</span><span class="sxs-lookup"><span data-stu-id="6096a-1111">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span> <span data-ttu-id="6096a-1112">Depois que o método for selecionado, ele será invocado.</span><span class="sxs-lookup"><span data-stu-id="6096a-1112">After the method is selected, it will be invoked.</span></span> <span data-ttu-id="6096a-1113">Acessibilidade é verificada nesse ponto.</span><span class="sxs-lookup"><span data-stu-id="6096a-1113">Accessibility is checked at that point.</span></span> <span data-ttu-id="6096a-1114">A pesquisa pode controlar qual conjunto de métodos são pesquisadas com base no atributo acessibilidade associado com o método.</span><span class="sxs-lookup"><span data-stu-id="6096a-1114">The search can control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="6096a-1115">O `IBinder.BindToMethod` método é responsável para selecionar o método a ser invocado.</span><span class="sxs-lookup"><span data-stu-id="6096a-1115">The `IBinder.BindToMethod` method is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="6096a-1116">O associador padrão seleciona a correspondência mais específica.</span><span class="sxs-lookup"><span data-stu-id="6096a-1116">The default binder selects the most specific match.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6096a-1117">Restrições de acesso são ignoradas por código totalmente confiável.</span><span class="sxs-lookup"><span data-stu-id="6096a-1117">Access restrictions are ignored for fully trusted code.</span></span> <span data-ttu-id="6096a-1118">Ou seja, propriedades, métodos, campos e construtores privados podem ser acessadas e invocados usando reflexão sempre que o código é totalmente confiável.</span><span class="sxs-lookup"><span data-stu-id="6096a-1118">That is, private constructors, methods, fields, and properties can be accessed and invoked using Reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="6096a-1119">Não há suporte para este método atualmente.</span><span class="sxs-lookup"><span data-stu-id="6096a-1119">This method is not currently supported.</span></span> <span data-ttu-id="6096a-1120">Você pode recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="6096a-1120">You can retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="6096a-1121">Não há suporte para tipos incompletos nesse método atualmente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1121">This method is not currently supported for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected override bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsArrayImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAssignableFrom">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-1122">Determina se um tipo especificado pode ser atribuído a esse objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1122">Determines whether a specified type can be assigned to this object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (System.Reflection.TypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Reflection.TypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(System::Reflection::TypeInfo ^ typeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Reflection.TypeInfo" />
      </Parameters>
      <Docs>
        <param name="typeInfo">
          <span data-ttu-id="6096a-1123">O objeto a ser testado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1123">The object to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-1124">Obtém um valor que indica se um objeto <see cref="T:System.Reflection.TypeInfo" /> especificado pode ser atribuído a esse objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1124">Gets a value that indicates whether a specified <see cref="T:System.Reflection.TypeInfo" /> object can be assigned to this object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-1125">
            <see langword="true" /> se <paramref name="typeInfo" /> puder ser atribuído a esse objeto; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1125">
              <see langword="true" /> if <paramref name="typeInfo" /> can be assigned to this object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(Type ^ c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">
          <span data-ttu-id="6096a-1126">O objeto a ser testado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1126">The object to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-1127">Obtém um valor que indica se um <see cref="T:System.Type" /> especificado pode ser atribuído a esse objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1127">Gets a value that indicates whether a specified <see cref="T:System.Type" /> can be assigned to this object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-1128">
            <see langword="true" /> se o parâmetro <paramref name="c" /> e o tipo atual representarem o mesmo tipo, se o tipo atual estiver na hierarquia de herança de <paramref name="c" /> ou se o tipo atual for uma interface à qual <paramref name="c" /> dá suporte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1128">
              <see langword="true" /> if the <paramref name="c" /> parameter and the current type represent the same type, or if the current type is in the inheritance hierarchy of <paramref name="c" />, or if the current type is an interface that <paramref name="c" /> supports.</span>
          </span>
          <span data-ttu-id="6096a-1129">
            <see langword="false" /> se nenhuma dessas condições for válida ou se <paramref name="c" /> for <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1129">
              <see langword="false" /> if none of these conditions are valid, or if <paramref name="c" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected override bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsByRefImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public override bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected override bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsCOMObjectImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-1130">Obtém um valor que indica se este objeto representa um tipo genérico construído.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1130">Gets a value that indicates whether this object represents a constructed generic type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6096a-1131">
            <see langword="true" /> se este objeto representar um tipo genérico construído; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1131">
              <see langword="true" /> if this object represents a constructed generic type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCreated">
      <MemberSignature Language="C#" Value="public bool IsCreated ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsCreated() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCreated" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCreated () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsCreated();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="6096a-1132">Retorna um valor que indica se o tipo dinâmico atual foi criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1132">Returns a value that indicates whether the current dynamic type has been created.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-1133">
            <see langword="true" /> se o método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> tiver sido chamado; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1133">
              <see langword="true" /> if the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method has been called; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1134">Após o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método foi chamado, o tipo representado pelo <xref:System.Reflection.Emit.TypeBuilder> objeto for concluído.</span><span class="sxs-lookup"><span data-stu-id="6096a-1134">After the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called, the type represented by the <xref:System.Reflection.Emit.TypeBuilder> object is complete.</span></span> <span data-ttu-id="6096a-1135">Exceções são geradas em quaisquer outras tentativas de adicionar membros ou alterar outras características do tipo.</span><span class="sxs-lookup"><span data-stu-id="6096a-1135">Exceptions are thrown on any further attempts to add members or change other characteristics of the type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <span data-ttu-id="6096a-1136">O tipo de atributo a ser pesquisado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1136">The type of attribute to search for.</span>
          </span>
          <span data-ttu-id="6096a-1137">Somente os atributos que podem ser atribuídos a esse tipo são retornados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1137">Only attributes that are assignable to this type are returned.</span>
          </span>
        </param>
        <param name="inherit">
          <span data-ttu-id="6096a-1138">Especifica se deve-se pesquisar ou não a cadeia de herança desse membro para localizar os atributos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1138">Specifies whether to search this member's inheritance chain to find the attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-1139">Determina se um atributo personalizado é aplicado ou tipo atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1139">Determines whether a custom attribute is applied to the current type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-1140">
            <see langword="true" /> se uma ou mais instâncias de <paramref name="attributeType" /> ou um atributo derivado de <paramref name="attributeType" /> forem definidos nesse tipo; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1140">
              <see langword="true" /> if one or more instances of <paramref name="attributeType" />, or an attribute derived from <paramref name="attributeType" />, is defined on this type; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1141">Esse método não tem suporte para parâmetros de tipo genérico incompleta.</span><span class="sxs-lookup"><span data-stu-id="6096a-1141">This method is not supported for incomplete generic type parameters.</span></span> <span data-ttu-id="6096a-1142">Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="6096a-1142">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="6096a-1143">Não há suporte para tipos incompletos nesse método atualmente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1143">This method is not currently supported for incomplete types.</span>
          </span>
          <span data-ttu-id="6096a-1144">Recupere o tipo usando <see cref="M:System.Type.GetType" /> e chame <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> no <see cref="T:System.Type" /> retornado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1144">Retrieve the type using <see cref="M:System.Type.GetType" /> and call <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> on the returned <see cref="T:System.Type" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-1145">
            <paramref name="attributeType" /> não está definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1145">
              <paramref name="attributeType" /> is not defined.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-1146">
            <paramref name="attributeType" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1146">
              <paramref name="attributeType" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public override bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public override bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-1147">Obtém um valor que indica se o tipo atual é um parâmetro de tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1147">Gets a value indicating whether the current type is a generic type parameter.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6096a-1148">
            <see langword="true" /> Se o atual <see cref="T:System.Reflection.Emit.TypeBuilder" /> objeto representa um parâmetro de tipo genérico; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1148">
              <see langword="true" /> if the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> object represents a generic type parameter; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="6096a-1149">Ao emitir código, um parâmetro de tipo genérico é representado por um <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto em vez de um <xref:System.Reflection.Emit.TypeBuilder> objeto.</span><span class="sxs-lookup"><span data-stu-id="6096a-1149">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public override bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-1150">Obtém um valor que indica se o tipo atual é um tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1150">Gets a value indicating whether the current type is a generic type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6096a-1151">
            <see langword="true" /> Se o tipo representado pelo atual <see cref="T:System.Reflection.Emit.TypeBuilder" /> objeto é genérico; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1151">
              <see langword="true" /> if the type represented by the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> object is generic; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1152">Um <xref:System.Reflection.Emit.TypeBuilder> objeto representa uma definição de tipo genérico se o <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> método foi usado para que ela tenha parâmetros de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="6096a-1152">A <xref:System.Reflection.Emit.TypeBuilder> object represents a generic type definition if the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method has been used to give it generic type parameters.</span></span> <span data-ttu-id="6096a-1153">Uma instância do <xref:System.Reflection.Emit.TypeBuilder> classe genérica é sempre uma definição de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="6096a-1153">An instance of the <xref:System.Reflection.Emit.TypeBuilder> class that is generic is always a generic type definition.</span></span>  
  
 <span data-ttu-id="6096a-1154">Para obter mais informações sobre tipos genéricos em reflexão e uma lista de condições invariáveis para termos usados na reflexão genérico, consulte o <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="6096a-1154">For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-1155">Obtém um valor que indica se o <see cref="T:System.Reflection.Emit.TypeBuilder" /> atual representa uma definição de tipo genérico, da qual outros tipos genéricos podem ser construídos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1155">Gets a value indicating whether the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> represents a generic type definition from which other generic types can be constructed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6096a-1156">
            <see langword="true" /> Se este <see cref="T:System.Reflection.Emit.TypeBuilder" /> objeto representa uma definição de tipo genérico; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1156">
              <see langword="true" /> if this <see cref="T:System.Reflection.Emit.TypeBuilder" /> object represents a generic type definition; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1157">Um <xref:System.Reflection.Emit.TypeBuilder> objeto representa uma definição de tipo genérico se o <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> método foi usado para que ela tenha parâmetros de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="6096a-1157">A <xref:System.Reflection.Emit.TypeBuilder> object represents a generic type definition if the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method has been used to give it generic type parameters.</span></span> <span data-ttu-id="6096a-1158">Uma instância do <xref:System.Reflection.Emit.TypeBuilder> classe genérica é sempre uma definição de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="6096a-1158">An instance of the <xref:System.Reflection.Emit.TypeBuilder> class that is generic is always a generic type definition.</span></span>  
  
 <span data-ttu-id="6096a-1159">Um <xref:System.Reflection.Emit.TypeBuilder> pode ser usado para criar definições de tipo genérico, mas tipos genéricos construídos não.</span><span class="sxs-lookup"><span data-stu-id="6096a-1159">A <xref:System.Reflection.Emit.TypeBuilder> can be used to build generic type definitions, but not constructed generic types.</span></span> <span data-ttu-id="6096a-1160">Para obter um tipo genérico construído, chame o <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método em um <xref:System.Reflection.Emit.TypeBuilder> que representa uma definição de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="6096a-1160">To get a constructed generic type, call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on a <xref:System.Reflection.Emit.TypeBuilder> that represents a generic type definition.</span></span>  
  
 <span data-ttu-id="6096a-1161">Para obter mais informações sobre tipos genéricos em reflexão e uma lista de condições invariáveis para termos usados na reflexão genérico, consulte o <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="6096a-1161">For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPointerImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPrimitiveImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-1162">Obtém um valor que indica se o tipo atual é crítico para segurança ou crítico para segurança e disponível no código transparente e, portanto, pode executar operações críticas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1162">Gets a value that indicates whether the current type is security-critical or security-safe-critical, and therefore can perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6096a-1163">
            <see langword="true" /> Se o tipo atual é crítico de segurança ou segurança-crítico para segurança; <see langword="false" /> se é transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1163">
              <see langword="true" /> if the current type is security-critical or security-safe-critical; <see langword="false" /> if it is transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1164">O <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, e <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> propriedades de relatório o nível de transparência do tipo, conforme determinado pelo common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="6096a-1164">The <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> properties report the transparency level of the type, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="6096a-1165">As combinações destas propriedades são mostradas na seguinte tabela:</span><span class="sxs-lookup"><span data-stu-id="6096a-1165">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="6096a-1166">Nível de segurança</span><span class="sxs-lookup"><span data-stu-id="6096a-1166">Security level</span></span>|<span data-ttu-id="6096a-1167">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="6096a-1167">IsSecurityCritical</span></span>|<span data-ttu-id="6096a-1168">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="6096a-1168">IsSecuritySafeCritical</span></span>|<span data-ttu-id="6096a-1169">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="6096a-1169">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="6096a-1170">Crítico</span><span class="sxs-lookup"><span data-stu-id="6096a-1170">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="6096a-1171">Crítico para segurança</span><span class="sxs-lookup"><span data-stu-id="6096a-1171">Safe-critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="6096a-1172">Transparente</span><span class="sxs-lookup"><span data-stu-id="6096a-1172">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="6096a-1173">Usar essas propriedade é muito mais simples que examinar as anotações de segurança de um assembly e seus tipos, verificando o nível de confiança atual e tentando duplicar as regras do tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="6096a-1173">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
 <span data-ttu-id="6096a-1174">O tempo de execução começa a avaliar os níveis de transparência no assembly.</span><span class="sxs-lookup"><span data-stu-id="6096a-1174">The runtime begins evaluating transparency levels at the assembly.</span></span> <span data-ttu-id="6096a-1175">Por exemplo, se o assembly dinâmico é crítico de segurança, as anotações em tipos são ignoradas e todos os tipos são críticas de segurança.</span><span class="sxs-lookup"><span data-stu-id="6096a-1175">For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</span></span>  
  
 <span data-ttu-id="6096a-1176">Por padrão, um assembly dinâmico herda a transparência do assembly que emite a ele.</span><span class="sxs-lookup"><span data-stu-id="6096a-1176">By default, a dynamic assembly inherits the transparency of the assembly that emits it.</span></span> <span data-ttu-id="6096a-1177">Você pode substituir esse padrão usando o <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, ou <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> sobrecarga de método e a especificação de atributos de segurança.</span><span class="sxs-lookup"><span data-stu-id="6096a-1177">You can override this default by using the <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, or <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> method overload and specifying security attributes.</span></span> <span data-ttu-id="6096a-1178">Não é possível elevar os níveis de segurança por fazer isso. ou seja, o código transparente não é possível emitir código crítico de segurança ou segurança crítica safe.</span><span class="sxs-lookup"><span data-stu-id="6096a-1178">You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</span></span> <span data-ttu-id="6096a-1179">Atributos devem ser especificados quando o assembly dinâmico é criado, ou eles não têm efeito até que o assembly foi salvo em disco e recarregado.</span><span class="sxs-lookup"><span data-stu-id="6096a-1179">Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6096a-1180">Herança padrão é limitada a avaliação do tempo de execução de transparência.</span><span class="sxs-lookup"><span data-stu-id="6096a-1180">Default inheritance is limited to the runtime's evaluation of transparency.</span></span> <span data-ttu-id="6096a-1181">Não há atributos são aplicados ao assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="6096a-1181">No attributes are applied to the dynamic assembly.</span></span> <span data-ttu-id="6096a-1182">Se você deseja adicionar os atributos de segurança, você mesmo deve aplicá-los.</span><span class="sxs-lookup"><span data-stu-id="6096a-1182">If you want to add security attributes, you must apply them yourself.</span></span>  
  
 <span data-ttu-id="6096a-1183">Para obter mais informações sobre reflexão emitir e transparência, consulte [problemas de segurança na emissão de reflexão](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span><span class="sxs-lookup"><span data-stu-id="6096a-1183">For more information about reflection emit and transparency, see [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span></span> <span data-ttu-id="6096a-1184">Para obter informações sobre a transparência, consulte [alterações de segurança](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="6096a-1184">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="6096a-1185">O tipo dinâmico atual não foi criado chamando o método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1185">The current dynamic type has not been created by calling the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span>
          </span>
        </exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-1186">Obtém um valor que indica se o tipo atual é crítico para segurança e disponível no código transparente, ou seja, se pode executar operações críticas e ser acessado por código transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1186">Gets a value that indicates whether the current type is security-safe-critical; that is, whether it can perform critical operations and can be accessed by transparent code.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6096a-1187">
            <see langword="true" /> Se o tipo atual é safe-crítico de segurança; <see langword="false" /> se ele é crítico de segurança ou transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1187">
              <see langword="true" /> if the current type is security-safe-critical; <see langword="false" /> if it is security-critical or transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1188">O <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, e <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> propriedades de relatório o nível de transparência do tipo, conforme determinado pelo common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="6096a-1188">The <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> properties report the transparency level of the type, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="6096a-1189">As combinações destas propriedades são mostradas na seguinte tabela:</span><span class="sxs-lookup"><span data-stu-id="6096a-1189">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="6096a-1190">Nível de segurança</span><span class="sxs-lookup"><span data-stu-id="6096a-1190">Security level</span></span>|<span data-ttu-id="6096a-1191">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="6096a-1191">IsSecurityCritical</span></span>|<span data-ttu-id="6096a-1192">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="6096a-1192">IsSecuritySafeCritical</span></span>|<span data-ttu-id="6096a-1193">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="6096a-1193">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="6096a-1194">Crítico</span><span class="sxs-lookup"><span data-stu-id="6096a-1194">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="6096a-1195">Crítico para segurança</span><span class="sxs-lookup"><span data-stu-id="6096a-1195">Safe-critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="6096a-1196">Transparente</span><span class="sxs-lookup"><span data-stu-id="6096a-1196">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="6096a-1197">Usar essas propriedade é muito mais simples que examinar as anotações de segurança de um assembly e seus tipos, verificando o nível de confiança atual e tentando duplicar as regras do tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="6096a-1197">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
 <span data-ttu-id="6096a-1198">O tempo de execução começa a avaliar os níveis de transparência no assembly.</span><span class="sxs-lookup"><span data-stu-id="6096a-1198">The runtime begins evaluating transparency levels at the assembly.</span></span> <span data-ttu-id="6096a-1199">Por exemplo, se o assembly dinâmico é crítico de segurança, as anotações em tipos são ignoradas e todos os tipos são críticas de segurança.</span><span class="sxs-lookup"><span data-stu-id="6096a-1199">For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</span></span>  
  
 <span data-ttu-id="6096a-1200">Por padrão, um assembly dinâmico herda a transparência do assembly que emite a ele.</span><span class="sxs-lookup"><span data-stu-id="6096a-1200">By default, a dynamic assembly inherits the transparency of the assembly that emits it.</span></span> <span data-ttu-id="6096a-1201">Você pode substituir esse padrão usando o <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, ou <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> sobrecarga de método e a especificação de atributos de segurança.</span><span class="sxs-lookup"><span data-stu-id="6096a-1201">You can override this default by using the <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, or <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> method overload and specifying security attributes.</span></span> <span data-ttu-id="6096a-1202">Não é possível elevar os níveis de segurança por fazer isso. ou seja, o código transparente não é possível emitir código crítico de segurança ou segurança crítica safe.</span><span class="sxs-lookup"><span data-stu-id="6096a-1202">You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</span></span> <span data-ttu-id="6096a-1203">Atributos devem ser especificados quando o assembly dinâmico é criado, ou eles não têm efeito até que o assembly foi salvo em disco e recarregado.</span><span class="sxs-lookup"><span data-stu-id="6096a-1203">Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6096a-1204">Herança padrão é limitada a avaliação do tempo de execução de transparência.</span><span class="sxs-lookup"><span data-stu-id="6096a-1204">Default inheritance is limited to the runtime's evaluation of transparency.</span></span> <span data-ttu-id="6096a-1205">Não há atributos são aplicados ao assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="6096a-1205">No attributes are applied to the dynamic assembly.</span></span> <span data-ttu-id="6096a-1206">Se você deseja adicionar os atributos de segurança, você mesmo deve aplicá-los.</span><span class="sxs-lookup"><span data-stu-id="6096a-1206">If you want to add security attributes, you must apply them yourself.</span></span>  
  
 <span data-ttu-id="6096a-1207">Para obter mais informações sobre reflexão emitir e transparência, consulte [problemas de segurança na emissão de reflexão](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span><span class="sxs-lookup"><span data-stu-id="6096a-1207">For more information about reflection emit and transparency, see [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span></span> <span data-ttu-id="6096a-1208">Para obter informações sobre a transparência, consulte [alterações de segurança](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="6096a-1208">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="6096a-1209">O tipo dinâmico atual não foi criado chamando o método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1209">The current dynamic type has not been created by calling the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span>
          </span>
        </exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-1210">Obtém um valor que indica se o tipo atual é transparente e, portanto, não pode executar operações críticas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1210">Gets a value that indicates whether the current type is transparent, and therefore cannot perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6096a-1211">
            <see langword="true" /> Se o tipo é transparente de segurança; Caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1211">
              <see langword="true" /> if the type is security-transparent; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1212">O <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, e <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> propriedades de relatório o nível de transparência do tipo, conforme determinado pelo common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="6096a-1212">The <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> properties report the transparency level of the type, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="6096a-1213">As combinações destas propriedades são mostradas na seguinte tabela:</span><span class="sxs-lookup"><span data-stu-id="6096a-1213">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="6096a-1214">Nível de segurança</span><span class="sxs-lookup"><span data-stu-id="6096a-1214">Security level</span></span>|<span data-ttu-id="6096a-1215">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="6096a-1215">IsSecurityCritical</span></span>|<span data-ttu-id="6096a-1216">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="6096a-1216">IsSecuritySafeCritical</span></span>|<span data-ttu-id="6096a-1217">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="6096a-1217">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="6096a-1218">Crítico</span><span class="sxs-lookup"><span data-stu-id="6096a-1218">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="6096a-1219">Crítico para segurança</span><span class="sxs-lookup"><span data-stu-id="6096a-1219">Safe-critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="6096a-1220">Transparente</span><span class="sxs-lookup"><span data-stu-id="6096a-1220">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="6096a-1221">Usar essas propriedade é muito mais simples que examinar as anotações de segurança de um assembly e seus tipos, verificando o nível de confiança atual e tentando duplicar as regras do tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="6096a-1221">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
 <span data-ttu-id="6096a-1222">O tempo de execução começa a avaliar os níveis de transparência no assembly.</span><span class="sxs-lookup"><span data-stu-id="6096a-1222">The runtime begins evaluating transparency levels at the assembly.</span></span> <span data-ttu-id="6096a-1223">Por exemplo, se o assembly dinâmico é crítico de segurança, as anotações em tipos são ignoradas e todos os tipos são críticas de segurança.</span><span class="sxs-lookup"><span data-stu-id="6096a-1223">For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</span></span>  
  
 <span data-ttu-id="6096a-1224">Por padrão, um assembly dinâmico herda a transparência do assembly que emite a ele.</span><span class="sxs-lookup"><span data-stu-id="6096a-1224">By default, a dynamic assembly inherits the transparency of the assembly that emits it.</span></span> <span data-ttu-id="6096a-1225">Você pode substituir esse padrão usando o <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, ou <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> sobrecarga de método e a especificação de atributos de segurança.</span><span class="sxs-lookup"><span data-stu-id="6096a-1225">You can override this default by using the <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, or <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> method overload and specifying security attributes.</span></span> <span data-ttu-id="6096a-1226">Não é possível elevar os níveis de segurança por fazer isso. ou seja, o código transparente não é possível emitir código crítico de segurança ou segurança crítica safe.</span><span class="sxs-lookup"><span data-stu-id="6096a-1226">You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</span></span> <span data-ttu-id="6096a-1227">Atributos devem ser especificados quando o assembly dinâmico é criado, ou eles não têm efeito até que o assembly foi salvo em disco e recarregado.</span><span class="sxs-lookup"><span data-stu-id="6096a-1227">Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6096a-1228">Herança padrão é limitada a avaliação do tempo de execução de transparência.</span><span class="sxs-lookup"><span data-stu-id="6096a-1228">Default inheritance is limited to the runtime's evaluation of transparency.</span></span> <span data-ttu-id="6096a-1229">Não há atributos são aplicados ao assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="6096a-1229">No attributes are applied to the dynamic assembly.</span></span> <span data-ttu-id="6096a-1230">Se você deseja adicionar os atributos de segurança, você mesmo deve aplicá-los.</span><span class="sxs-lookup"><span data-stu-id="6096a-1230">If you want to add security attributes, you must apply them yourself.</span></span>  
  
 <span data-ttu-id="6096a-1231">Para obter mais informações sobre reflexão emitir e transparência, consulte [problemas de segurança na emissão de reflexão](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span><span class="sxs-lookup"><span data-stu-id="6096a-1231">For more information about reflection emit and transparency, see [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span></span> <span data-ttu-id="6096a-1232">Para obter informações sobre a transparência, consulte [alterações de segurança](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="6096a-1232">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="6096a-1233">O tipo dinâmico atual não foi criado chamando o método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1233">The current dynamic type has not been created by calling the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span>
          </span>
        </exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public override bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public override bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsSubclassOf(Type ^ c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">
          <span data-ttu-id="6096a-1234">Um <see cref="T:System.Type" /> que será verificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1234">A <see cref="T:System.Type" /> that is to be checked.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-1235">Determina se esse tipo é derivado de um tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1235">Determines whether this type is derived from a specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-1236">Somente leitura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1236">Read-only.</span>
          </span>
          <span data-ttu-id="6096a-1237">Retorna <see langword="true" /> se esse tipo for igual ao tipo <paramref name="c" /> ou um subtipo do tipo <paramref name="c" />; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1237">Returns <see langword="true" /> if this type is the same as the type <paramref name="c" />, or is a subtype of type <paramref name="c" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public override bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsValueTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public override bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-1238">Retorna um objeto <see cref="T:System.Type" /> que representa uma matriz do tipo atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1238">Returns a <see cref="T:System.Type" /> object that represents an array of the current type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeArrayType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="6096a-1239">Retorna um objeto <see cref="T:System.Type" /> que representa uma matriz unidimensional do tipo atual, com um limite inferior de zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1239">Returns a <see cref="T:System.Type" /> object that represents a one-dimensional array of the current type, with a lower bound of zero.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-1240">Um objeto <see cref="T:System.Type" /> que representa uma matriz unidimensional do tipo cujo tipo de elemento é o tipo atual, com um limite inferior de zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1240">A <see cref="T:System.Type" /> object representing a one-dimensional array type whose element type is the current type, with a lower bound of zero.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1241">O <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> método fornece uma maneira de gerar um tipo de matriz com qualquer tipo de elemento possíveis, incluindo tipos genéricos.</span><span class="sxs-lookup"><span data-stu-id="6096a-1241">The <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> method provides a way to generate an array type with any possible element type, including generic types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6096a-1242">O exemplo de código a seguir cria um módulo dinâmico, um tipo abstrato denominado `Sample`e um método abstrato denominado `TestMethod`.</span><span class="sxs-lookup"><span data-stu-id="6096a-1242">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="6096a-1243">`TestMethod` leva um `ref` parâmetro (`ByRef` no Visual Basic) do tipo `Sample`, um ponteiro para o tipo `Sample`e uma matriz do tipo `Sample`.</span><span class="sxs-lookup"><span data-stu-id="6096a-1243">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="6096a-1244">Retorna uma matriz bidimensional de tipo `Sample`.</span><span class="sxs-lookup"><span data-stu-id="6096a-1244">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="6096a-1245">O exemplo de código salva o módulo dinâmico no disco, para que você possa examiná-lo com o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span><span class="sxs-lookup"><span data-stu-id="6096a-1245">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeArrayType(int rank);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">
          <span data-ttu-id="6096a-1246">O número de dimensões da matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1246">The number of dimensions for the array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-1247">Retorna um objeto <see cref="T:System.Type" /> que representa uma matriz do tipo atual, com o número de dimensões especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1247">Returns a <see cref="T:System.Type" /> object that represents an array of the current type, with the specified number of dimensions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-1248">Um objeto <see cref="T:System.Type" /> que representa uma matriz unidimensional do tipo atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1248">A <see cref="T:System.Type" /> object that represents a one-dimensional array of the current type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1249">O <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> método fornece uma maneira de gerar um tipo de matriz com qualquer tipo de elemento possíveis, incluindo tipos genéricos.</span><span class="sxs-lookup"><span data-stu-id="6096a-1249">The <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> method provides a way to generate an array type with any possible element type, including generic types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6096a-1250">O exemplo de código a seguir cria um módulo dinâmico, um tipo abstrato denominado `Sample`e um método abstrato denominado `TestMethod`.</span><span class="sxs-lookup"><span data-stu-id="6096a-1250">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="6096a-1251">`TestMethod` leva um `ref` parâmetro (`ByRef` no Visual Basic) do tipo `Sample`, um ponteiro para o tipo `Sample`e uma matriz do tipo `Sample`.</span><span class="sxs-lookup"><span data-stu-id="6096a-1251">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="6096a-1252">Retorna uma matriz bidimensional de tipo `Sample`.</span><span class="sxs-lookup"><span data-stu-id="6096a-1252">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="6096a-1253">O exemplo de código salva o módulo dinâmico no disco, para que você possa examiná-lo com o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span><span class="sxs-lookup"><span data-stu-id="6096a-1253">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="6096a-1254">
            <paramref name="rank" /> não é uma dimensão de matriz válida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1254">
              <paramref name="rank" /> is not a valid array dimension.</span>
          </span>
        </exception>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public override Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeByRefType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="6096a-1255">Retorna um objeto <see cref="T:System.Type" /> que representa o tipo atual quando passado como um parâmetro <see langword="ref" /> (<see langword="ByRef" /> no Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1255">Returns a <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> in Visual Basic).</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-1256">Um objeto <see cref="T:System.Type" /> que representa o tipo atual quando passado como um parâmetro <see langword="ref" /> (<see langword="ByRef" /> no Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1256">A <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> in Visual Basic).</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1257">O <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> método fornece uma maneira de gerar `ref` tipos (`ByRef` no Visual Basic) para o parâmetro de lista.</span><span class="sxs-lookup"><span data-stu-id="6096a-1257">The <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> method provides a way to generate `ref` types (`ByRef` in Visual Basic) for parameter lists.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6096a-1258">Usando a sintaxe do Microsoft intermediate language (MSIL), se o atual <xref:System.Reflection.Emit.TypeBuilder> representa `MyType`, o tipo retornado por este método será `MyType&`.</span><span class="sxs-lookup"><span data-stu-id="6096a-1258">Using Microsoft intermediate language (MSIL) syntax, if the current <xref:System.Reflection.Emit.TypeBuilder> represents `MyType`, then the type returned by this method would be `MyType&`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6096a-1259">O exemplo de código a seguir cria um módulo dinâmico, um tipo abstrato denominado `Sample`e um método abstrato denominado `TestMethod`.</span><span class="sxs-lookup"><span data-stu-id="6096a-1259">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="6096a-1260">`TestMethod` leva um `ref` parâmetro (`ByRef` no Visual Basic) do tipo `Sample`, um ponteiro para o tipo `Sample`e uma matriz do tipo `Sample`.</span><span class="sxs-lookup"><span data-stu-id="6096a-1260">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="6096a-1261">Retorna uma matriz bidimensional de tipo `Sample`.</span><span class="sxs-lookup"><span data-stu-id="6096a-1261">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="6096a-1262">O exemplo de código salva o módulo dinâmico no disco, para que você possa examiná-lo com o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span><span class="sxs-lookup"><span data-stu-id="6096a-1262">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public override Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">
          <span data-ttu-id="6096a-1263">Uma matriz de tipos a serem substituídos pelos parâmetros da definição de tipo genérico atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1263">An array of types to be substituted for the type parameters of the current generic type definition.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-1264">Substitui os elementos de uma matriz de tipos pelos parâmetros de tipo da definição de tipo genérico atual e retorna o tipo construído resultante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1264">Substitutes the elements of an array of types for the type parameters of the current generic type definition, and returns the resulting constructed type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-1265">Um <see cref="T:System.Type" /> representando o tipo construído formado substituindo os elementos do <paramref name="typeArguments" /> pelos parâmetros de tipo do tipo genérico atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1265">A <see cref="T:System.Type" /> representing the constructed type formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1266">Use esse método quando seu código emitido requer um tipo construído da definição do tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="6096a-1266">Use this method when your emitted code requires a type constructed from the current generic type definition.</span></span> <span data-ttu-id="6096a-1267">Não é necessário chamar o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método antes de chamar o <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método em um <xref:System.Reflection.Emit.TypeBuilder> que representa uma definição de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="6096a-1267">It is not necessary to call the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method before calling the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on a <xref:System.Reflection.Emit.TypeBuilder> that represents a generic type definition.</span></span> <span data-ttu-id="6096a-1268">Se o atual <xref:System.Reflection.Emit.TypeBuilder> não representa a definição de um tipo genérico, um <xref:System.InvalidOperationException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="6096a-1268">If the current <xref:System.Reflection.Emit.TypeBuilder> does not represent the definition of a generic type, an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
 <span data-ttu-id="6096a-1269">O objeto retornado pelas funções método como um espaço reservado para um tipo genérico construído no seu código emitido.</span><span class="sxs-lookup"><span data-stu-id="6096a-1269">The object returned by this method functions as a placeholder for a constructed generic type in your emitted code.</span></span> <span data-ttu-id="6096a-1270">É uma instância de uma classe derivada de <xref:System.Type> que tem recursos limitados.</span><span class="sxs-lookup"><span data-stu-id="6096a-1270">It is an instance of a class derived from <xref:System.Type> that has limited capabilities.</span></span> <span data-ttu-id="6096a-1271">Em particular:</span><span class="sxs-lookup"><span data-stu-id="6096a-1271">In particular:</span></span>  
  
-   <span data-ttu-id="6096a-1272">Para obter os construtores, métodos e campos para esses tipos genéricos construídos, use o <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29>, e <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29> sobrecargas do método.</span><span class="sxs-lookup"><span data-stu-id="6096a-1272">To get methods, fields, and constructors for these constructed generic types, use the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29>, and <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29> method overloads.</span></span>  
  
-   <span data-ttu-id="6096a-1273">Duas instâncias que representam o mesmo tipo construído não são comparados como iguais.</span><span class="sxs-lookup"><span data-stu-id="6096a-1273">Two instances that represent the same constructed type do not compare as equal.</span></span> <span data-ttu-id="6096a-1274">Por exemplo, no código a seguir `t1.Equals(t2)` retorna `false`:</span><span class="sxs-lookup"><span data-stu-id="6096a-1274">For example, in the following code `t1.Equals(t2)` returns `false`:</span></span>  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/vb/remarks.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-1275">O tipo atual não representa a definição de um tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1275">The current type does not represent the definition of a generic type.</span>
          </span>
          <span data-ttu-id="6096a-1276">Ou seja, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> retorna <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1276">That is, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> returns <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-1277">
            <paramref name="typeArguments" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1277">
              <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="6096a-1278">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1278">-or-</span>
          </span>
          <span data-ttu-id="6096a-1279">Qualquer elemento de <paramref name="typeArguments" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1279">Any element of <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-1280">A propriedade <see cref="P:System.Type.Module" /> de qualquer elemento de <paramref name="typeArguments" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1280">The <see cref="P:System.Type.Module" /> property of any element of <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="6096a-1281">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1281">-or-</span>
          </span>
          <span data-ttu-id="6096a-1282">A propriedade <see cref="P:System.Reflection.Module.Assembly" /> do módulo de qualquer elemento de <paramref name="typeArguments" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1282">The <see cref="P:System.Reflection.Module.Assembly" /> property of the module of any element of <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public override Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakePointerType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="6096a-1283">Retorna um objeto <see cref="T:System.Type" /> que representa o tipo de um ponteiro não gerenciado para o tipo atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1283">Returns a <see cref="T:System.Type" /> object that represents the type of an unmanaged pointer to the current type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-1284">Um objeto <see cref="T:System.Type" /> que representa o tipo de um ponteiro não gerenciado para o tipo atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1284">A <see cref="T:System.Type" /> object that represents the type of an unmanaged pointer to the current type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1285">O <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> método fornece uma maneira de gerar tipos de ponteiro para listas de parâmetros.</span><span class="sxs-lookup"><span data-stu-id="6096a-1285">The <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> method provides a way to generate pointer types for parameter lists.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6096a-1286">Usando a sintaxe do Microsoft intermediate language (MSIL), se o atual <xref:System.Reflection.Emit.TypeBuilder> representa `MyType`, o tipo retornado por este método será `MyType*`.</span><span class="sxs-lookup"><span data-stu-id="6096a-1286">Using Microsoft intermediate language (MSIL) syntax, if the current <xref:System.Reflection.Emit.TypeBuilder> represents `MyType`, then the type returned by this method would be `MyType*`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6096a-1287">O exemplo de código a seguir cria um módulo dinâmico, um tipo abstrato denominado `Sample`e um método abstrato denominado `TestMethod`.</span><span class="sxs-lookup"><span data-stu-id="6096a-1287">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="6096a-1288">`TestMethod` leva um `ref` parâmetro (`ByRef` no Visual Basic) do tipo `Sample`, um ponteiro para o tipo `Sample`e uma matriz do tipo `Sample`.</span><span class="sxs-lookup"><span data-stu-id="6096a-1288">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="6096a-1289">Retorna uma matriz bidimensional de tipo `Sample`.</span><span class="sxs-lookup"><span data-stu-id="6096a-1289">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="6096a-1290">O exemplo de código salva o módulo dinâmico no disco, para que você possa examiná-lo com o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span><span class="sxs-lookup"><span data-stu-id="6096a-1290">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-1291">Recupera o módulo dinâmico que contém essa definição de tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1291">Retrieves the dynamic module that contains this type definition.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6096a-1292">Somente leitura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1292">Read-only.</span>
          </span>
          <span data-ttu-id="6096a-1293">Recupera o módulo dinâmico que contém essa definição de tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1293">Retrieves the dynamic module that contains this type definition.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-1294">Recupera o nome desse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1294">Retrieves the name of this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6096a-1295">Somente leitura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1295">Read-only.</span>
          </span>
          <span data-ttu-id="6096a-1296">Recupera o <see cref="T:System.String" /> nome deste tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1296">Retrieves the <see cref="T:System.String" /> name of this type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public override string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-1297">Recupera o namespace em que esse <see langword="TypeBuilder" /> é definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1297">Retrieves the namespace where this <see langword="TypeBuilder" /> is defined.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6096a-1298">Somente leitura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1298">Read-only.</span>
          </span>
          <span data-ttu-id="6096a-1299">Recupera o namespace em que esse <see langword="TypeBuilder" /> é definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1299">Retrieves the namespace where this <see langword="TypeBuilder" /> is defined.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PackingSize">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PackingSize PackingSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.PackingSize PackingSize" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.PackingSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PackingSize As PackingSize" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::PackingSize PackingSize { System::Reflection::Emit::PackingSize get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PackingSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-1300">Recupera o tamanho de empacotamento desse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1300">Retrieves the packing size of this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6096a-1301">Somente leitura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1301">Read-only.</span>
          </span>
          <span data-ttu-id="6096a-1302">Recupera o tamanho de empacotamento desse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1302">Retrieves the packing size of this type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-1303">Retorna o tipo usado para obter esse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1303">Returns the type that was used to obtain this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6096a-1304">Somente leitura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1304">Read-only.</span>
          </span>
          <span data-ttu-id="6096a-1305">O tipo que foi usado para obter esse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1305">The type that was used to obtain this type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-1306">Define um atributo personalizado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1306">Sets a custom attribute.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (customBuilder As CustomAttributeBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::Emit::CustomAttributeBuilder ^ customBuilder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">
          <span data-ttu-id="6096a-1307">Uma instância de uma classe auxiliar para definir o atributo personalizado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1307">An instance of a helper class to define the custom attribute.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-1308">Defina um atributo personalizado usando um construtor de atributos personalizados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1308">Set a custom attribute using a custom attribute builder.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="6096a-1309">Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> sinalizador.</span><span class="sxs-lookup"><span data-stu-id="6096a-1309">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="6096a-1310">(Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.</span><span class="sxs-lookup"><span data-stu-id="6096a-1310">(See [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-1311">
            <paramref name="customBuilder" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1311">
              <paramref name="customBuilder" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-1312">Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1312">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (con As ConstructorInfo, binaryAttribute As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::ConstructorInfo ^ con, cli::array &lt;System::Byte&gt; ^ binaryAttribute);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">
          <span data-ttu-id="6096a-1313">O construtor do atributo personalizado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1313">The constructor for the custom attribute.</span>
          </span>
        </param>
        <param name="binaryAttribute">
          <span data-ttu-id="6096a-1314">Um blob de bytes que representa os atributos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1314">A byte blob representing the attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-1315">Define um atributo personalizado usando um blob de atributo personalizado especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1315">Sets a custom attribute using a specified custom attribute blob.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1316">Para obter mais informações sobre como formatar `binaryAttribute`, consulte a documentação de infra-estrutura de linguagem comum (CLI), especialmente "partição II: metadados definição e semântica".</span><span class="sxs-lookup"><span data-stu-id="6096a-1316">For more information on how to format `binaryAttribute`, see the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="6096a-1317">A documentação está disponível online; confira [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212), no MSDN, e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552), no site internacional da Ecma.</span><span class="sxs-lookup"><span data-stu-id="6096a-1317">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6096a-1318">Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> sinalizador.</span><span class="sxs-lookup"><span data-stu-id="6096a-1318">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="6096a-1319">(Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.</span><span class="sxs-lookup"><span data-stu-id="6096a-1319">(See [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6096a-1320">
            <paramref name="con" /> ou <paramref name="binaryAttribute" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1320">
              <paramref name="con" /> or <paramref name="binaryAttribute" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-1321">Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1321">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetParent">
      <MemberSignature Language="C#" Value="public void SetParent (Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetParent(class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetParent (parent As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetParent(Type ^ parent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="parent">
          <span data-ttu-id="6096a-1322">O novo tipo base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1322">The new base type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-1323">Define o tipo base do tipo em construção atualmente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1323">Sets the base type of the type currently under construction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1324">Se `parent` é `null`, <xref:System.Object> é usado como o tipo base.</span><span class="sxs-lookup"><span data-stu-id="6096a-1324">If `parent` is `null`, <xref:System.Object> is used as the base type.</span></span>  
  
 <span data-ttu-id="6096a-1325">Nas versões do .NET Framework 1.0 e 1.1, nenhuma exceção é lançada se `parent` é um tipo de interface, mas um <xref:System.TypeLoadException> é gerada quando o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método é chamado.</span><span class="sxs-lookup"><span data-stu-id="6096a-1325">In the .NET Framework versions 1.0 and 1.1, no exception is thrown if `parent` is an interface type, but a <xref:System.TypeLoadException> is thrown when the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method is called.</span></span>  
  
 <span data-ttu-id="6096a-1326">O <xref:System.Reflection.Emit.TypeBuilder.SetParent%2A> método não verifica se a maioria dos tipos de pai inválido.</span><span class="sxs-lookup"><span data-stu-id="6096a-1326">The <xref:System.Reflection.Emit.TypeBuilder.SetParent%2A> method does not check for most invalid parent types.</span></span> <span data-ttu-id="6096a-1327">Por exemplo, ele não rejeitar um tipo de pai que não possui construtor padrão quando o tipo atual tiver um construtor padrão, ele não rejeitar tipos lacrados e não rejeitar o <xref:System.Delegate> tipo.</span><span class="sxs-lookup"><span data-stu-id="6096a-1327">For example, it does not reject a parent type that has no default constructor when the current type has a default constructor, it does not reject sealed types, and it does not reject the <xref:System.Delegate> type.</span></span> <span data-ttu-id="6096a-1328">Nesses casos, as exceções são geradas pelo <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método.</span><span class="sxs-lookup"><span data-stu-id="6096a-1328">In all these cases, exceptions are thrown by the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-1329">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1329">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="6096a-1330">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1330">-or-</span>
          </span>
          <span data-ttu-id="6096a-1331">
            <paramref name="parent" /> é <see langword="null" /> e a instância atual representa uma interface cujos atributos não incluem <see cref="F:System.Reflection.TypeAttributes.Abstract" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1331">
              <paramref name="parent" /> is <see langword="null" />, and the current instance represents an interface whose attributes do not include <see cref="F:System.Reflection.TypeAttributes.Abstract" />.</span>
          </span>
          <span data-ttu-id="6096a-1332">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1332">-or-</span>
          </span>
          <span data-ttu-id="6096a-1333">Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1333">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6096a-1334">
            <paramref name="parent" /> é uma interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1334">
              <paramref name="parent" /> is an interface.</span>
          </span>
          <span data-ttu-id="6096a-1335">Essa condição de exceção é nova na versão 2.0 do .NET Framework.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1335">This exception condition is new in the .NET Framework version 2.0.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public int Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Size" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Size" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Size As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Size { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-1336">Recupera o tamanho total de um tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1336">Retrieves the total size of a type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6096a-1337">Somente leitura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1337">Read-only.</span>
          </span>
          <span data-ttu-id="6096a-1338">Recupera o tamanho total desse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1338">Retrieves this type’s total size.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _TypeBuilder.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_TypeBuilder::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">
          <span data-ttu-id="6096a-1339">Reservado para uso futuro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1339">Reserved for future use.</span>
          </span>
          <span data-ttu-id="6096a-1340">Deve ser IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1340">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="rgszNames">
          <span data-ttu-id="6096a-1341">Matriz passada de nomes a serem mapeados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1341">Passed-in array of names to be mapped.</span>
          </span>
        </param>
        <param name="cNames">
          <span data-ttu-id="6096a-1342">Contagem dos nomes a serem mapeados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1342">Count of the names to be mapped.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="6096a-1343">O contexto de localidade no qual interpretar os nomes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1343">The locale context in which to interpret the names.</span>
          </span>
        </param>
        <param name="rgDispId">
          <span data-ttu-id="6096a-1344">Matriz alocada pelo chamador que recebe os IDs correspondentes aos nomes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1344">Caller-allocated array which receives the IDs corresponding to the names.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-1345">Mapeia um conjunto de nomes para um conjunto correspondente de identificadores de expedição.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1345">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1346">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="6096a-1346">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="6096a-1347">Para obter mais informações sobre `IDispatch::GetIDsOfNames`, consulte a Biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="6096a-1347">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="6096a-1348">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1348">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _TypeBuilder.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_TypeBuilder::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">
          <span data-ttu-id="6096a-1349">As informações de tipo a serem retornadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1349">The type information to return.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="6096a-1350">O identificador de localidade das informações do tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1350">The locale identifier for the type information.</span>
          </span>
        </param>
        <param name="ppTInfo">
          <span data-ttu-id="6096a-1351">Recebe um ponteiro para o objeto de informações de tipo solicitado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1351">Receives a pointer to the requested type information object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-1352">Recupera as informações do tipo de um objeto, que podem ser usadas para obter informações de tipo para uma interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1352">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1353">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="6096a-1353">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="6096a-1354">Para obter mais informações sobre `IDispatch::GetTypeInfo`, consulte a Biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="6096a-1354">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="6096a-1355">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1355">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _TypeBuilder.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_TypeBuilder::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">
          <span data-ttu-id="6096a-1356">Aponta para um local que recebe o número de interfaces de informações de tipo fornecido pelo objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1356">Points to a location that receives the number of type information interfaces provided by the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-1357">Retorna o número de interfaces de informações do tipo que um objeto fornece (0 ou 1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1357">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1358">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="6096a-1358">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="6096a-1359">Para obter mais informações sobre `IDispatch::GetTypeInfoCount`, consulte a Biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="6096a-1359">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="6096a-1360">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1360">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _TypeBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _TypeBuilder.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_TypeBuilder::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">
          <span data-ttu-id="6096a-1361">Identifica o membro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1361">Identifies the member.</span>
          </span>
        </param>
        <param name="riid">
          <span data-ttu-id="6096a-1362">Reservado para uso futuro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1362">Reserved for future use.</span>
          </span>
          <span data-ttu-id="6096a-1363">Deve ser IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1363">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="6096a-1364">O contexto de localidade no qual interpretar argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1364">The locale context in which to interpret arguments.</span>
          </span>
        </param>
        <param name="wFlags">
          <span data-ttu-id="6096a-1365">Sinalizadores que descrevem o contexto da chamada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1365">Flags describing the context of the call.</span>
          </span>
        </param>
        <param name="pDispParams">
          <span data-ttu-id="6096a-1366">Ponteiro para uma estrutura contendo uma matriz de argumentos, uma matriz de DISPIDs de argumento para argumentos nomeados e contagens para o número de elementos nas matrizes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1366">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span>
          </span>
        </param>
        <param name="pVarResult">
          <span data-ttu-id="6096a-1367">Ponteiro para o local onde o resultado deve ser armazenado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1367">Pointer to the location where the result is to be stored.</span>
          </span>
        </param>
        <param name="pExcepInfo">
          <span data-ttu-id="6096a-1368">Ponteiro para uma estrutura que contém informações de exceção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1368">Pointer to a structure that contains exception information.</span>
          </span>
        </param>
        <param name="puArgErr">
          <span data-ttu-id="6096a-1369">O índice do primeiro argumento que tem um erro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1369">The index of the first argument that has an error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6096a-1370">Fornece acesso a propriedades e métodos expostos por um objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1370">Provides access to properties and methods exposed by an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1371">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="6096a-1371">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="6096a-1372">Para obter mais informações sobre `IDispatch::Invoke`, consulte a Biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="6096a-1372">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="6096a-1373">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1373">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="6096a-1374">Retorna o nome do tipo excluindo o namespace.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1374">Returns the name of the type excluding the namespace.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6096a-1375">Somente leitura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1375">Read-only.</span>
          </span>
          <span data-ttu-id="6096a-1376">O nome do tipo excluindo o namespace.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1376">The name of the type excluding the namespace.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public override RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-1377">Não tem suporte em módulos dinâmicos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1377">Not supported in dynamic modules.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6096a-1378">Somente leitura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1378">Read-only.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6096a-1379">Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="6096a-1379">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="6096a-1380">Não tem suporte em módulos dinâmicos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1380">Not supported in dynamic modules.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TypeToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeToken TypeToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.TypeToken TypeToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeToken As TypeToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::TypeToken TypeToken { System::Reflection::Emit::TypeToken get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-1381">Retorna o token de tipo desse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1381">Returns the type token of this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6096a-1382">Somente leitura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1382">Read-only.</span>
          </span>
          <span data-ttu-id="6096a-1383">Retorna o <see langword="TypeToken" /> desse tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1383">Returns the <see langword="TypeToken" /> of this type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-1384">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1384">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public override Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-1385">Retorna o tipo de sistema subjacente para esse <see langword="TypeBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1385">Returns the underlying system type for this <see langword="TypeBuilder" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6096a-1386">Somente leitura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1386">Read-only.</span>
          </span>
          <span data-ttu-id="6096a-1387">Retorna o tipo de sistema subjacente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1387">Returns the underlying system type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6096a-1388">Esse tipo é uma enumeração, mas não há um tipo de sistema subjacente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1388">This type is an enumeration, but there is no underlying system type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="UnspecifiedTypeSize">
      <MemberSignature Language="C#" Value="public const int UnspecifiedTypeSize = 0;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 UnspecifiedTypeSize = (0)" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize" />
      <MemberSignature Language="VB.NET" Value="Public Const UnspecifiedTypeSize As Integer  = 0" />
      <MemberSignature Language="C++ CLI" Value="public: int UnspecifiedTypeSize = 0;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="6096a-1389">Representa a não especificação do tamanho total do tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6096a-1389">Represents that total size for the type is not specified.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>