<Type Name="DynamicMethod" FullName="System.Reflection.Emit.DynamicMethod">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1bd4c32b39444d8bae0938e364893b4e9b22d0bd" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52591096" /></Metadata><TypeSignature Language="C#" Value="public sealed class DynamicMethod : System.Reflection.MethodInfo" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit DynamicMethod extends System.Reflection.MethodInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.DynamicMethod" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DynamicMethod&#xA;Inherits MethodInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicMethod sealed : System::Reflection::MethodInfo" />
  <TypeSignature Language="F#" Value="type DynamicMethod = class&#xA;    inherit MethodInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Define e representa um método dinâmico que pode ser compilado, executado e descartado. Os métodos descartados estão disponíveis para coleta de lixo.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar o <xref:System.Reflection.Emit.DynamicMethod> classe para gerar e executar um método em tempo de execução sem a necessidade de gerar um assembly dinâmico e um tipo dinâmico para conter o método. O código executável criado pelo compilador just-in-time (JIT) é recuperado quando a <xref:System.Reflection.Emit.DynamicMethod> objeto seja recuperado. Métodos dinâmicos são a maneira mais eficiente para gerar e executar pequenas quantidades de código.  
  
 Um método dinâmico pode ser hospedado anonimamente, ou ele pode ser logicamente associado com um módulo ou com um tipo.  
  
-   Se o método dinâmico é hospedado anonimamente, ele está localizado em um assembly fornecido pelo sistema e, portanto, é isolado de outro código. Por padrão, ele não tem acesso a dados não públicos. Um método dinâmico hospedado anonimamente pode ter restringido a capacidade de ignorar as verificações de visibilidade do compilador JIT, se ela foi concedida <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> sinalizador. O nível de confiança do assembly cujos membros não públicos são acessados pelo método dinâmico deve ser igual a ou um subconjunto do, o nível de confiança da pilha de chamadas que se emitiu o método dinâmico. Para obter mais informações sobre métodos dinâmicos hospedados anonimamente, consulte [instruções passo a passo: emitindo código em cenários de confiança parcial](~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md).  
  
-   Se o método dinâmico está associado a um módulo que você especificar, o método dinâmico é efetivamente global para que o módulo. Ele pode acessar todos os tipos no módulo e todos os `internal` (`Friend` no Visual Basic) membros dos tipos. Você pode associar um dinâmico método com qualquer módulo, independentemente se você criou o módulo, contanto que uma demanda por <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> sinalizador pode ser atendido pela pilha de chamadas que inclui seu código. Se o <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> sinalizador é incluído na concessão, o método dinâmico pode ignorar as verificações de visibilidade do compilador JIT e acessar os dados privados de todos os tipos declarados no módulo ou em qualquer outro módulo em qualquer assembly.  
  
    > [!NOTE]
    >  Quando você especifica o módulo ao qual um método dinâmico está associado, esse módulo não deve ser no assembly fornecido pelo sistema que é usado para hospedagem anônima.  
  
-   Se o método dinâmico está associado com um tipo especificado por você, ele tem acesso a todos os membros do tipo, independentemente do nível de acesso. Além disso, as verificações de visibilidade JIT podem ser ignoradas. Assim, o método dinâmico o acesso aos dados de outros tipos declarados no mesmo módulo ou em qualquer outro módulo em qualquer assembly privados. Você pode associar um método dinâmico com qualquer tipo, mas seu código deve ser concedido <xref:System.Security.Permissions.ReflectionPermission> com ambos os <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> e <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess> sinalizadores.  
  
 A tabela a seguir mostra quais tipos e membros são acessíveis a um método dinâmico hospedado anonimamente, com e sem verificações de visibilidade JIT, dependendo se <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> sinalizador é concedido.  
  
||Sem <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|com o <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|  
|-|-|-|  
|Sem ignorar verificações de visibilidade JIT|Membros públicos de tipos públicos em qualquer assembly.|Membros públicos de tipos públicos em qualquer assembly.|  
|Ignorando o JIT as verificações de visibilidade, com restrições|Membros públicos de tipos públicos em qualquer assembly.|Todos os membros de todos os tipos somente em assemblies cujos níveis de confiança são igual ou menor que o nível de confiança do assembly que se emitiu o método dinâmico.|  
  
> [!NOTE]
>  Antes do [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], emitir o código necessário <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> sinalizador. Essa permissão é incluída por padrão no FullTrust e LocalIntranet conjuntos de permissão nomeada, mas não a permissão de Internet definidos. Portanto, em versões anteriores dos [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] uma biblioteca pode ser usada com permissões de Internet somente se ele tiver o <xref:System.Security.SecurityCriticalAttribute> de atributo e também executa uma <xref:System.Security.PermissionSet.Assert%2A> para <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>. Tais bibliotecas exigem uma análise atenta da segurança, pois erros de código poderiam resultar em falhas de segurança. O [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)] permite que o código seja emitido em cenários de confiança parcial sem emitir qualquer demanda de segurança, pois a geração de código não é uma operação inerentemente privilegiada. Ou seja, o código gerado não tem mais permissões que o assembly que o emite. Isso permite que as bibliotecas que emitem código tenham a segurança transparente e remove a necessidade de declarar <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>, o que simplifica a tarefa de escrever uma biblioteca de segurança. Para usar esse recurso, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 A tabela a seguir mostra quais tipos e membros são acessíveis para um método dinâmico que está associado com um módulo ou com um tipo em um módulo.  
  
||Associado com o módulo|Associado ao tipo|  
|-|-|-|  
|Sem ignorar verificações de visibilidade JIT|Membros públicos e internos dos tipos de públicos, internos e privados no módulo.<br /><br /> Membros públicos de tipos públicos em qualquer assembly.|Todos os membros do tipo associado. Membros públicos e internos de todos os outros tipos no módulo.<br /><br /> Membros públicos de tipos públicos em qualquer assembly.|  
|Ignorar as verificações de visibilidade JIT|Todos os membros de todos os tipos em qualquer assembly.|Todos os membros de todos os tipos em qualquer assembly.|  
  
 Um método dinâmico que está associado um módulo tem as permissões desse módulo. Um método dinâmico que está associado um tipo tem as permissões do módulo que contém esse tipo.  
  
 Métodos dinâmicos e seus parâmetros não precisam ser nomeados, mas você pode especificar nomes para ajudar na depuração. Não há suporte para os atributos personalizados em métodos dinâmicos ou seus parâmetros.  
  
 Embora sejam métodos dinâmicos `static` métodos (`Shared` métodos no Visual Basic), o relaxada regras de associação de delegados introduzidos no [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] permitem um método dinâmico a ser associado a um objeto, de modo que ele atua como um método de instância quando chamado usando essa instância do delegado. Um exemplo que demonstra tudo isso é fornecido para o <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> sobrecarga de método.  
  
> [!NOTE]
>  No [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], métodos dinâmicos não dão suporte a informações de símbolo, que é, nomes de variável local e o mapeamento de número de linha. Essa limitação pode ser removida em uma versão futura. Você pode usar <xref:System.Reflection.Emit.AssemblyBuilder> durante o desenvolvimento para simplificar a depuração a gerado Microsoft intermediate language (MSIL) e, em seguida, alternar para métodos dinâmicos durante a implantação final, porque o <xref:System.Reflection.Emit.ILGenerator> chamadas são os mesmos em ambos os casos.  
  
## <a name="verification"></a>Verificação  
 A lista a seguir resume as condições sob as quais métodos dinâmicos podem conter código não verificável. (Por exemplo, um método dinâmico não é verificável se suas <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A> estiver definida como `false`.)  
  
-   Um método dinâmico que está associado um assembly crítico para segurança também é crítico para segurança e pode ignorar a verificação. Por exemplo, um assembly sem atributos de segurança que é executado como um aplicativo de desktop é tratado como crítico de segurança em tempo de execução. Se você associar um método dinâmico com o assembly, o método dinâmico pode conter código não verificável.  
  
-   Se um método dinâmico que contém o código não verificável estiver associado um assembly com transparência de nível 1, o compilador just-in-time (JIT) injeta uma exigência de segurança. A solicitação será bem-sucedida somente se o método dinâmico é executado pelo código totalmente confiável. Ver [código transparente de segurança, nível 1](~/docs/framework/misc/security-transparent-code-level-1.md).  
  
-   Se um método dinâmico que contém o código não verificável estiver associado um assembly com transparência de nível 2 (como mscorlib. dll), ele gerará uma exceção (injetada pelo compilador JIT) em vez de fazer uma exigência de segurança. Ver [código transparente de segurança, nível 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
-   Um método dinâmico hospedado anonimamente que contém o código não verificável sempre gera uma exceção. Ele nunca pode ignorar a verificação, mesmo se ele é criado e executado pelo código totalmente confiável.  
  
 A exceção que é lançada para código não verificável varia dependendo do modo como o método dinâmico é invocado. Se você invocar um método dinâmico usando um delegado retornado a <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> método, um <xref:System.Security.VerificationException> é gerada. Se você invocar o método dinâmico usando o <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> método, uma <xref:System.Reflection.TargetInvocationException> será lançada com uma interna <xref:System.Security.VerificationException>.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um método dinâmico que usa dois parâmetros. O exemplo emite um corpo de função simples que imprime o primeiro parâmetro para o console e o exemplo usa o segundo parâmetro como o valor de retorno do método. O exemplo conclui o método com a criação de um delegado, invoca o delegado com parâmetros diferentes e, finalmente, chama o método dinâmico usando o <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> método.  
  
 [!code-cpp[Reflection.DynamicMethod.All#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.All#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.All#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Como definir e executar métodos dinâmicos</related>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemas de segurança na emissão de reflexão</related>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">Instruções passo a passo: emitindo código em cenários de confiança parcial</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria um método dinâmico.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">O nome do método dinâmico. Isso pode ser uma cadeia de comprimento zero, mas não pode ser <see langword="null" />.</param>
        <param name="returnType">Um objeto <see cref="T:System.Type" /> que especifica o tipo de retorno do método dinâmico ou <see langword="null" /> se o método não tiver nenhum tipo de retorno.</param>
        <param name="parameterTypes">Uma matriz de objetos <see cref="T:System.Type" /> que especifica os tipos dos parâmetros do método dinâmico ou <see langword="null" />, se o método não tiver nenhum parâmetro.</param>
        <summary>Inicializa um método dinâmico hospedado anonimamente, especificando o nome do método, o tipo de retorno e os tipos de parâmetro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método dinâmico que é criado por esse construtor está associado um assembly anônimo em vez de um módulo ou tipo existente. O assembly anônimo existe somente para fornecer um ambiente de área restrita para métodos dinâmicos, ou seja, para isolá-los de outro código. Esse ambiente torna segura para o método dinâmico a ser emitido e executados pelo código parcialmente confiável.  
  
 Este construtor Especifica que just-in-time (JIT) as verificações de visibilidade será imposta para a Microsoft intermediate language (MSIL) do método dinâmico. Ou seja, o código no método dinâmico tem acesso aos métodos públicos de classes públicas. As exceções são geradas, se o método tenta acessar tipos ou membros que são `private`, `protected`, ou `internal` (`Friend` no Visual Basic). Para criar um método dinâmico que restringiu a capacidade de ignorar verificações de visibilidade JIT, use o <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29> construtor.  
  
 Quando um método dinâmico hospedado anonimamente é construído, a pilha de chamadas de concessões do assembly está incluída. Quando o método é chamado, as permissões de concessões do assembly são usadas em vez de permissões do chamador real. Portanto, o método dinâmico não pode executar em um nível mais alto de privilégio do que o assembly que o emitiu, mesmo que ele seja passado para e executado por um assembly que tem um nível mais alto de confiança.  
  
 Este construtor Especifica os atributos de método <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> e <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>e a convenção de chamada <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Esse construtor foi introduzido no [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um elemento de <paramref name="parameterTypes" /> é <see langword="null" /> ou <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> é um tipo para o qual <see cref="P:System.Type.IsByRef" /> retorna <see langword="true" />.</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Como definir e executar métodos dinâmicos</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemas de segurança na emissão de reflexão</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">Instruções passo a passo: emitindo código em cenários de confiança parcial</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, bool restrictedSkipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), restrictedSkipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, restrictedSkipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="restrictedSkipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">O nome do método dinâmico. Isso pode ser uma cadeia de comprimento zero, mas não pode ser <see langword="null" />.</param>
        <param name="returnType">Um objeto <see cref="T:System.Type" /> que especifica o tipo de retorno do método dinâmico ou <see langword="null" /> se o método não tiver nenhum tipo de retorno.</param>
        <param name="parameterTypes">Uma matriz de objetos <see cref="T:System.Type" /> que especifica os tipos dos parâmetros do método dinâmico ou <see langword="null" />, se o método não tiver nenhum parâmetro.</param>
        <param name="restrictedSkipVisibility"><see langword="true" /> para ignorar as verificações de visibilidade JIT nos tipos e membros acessados pelo MSIL do método dinâmico, com essa restrição: o nível de confiança dos assemblies que contêm esses tipos e membros deve ser igual ou menor do que o nível de confiança da pilha de chamadas que emite o método dinâmico, caso contrário, <see langword="false" />.</param>
        <summary>Inicializa um método dinâmico hospedado anonimamente, especificando o nome do método, o tipo de retorno, os tipos de parâmetro e se as verificações de visibilidade JIT (Just-In-Time) devem ser ignoradas para os tipos e membros acessados pelo MSIL (Microsoft Intermediate Language) do método dinâmico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método dinâmico que é criado por esse construtor está associado um assembly anônimo em vez de um módulo ou tipo existente. O assembly anônimo existe somente para fornecer um ambiente de área restrita para métodos dinâmicos, ou seja, para isolá-los de outro código. Esse ambiente torna segura para o método dinâmico a ser emitido e executados pelo código parcialmente confiável.  
  
 Métodos dinâmicos hospedados anonimamente não têm acesso automático a todos os tipos ou membros que são `private`, `protected`, ou `internal` (`Friend` no Visual Basic). Isso é diferente de métodos dinâmicos que estão associados um tipo existente ou um módulo, que têm acesso a membros ocultos em seu escopo associado.  
  
 Especificar `true` para `restrictedSkipVisibility` se seu método dinâmico tem que acessar tipos ou membros que estão `private`, `protected`, ou `internal`. Assim, o método dinâmico restringido o acesso a esses membros. Ou seja, os membros podem ser acessados apenas se as seguintes condições forem atendidas:  
  
-   Os membros de destino pertencem a um assembly que tem um nível de confiança igual ou menor do que a pilha de chamadas que emite o método dinâmico.  
  
-   A pilha de chamadas que emite o método dinâmico é concedida <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> sinalizador. Isso é sempre verdadeiro quando o código é executado com confiança total. Para código parcialmente confiável, ele é true somente se o host concede explicitamente a permissão.  
  
    > [!IMPORTANT]
    >  Se a permissão não recebeu, uma exceção é lançada quando <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> é chamado ou quando o método dinâmico é invocado, não quando esse construtor é chamado. Nenhuma permissão especial é necessária para emitir o método dinâmico.  
  
 Por exemplo, um método dinâmico é criado com `restrictedSkipVisibility` definido como `true` pode acessar um membro particular de qualquer assembly na pilha de chamadas, se a pilha de chamadas recebeu acesso de membro restrito. Se o método dinâmico é criado com código parcialmente confiável na pilha de chamadas, ele não pode acessar um membro particular de um tipo em um [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] assembly, porque esses assemblies são totalmente confiáveis.  
  
 Se `restrictedSkipVisibility` é `false`, verificações de visibilidade JIT são impostas. O código no método dinâmico tem acesso aos métodos públicos de classes públicas, e as exceções são geradas, se ele tentar acessar tipos ou membros que são `private`, `protected`, ou `internal`.  
  
 Quando um método dinâmico hospedado anonimamente é construído, a pilha de chamadas de concessões do assembly está incluída. Quando o método é chamado, as permissões da pilha de chamadas de emissão são usadas em vez de permissões do chamador real. Portanto, o método dinâmico não pode executar em um nível mais alto de privilégio do que o assembly que o emitiu, mesmo que ele seja passado para e executado por um assembly que tem um nível mais alto de confiança.  
  
 Este construtor Especifica os atributos de método <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> e <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>e a convenção de chamada <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Esse construtor foi introduzido no [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um elemento de <paramref name="parameterTypes" /> é <see langword="null" /> ou <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> é um tipo para o qual <see cref="P:System.Type.IsByRef" /> retorna <see langword="true" />.</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Como definir e executar métodos dinâmicos</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemas de segurança na emissão de reflexão</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">Instruções passo a passo: emitindo código em cenários de confiança parcial</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="name">O nome do método dinâmico. Isso pode ser uma cadeia de comprimento zero, mas não pode ser <see langword="null" />.</param>
        <param name="returnType">Um objeto <see cref="T:System.Type" /> que especifica o tipo de retorno do método dinâmico ou <see langword="null" /> se o método não tiver nenhum tipo de retorno.</param>
        <param name="parameterTypes">Uma matriz de objetos <see cref="T:System.Type" /> que especifica os tipos dos parâmetros do método dinâmico ou <see langword="null" />, se o método não tiver nenhum parâmetro.</param>
        <param name="m">Um <see cref="T:System.Reflection.Module" /> que representa o módulo com o qual o método dinâmico deve ser logicamente associado.</param>
        <summary>Cria um método dinâmico global para um módulo, especificando o nome do método, o tipo de retorno, os tipos de parâmetro e o módulo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor Especifica atributos de método <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> e <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, convenção de chamada <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>e não ignora as verificações de visibilidade do just-in-time (JIT).  
  
 O método dinâmico criado com esse construtor tem acesso ao público e `internal` (`Friend` no Visual Basic) membros de todos os tipos contidos no módulo `m`.  
  
> [!NOTE]
>  Para compatibilidade com versões anteriores, esse construtor exigirá <xref:System.Security.Permissions.SecurityPermission> com o <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> sinalizador se as seguintes condições forem true: `m` é um módulo diferente do módulo chamador e a demanda por <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> sinalizador falhou. Se a demanda por <xref:System.Security.Permissions.SecurityPermission> for bem-sucedida, a operação é permitida.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não exige mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança na reflexão emissão](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um método dinâmico que usa dois parâmetros. O exemplo emite um corpo de função simples que imprime o primeiro parâmetro para o console e o exemplo usa o segundo parâmetro como o valor de retorno do método. O exemplo conclui o método com a criação de um delegado, invoca o delegado com parâmetros diferentes e, finalmente, chama o método dinâmico usando o <xref:System.Reflection.Emit.DynamicMethod.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> método.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um elemento de <paramref name="parameterTypes" /> é <see langword="null" /> ou <see cref="T:System.Void" />.  
  
- ou - 
 <paramref name="m" /> é um módulo que fornece hospedagem anônima para métodos dinâmicos.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="m" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> é um tipo para o qual <see cref="P:System.Type.IsByRef" /> retorna <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para associar o método dinâmico com um módulo que não seja o módulo de chamada. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Como definir e executar métodos dinâmicos</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemas de segurança na emissão de reflexão</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">O nome do método dinâmico. Isso pode ser uma cadeia de comprimento zero, mas não pode ser <see langword="null" />.</param>
        <param name="returnType">Um objeto <see cref="T:System.Type" /> que especifica o tipo de retorno do método dinâmico ou <see langword="null" /> se o método não tiver nenhum tipo de retorno.</param>
        <param name="parameterTypes">Uma matriz de objetos <see cref="T:System.Type" /> que especifica os tipos dos parâmetros do método dinâmico ou <see langword="null" />, se o método não tiver nenhum parâmetro.</param>
        <param name="owner">Um <see cref="T:System.Type" /> ao qual o método dinâmico está logicamente associado. O método dinâmico tem acesso a todos os membros do tipo.</param>
        <summary>Cria um método dinâmico, especificando o nome do método, o tipo de retorno, os tipos de parâmetro e o tipo ao qual o método dinâmico está logicamente associado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método dinâmico criado com esse construtor tem acesso a todos os membros do tipo `owner`e como públicas e `internal` (`Friend` no Visual Basic) membros de todos os outros tipos no módulo que contém `owner`.  
  
 Este construtor Especifica atributos de método <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> e <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, convenção de chamada <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>e não ignora as verificações de visibilidade do just-in-time (JIT).  
  
> [!NOTE]
>  Para compatibilidade com versões anteriores, esse construtor exigirá <xref:System.Security.Permissions.SecurityPermission> com o <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> sinalizador se as seguintes condições forem true: `owner` está em um módulo diferente do módulo chamador e a demanda por <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Falha do sinalizador. Se a demanda por <xref:System.Security.Permissions.SecurityPermission> for bem-sucedida, a operação é permitida.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não exige mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança na reflexão emissão](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um <xref:System.Reflection.Emit.DynamicMethod> logicamente associado a um tipo. Essa associação dá acesso aos membros privados desse tipo.  
  
 O exemplo de código define uma classe chamada `Example` com um campo privado, uma classe chamada `DerivedFromxample` que deriva de primeira classe, um tipo delegado chamado `UseLikeStatic` que retorna <xref:System.Int32> parâmetros de tipo `Example` e <xref:System.Int32>e um tipo delegado chamado `UseLikeInstance` que retorna <xref:System.Int32> e tem um parâmetro de tipo <xref:System.Int32>.  
  
 O exemplo de código, em seguida, cria uma <xref:System.Reflection.Emit.DynamicMethod> que altera o campo privado de uma instância de `Example` e retorna o valor anterior.  
  
> [!NOTE]
>  Em geral, alterar os campos internos de classes não é boa prática de codificação orientada a objeto.  
  
 O exemplo de código cria uma instância de `Example` e, em seguida, cria dois delegados. A primeira é do tipo `UseLikeStatic`, que tem os mesmos parâmetros que o método dinâmico. O segundo é do tipo `UseLikeInstance`, que não tem o primeiro parâmetro (do tipo `Example`). Esse delegado é criado usando o <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> sobrecarga de método; o segundo parâmetro da sobrecarga desse método é uma instância de `Example`, nesse caso, a instância recém-criada, que é associada ao representante recém-criado. Sempre que esse delegado é invocado, o método dinâmico age sobre a instância associada do `Example`.  
  
> [!NOTE]
>  Este é um exemplo das regras flexíveis de associação de delegados introduzidos na [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], juntamente com as novas sobrecargas a <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> método. Para obter mais informações, consulte a classe <xref:System.Delegate>.  
  
 O `UseLikeStatic` delegado é chamado, passando a instância do `Example` que está associado ao `UseLikeInstance` delegar. Em seguida, a `UseLikeInstance` delegado é invocado, para que os dois delegados atuam na mesma instância do `Example`. As alterações nos valores do campo interno são exibidas após cada chamada. Por fim, uma `UseLikeInstance` delegado está associado a uma instância de `DerivedFromxample`, e as chamadas de delegados são repetidas.  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um elemento de <paramref name="parameterTypes" /> é <see langword="null" /> ou <see cref="T:System.Void" />.  
  
- ou - 
 <paramref name="owner" /> é uma interface, uma matriz, um tipo genérico aberto ou um parâmetro de tipo de um método ou tipo genérico.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="owner" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> é <see langword="null" /> ou é um tipo para o qual <see cref="P:System.Type.IsByRef" /> retorna <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para associar a um tipo em um módulo que não seja o módulo de chamada do método dinâmico. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Como definir e executar métodos dinâmicos</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemas de segurança na emissão de reflexão</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">O nome do método dinâmico. Isso pode ser uma cadeia de comprimento zero, mas não pode ser <see langword="null" />.</param>
        <param name="returnType">Um objeto <see cref="T:System.Type" /> que especifica o tipo de retorno do método dinâmico ou <see langword="null" /> se o método não tiver nenhum tipo de retorno.</param>
        <param name="parameterTypes">Uma matriz de objetos <see cref="T:System.Type" /> que especifica os tipos dos parâmetros do método dinâmico ou <see langword="null" />, se o método não tiver nenhum parâmetro.</param>
        <param name="m">Um <see cref="T:System.Reflection.Module" /> que representa o módulo com o qual o método dinâmico deve ser logicamente associado.</param>
        <param name="skipVisibility"><see langword="true" /> para ignorar as verificações de visibilidade JIT nos tipos e membros acessados pelo MSIL do método dinâmico.</param>
        <summary>Cria um método dinâmico que é global para um módulo, especificando o nome do método, o tipo de retorno, os tipos de parâmetro, o módulo e se as verificações de visibilidade JIT (just-in-time) devem ser ignoradas para os tipos e membros acessados pelo MSIL (Microsoft Intermediate Language) do método dinâmico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor Especifica atributos de método <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> e <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>e a convenção de chamada <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
 O método dinâmico criado com esse construtor tem acesso ao público e `internal` (`Friend` no Visual Basic) membros de todos os tipos no módulo independente `m`. As verificações de visibilidade do compilador ignorando o JIT permite que o método dinâmico acessar membros particulares e protegidos de todos os outros tipos. Isso é útil, por exemplo, ao escrever código para serializar objetos.  
  
> [!NOTE]
>  Para compatibilidade com versões anteriores, esse construtor exigirá <xref:System.Security.Permissions.SecurityPermission> com o <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> sinalizador se as seguintes condições forem true: `m` é um módulo diferente do módulo chamador e a demanda por <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> sinalizador falhou. Se a demanda por <xref:System.Security.Permissions.SecurityPermission> for bem-sucedida, a operação é permitida.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não exige mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança na reflexão emissão](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um elemento de <paramref name="parameterTypes" /> é <see langword="null" /> ou <see cref="T:System.Void" />.  
  
- ou - 
 <paramref name="m" /> é um módulo que fornece hospedagem anônima para métodos dinâmicos.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="m" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> é um tipo para o qual <see cref="P:System.Type.IsByRef" /> retorna <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para associar o método dinâmico com um módulo que não seja o módulo de chamada. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Como definir e executar métodos dinâmicos</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemas de segurança na emissão de reflexão</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">O nome do método dinâmico. Isso pode ser uma cadeia de comprimento zero, mas não pode ser <see langword="null" />.</param>
        <param name="returnType">Um objeto <see cref="T:System.Type" /> que especifica o tipo de retorno do método dinâmico ou <see langword="null" /> se o método não tiver nenhum tipo de retorno.</param>
        <param name="parameterTypes">Uma matriz de objetos <see cref="T:System.Type" /> que especifica os tipos dos parâmetros do método dinâmico ou <see langword="null" />, se o método não tiver nenhum parâmetro.</param>
        <param name="owner">Um <see cref="T:System.Type" /> ao qual o método dinâmico está logicamente associado. O método dinâmico tem acesso a todos os membros do tipo.</param>
        <param name="skipVisibility"><see langword="true" /> para ignorar as verificações de visibilidade JIT nos tipos e membros acessados pelo MSIL do método dinâmico, caso contrário, <see langword="false" />.</param>
        <summary>Cria um método dinâmico, especificando o nome do método, o tipo de retorno, os tipos de parâmetro, o tipo como qual o método dinâmico é logicamente associado e se as verificações de visibilidade JIT (just-in-time) devem ser ignoradas para tipos e membros acessados pelo MSIL (Microsoft Intermediate Language) do método dinâmico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método dinâmico criado com esse construtor tem acesso a todos os membros do tipo `owner`e como públicas e `internal` (`Friend` no Visual Basic) membros de todos os outros tipos no módulo que contém `owner`. As verificações de visibilidade do compilador ignorando o JIT permite que o método dinâmico acessar membros particulares e protegidos de todos os outros tipos. Isso é útil, por exemplo, ao escrever código para serializar objetos.  
  
 Este construtor Especifica atributos de método <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> e <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>e a convenção de chamada <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Para compatibilidade com versões anteriores, esse construtor exigirá <xref:System.Security.Permissions.SecurityPermission> com o <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> sinalizador se as seguintes condições forem true: `owner` está em um módulo diferente do módulo chamador e a demanda por <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Falha do sinalizador. Se a demanda por <xref:System.Security.Permissions.SecurityPermission> for bem-sucedida, a operação é permitida.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não exige mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança na reflexão emissão](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um elemento de <paramref name="parameterTypes" /> é <see langword="null" /> ou <see cref="T:System.Void" />.  
  
- ou - 
 <paramref name="owner" /> é uma interface, uma matriz, um tipo genérico aberto ou um parâmetro de tipo de um método ou tipo genérico.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="owner" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> é <see langword="null" /> ou é um tipo para o qual <see cref="P:System.Type.IsByRef" /> retorna <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para associar a um tipo em um módulo que não seja o módulo de chamada do método dinâmico. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Como definir e executar métodos dinâmicos</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemas de segurança na emissão de reflexão</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">O nome do método dinâmico. Isso pode ser uma cadeia de caracteres de comprimento zero, mas não pode ser <see langword="null" />.</param>
        <param name="attributes">Uma combinação bit a bit de valores <see cref="T:System.Reflection.MethodAttributes" /> que especifica os atributos do método dinâmico. A única combinação permitida é <see cref="F:System.Reflection.MethodAttributes.Public" /> e <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">A convenção de chamada para o método dinâmico. Deve ser <see cref="F:System.Reflection.CallingConventions.Standard" />.</param>
        <param name="returnType">Um objeto <see cref="T:System.Type" /> que especifica o tipo de retorno do método dinâmico ou <see langword="null" />, se o método não tiver nenhum tipo de retorno.</param>
        <param name="parameterTypes">Uma matriz de objetos <see cref="T:System.Type" /> que especifica os tipos dos parâmetros do método dinâmico ou <see langword="null" />, se o método não tiver nenhum parâmetro.</param>
        <param name="m">Um <see cref="T:System.Reflection.Module" /> que representa o módulo com o qual o método dinâmico deve ser logicamente associado.</param>
        <param name="skipVisibility"><see langword="true" /> para ignorar as verificações de visibilidade JIT nos tipos e membros acessados pelo MSIL do método dinâmico, caso contrário, <see langword="false" />.</param>
        <summary>Cria um método dinâmico que é global para um módulo, especificando o nome do método, os atributos, a convenção de chamada, o tipo de retorno, os tipos de parâmetro, o módulo e se as verificações de visibilidade JIT (just-in-time) devem ser ignoradas para os tipos e membros acessados pelo MSIL (Microsoft Intermediate Language) do método dinâmico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método dinâmico criado com esse construtor tem acesso ao público e `internal` (`Friend` no Visual Basic) membros de todos os tipos de públicos e internos contidos no módulo `m`.  
  
 As verificações de visibilidade do compilador ignorando o JIT permite que o método dinâmico acessar membros particulares e protegidos de todos os outros tipos no módulo e em todos os outros assemblies. Isso é útil, por exemplo, ao escrever código para serializar objetos.  
  
> [!NOTE]
>  Para compatibilidade com versões anteriores, esse construtor exigirá <xref:System.Security.Permissions.SecurityPermission> com o <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> sinalizador se as seguintes condições forem true: `m` é um módulo diferente do módulo chamador e a demanda por <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> sinalizador falhou. Se a demanda por <xref:System.Security.Permissions.SecurityPermission> for bem-sucedida, a operação é permitida.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não exige mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança na reflexão emissão](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um elemento de <paramref name="parameterTypes" /> é <see langword="null" /> ou <see cref="T:System.Void" />.  
  
- ou - 
 <paramref name="m" /> é um módulo que fornece hospedagem anônima para métodos dinâmicos.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="m" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="attributes" /> é uma combinação de sinalizadores diferente de <see cref="F:System.Reflection.MethodAttributes.Public" /> e <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
- ou - 
 <paramref name="callingConvention" /> não é <see cref="F:System.Reflection.CallingConventions.Standard" />.  
  
- ou - 
 <paramref name="returnType" /> é um tipo para o qual <see cref="P:System.Type.IsByRef" /> retorna <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para associar o método dinâmico com um módulo que não seja o módulo de chamada. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Como definir e executar métodos dinâmicos</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemas de segurança na emissão de reflexão</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">O nome do método dinâmico. Isso pode ser uma cadeia de caracteres de comprimento zero, mas não pode ser <see langword="null" />.</param>
        <param name="attributes">Uma combinação bit a bit de valores <see cref="T:System.Reflection.MethodAttributes" /> que especifica os atributos do método dinâmico. A única combinação permitida é <see cref="F:System.Reflection.MethodAttributes.Public" /> e <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">A convenção de chamada para o método dinâmico. Deve ser <see cref="F:System.Reflection.CallingConventions.Standard" />.</param>
        <param name="returnType">Um objeto <see cref="T:System.Type" /> que especifica o tipo de retorno do método dinâmico ou <see langword="null" />, se o método não tiver nenhum tipo de retorno.</param>
        <param name="parameterTypes">Uma matriz de objetos <see cref="T:System.Type" /> que especifica os tipos dos parâmetros do método dinâmico ou <see langword="null" />, se o método não tiver nenhum parâmetro.</param>
        <param name="owner">Um <see cref="T:System.Type" /> ao qual o método dinâmico está logicamente associado. O método dinâmico tem acesso a todos os membros do tipo.</param>
        <param name="skipVisibility"><see langword="true" /> para ignorar as verificações de visibilidade JIT nos tipos e membros acessados pelo MSIL do método dinâmico, caso contrário, <see langword="false" />.</param>
        <summary>Cria um método dinâmico, especificando o nome do método, os atributos, a convenção de chamada, o tipo de retorno, os tipos de parâmetro, o tipo como qual o método dinâmico é logicamente associado e se as verificações de visibilidade JIT (just-in-time) devem ser ignoradas para tipos e membros acessados pelo MSIL (Microsoft Intermediate Language) do método dinâmico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método dinâmico é global para o módulo que contém o tipo `owner`. Ele tem acesso a todos os membros do tipo `owner`.  
  
 O método dinâmico criado com esse construtor tem acesso a todos os membros do tipo `owner`e como públicas e `internal` (`Friend` no Visual Basic) membros de todos os tipos contidos no módulo que contém `owner`. As verificações de visibilidade do compilador ignorando o JIT permite que o método dinâmico acessar membros particulares e protegidos de todos os outros tipos. Isso é útil, por exemplo, ao escrever código para serializar objetos.  
  
> [!NOTE]
>  Para compatibilidade com versões anteriores, esse construtor exigirá <xref:System.Security.Permissions.SecurityPermission> com o <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> sinalizador se as seguintes condições forem true: `owner` está em um módulo diferente do módulo chamador e a demanda por <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Falha do sinalizador. Se a demanda por <xref:System.Security.Permissions.SecurityPermission> for bem-sucedida, a operação é permitida.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não exige mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança na reflexão emissão](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um elemento de <paramref name="parameterTypes" /> é <see langword="null" /> ou <see cref="T:System.Void" />.  
  
- ou - 
 <paramref name="owner" /> é uma interface, uma matriz, um tipo genérico aberto ou um parâmetro de tipo de um método ou tipo genérico.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="owner" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="attributes" /> é uma combinação de sinalizadores diferente de <see cref="F:System.Reflection.MethodAttributes.Public" /> e <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
- ou - 
 <paramref name="callingConvention" /> não é <see cref="F:System.Reflection.CallingConventions.Standard" />.  
  
- ou - 
 <paramref name="returnType" /> é um tipo para o qual <see cref="P:System.Type.IsByRef" /> retorna <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para associar a um tipo em um módulo que não seja o módulo de chamada do método dinâmico. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Como definir e executar métodos dinâmicos</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemas de segurança na emissão de reflexão</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.MethodAttributes" Usage="System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém os atributos especificados quando o método dinâmico foi criado.</summary>
        <value>Uma combinação bit a bit do <see cref="T:System.Reflection.MethodAttributes" /> valores que representam os atributos para o método.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atualmente, os atributos de método para um método dinâmico são sempre <xref:System.Reflection.MethodAttributes.Public> e <xref:System.Reflection.MethodAttributes.Static>.  
  
   
  
## Examples  
 O exemplo de código a seguir exibe os atributos de método de um método dinâmico. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#21](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#21)]
 [!code-csharp[Reflection.DynamicMethod.All#21](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#21)]
 [!code-vb[Reflection.DynamicMethod.All#21](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberSignature Language="F#" Value="member this.CallingConvention : System.Reflection.CallingConventions" Usage="System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a convenção de chamada especificada quando o método dinâmico foi criado.</summary>
        <value>Um do <see cref="T:System.Reflection.CallingConventions" /> valores que indica a convenção de chamada do método.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atualmente, a convenção de chamada para um método dinâmico é sempre <xref:System.Reflection.CallingConventions.Standard>.  
  
   
  
## Examples  
 O exemplo de código a seguir exibe a convenção de chamada de um método dinâmico. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#22](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#22)]
 [!code-csharp[Reflection.DynamicMethod.All#22](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#22)]
 [!code-vb[Reflection.DynamicMethod.All#22](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Conclui o método dinâmico e cria um delegado que pode ser usado para executá-lo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type -&gt; Delegate" Usage="dynamicMethod.CreateDelegate delegateType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="delegateType">Um tipo de delegado cuja assinatura corresponde à do método dinâmico.</param>
        <summary>Conclui o método dinâmico e cria um delegado que pode ser usado para executá-lo.</summary>
        <returns>Um delegado do tipo especificado, que pode ser usado para executar o método dinâmico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar o <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> método ou o <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> método conclui o método dinâmico. Qualquer tentativa de alterar o método dinâmico, como modificar as definições de parâmetro ou emitir mais MSIL Microsoft intermediate language (), é ignorado; ainda mais nenhuma exceção é lançada.  
  
 Para criar um corpo de método para um método dinâmico quando você tem seu próprio gerador de MSIL, chame o <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A> método para obter um <xref:System.Reflection.Emit.DynamicILInfo> objeto. Se você não tiver seu próprio gerador de MSIL, chame o <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A> método para obter um <xref:System.Reflection.Emit.ILGenerator> objeto que pode ser usado para gerar o corpo do método.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um método dinâmico que usa dois parâmetros. O exemplo emite um corpo de função simples que imprime o primeiro parâmetro para o console e o exemplo usa o segundo parâmetro como o valor de retorno do método. O exemplo conclui o método com a criação de um delegado, invoca o delegado com parâmetros diferentes e, finalmente, chama o método dinâmico usando o <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> método.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O método dinâmico não tem nenhum corpo de método.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="delegateType" /> tem o número de parâmetros incorreto ou tipos de parâmetro incorretos.</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Como definir e executar métodos dinâmicos</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType, object target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType, object target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type, target As Object) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType, System::Object ^ target);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type * obj -&gt; Delegate" Usage="dynamicMethod.CreateDelegate (delegateType, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="delegateType">Um tipo de delegado cuja assinatura corresponde à do método dinâmico, menos o primeiro parâmetro.</param>
        <param name="target">Um objeto ao qual o delegado está associado. Deve ser do mesmo tipo que o primeiro parâmetro do método dinâmico.</param>
        <summary>Conclui o método dinâmico e cria um delegado que pode ser usado para executá-lo, especificando o tipo de delegado e um objeto ao qual o delegado está associado.</summary>
        <returns>Um delegado do tipo especificado, que pode ser usado para executar o método dinâmico com o objeto de destino especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga de método cria um delegado associado a um determinado objeto. Um delegado desse tipo deve ser fechado ao longo de seu primeiro argumento. Embora o método for estático, ele atua como se fosse um método de instância; a instância é `target`.  
  
 Essa sobrecarga de método requer `target` para ser do mesmo tipo como o primeiro parâmetro do método dinâmico, ou para ser atribuível a esse tipo (por exemplo, uma classe derivada).  A assinatura de `delegateType` tem todos os parâmetros do método dinâmico, exceto a primeira. Por exemplo, se o método dinâmico tem os parâmetros <xref:System.String>, <xref:System.Int32>, e <xref:System.Byte>, em seguida, `delegateType` tem os parâmetros <xref:System.Int32> e <xref:System.Byte>; `target` é do tipo <xref:System.String>.  
  
 Chamar o <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> método ou o <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> método conclui o método dinâmico. Qualquer tentativa de alterar o método dinâmico, como modificar as definições de parâmetro ou emitir mais MSIL Microsoft intermediate language (), é ignorado; ainda mais nenhuma exceção é lançada.  
  
 Para criar um corpo de método para um método dinâmico quando você tem seu próprio gerador de MSIL, chame o <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A> método para obter um <xref:System.Reflection.Emit.DynamicILInfo> objeto. Se você não tiver seu próprio gerador de MSIL, chame o <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A> método para obter um <xref:System.Reflection.Emit.ILGenerator> objeto que pode ser usado para gerar o corpo do método.  
  
   
  
## Examples  
 O exemplo de código a seguir cria o delegado que associa um <xref:System.Reflection.Emit.DynamicMethod> a uma instância de um tipo, para que o método atua na mesma instância de cada vez que ele é invocado.  
  
 O exemplo de código define uma classe chamada `Example` com um campo privado, uma classe chamada `DerivedFromxample` que deriva de primeira classe, um tipo delegado chamado `UseLikeStatic` que retorna <xref:System.Int32> parâmetros de tipo `Example` e <xref:System.Int32>e um tipo delegado chamado `UseLikeInstance` que retorna <xref:System.Int32> e tem um parâmetro de tipo <xref:System.Int32>.  
  
 O exemplo de código, em seguida, cria uma <xref:System.Reflection.Emit.DynamicMethod> que altera o campo privado de uma instância de `Example` e retorna o valor anterior.  
  
> [!NOTE]
>  Em geral, alterar os campos internos de classes não é boa prática de codificação orientada a objeto.  
  
 O exemplo de código cria uma instância de `Example` e, em seguida, cria dois delegados. A primeira é do tipo `UseLikeStatic`, que tem os mesmos parâmetros que o método dinâmico. O segundo é do tipo `UseLikeInstance`, que não tem o primeiro parâmetro (do tipo `Example`). Esse delegado é criado usando o <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> sobrecarga de método; o segundo parâmetro da sobrecarga desse método é uma instância de `Example`, nesse caso, a instância recém-criada, que é associada ao representante recém-criado. Sempre que esse delegado é invocado, o método dinâmico age sobre a instância associada do `Example`.  
  
> [!NOTE]
>  Este é um exemplo das regras flexíveis de associação de delegados introduzidos na [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], juntamente com as novas sobrecargas a <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> método. Para obter mais informações, consulte a classe <xref:System.Delegate>.  
  
 O `UseLikeStatic` delegado é chamado, passando a instância do `Example` que está associado ao `UseLikeInstance` delegar. Em seguida, a `UseLikeInstance` delegado é invocado, para que os dois delegados atuam na mesma instância do `Example`. As alterações nos valores do campo interno são exibidas após cada chamada. Por fim, uma `UseLikeInstance` delegado está associado a uma instância de `DerivedFromxample`, e as chamadas de delegados são repetidas.  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O método dinâmico não tem nenhum corpo de método.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> não é do mesmo tipo que o primeiro parâmetro do método dinâmico e não é atribuível a esse tipo.  
  
- ou - 
 <paramref name="delegateType" /> tem o número de parâmetros incorreto ou tipos de parâmetro incorretos.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tipo que declara o método, que é sempre <see langword="null" /> para métodos dinâmicos.</summary>
        <value>Sempre <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade sempre retorna `null` para métodos dinâmicos. Mesmo quando um método dinâmico está logicamente associado com um tipo, ele não está declarado pelo tipo.  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o tipo de declaração de um método dinâmico. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#23](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#23)]
 [!code-csharp[Reflection.DynamicMethod.All#23](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#23)]
 [!code-vb[Reflection.DynamicMethod.All#23](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, parameterName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ parameterName);" />
      <MemberSignature Language="F#" Value="member this.DefineParameter : int * System.Reflection.ParameterAttributes * string -&gt; System.Reflection.Emit.ParameterBuilder" Usage="dynamicMethod.DefineParameter (position, attributes, parameterName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" />
        <Parameter Name="parameterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position">A posição do parâmetro na lista de parâmetros. Os parâmetros são indexados começando com o número 1 para o primeiro parâmetro.</param>
        <param name="attributes">Uma combinação bit a bit de valores <see cref="T:System.Reflection.ParameterAttributes" /> que especifica os atributos do parâmetro.</param>
        <param name="parameterName">O nome do parâmetro. O nome pode ser uma cadeia de caracteres de comprimento zero.</param>
        <summary>Define um parâmetro do método dinâmico.</summary>
        <returns>Sempre retorna <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `position` é 0, o <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> método refere-se ao valor de retorno. Definir informações de parâmetro não tem nenhum efeito sobre o valor de retorno.  
  
 Se o método dinâmico já foi concluído, chamando o <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> ou <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> método, o <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> método não tem nenhum efeito. Nenhuma exceção é lançada.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como definir informações de parâmetro para um método dinâmico. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#33](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#33)]
 [!code-csharp[Reflection.DynamicMethod.All#33](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#33)]
 [!code-vb[Reflection.DynamicMethod.All#33](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O método não tem parâmetros.  
  
- ou - 
 <paramref name="position" /> é menor que 0.  
  
- ou - 
 <paramref name="position" /> é maior que o número de parâmetros do método.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetBaseDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="dynamicMethod.GetBaseDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna a implementação base para o método.</summary>
        <returns>A implementação base do método.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método sempre retorna atual `DynamicMethod` objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna os atributos personalizados aplicados ao método.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit"><see langword="true" /> para pesquisar a cadeia de herança do método para encontrar os atributos personalizados, <see langword="false" /> para verificar apenas o método atual.</param>
        <summary>Retorna todos os atributos personalizados definidos para o método.</summary>
        <returns>Uma matriz de objetos que representam todos os atributos personalizados do método.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para métodos dinâmicos, especificando `true` para `inherit` não tem nenhum efeito, porque o método não é declarado em um tipo.  
  
> [!NOTE]
>  Atributos personalizados não têm suporte no momento em métodos dinâmicos. O único atributo retornado é <xref:System.Runtime.CompilerServices.MethodImplAttribute>; você pode obter o método sinalizadores de implementação mais facilmente usando o <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Um <see cref="T:System.Type" /> que representa o tipo de atributo personalizado a ser retornado.</param>
        <param name="inherit"><see langword="true" /> para pesquisar a cadeia de herança do método para encontrar os atributos personalizados, <see langword="false" /> para verificar apenas o método atual.</param>
        <summary>Retorna os atributos personalizados do tipo especificado que foram aplicados ao método.</summary>
        <returns>Uma matriz de objetos que representa os atributos do método que são do tipo <paramref name="attributeType" /> ou derivados do tipo <paramref name="attributeType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para métodos dinâmicos, especificando `true` para `inherit` não tem nenhum efeito, porque o método não é declarado em um tipo.  
  
> [!NOTE]
>  Atributos personalizados não têm suporte no momento em métodos dinâmicos. O único atributo retornado é <xref:System.Runtime.CompilerServices.MethodImplAttribute>; você pode obter o método sinalizadores de implementação mais facilmente usando o <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="attributeType" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetDynamicILInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.DynamicILInfo GetDynamicILInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.DynamicILInfo GetDynamicILInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDynamicILInfo () As DynamicILInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::DynamicILInfo ^ GetDynamicILInfo();" />
      <MemberSignature Language="F#" Value="member this.GetDynamicILInfo : unit -&gt; System.Reflection.Emit.DynamicILInfo" Usage="dynamicMethod.GetDynamicILInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.DynamicILInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um <see cref="T:System.Reflection.Emit.DynamicILInfo" /> objeto que pode ser usado para gerar um corpo de método de tokens de metadados, escopos e fluxos MSIL (Microsoft Intermediate Language).</summary>
        <returns>Um objeto <see cref="T:System.Reflection.Emit.DynamicILInfo" /> que pode ser usado para gerar um corpo de método de tokens de metadados, escopos e fluxos MSIL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.Emit.DynamicILInfo> classe é fornecida para oferecer suporte à geração de código não gerenciado.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para executar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="T:System.Reflection.Emit.DynamicILInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna um gerador de MSIL que pode ser usado para emitir um corpo de método dinâmico.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : unit -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um gerador de MSIL (Microsoft Intermediate Language) para o método com um tamanho de fluxo MSIL padrão de 64 bytes.</summary>
        <returns>Um objeto <see cref="T:System.Reflection.Emit.ILGenerator" /> para o método.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Depois que um método dinâmico foi concluído, chamando o <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> ou <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> método, qualquer ainda mais tentativa de adicionar MSIL é ignorado. Nenhuma exceção é lançada.  
  
> [!NOTE]
>  Há restrições em código não verificável em métodos dinâmicos, até mesmo em alguns cenários de confiança total. Consulte a seção “Verificação” em Comentários de <xref:System.Reflection.Emit.DynamicMethod>.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um método dinâmico que usa dois parâmetros. O exemplo emite um corpo de função simples que imprime o primeiro parâmetro para o console e o exemplo usa o segundo parâmetro como o valor de retorno do método. O exemplo conclui o método com a criação de um delegado, invoca o delegado com parâmetros diferentes e, finalmente, chama o método dinâmico usando o <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> método.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Como definir e executar métodos dinâmicos</related>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int streamSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 streamSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (streamSize As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int streamSize);" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : int -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator streamSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="streamSize">O tamanho do fluxo MSIL, em bytes.</param>
        <summary>Retorna um gerador de MSIL (Microsoft Intermediate Language) para o método com o tamanho do fluxo MSIL especificado.</summary>
        <returns>Um objeto <see cref="T:System.Reflection.Emit.ILGenerator" /> para o método, com o tamanho do fluxo MSIL especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Depois que um método dinâmico foi concluído, chamando o <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> ou <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> método, qualquer ainda mais tentativa de adicionar MSIL é ignorado. Nenhuma exceção é lançada.  
  
> [!NOTE]
>  Há restrições em código não verificável em métodos dinâmicos, até mesmo em alguns cenários de confiança total. Consulte a seção “Verificação” em Comentários de <xref:System.Reflection.Emit.DynamicMethod>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra essa sobrecarga de método. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#2](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#2)]
 [!code-csharp[Reflection.DynamicMethod.All#2](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#2)]
 [!code-vb[Reflection.DynamicMethod.All#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Como definir e executar métodos dinâmicos</related>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberSignature Language="F#" Value="override this.GetMethodImplementationFlags : unit -&gt; System.Reflection.MethodImplAttributes" Usage="dynamicMethod.GetMethodImplementationFlags " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna os sinalizadores de implementação para o método.</summary>
        <returns>Uma combinação bit a bit de valores <see cref="T:System.Reflection.MethodImplAttributes" /> que representam os sinalizadores de implementação para o método.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atualmente, os atributos de implementação de método para métodos dinâmicos são sempre <xref:System.Reflection.MethodImplAttributes.IL> e <xref:System.Reflection.MethodImplAttributes.NoInlining>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberSignature Language="F#" Value="override this.GetParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="dynamicMethod.GetParameters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna os parâmetros do método dinâmico.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Reflection.ParameterInfo" /> que representam os parâmetros do método dinâmico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.ParameterInfo> objetos retornados por esse método são apenas para fins informativos. Use o <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> método para definir ou alterar as características dos parâmetros.  
  
   
  
## Examples  
 O exemplo de código a seguir exibe os parâmetros de um método dinâmico. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#34](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#34)]
 [!code-csharp[Reflection.DynamicMethod.All#34](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#34)]
 [!code-vb[Reflection.DynamicMethod.All#34](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#34)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InitLocals : bool with get, set" Usage="System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se as variáveis locais no método são inicializadas em zero.</summary>
        <value><see langword="true" /> Se as variáveis locais no método são inicializadas em zero; Caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se essa propriedade é definida como `true`, o emitido Microsoft intermediate language (MSIL) inclui a inicialização de variáveis locais. Se ele for definido como `false`, variáveis locais não são inicializadas e o código gerado não é verificável.  
  
   
  
## Examples  
 O seguinte código de exemplo exibe o <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A> propriedade de um método dinâmico. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#24](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#24)]
 [!code-csharp[Reflection.DynamicMethod.All#24](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#24)]
 [!code-vb[Reflection.DynamicMethod.All#24](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="override this.Invoke : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="dynamicMethod.Invoke (obj, invokeAttr, binder, parameters, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">Esse parâmetro é ignorado para métodos dinâmicos, pois é estático. Especifique <see langword="null" />.</param>
        <param name="invokeAttr">Uma combinação bit a bit dos valores <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="binder">Um objeto <see cref="T:System.Reflection.Binder" /> que permite a associação, coerção de tipos de argumento, invocação de membros e recuperação de objetos <see cref="T:System.Reflection.MemberInfo" /> por meio da reflexão. Caso <paramref name="binder" /> seja <see langword="null" />, o associador padrão é usado. Para obter mais detalhes, consulte <see cref="T:System.Reflection.Binder" />.</param>
        <param name="parameters">Uma lista de argumentos. Essa é uma matriz de argumentos com o mesmo número, ordem e tipo que os parâmetros do método a ser invocado. Se não houver nenhum parâmetro, esse parâmetro deverá ser <see langword="null" />.</param>
        <param name="culture">Uma instância de <see cref="T:System.Globalization.CultureInfo" /> usada para determinar a coerção de tipos. Se isso for <see langword="null" />, será usado o <see cref="T:System.Globalization.CultureInfo" /> para o thread atual. Por exemplo, essas informações são necessárias para converter corretamente um <see cref="T:System.String" /> que representa 1000 em um valor <see cref="T:System.Double" />, pois 1000 é representado de forma diferente por diferentes culturas.</param>
        <summary>Invoca o método dinâmico usando os parâmetros especificados, sob as restrições do associador especificado e com as informações de cultura especificadas.</summary>
        <returns>Um <see cref="T:System.Object" /> que contém o valor retornado do método invocado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Além das exceções listadas, o código de chamada deve estar preparado para capturar todas as exceções geradas pelo método dinâmico.  
  
 Executar um método dinâmico com um delegado criado pelo <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> método é mais eficiente do que executá-lo com o <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> método.  
  
 Chamar o <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> método ou o <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> método conclui o método dinâmico. Qualquer tentativa de alterar o método dinâmico, como modificar as definições de parâmetro ou emitir mais MSIL Microsoft intermediate language (), é ignorado; ainda mais nenhuma exceção é lançada.  
  
 Todos os métodos dinâmicos são estáticos, portanto, o `obj` parâmetro é sempre ignorado. Para tratar um método dinâmico, como se fosse um método de instância, use o <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> sobrecarga que utiliza uma instância do objeto.  
  
 Se o método dinâmico não tem parâmetros, o valor de `parameters` deve ser `null`. Caso contrário, o número, tipo e ordem dos elementos na matriz de parâmetros devem ser idênticos ao número, tipo e ordem dos parâmetros do método dinâmico.  
  
> [!NOTE]
>  Essa sobrecarga de método é chamada pelo <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29> sobrecarga do método herdado da <xref:System.Reflection.MethodBase> de classe, portanto, os comentários anteriores se aplicam a ambas as sobrecargas.  
  
 Esse método não exigir permissões diretamente, mas invocar o método dinâmico pode resultar em solicitações de segurança, dependendo do método. Por exemplo, nenhuma demanda é feita para métodos dinâmicos hospedados anonimamente que são criados com o `restrictedSkipVisibility` parâmetro definido como `false`. Por outro lado, se você criar um método com `restrictedSkipVisibility` definido como `true` para que possa acessar um membro oculto de um assembly de destino, o método causará uma exigência para as permissões do assembly de destino adição <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> sinalizador.  
  
> [!NOTE]
>  Antes do [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método exigido <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess> sinalizador.  
  
   
  
## Examples  
 O exemplo de código a seguir invoca um método dinâmico com a associação exata, usando a cultura do inglês dos EUA. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#4](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#4)]
 [!code-csharp[Reflection.DynamicMethod.All#4](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#4)]
 [!code-vb[Reflection.DynamicMethod.All#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Não há suporte para a convenção de chamada <see cref="F:System.Reflection.CallingConventions.VarArgs" />.</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">O número de elementos em <paramref name="parameters" /> não corresponde ao número de parâmetros no método dinâmico.</exception>
        <exception cref="T:System.ArgumentException">O tipo de um ou mais elementos de <paramref name="parameters" /> não corresponde ao tipo do parâmetro correspondente do método dinâmico.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">O método dinâmico está associado a um módulo, não é hospedado anonimamente e foi construído com <paramref name="skipVisibility" /> definido como <see langword="false" />, mas acessa membros que não são <see langword="public" /> nem <see langword="internal" /> (<see langword="Friend" /> no Visual Basic).  
  
- ou - 
O método dinâmico é hospedado anonimamente e foi construído com <paramref name="skipVisibility" /> definido como <see langword="false" />, mas acessa membros que não são <see langword="public" />.  
  
- ou - 
O método dinâmico contém um código não verificável. Consulte a seção “Verificação” em Comentários de <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="dynamicMethod.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Um <see cref="T:System.Type" /> que representa o tipo de atributo personalizado a ser pesquisado.</param>
        <param name="inherit"><see langword="true" /> para pesquisar a cadeia de herança do método para encontrar os atributos personalizados, <see langword="false" /> para verificar apenas o método atual.</param>
        <summary>Indica se o tipo de atributo personalizado especificado é definido.</summary>
        <returns><see langword="true" /> se o tipo de atributo personalizado especificado estiver definido, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para métodos dinâmicos, especificando `true` para `inherit` não tem nenhum efeito. Métodos dinâmicos não têm nenhuma cadeia de herança.  
  
> [!NOTE]
>  Atributos personalizados não têm suporte no momento em métodos dinâmicos.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o método dinâmico atual é crítico para segurança ou crítico para segurança e disponível no código transparente e, portanto, pode executar operações críticas.</summary>
        <value><see langword="true" /> Se o método dinâmico atual é crítico para segurança ou segurança-seguro-crítica; <see langword="false" /> se for transparente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, e <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> propriedades relatam o nível de transparência do método dinâmico, conforme determinado pelo common language runtime (CLR). As combinações destas propriedades são mostradas na seguinte tabela:  
  
|Nível de segurança|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Crítico|`true`|`false`|`false`|  
|Segurança crítica|`true`|`true`|`false`|  
|Transparente|`false`|`false`|`true`|  
  
 Usar essas propriedade é muito mais simples que examinar as anotações de segurança de um assembly e seus tipos, verificando o nível de confiança atual e tentando duplicar as regras do tempo de execução.  
  
 A transparência de um método dinâmico depende do módulo que está associado. Se o método dinâmico está associado com um tipo em vez de um módulo, a transparência depende do módulo que contém o tipo. Métodos dinâmicos não têm anotações de segurança, portanto, eles são atribuídos a transparência padrão para o módulo associado.  
  
-   Métodos dinâmicos hospedados anonimamente são sempre transparentes, pois o módulo fornecido pelo sistema que os contém é transparente.  
  
-   A transparência de um método dinâmico que está associado um assembly confiável (ou seja, um assembly de nome forte que está instalado no cache de assembly global) é descrita na tabela a seguir.  
  
    |Anotação de assembly|Transparência de nível 1|Transparência de nível 2|  
    |-------------------------|--------------------------|--------------------------|  
    |Totalmente transparente|Transparente|Transparente|  
    |Totalmente crítica|Crítico|Crítico|  
    |Transparência mista|Transparente|Transparente|  
    |Independente de segurança|Crítico para segurança|Crítico|  
  
     Por exemplo, se você associar um método dinâmico com um tipo que está em mscorlib. dll, que tem o nível 2 transparência misto, o método dinâmico é transparente e não é possível executar o código critical. Para obter informações sobre os níveis de transparência, consulte [código transparente de segurança, nível 1](~/docs/framework/misc/security-transparent-code-level-1.md) e [código transparente de segurança, nível 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Associar um método dinâmico com um módulo em um assembly confiável de nível 1 que é independente de segurança, como System. dll, não permitir a elevação de confiança. Se o conjunto de concessões do código que chama o método dinâmico não inclui o conjunto de concessões de System. dll (ou seja, confiança total), <xref:System.Security.SecurityException> é lançada quando o método dinâmico é chamado.  
  
-   A transparência de um método dinâmico que está associado um assembly parcialmente confiável depende de como o assembly é carregado. Se o assembly é carregado com confiança parcial (por exemplo, para um domínio de aplicativo em área restrita), o tempo de execução ignora as anotações de segurança do assembly. O assembly e todos os seus tipos e membros, incluindo métodos dinâmicos, são tratados como transparentes. O tempo de execução presta atenção nas anotações de segurança somente se o assembly de confiança parcial é carregado com confiança total (por exemplo, no domínio de aplicativo padrão de um aplicativo da área de trabalho). Nesse caso, o tempo de execução atribui o método dinâmico a transparência padrão para métodos de acordo com as anotações do assembly.  
  
 Para obter mais informações sobre reflexão emitir e transparência, consulte [problemas de segurança na emissão de reflexão](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Para obter informações sobre transparência, consulte [alterações de segurança](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O método dinâmico não tem um corpo de método.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemas de segurança na emissão de reflexão</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Considerações sobre segurança relacionadas à reflexão</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Alterações de segurança no .NET Framework versão 4.0</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">Código transparente de segurança, nível 1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">Código transparente de segurança, nível 2</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o método dinâmico é crítico para segurança e disponível no código transparente no nível de confiança atual; ou seja, se ele pode realizar operações críticas e ser acessado pelo código transparente.</summary>
        <value><see langword="true" /> Se o método dinâmico é segurança-seguro-crítica no nível de confiança atual; <see langword="false" /> se ele é crítico para segurança ou transparente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, e <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> propriedades relatam o nível de transparência do método dinâmico, conforme determinado pelo common language runtime (CLR). As combinações destas propriedades são mostradas na seguinte tabela:  
  
|Nível de segurança|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Crítico|`true`|`false`|`false`|  
|Segurança crítica|`true`|`true`|`false`|  
|Transparente|`false`|`false`|`true`|  
  
 Usar essas propriedade é muito mais simples que examinar as anotações de segurança de um assembly e seus tipos, verificando o nível de confiança atual e tentando duplicar as regras do tempo de execução.  
  
 A transparência de um método dinâmico depende do módulo que está associado. Se o método dinâmico está associado com um tipo em vez de um módulo, a transparência depende do módulo que contém o tipo. Métodos dinâmicos não têm anotações de segurança, portanto, eles são atribuídos a transparência padrão para o módulo associado.  
  
-   Métodos dinâmicos hospedados anonimamente são sempre transparentes, pois o módulo fornecido pelo sistema que os contém é transparente.  
  
-   A transparência de um método dinâmico que está associado um assembly confiável (ou seja, um assembly de nome forte que está instalado no cache de assembly global) é descrita na tabela a seguir.  
  
    |Anotação de assembly|Transparência de nível 1|Transparência de nível 2|  
    |-------------------------|--------------------------|--------------------------|  
    |Totalmente transparente|Transparente|Transparente|  
    |Totalmente crítica|Crítico|Crítico|  
    |Transparência mista|Transparente|Transparente|  
    |Independente de segurança|Crítico para segurança|Crítico|  
  
     Por exemplo, se você associar um método dinâmico com um tipo que está em mscorlib. dll, que tem o nível 2 transparência misto, o método dinâmico é transparente e não é possível executar o código critical. Para obter informações sobre os níveis de transparência, consulte [código transparente de segurança, nível 1](~/docs/framework/misc/security-transparent-code-level-1.md) e [código transparente de segurança, nível 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Associar um método dinâmico com um módulo em um assembly confiável de nível 1 que é independente de segurança, como System. dll, não permitir a elevação de confiança. Se o conjunto de concessões do código que chama o método dinâmico não inclui o conjunto de concessões de System. dll (ou seja, confiança total), <xref:System.Security.SecurityException> é lançada quando o método dinâmico é chamado.  
  
-   A transparência de um método dinâmico que está associado um assembly parcialmente confiável depende de como o assembly é carregado. Se o assembly é carregado com confiança parcial (por exemplo, para um domínio de aplicativo em área restrita), o tempo de execução ignora as anotações de segurança do assembly. O assembly e todos os seus tipos e membros, incluindo métodos dinâmicos, são tratados como transparentes. O tempo de execução presta atenção nas anotações de segurança somente se o assembly de confiança parcial é carregado com confiança total (por exemplo, no domínio de aplicativo padrão de um aplicativo da área de trabalho). Nesse caso, o tempo de execução atribui o método dinâmico a transparência padrão para métodos de acordo com as anotações do assembly.  
  
 Para obter mais informações sobre reflexão emitir e transparência, consulte [problemas de segurança na emissão de reflexão](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Para obter informações sobre transparência, consulte [alterações de segurança](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O método dinâmico não tem um corpo de método.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemas de segurança na emissão de reflexão</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Considerações sobre segurança relacionadas à reflexão</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Alterações de segurança no .NET Framework versão 4.0</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">Código transparente de segurança, nível 1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">Código transparente de segurança, nível 2</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica que se o método dinâmico atual é transparente no nível de confiança atual e, portanto, não é pode realizar operações críticas.</summary>
        <value><see langword="true" /> Se o método dinâmico é transparente de segurança no nível de confiança atual; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, e <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> propriedades relatam o nível de transparência do método dinâmico, conforme determinado pelo common language runtime (CLR). As combinações destas propriedades são mostradas na seguinte tabela:  
  
|Nível de segurança|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Crítico|`true`|`false`|`false`|  
|Segurança crítica|`true`|`true`|`false`|  
|Transparente|`false`|`false`|`true`|  
  
 Usar essas propriedade é muito mais simples que examinar as anotações de segurança de um assembly e seus tipos, verificando o nível de confiança atual e tentando duplicar as regras do tempo de execução.  
  
 A transparência de um método dinâmico depende do módulo que está associado. Se o método dinâmico está associado com um tipo em vez de um módulo, a transparência depende do módulo que contém o tipo. Métodos dinâmicos não têm anotações de segurança, portanto, eles são atribuídos a transparência padrão para o módulo associado.  
  
-   Métodos dinâmicos hospedados anonimamente são sempre transparentes, pois o módulo fornecido pelo sistema que os contém é transparente.  
  
-   A transparência de um método dinâmico que está associado um assembly confiável (ou seja, um assembly de nome forte que está instalado no cache de assembly global) é descrita na tabela a seguir.  
  
    |Anotação de assembly|Transparência de nível 1|Transparência de nível 2|  
    |-------------------------|--------------------------|--------------------------|  
    |Totalmente transparente|Transparente|Transparente|  
    |Totalmente crítica|Crítico|Crítico|  
    |Transparência mista|Transparente|Transparente|  
    |Independente de segurança|Crítico para segurança|Crítico|  
  
     Por exemplo, se você associar um método dinâmico com um tipo que está em mscorlib. dll, que tem o nível 2 transparência misto, o método dinâmico é transparente e não é possível executar o código critical. Para obter informações sobre os níveis de transparência, consulte [código transparente de segurança, nível 1](~/docs/framework/misc/security-transparent-code-level-1.md) e [código transparente de segurança, nível 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Associar um método dinâmico com um módulo em um assembly confiável de nível 1 que é independente de segurança, como System. dll, não permitir a elevação de confiança. Se o conjunto de concessões do código que chama o método dinâmico não inclui o conjunto de concessões de System. dll (ou seja, confiança total), <xref:System.Security.SecurityException> é lançada quando o método dinâmico é chamado.  
  
-   A transparência de um método dinâmico que está associado um assembly parcialmente confiável depende de como o assembly é carregado. Se o assembly é carregado com confiança parcial (por exemplo, para um domínio de aplicativo em área restrita), o tempo de execução ignora as anotações de segurança do assembly. O assembly e todos os seus tipos e membros, incluindo métodos dinâmicos, são tratados como transparentes. O tempo de execução presta atenção nas anotações de segurança somente se o assembly de confiança parcial é carregado com confiança total (por exemplo, no domínio de aplicativo padrão de um aplicativo da área de trabalho). Nesse caso, o tempo de execução atribui o método dinâmico a transparência padrão para métodos de acordo com as anotações do assembly.  
  
 Para obter mais informações sobre reflexão emitir e transparência, consulte [problemas de segurança na emissão de reflexão](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Para obter informações sobre transparência, consulte [alterações de segurança](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O método dinâmico não tem um corpo de método.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemas de segurança na emissão de reflexão</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Considerações sobre segurança relacionadas à reflexão</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Alterações de segurança no .NET Framework versão 4.0</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">Código transparente de segurança, nível 1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">Código transparente de segurança, nível 2</related>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodHandle : RuntimeMethodHandle" Usage="System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Não tem suporte para métodos dinâmicos.</summary>
        <value>Não tem suporte para métodos dinâmicos.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Não é permitido para métodos dinâmicos.</exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodImplementationFlags : System.Reflection.MethodImplAttributes" Usage="System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.DynamicMethod.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o módulo ao qual o método dinâmico está logicamente associado.</summary>
        <value>O <see cref="T:System.Reflection.Module" /> ao qual o método dinâmico atual está associado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um módulo tiver sido especificado quando o método dinâmico foi criado, essa propriedade retorna o módulo. Se um tipo foi especificado como o proprietário quando o método dinâmico foi criado, essa propriedade retorna o módulo que contém esse tipo.  
  
   
  
## Examples  
 O seguinte código de exemplo exibe o <xref:System.Reflection.Emit.DynamicMethod.Module%2A> propriedade de um método dinâmico. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#26](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#26)]
 [!code-csharp[Reflection.DynamicMethod.All#26](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#26)]
 [!code-vb[Reflection.DynamicMethod.All#26](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.DynamicMethod.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome do método dinâmico.</summary>
        <value>O nome simples do método.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Não é necessário para métodos dinâmicos do nome.  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o nome de um método dinâmico. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#27](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#27)]
 [!code-csharp[Reflection.DynamicMethod.All#27](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#27)]
 [!code-vb[Reflection.DynamicMethod.All#27](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a classe que foi usada na reflexão para obter o método.</summary>
        <value>Sempre <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade sempre retorna `null` para métodos dinâmicos.  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o tipo refletido de um método dinâmico. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#28](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#28)]
 [!code-csharp[Reflection.DynamicMethod.All#28](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#28)]
 [!code-vb[Reflection.DynamicMethod.All#28](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnParameter : System.Reflection.ParameterInfo" Usage="System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o parâmetro de retorno do método dinâmico.</summary>
        <value>Sempre <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade sempre retorna `null` para métodos dinâmicos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tipo de valor retornado do método dinâmico.</summary>
        <value>Um <see cref="T:System.Type" /> que representa o tipo do valor de retorno do método atual; <see cref="T:System.Void" /> se o método não tem nenhum tipo de retorno.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `null` foi especificado para o tipo de retorno quando o método dinâmico foi criado, essa propriedade retornará <xref:System.Void?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o tipo de retorno de um método dinâmico. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#30](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#30)]
 [!code-csharp[Reflection.DynamicMethod.All#30](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#30)]
 [!code-vb[Reflection.DynamicMethod.All#30](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnTypeCustomAttributes : System.Reflection.ICustomAttributeProvider" Usage="System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém os atributos personalizados do tipo de retorno para o método dinâmico.</summary>
        <value>Um <see cref="T:System.Reflection.ICustomAttributeProvider" /> que representa os atributos personalizados do tipo de retorno para o método dinâmico.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atributos personalizados não têm suporte em tipo de retorno de um método dinâmico, portanto, a matriz de atributos personalizados retornada pelo <xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A> método sempre está vazio.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como exibir os atributos personalizados do tipo de retorno de um método dinâmico. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#31](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#31)]
 [!code-csharp[Reflection.DynamicMethod.All#31](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#31)]
 [!code-vb[Reflection.DynamicMethod.All#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#31)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dynamicMethod.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna a assinatura do método, representada como uma cadeia de caracteres.</summary>
        <returns>Uma cadeia de caracteres que representa a assinatura do método.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A assinatura inclui apenas tipos e o nome do método, se houver. Nomes de parâmetros não são incluídos.  
  
   
  
## Examples  
 O seguinte código de exemplo exibe o <xref:System.Reflection.Emit.DynamicMethod.ToString%2A> método de um método dinâmico. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#32](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#32)]
 [!code-csharp[Reflection.DynamicMethod.All#32](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#32)]
 [!code-vb[Reflection.DynamicMethod.All#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>