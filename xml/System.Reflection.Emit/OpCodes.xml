<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b90a20583f24b5370819a5d643b5b26bb93210ac" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37643725" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="de0f3-101">Fornece representações de campo das instruções da MSIL (Microsoft intermediate language) para emissão por membros da classe <see cref="T:System.Reflection.Emit.ILGenerator" /> (como <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />).</span>
      <span class="sxs-lookup">
        <span data-stu-id="de0f3-101">Provides field representations of the Microsoft Intermediate Language (MSIL) instructions for emission by the <see cref="T:System.Reflection.Emit.ILGenerator" /> class members (such as <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />).</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-102">Para obter uma descrição detalhada dos opcodes de membro, consulte a documentação do Common Language Infrastructure (CLI), especialmente "Partição III: CIL Instruction Set" e "Partição II: Metadata Definition and Semantics".</span><span class="sxs-lookup"><span data-stu-id="de0f3-102">For a detailed description of the member opcodes, see the Common Language Infrastructure (CLI) documentation, especially "Partition III: CIL Instruction Set" and "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="de0f3-103">A documentação está disponível online; confira [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212), no MSDN, e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552), no site internacional da Ecma.</span><span class="sxs-lookup"><span data-stu-id="de0f3-103">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="de0f3-104">O exemplo a seguir demonstra a construção de um método dinâmico usando <xref:System.Reflection.Emit.ILGenerator> emita `OpCodes` em um <xref:System.Reflection.Emit.MethodBuilder>.</span><span class="sxs-lookup"><span data-stu-id="de0f3-104">The following example demonstrates the construction of a dynamic method using <xref:System.Reflection.Emit.ILGenerator> to emit `OpCodes` into a <xref:System.Reflection.Emit.MethodBuilder>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-105">Adiciona dois valores e envia o resultado para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-105">Adds two values and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-106">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-106">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-107">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-107">Format</span></span>|<span data-ttu-id="de0f3-108">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-108">Assembly Format</span></span>|<span data-ttu-id="de0f3-109">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-109">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-110">58</span><span class="sxs-lookup"><span data-stu-id="de0f3-110">58</span></span>|<span data-ttu-id="de0f3-111">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-111">add</span></span>|<span data-ttu-id="de0f3-112">Adiciona dois valores numéricos, retornando um novo valor numérico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-112">Adds two numeric values, returning a new numeric value.</span></span>|  
  
 <span data-ttu-id="de0f3-113">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-113">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-114">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-114">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-115">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-115">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-116">`value2` e `value1` são removidos da pilha; `value1` é adicionado ao `value2`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-116">`value2` and `value1` are popped from the stack; `value1` is added to `value2`.</span></span>  
  
4.  <span data-ttu-id="de0f3-117">O resultado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-117">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-118">Estouro não é detectado para operações de inteiros (para a manipulação de estouro adequada, consulte <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).</span><span class="sxs-lookup"><span data-stu-id="de0f3-118">Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).</span></span>  
  
 <span data-ttu-id="de0f3-119">Adição de inteiro envolve, em vez de esteja saturado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-119">Integer addition wraps, rather than saturates.</span></span> <span data-ttu-id="de0f3-120">Por exemplo, supondo que os inteiros de 8 bits em que `value1` é definido como 255 e `value2` é definido como 1, o resultado encapsulado é 0 em vez de 256.</span><span class="sxs-lookup"><span data-stu-id="de0f3-120">For example, assuming 8-bit integers where `value1` is set to 255 and `value2` is set to 1, the wrapped result is 0 rather than 256.</span></span>  
  
 <span data-ttu-id="de0f3-121">Retorna de estouro de ponto flutuante `+inf` (`PositiveInfinity`) ou `-inf` (`NegativeInfinity`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-121">Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`).</span></span>  
  
 <span data-ttu-id="de0f3-122">Os tipos de operando aceitável e seu tipo de dados de resultado correspondente são listados na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="de0f3-122">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="de0f3-123">Se não houver nenhuma entrada para uma combinação de tipo específico (por exemplo, `int32` e `float`; `int32` e `int64`), ele é um inválido MSIL Microsoft Intermediate Language () e gera um erro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-123">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) and generates an error.</span></span>  
  
|<span data-ttu-id="de0f3-124">operando</span><span class="sxs-lookup"><span data-stu-id="de0f3-124">operand</span></span>|<span data-ttu-id="de0f3-125">tipo de valor1</span><span class="sxs-lookup"><span data-stu-id="de0f3-125">value1 type</span></span>|<span data-ttu-id="de0f3-126">tipo de value2</span><span class="sxs-lookup"><span data-stu-id="de0f3-126">value2 type</span></span>|<span data-ttu-id="de0f3-127">tipo de resultado</span><span class="sxs-lookup"><span data-stu-id="de0f3-127">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="de0f3-128">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-128">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="de0f3-129">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-129">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="de0f3-130">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-130">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="de0f3-131">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-131">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="de0f3-132">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-132">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="de0f3-133">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-133">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="de0f3-134">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-134">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="de0f3-135">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-135">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="de0f3-136">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-136">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="de0f3-137">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-137">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="de0f3-138">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-138">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="de0f3-139">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-139">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="de0f3-140">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-140">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="de0f3-141">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-141">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="de0f3-142">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `add` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-142">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-143">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-143">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-144">Adiciona dois números inteiros, executa uma verificação de estouro e efetua o push do resultado para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-144">Adds two integers, performs an overflow check, and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-145">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-145">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-146">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-146">Format</span></span>|<span data-ttu-id="de0f3-147">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-147">Assembly Format</span></span>|<span data-ttu-id="de0f3-148">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-148">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-149">D6</span><span class="sxs-lookup"><span data-stu-id="de0f3-149">D6</span></span>|<span data-ttu-id="de0f3-150">add.ovf</span><span class="sxs-lookup"><span data-stu-id="de0f3-150">add.ovf</span></span>|<span data-ttu-id="de0f3-151">Adiciona dois valores de inteiro com sinal com uma verificação de estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-151">Adds two signed integer values with an overflow check.</span></span>|  
  
 <span data-ttu-id="de0f3-152">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-152">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-153">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-153">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-154">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-154">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-155">`value2` e `value1` são removidos da pilha; `value1` é adicionado ao `value2` com uma verificação de estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-155">`value2` and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="de0f3-156">O resultado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-156">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-157"><xref:System.OverflowException> será gerada se o resultado não é representado no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-157"><xref:System.OverflowException> is thrown if the result is not represented in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-158">Você pode executar esta operação em inteiros com sinal.</span><span class="sxs-lookup"><span data-stu-id="de0f3-158">You can perform this operation on signed integers.</span></span> <span data-ttu-id="de0f3-159">Para valores de ponto flutuantes, use <xref:System.Reflection.Emit.OpCodes.Add>.</span><span class="sxs-lookup"><span data-stu-id="de0f3-159">For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.</span></span>  
  
 <span data-ttu-id="de0f3-160">Os tipos de operando aceitável e seu tipo de dados de resultado correspondente são listados na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="de0f3-160">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="de0f3-161">Se não houver nenhuma entrada para uma combinação de tipo específico (por exemplo, `int32` e `float`; `int32` e `int64`), ele é uma instrução inválida do Microsoft Intermediate Language (MSIL) e gera um erro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-161">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</span></span>  
  
|<span data-ttu-id="de0f3-162">operando</span><span class="sxs-lookup"><span data-stu-id="de0f3-162">operand</span></span>|<span data-ttu-id="de0f3-163">tipo de valor1</span><span class="sxs-lookup"><span data-stu-id="de0f3-163">value1 type</span></span>|<span data-ttu-id="de0f3-164">tipo de value2</span><span class="sxs-lookup"><span data-stu-id="de0f3-164">value2 type</span></span>|<span data-ttu-id="de0f3-165">tipo de resultado</span><span class="sxs-lookup"><span data-stu-id="de0f3-165">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="de0f3-166">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-166">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="de0f3-167">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-167">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="de0f3-168">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-168">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="de0f3-169">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-169">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="de0f3-170">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-170">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="de0f3-171">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-171">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="de0f3-172">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-172">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="de0f3-173">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-173">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="de0f3-174">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-174">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="de0f3-175">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-175">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="de0f3-176">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-176">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="de0f3-177">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-177">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="de0f3-178">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-178">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="de0f3-179">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-179">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="de0f3-180">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `add.ovf` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-180">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-181">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-181">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-182">Adiciona dois valores de inteiro sem sinal, executa uma verificação de estouro e efetua o push do resultado para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-182">Adds two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-183">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-183">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-184">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-184">Format</span></span>|<span data-ttu-id="de0f3-185">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-185">Assembly Format</span></span>|<span data-ttu-id="de0f3-186">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-186">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-187">D7</span><span class="sxs-lookup"><span data-stu-id="de0f3-187">D7</span></span>|<span data-ttu-id="de0f3-188">add.ovf.un</span><span class="sxs-lookup"><span data-stu-id="de0f3-188">add.ovf.un</span></span>|<span data-ttu-id="de0f3-189">Adiciona dois valores inteiros sem sinal com uma verificação de estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-189">Adds two unsigned integer values with an overflow check.</span></span>|  
  
 <span data-ttu-id="de0f3-190">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-190">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-191">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-191">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-192">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-192">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-193">`value2` e `value1` são removidos da pilha; `value1` é adicionado ao `value2` com uma verificação de estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-193">`value2` and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="de0f3-194">O resultado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-194">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-195"><xref:System.OverflowException> será gerada se o resultado não é representado no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-195"><xref:System.OverflowException> is thrown if the result is not represented in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-196">Você pode executar esta operação em inteiros com sinal.</span><span class="sxs-lookup"><span data-stu-id="de0f3-196">You can perform this operation on signed integers.</span></span> <span data-ttu-id="de0f3-197">Para valores de ponto flutuantes, use <xref:System.Reflection.Emit.OpCodes.Add>.</span><span class="sxs-lookup"><span data-stu-id="de0f3-197">For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.</span></span>  
  
 <span data-ttu-id="de0f3-198">Os tipos de operando aceitável e seu tipo de dados de resultado correspondente são listados na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="de0f3-198">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="de0f3-199">Se não houver nenhuma entrada para uma combinação de tipo específico (por exemplo, `int32` e `float`; `int32` e `int64`), ele é uma instrução inválida do Microsoft Intermediate Language (MSIL) e gera um erro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-199">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</span></span>  
  
|<span data-ttu-id="de0f3-200">operando</span><span class="sxs-lookup"><span data-stu-id="de0f3-200">operand</span></span>|<span data-ttu-id="de0f3-201">tipo de valor1</span><span class="sxs-lookup"><span data-stu-id="de0f3-201">value1 type</span></span>|<span data-ttu-id="de0f3-202">tipo de value2</span><span class="sxs-lookup"><span data-stu-id="de0f3-202">value2 type</span></span>|<span data-ttu-id="de0f3-203">tipo de resultado</span><span class="sxs-lookup"><span data-stu-id="de0f3-203">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="de0f3-204">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-204">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="de0f3-205">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-205">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="de0f3-206">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-206">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="de0f3-207">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-207">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="de0f3-208">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-208">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="de0f3-209">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-209">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="de0f3-210">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-210">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="de0f3-211">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-211">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="de0f3-212">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-212">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="de0f3-213">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-213">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="de0f3-214">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-214">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="de0f3-215">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-215">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="de0f3-216">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-216">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="de0f3-217">adicionar</span><span class="sxs-lookup"><span data-stu-id="de0f3-217">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="de0f3-218">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `add.ovf.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-218">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-219">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-219">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-220">Calcula o AND bit a bit de dois valores e efetua o push do resultado para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-220">Computes the bitwise AND of two values and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-221">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-221">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-222">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-222">Format</span></span>|<span data-ttu-id="de0f3-223">Instrução</span><span class="sxs-lookup"><span data-stu-id="de0f3-223">Instruction</span></span>|<span data-ttu-id="de0f3-224">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-224">Description</span></span>|  
|------------|-----------------|-----------------|  
|<span data-ttu-id="de0f3-225">5F</span><span class="sxs-lookup"><span data-stu-id="de0f3-225">5F</span></span>|<span data-ttu-id="de0f3-226">e</span><span class="sxs-lookup"><span data-stu-id="de0f3-226">and</span></span>|<span data-ttu-id="de0f3-227">Determina o AND bit a bit de dois valores inteiros.</span><span class="sxs-lookup"><span data-stu-id="de0f3-227">Determines the bitwise AND of two integer values.</span></span>|  
  
 <span data-ttu-id="de0f3-228">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-228">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-229">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-229">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-230">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-230">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-231">`value1` e `value2` são removidos da pilha; o AND bit a bit dos dois valores é computado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-231">`value1` and `value2` are popped from the stack; the bitwise AND of the two values is computed.</span></span>  
  
4.  <span data-ttu-id="de0f3-232">O resultado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-232">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-233">O `and` instrução calcula o AND bit a bit dos valores de dois primeiros na pilha e deixa o resultado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-233">The `and` instruction computes the bitwise AND of the top two values on the stack and leaves the result on the stack.</span></span>  
  
 <span data-ttu-id="de0f3-234">`And` é uma operação de inteiro específico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-234">`And` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="de0f3-235">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `and` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-235">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `and` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-236">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-236">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-237">Retorna um ponteiro não gerenciado para a lista de argumentos do método atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-237">Returns an unmanaged pointer to the argument list of the current method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-238">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-238">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-239">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-239">Format</span></span>|<span data-ttu-id="de0f3-240">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-240">Assembly Format</span></span>|<span data-ttu-id="de0f3-241">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-241">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-242">FE 00</span><span class="sxs-lookup"><span data-stu-id="de0f3-242">FE 00</span></span>|<span data-ttu-id="de0f3-243">arglist</span><span class="sxs-lookup"><span data-stu-id="de0f3-243">arglist</span></span>|<span data-ttu-id="de0f3-244">Retorna um identificador de lista de argumento para o método atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-244">Returns an argument list handle for the current method.</span></span>|  
  
 <span data-ttu-id="de0f3-245">Não há comportamentos de pilha de avaliação são executados por esta operação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-245">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="de0f3-246">O `arglist` instrução retorna um identificador opaco (um ponteiro não gerenciado, do tipo `native int`) que representa a lista de argumentos do método atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-246">The `arglist` instruction returns an opaque handle (an unmanaged pointer, of type `native int`) that represents the argument list of the current method.</span></span> <span data-ttu-id="de0f3-247">Esse identificador é válido somente durante o tempo de vida do método atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-247">This handle is valid only during the lifetime of the current method.</span></span> <span data-ttu-id="de0f3-248">No entanto, você pode, passar o identificador para outros métodos, desde que o método atual está no thread de controle.</span><span class="sxs-lookup"><span data-stu-id="de0f3-248">You can, however, pass the handle to other methods as long as the current method is on the thread of control.</span></span> <span data-ttu-id="de0f3-249">Você pode executar apenas o `arglist` instrução dentro de um método que usa um número variável de argumentos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-249">You can only execute the `arglist` instruction within a method that takes a variable number of arguments.</span></span>  
  
 <span data-ttu-id="de0f3-250">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `arglist` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-250">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `arglist` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-251">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-251">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-252">Transfere o controle para uma instrução de destino se dois valores são iguais.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-252">Transfers control to a target instruction if two values are equal.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-253">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-253">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-254">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-254">Format</span></span>|<span data-ttu-id="de0f3-255">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-255">Assembly Format</span></span>|<span data-ttu-id="de0f3-256">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-256">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-257">3B &LT; `int32` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-257">3B < `int32` ></span></span>|<span data-ttu-id="de0f3-258">beq `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-258">beq `target`</span></span>|<span data-ttu-id="de0f3-259">Branch para a instrução de destino no deslocamento `target` se os dois valores forem iguais.</span><span class="sxs-lookup"><span data-stu-id="de0f3-259">Branch to the target instruction at offset `target` if the two values are equal.</span></span>|  
  
 <span data-ttu-id="de0f3-260">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-260">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-261">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-261">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-262">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-262">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-263">`value2` e `value1` são removidos da pilha; se `value1` é igual a `value2`, a operação de ramificação é executada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-263">`value2` and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de0f3-264">O `beq` instrução transfere o controle para a instrução de destino especificado se `value1` é igual a `value2`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-264">The `beq` instruction transfers control to the specified target instruction if `value1` is equal to `value2`.</span></span> <span data-ttu-id="de0f3-265">O efeito é o mesmo que executar uma `ceq` instruções seguidas por um `brtrue` ramificação para a instrução de destino específico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-265">The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="de0f3-266">A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-266">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-267">Os tipos de operando aceitáveis são encapsulados abaixo:</span><span class="sxs-lookup"><span data-stu-id="de0f3-267">The acceptable operand types are encapsulated below:</span></span>  
  
 <span data-ttu-id="de0f3-268">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-268">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="de0f3-269">O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução (essas transferências são rigorosamente restritas e deve usar o <xref:System.Reflection.Emit.OpCodes.Leave> instrução em vez disso).</span><span class="sxs-lookup"><span data-stu-id="de0f3-269">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead).</span></span>  
  
 <span data-ttu-id="de0f3-270">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `beq` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-270">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-271">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-271">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-272">Transferirá o controle para uma instrução de destino (forma abreviada) se dois valores forem iguais.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-272">Transfers control to a target instruction (short form) if two values are equal.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-273">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-273">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-274">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-274">Format</span></span>|<span data-ttu-id="de0f3-275">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-275">Assembly Format</span></span>|<span data-ttu-id="de0f3-276">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-276">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-277">2E < `int8` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-277">2E < `int8` ></span></span>|<span data-ttu-id="de0f3-278">beq.s `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-278">beq.s `target`</span></span>|<span data-ttu-id="de0f3-279">Branch para a instrução de destino no deslocamento `target` se for igual, forma abreviada</span><span class="sxs-lookup"><span data-stu-id="de0f3-279">Branch to the target instruction at offset `target` if equal, short form</span></span>|  
  
 <span data-ttu-id="de0f3-280">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-280">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-281">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-281">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-282">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-282">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-283">`value2` e `value1` são removidos da pilha; se `value1` é igual a `value2`, a operação de ramificação é executada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-283">`value2` and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de0f3-284">O `beq.s` instrução transfere o controle para a instrução de destino especificado se `value1` é igual a `value2`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-284">The `beq.s` instruction transfers control to the specified target instruction if `value1` is equal to `value2`.</span></span> <span data-ttu-id="de0f3-285">O efeito é o mesmo que executar uma `ceq` instruções seguidas por um `brtrue` ramificação para a instrução de destino específico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-285">The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="de0f3-286">A instrução de destino é representada como uma diferença de 1 byte com sinal desde o início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-286">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-287">Os tipos de operando aceitáveis são encapsulados abaixo:</span><span class="sxs-lookup"><span data-stu-id="de0f3-287">The acceptable operand types are encapsulated below:</span></span>  
  
 <span data-ttu-id="de0f3-288">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-288">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="de0f3-289">O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução (essas transferências são rigorosamente restritas e deve usar o <xref:System.Reflection.Emit.OpCodes.Leave> instrução em vez disso).</span><span class="sxs-lookup"><span data-stu-id="de0f3-289">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead).</span></span>  
  
 <span data-ttu-id="de0f3-290">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `beq.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-290">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq.s` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-291">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-291">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-292">Transferirá controle para uma instrução de destino se o primeiro valor for maior ou igual ao segundo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-292">Transfers control to a target instruction if the first value is greater than or equal to the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-293">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-293">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-294">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-294">Format</span></span>|<span data-ttu-id="de0f3-295">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-295">Assembly Format</span></span>|<span data-ttu-id="de0f3-296">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-296">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-297">3C `<int32>`</span><span class="sxs-lookup"><span data-stu-id="de0f3-297">3C `<int32>`</span></span>|<span data-ttu-id="de0f3-298">bge `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-298">bge `target`</span></span>|<span data-ttu-id="de0f3-299">Branch para a instrução de destino no deslocamento especificado se o primeiro valor é maior que ou igual ao segundo valor.</span><span class="sxs-lookup"><span data-stu-id="de0f3-299">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value.</span></span>|  
  
 <span data-ttu-id="de0f3-300">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-300">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-301">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-301">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-302">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-302">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-303">`value2` e `value1` são removidos da pilha; se `value1` é maior que ou igual a `value2`, a operação de ramificação é executada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-303">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de0f3-304">O `bge` instrução transfere o controle para a instrução de destino especificado se `value1` é maior que ou igual a `value2`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-304">The `bge` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`.</span></span> <span data-ttu-id="de0f3-305">O efeito é idêntico ao executar uma `clt.un` instruções seguidas por um `brfalse` ramificação para a instrução de destino específico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-305">The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="de0f3-306">A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-306">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-307">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-307">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de0f3-308">O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-308">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-309">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bge` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-309">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-310">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-310">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-311">Transferirá controle para uma instrução de destino (forma abreviada) se o primeiro valor for maior ou igual ao segundo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-311">Transfers control to a target instruction (short form) if the first value is greater than or equal to the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-312">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-312">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-313">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-313">Format</span></span>|<span data-ttu-id="de0f3-314">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-314">Assembly Format</span></span>|<span data-ttu-id="de0f3-315">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-315">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-316">2F `<int8>`</span><span class="sxs-lookup"><span data-stu-id="de0f3-316">2F `<int8>`</span></span>|<span data-ttu-id="de0f3-317">bge.s `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-317">bge.s `target`</span></span>|<span data-ttu-id="de0f3-318">Branch para a instrução de destino no deslocamento especificado se o primeiro valor é maior que ou igual ao segundo valor, a forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-318">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value, short form.</span></span>|  
  
 <span data-ttu-id="de0f3-319">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-319">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-320">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-320">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-321">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-321">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-322">`value2` e `value1` são removidos da pilha; se `value1` é maior que ou igual a `value2`, a operação de ramificação é executada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-322">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de0f3-323">O `bge.s` instrução transfere o controle para a instrução de destino especificado se `value1` é maior que ou igual a `value2`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-323">The `bge.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`.</span></span> <span data-ttu-id="de0f3-324">O efeito é idêntico ao executar uma `clt.un` instruções seguidas por um `brfalse` ramificação para a instrução de destino específico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-324">The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="de0f3-325">A instrução de destino é representada como uma diferença de 1 byte com sinal desde o início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-325">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-326">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-326">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de0f3-327">O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-327">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-328">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bge.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-328">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.s` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-329">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-329">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-330">Transferirá o controle para uma instrução de destino se o primeiro valor for maior que o segundo valor ao comparar valores de inteiro sem sinal ou valores float não ordenados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-330">Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-331">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-331">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-332">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-332">Format</span></span>|<span data-ttu-id="de0f3-333">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-333">Assembly Format</span></span>|<span data-ttu-id="de0f3-334">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-334">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-335">41 `<int32>`</span><span class="sxs-lookup"><span data-stu-id="de0f3-335">41 `<int32>`</span></span>|<span data-ttu-id="de0f3-336">bge.Un `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-336">bge.un `target`</span></span>|<span data-ttu-id="de0f3-337">Branch para a instrução de destino no deslocamento especificado se o primeiro valor é maior que ou igual ao segundo valor (valores sem sinal).</span><span class="sxs-lookup"><span data-stu-id="de0f3-337">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="de0f3-338">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-338">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-339">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-339">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-340">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-340">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-341">`value2` e `value1` são removidos da pilha; se `value1` é maior que ou igual a `value2`, a operação de ramificação é executada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-341">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de0f3-342">O `bge.un` instrução transfere o controle para a instrução de destino especificado se `value1` é maior que ou igual a `value2`, quando comparados com o inteiro sem sinal ou valores float não ordenados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-342">The `bge.un` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="de0f3-343">O efeito é idêntico ao executar uma `clt` instruções seguidas por um `brfalse` ramificação para a instrução de destino específico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-343">The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="de0f3-344">A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-344">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-345">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-345">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de0f3-346">O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-346">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-347">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bge.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-347">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-348">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-348">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-349">Transferirá o controle para uma instrução de destino (forma abreviada) se o primeiro valor for maior que o segundo valor ao comparar valores de inteiro sem sinal ou valores float não ordenados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-349">Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-350">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-350">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-351">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-351">Format</span></span>|<span data-ttu-id="de0f3-352">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-352">Assembly Format</span></span>|<span data-ttu-id="de0f3-353">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-353">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-354">34 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-354">34 < `int8` ></span></span>|<span data-ttu-id="de0f3-355">bge.un.s `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-355">bge.un.s `target`</span></span>|<span data-ttu-id="de0f3-356">Branch para a instrução de destino no deslocamento especificado se o primeiro valor é maior que ou igual ao segundo valor (valores sem sinal), forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-356">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="de0f3-357">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-357">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-358">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-358">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-359">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-359">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-360">`value2` e `value1` são removidos da pilha; se `value1` é maior que ou igual a `value2`, a operação de ramificação é executada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-360">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de0f3-361">O `bge.un.s` instrução transfere o controle para a instrução de destino especificado se `value1` é maior que ou igual a `value2`, quando comparados com o inteiro sem sinal ou valores float não ordenados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-361">The `bge.un.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="de0f3-362">O efeito é idêntico ao executar uma `clt` instruções seguidas por um `brfalse` ramificação para a instrução de destino específico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-362">The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="de0f3-363">A instrução de destino é representada como uma diferença de 1 byte com sinal desde o início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-363">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-364">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-364">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de0f3-365">O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-365">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-366">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bge.un.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-366">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-367">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-367">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-368">Transferirá controle para uma instrução de destino se o primeiro valor for maior que o segundo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-368">Transfers control to a target instruction if the first value is greater than the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-369">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-369">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-370">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-370">Format</span></span>|<span data-ttu-id="de0f3-371">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-371">Assembly Format</span></span>|<span data-ttu-id="de0f3-372">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-372">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-373">3D < `int32` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-373">3D < `int32` ></span></span>|<span data-ttu-id="de0f3-374">bgt `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-374">bgt `target`</span></span>|<span data-ttu-id="de0f3-375">Branch para a instrução de destino no deslocamento especificado se o primeiro valor for maior que o segundo valor.</span><span class="sxs-lookup"><span data-stu-id="de0f3-375">Branch to the target instruction at the specified offset if the first value is greater than the second value.</span></span>|  
  
 <span data-ttu-id="de0f3-376">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-376">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-377">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-377">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-378">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-378">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-379">`value2` e `value1` são removidos da pilha; se `value1` é maior que `value2`, a operação de ramificação é executada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-379">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de0f3-380">O `bgt` instrução transfere o controle para a instrução de destino especificado se `value1` é maior que `value2`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-380">The `bgt` instruction transfers control to the specified target instruction if `value1` is greater than `value2`.</span></span> <span data-ttu-id="de0f3-381">O efeito é idêntico ao executar uma `cgt` instruções seguidas por um `brtrue` ramificação para a instrução de destino específico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-381">The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="de0f3-382">A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-382">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-383">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-383">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de0f3-384">O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-384">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-385">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bgt` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-385">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-386">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-386">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-387">Transferirá controle para uma instrução de destino (forma abreviada) se o primeiro valor for maior que o segundo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-387">Transfers control to a target instruction (short form) if the first value is greater than the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-388">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-388">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-389">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-389">Format</span></span>|<span data-ttu-id="de0f3-390">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-390">Assembly Format</span></span>|<span data-ttu-id="de0f3-391">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-391">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-392">30 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-392">30 < `int8` ></span></span>|<span data-ttu-id="de0f3-393">bgt.s `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-393">bgt.s `target`</span></span>|<span data-ttu-id="de0f3-394">Branch para a instrução de destino no deslocamento especificado se o primeiro valor for maior que o segundo valor, de forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-394">Branch to the target instruction at the specified offset if the first value is greater than the second value, short form.</span></span>|  
  
 <span data-ttu-id="de0f3-395">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-395">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-396">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-396">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-397">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-397">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-398">`value2` e `value1` são removidos da pilha; se `value1` é maior que `value2`, a operação de ramificação é executada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-398">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de0f3-399">O `bgt.s` instrução transfere o controle para a instrução de destino especificado se `value1` é maior que `value2`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-399">The `bgt.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`.</span></span> <span data-ttu-id="de0f3-400">O efeito é idêntico ao executar uma `cgt` instruções seguidas por um `brtrue` ramificação para a instrução de destino específico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-400">The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="de0f3-401">A instrução de destino é representada como uma diferença de 1 byte com sinal desde o início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-401">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-402">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-402">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de0f3-403">O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-403">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-404">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bgt.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-404">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.s` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-405">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-405">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-406">Transferirá o controle para uma instrução de destino se o primeiro valor for maior que o segundo valor ao comparar valores de inteiro sem sinal ou valores float não ordenados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-406">Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-407">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-407">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-408">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-408">Format</span></span>|<span data-ttu-id="de0f3-409">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-409">Assembly Format</span></span>|<span data-ttu-id="de0f3-410">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-410">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-411">42 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-411">42 < `int32` ></span></span>|<span data-ttu-id="de0f3-412">bgt.Un `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-412">bgt.un `target`</span></span>|<span data-ttu-id="de0f3-413">Branch para a instrução de destino no deslocamento especificado se o primeiro valor for maior que o segundo valor (valores sem sinal).</span><span class="sxs-lookup"><span data-stu-id="de0f3-413">Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="de0f3-414">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-414">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-415">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-415">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-416">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-416">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-417">`value2` e `value1` são removidos da pilha; se `value1` é maior que `value2`, a operação de ramificação é executada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-417">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de0f3-418">O `bgt.un` instrução transfere o controle para a instrução de destino especificado se `value1` é maior que `value2`, quando comparados com o inteiro sem sinal ou valores float não ordenados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-418">The `bgt.un` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="de0f3-419">O efeito é idêntico ao executar uma `cgt.un` instruções seguidas por um `brtrue` ramificação para a instrução de destino específico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-419">The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="de0f3-420">A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-420">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-421">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-421">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de0f3-422">O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-422">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-423">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bgt.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-423">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-424">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-424">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-425">Transferirá o controle para uma instrução de destino (forma abreviada) se o primeiro valor for maior que o segundo valor ao comparar valores de inteiro sem sinal ou valores float não ordenados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-425">Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-426">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-426">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-427">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-427">Format</span></span>|<span data-ttu-id="de0f3-428">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-428">Assembly Format</span></span>|<span data-ttu-id="de0f3-429">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-429">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-430">35 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-430">35 < `int8` ></span></span>|<span data-ttu-id="de0f3-431">bgt.un.s `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-431">bgt.un.s `target`</span></span>|<span data-ttu-id="de0f3-432">Branch para a instrução de destino no deslocamento especificado se o primeiro valor for maior que o segundo valor (valores sem sinal), forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-432">Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="de0f3-433">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-433">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-434">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-434">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-435">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-435">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-436">`value2` e `value1` são removidos da pilha; se `value1` é maior que `value2`, a operação de ramificação é executada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-436">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de0f3-437">O `bgt.un.s` instrução transfere o controle para a instrução de destino especificado se `value1` é maior que `value2`, quando comparados com o inteiro sem sinal ou valores float não ordenados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-437">The `bgt.un.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="de0f3-438">O efeito é idêntico ao executar uma `cgt.un` instruções seguidas por um `brtrue` ramificação para a instrução de destino específico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-438">The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="de0f3-439">A instrução de destino é representada como uma diferença de 1 byte com sinal desde o início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-439">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-440">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-440">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de0f3-441">O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-441">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-442">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bgt.un.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-442">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-443">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-443">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-444">Transferirá controle para uma instrução de destino se o primeiro valor for menor ou igual ao segundo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-444">Transfers control to a target instruction if the first value is less than or equal to the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-445">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-445">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-446">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-446">Format</span></span>|<span data-ttu-id="de0f3-447">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-447">Assembly Format</span></span>|<span data-ttu-id="de0f3-448">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-448">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-449">3E `<int32>`</span><span class="sxs-lookup"><span data-stu-id="de0f3-449">3E `<int32>`</span></span>|<span data-ttu-id="de0f3-450">ble `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-450">ble `target`</span></span>|<span data-ttu-id="de0f3-451">Branch para a instrução de destino no deslocamento especificado se o primeiro valor é menor ou igual ao segundo valor.</span><span class="sxs-lookup"><span data-stu-id="de0f3-451">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value.</span></span>|  
  
 <span data-ttu-id="de0f3-452">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-452">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-453">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-453">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-454">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-454">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-455">`value2` e `value1` são removidos da pilha; se `value1` é menor que ou igual a `value2`, a operação de ramificação é executada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-455">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de0f3-456">O `ble` instrução transfere o controle para a instrução de destino especificado se `value1` é menor que ou igual a `value2`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-456">The `ble` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="de0f3-457">O efeito é idêntico ao executar uma `cgt` instrução (`cgt.un` para flutuações) seguido por um `brfalse` ramificação para a instrução de destino específico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-457">The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="de0f3-458">A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-458">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-459">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-459">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de0f3-460">O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-460">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-461">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ble` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-461">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-462">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-462">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-463">Transferirá controle para uma instrução de destino (forma abreviada) se o primeiro valor for menor ou igual ao segundo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-463">Transfers control to a target instruction (short form) if the first value is less than or equal to the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-464">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-464">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-465">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-465">Format</span></span>|<span data-ttu-id="de0f3-466">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-466">Assembly Format</span></span>|<span data-ttu-id="de0f3-467">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-467">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-468">31 `<int8>`</span><span class="sxs-lookup"><span data-stu-id="de0f3-468">31 `<int8>`</span></span>|<span data-ttu-id="de0f3-469">ble.s `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-469">ble.s `target`</span></span>|<span data-ttu-id="de0f3-470">Branch para a instrução de destino no deslocamento especificado se o primeiro valor é menor ou igual ao segundo valor, a forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-470">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value, short form.</span></span>|  
  
 <span data-ttu-id="de0f3-471">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-471">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-472">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-472">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-473">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-473">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-474">`value2` e `value1` são removidos da pilha; se `value1` é menor que ou igual a `value2`, a operação de ramificação é executada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-474">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de0f3-475">O `ble.s` instrução transfere o controle para a instrução de destino especificado se `value1` é menor que ou igual a `value2`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-475">The `ble.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="de0f3-476">O efeito é idêntico ao executar uma `cgt` instrução (`cgt.un` para flutuações) instruções seguidas por um`brfalse` ramificação para a instrução de destino específico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-476">The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) instruction followed by a`brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="de0f3-477">A instrução de destino é representada como uma diferença de 1 byte com sinal desde o início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-477">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-478">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-478">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de0f3-479">O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-479">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-480">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ble.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-480">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.s` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-481">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-481">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-482">Transferirá o controle para uma instrução de destino se o primeiro valor for menor ou igual ao segundo valor ao comparar valores de inteiro sem sinal ou valores float não ordenados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-482">Transfers control to a target instruction if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-483">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-483">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-484">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-484">Format</span></span>|<span data-ttu-id="de0f3-485">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-485">Assembly Format</span></span>|<span data-ttu-id="de0f3-486">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-486">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-487">43 `<int32>`</span><span class="sxs-lookup"><span data-stu-id="de0f3-487">43 `<int32>`</span></span>|<span data-ttu-id="de0f3-488">ble.Un `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-488">ble.un `target`</span></span>|<span data-ttu-id="de0f3-489">Branch para a instrução de destino no deslocamento especificado se o primeiro valor é menor ou igual ao segundo valor (valores sem sinal).</span><span class="sxs-lookup"><span data-stu-id="de0f3-489">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="de0f3-490">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-490">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-491">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-491">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-492">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-492">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-493">`value2` e `value1` são removidos da pilha; se `value1` é menor que ou igual a `value2`, a operação de ramificação é executada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-493">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de0f3-494">O `ble.un` instrução transfere o controle para a instrução de destino especificado se `value1` é menor que ou igual a `value2`, quando comparados com o inteiro sem sinal ou valores float não ordenados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-494">The `ble.un` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="de0f3-495">O efeito é idêntico ao executar uma `cgt.un` instrução (`cgt` para flutuações) seguido por um `brfalse` ramificação para a instrução de destino específico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-495">The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="de0f3-496">A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-496">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-497">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-497">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de0f3-498">O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-498">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-499">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ble.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-499">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-500">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-500">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-501">Transferirá o controle para uma instrução de destino (forma abreviada) se o primeiro valor for menor ou igual ao segundo valor ao comparar valores de inteiro sem sinal ou valores float não ordenados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-501">Transfers control to a target instruction (short form) if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-502">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-502">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-503">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-503">Format</span></span>|<span data-ttu-id="de0f3-504">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-504">Assembly Format</span></span>|<span data-ttu-id="de0f3-505">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-505">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-506">36 `<int8>`</span><span class="sxs-lookup"><span data-stu-id="de0f3-506">36 `<int8>`</span></span>|<span data-ttu-id="de0f3-507">ble.un.s `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-507">ble.un.s `target`</span></span>|<span data-ttu-id="de0f3-508">Branch para a instrução de destino no deslocamento especificado se o primeiro valor é menor ou igual ao segundo valor (valores sem sinal), forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-508">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="de0f3-509">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-509">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-510">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-510">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-511">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-511">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-512">`value2` e `value1` são removidos da pilha; se `value1` é menor que ou igual a `value2`, a operação de ramificação é executada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-512">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de0f3-513">O `ble.un.s` instrução transfere o controle para a instrução de destino especificado se `value1` é menor que ou igual a `value2`, quando comparados com o inteiro sem sinal ou valores float não ordenados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-513">The `ble.un.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="de0f3-514">O efeito é idêntico ao executar uma `cgt.un` instrução (`cgt` para flutuações) seguido por um `brfalse` ramificação para a instrução de destino específico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-514">The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="de0f3-515">A instrução de destino é representada como uma diferença de 1 byte com sinal desde o início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-515">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-516">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-516">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de0f3-517">O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-517">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-518">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ble.un.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-518">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-519">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-519">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-520">Transferirá controle para uma instrução de destino se o primeiro valor for menor que o segundo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-520">Transfers control to a target instruction if the first value is less than the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-521">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-521">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-522">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-522">Format</span></span>|<span data-ttu-id="de0f3-523">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-523">Assembly Format</span></span>|<span data-ttu-id="de0f3-524">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-524">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-525">3F < `int32` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-525">3F < `int32` ></span></span>|<span data-ttu-id="de0f3-526">blt `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-526">blt `target`</span></span>|<span data-ttu-id="de0f3-527">Branch para a instrução de destino no deslocamento especificado se o primeiro valor é menor que o segundo valor.</span><span class="sxs-lookup"><span data-stu-id="de0f3-527">Branch to the target instruction at the specified offset if the first value is less than the second value.</span></span>|  
  
 <span data-ttu-id="de0f3-528">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-528">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-529">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-529">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-530">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-530">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-531">`value2` e `value1` são removidos da pilha; se `value1` é menor que `value2`, a operação de ramificação é executada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-531">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de0f3-532">O `blt` instrução transfere o controle para a instrução de destino especificado se `value1` é menor que ou igual a `value2`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-532">The `blt` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="de0f3-533">O efeito é idêntico ao executar uma `clt` instruções seguidas por um `brtrue` ramificação para a instrução de destino específico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-533">The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="de0f3-534">A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-534">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-535">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-535">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de0f3-536">O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-536">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-537">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `blt` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-537">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-538">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-538">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-539">Transferirá controle para uma instrução de destino (forma abreviada) se o primeiro valor for menor que o segundo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-539">Transfers control to a target instruction (short form) if the first value is less than the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-540">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-540">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-541">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-541">Format</span></span>|<span data-ttu-id="de0f3-542">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-542">Assembly Format</span></span>|<span data-ttu-id="de0f3-543">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-543">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-544">32 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-544">32 < `int8` ></span></span>|<span data-ttu-id="de0f3-545">blt.s `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-545">blt.s `target`</span></span>|<span data-ttu-id="de0f3-546">Branch para a instrução de destino no deslocamento especificado se o primeiro valor é menor que o segundo valor, de forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-546">Branch to the target instruction at the specified offset if the first value is less than the second value, short form.</span></span>|  
  
 <span data-ttu-id="de0f3-547">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-547">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-548">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-548">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-549">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-549">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-550">`value2` e `value1` são removidos da pilha; se `value1` é menor que `value2`, a operação de ramificação é executada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-550">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de0f3-551">O `blt.s` instrução transfere o controle para a instrução de destino especificado se `value1` é menor que `value2`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-551">The `blt.s` instruction transfers control to the specified target instruction if `value1` is less than `value2`.</span></span> <span data-ttu-id="de0f3-552">O efeito é idêntico ao executar uma `clt` instruções seguidas por um `brtrue` ramificação para a instrução de destino específico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-552">The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="de0f3-553">A instrução de destino é representada como uma diferença de 1 byte com sinal desde o início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-553">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-554">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-554">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de0f3-555">O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-555">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-556">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `blt.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-556">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.s` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-557">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-557">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-558">Transferirá o controle para uma instrução de destino se o primeiro valor for menor que o segundo valor ao comparar valores de inteiro sem sinal ou valores float não ordenados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-558">Transfers control to a target instruction if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-559">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-559">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-560">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-560">Format</span></span>|<span data-ttu-id="de0f3-561">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-561">Assembly Format</span></span>|<span data-ttu-id="de0f3-562">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-562">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-563">44 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-563">44 < `int32` ></span></span>|<span data-ttu-id="de0f3-564">blt.Un `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-564">blt.un `target`</span></span>|<span data-ttu-id="de0f3-565">Branch para a instrução de destino no deslocamento especificado se o primeiro valor é menor que o segundo valor (valores sem sinal).</span><span class="sxs-lookup"><span data-stu-id="de0f3-565">Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="de0f3-566">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-566">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-567">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-567">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-568">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-568">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-569">`value2` e `value1` são removidos da pilha; se `value1` é menor que `value2`, a operação de ramificação é executada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-569">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de0f3-570">O `blt.un` instrução transfere o controle para a instrução de destino especificado se `value1` é menor que `value2`, quando comparados com o inteiro sem sinal ou valores float não ordenados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-570">The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="de0f3-571">O efeito é idêntico ao executar uma `clt.un` instruções seguidas por um `brtrue` ramificação para a instrução de destino específico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-571">The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="de0f3-572">A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-572">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-573">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-573">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de0f3-574">O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-574">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-575">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `blt.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-575">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-576">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-576">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-577">Transferirá o controle para uma instrução de destino (forma abreviada) se o primeiro valor for menor que o segundo valor ao comparar valores de inteiro sem sinal ou valores float não ordenados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-577">Transfers control to a target instruction (short form) if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-578">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-578">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-579">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-579">Format</span></span>|<span data-ttu-id="de0f3-580">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-580">Assembly Format</span></span>|<span data-ttu-id="de0f3-581">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-581">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-582">37 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-582">37 < `int8` ></span></span>|<span data-ttu-id="de0f3-583">blt.un.s `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-583">blt.un.s `target`</span></span>|<span data-ttu-id="de0f3-584">Branch para a instrução de destino no deslocamento especificado se o primeiro valor é menor que o segundo valor (valores sem sinal), forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-584">Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="de0f3-585">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-585">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-586">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-586">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-587">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-587">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-588">`value2` e `value1` são removidos da pilha; se `value1` é menor que `value2`, a operação de ramificação é executada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-588">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de0f3-589">O `blt.un` instrução transfere o controle para a instrução de destino especificado se `value1` é menor que `value2`, quando comparados com o inteiro sem sinal ou valores float não ordenados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-589">The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="de0f3-590">O efeito é idêntico ao executar uma `clt.un` instruções seguidas por um `brtrue` ramificação para a instrução de destino específico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-590">The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="de0f3-591">A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-591">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-592">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-592">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de0f3-593">O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-593">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-594">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `blt.un.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-594">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-595">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-595">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-596">Transfere o controle para uma instrução de destino quando dois valores de inteiro sem sinal ou valores de float não ordenados não são iguais.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-596">Transfers control to a target instruction when two unsigned integer values or unordered float values are not equal.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-597">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-597">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-598">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-598">Format</span></span>|<span data-ttu-id="de0f3-599">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-599">Assembly Format</span></span>|<span data-ttu-id="de0f3-600">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-600">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-601">40 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-601">40 < `int32` ></span></span>|<span data-ttu-id="de0f3-602">bne.Un `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-602">bne.un `target`</span></span>|<span data-ttu-id="de0f3-603">Branch para o destino de instrução no deslocamento especificado se dois valores inteiros sem sinal são não igual (valores sem sinal).</span><span class="sxs-lookup"><span data-stu-id="de0f3-603">Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values).</span></span>|  
  
 <span data-ttu-id="de0f3-604">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-604">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-605">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-605">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-606">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-606">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-607">`value2` e `value1` são removidos da pilha; se `value1` não é igual a `value2`, a operação de ramificação é executada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-607">`value2` and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de0f3-608">O `bne.un` instrução transfere o controle para a instrução de destino especificado se `value1` não é igual a `value2`, quando comparados com o inteiro sem sinal ou valores float não ordenados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-608">The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="de0f3-609">O efeito é idêntico ao executar uma `ceq` instruções seguidas por um `brfalse` ramificação para a instrução de destino específico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-609">The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="de0f3-610">A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-610">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-611">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-611">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de0f3-612">O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-612">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-613">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bne.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-613">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-614">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-614">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-615">Transfere o controle para uma instrução de destino (forma abreviada) quando dois valores inteiros sem sinal ou valores de float não ordenados não são iguais.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-615">Transfers control to a target instruction (short form) when two unsigned integer values or unordered float values are not equal.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-616">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-616">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-617">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-617">Format</span></span>|<span data-ttu-id="de0f3-618">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-618">Assembly Format</span></span>|<span data-ttu-id="de0f3-619">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-619">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-620">33 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-620">33 < `int8` ></span></span>|<span data-ttu-id="de0f3-621">bne.un.s `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-621">bne.un.s `target`</span></span>|<span data-ttu-id="de0f3-622">Branch para o destino de instrução no deslocamento especificado se dois valores inteiros sem sinal são não igual (valores sem sinal), a forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-622">Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="de0f3-623">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-623">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-624">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-624">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-625">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-625">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-626">`value2` e `value1` são removidos da pilha; se `value1` não é igual a `value2`, a operação de ramificação é executada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-626">`value2` and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de0f3-627">O `bne.un` instrução transfere o controle para a instrução de destino especificado se `value1` não é igual a `value2`, quando comparados com o inteiro sem sinal ou valores float não ordenados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-627">The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="de0f3-628">O efeito é idêntico ao executar uma `ceq` instruções seguidas por um `brfalse` ramificação para a instrução de destino específico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-628">The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="de0f3-629">A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-629">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-630">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-630">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de0f3-631">O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-631">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-632">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bne.un.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-632">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-633">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-633">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-634">Converte um tipo de valor em uma referência de objeto (tipo <see langword="O" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-634">Converts a value type to an object reference (type <see langword="O" />).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-635">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-635">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-636">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-636">Format</span></span>|<span data-ttu-id="de0f3-637">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-637">Assembly Format</span></span>|<span data-ttu-id="de0f3-638">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-638">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-639">8C < `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-639">8C < `T` ></span></span>|<span data-ttu-id="de0f3-640">caixa `valTypeToken`</span><span class="sxs-lookup"><span data-stu-id="de0f3-640">box `valTypeToken`</span></span>|<span data-ttu-id="de0f3-641">Converter um tipo de valor (do tipo especificado em `valTypeToken`) para uma referência ao objeto true.</span><span class="sxs-lookup"><span data-stu-id="de0f3-641">Convert a value type (of the type specified in `valTypeToken`) to a true object reference.</span></span>|  
  
 <span data-ttu-id="de0f3-642">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-642">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-643">Um tipo de valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-643">A value type is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-644">O tipo de valor é aparecido da pilha; o `box` operação é executada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-644">The value type is popped from the stack; the `box` operation is performed.</span></span>  
  
3.  <span data-ttu-id="de0f3-645">Uma referência de objeto para o tipo de valor "demarcado" resultante é enviada para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-645">An object reference to the resulting "boxed" value type is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-646">Um tipo de valor tem duas representações separadas dentro do Common Language Infrastructure (CLI):</span><span class="sxs-lookup"><span data-stu-id="de0f3-646">A value type has two separate representations within the Common Language Infrastructure (CLI):</span></span>  
  
-   <span data-ttu-id="de0f3-647">Formulário 'raw' usado quando um tipo de valor é inserido em outro objeto ou na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-647">A 'raw' form used when a value type is embedded within another object or on the stack.</span></span>  
  
-   <span data-ttu-id="de0f3-648">Um formulário 'boxed', onde os dados no tipo de valor são empacotados (convertido) em um objeto para que ele pode existir como uma entidade independente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-648">A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</span></span>  
  
 <span data-ttu-id="de0f3-649">O `box` instrução converte o tipo de valor (não demarcado) 'raw' em uma referência de objeto (tipo `O`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-649">The `box` instruction converts the 'raw' (unboxed) value type into an object reference (type `O`).</span></span> <span data-ttu-id="de0f3-650">Isso é feito criando um novo objeto e copiar os dados do tipo de valor para o objeto recentemente alocado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-650">This is accomplished by creating a new object and copying the data from the value type into the newly allocated object.</span></span> <span data-ttu-id="de0f3-651">`valTypeToken` é um token de metadados que indica o tipo do tipo do valor na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-651">`valTypeToken` is a metadata token indicating the type of the value type on the stack.</span></span>  
  
 <span data-ttu-id="de0f3-652"><xref:System.OutOfMemoryException> será gerada se não houver memória suficiente para atender à solicitação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-652"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="de0f3-653"><xref:System.TypeLoadException> será gerada se a classe não pode ser encontrada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-653"><xref:System.TypeLoadException> is thrown if the class cannot be found.</span></span> <span data-ttu-id="de0f3-654">Normalmente, isso é detectado quando a Microsoft Intermediate Language (MSIL) é convertido em código nativo, em vez de em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-654">This is typically detected when Microsoft Intermediate Language (MSIL) is converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="de0f3-655">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `box` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-655">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `box` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-656">ILGenerator.Emit (OpCode, tipo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-656">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-657">Transfere o controle 	incondicionalmente para uma instrução de destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-657">Unconditionally transfers control to a target instruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-658">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-658">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-659">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-659">Format</span></span>|<span data-ttu-id="de0f3-660">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-660">Assembly Format</span></span>|<span data-ttu-id="de0f3-661">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-661">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-662">38 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-662">38 < `int32` ></span></span>|<span data-ttu-id="de0f3-663">br `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-663">br `target`</span></span>|<span data-ttu-id="de0f3-664">Ramificações para uma instrução de destino no deslocamento especificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-664">Branches to a target instruction at the specified offset.</span></span>|  
  
 <span data-ttu-id="de0f3-665">Não há comportamentos de pilha de avaliação são executados por esta operação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-665">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="de0f3-666">O `br` instrução transfere o controle incondicionalmente para uma instrução de destino.</span><span class="sxs-lookup"><span data-stu-id="de0f3-666">The `br` instruction unconditionally transfers control to a target instruction.</span></span> <span data-ttu-id="de0f3-667">A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-667">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-668">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-668">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de0f3-669">O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-669">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-670">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `br` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-670">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-671">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-671">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-672">Transfere o controle de forma incondicional para uma instrução de destino (forma abreviada).</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-672">Unconditionally transfers control to a target instruction (short form).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-673">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-673">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-674">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-674">Format</span></span>|<span data-ttu-id="de0f3-675">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-675">Assembly Format</span></span>|<span data-ttu-id="de0f3-676">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-676">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-677">2B < `int8` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-677">2B < `int8` ></span></span>|<span data-ttu-id="de0f3-678">br.s `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-678">br.s `target`</span></span>|<span data-ttu-id="de0f3-679">Ramificações para uma instrução de destino no deslocamento especificado, de forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-679">Branches to a target instruction at the specified offset, short form.</span></span>|  
  
 <span data-ttu-id="de0f3-680">Não há comportamentos de pilha de avaliação são executados por esta operação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-680">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="de0f3-681">O `br.s` instrução transfere o controle incondicionalmente para uma instrução de destino.</span><span class="sxs-lookup"><span data-stu-id="de0f3-681">The `br.s` instruction unconditionally transfers control to a target instruction.</span></span> <span data-ttu-id="de0f3-682">A instrução de destino é representada como uma diferença de 1 byte com sinal desde o início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-682">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-683">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-683">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de0f3-684">O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-684">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-685">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `br.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-685">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br.s` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-686">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-686">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-687">Sinaliza a CLI (Common Language Infrastructure) para informar o depurador de que um ponto de interrupção foi ultrapassado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-687">Signals the Common Language Infrastructure (CLI) to inform the debugger that a break point has been tripped.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-688">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-688">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-689">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-689">Format</span></span>|<span data-ttu-id="de0f3-690">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-690">Assembly Format</span></span>|<span data-ttu-id="de0f3-691">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-691">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-692">01</span><span class="sxs-lookup"><span data-stu-id="de0f3-692">01</span></span>|<span data-ttu-id="de0f3-693">break</span><span class="sxs-lookup"><span data-stu-id="de0f3-693">break</span></span>|<span data-ttu-id="de0f3-694">Informe um depurador um ponto de interrupção foi atingido.</span><span class="sxs-lookup"><span data-stu-id="de0f3-694">inform a debugger that a breakpoint has been reached.</span></span>|  
  
 <span data-ttu-id="de0f3-695">Não há comportamentos de pilha de avaliação são executados por esta operação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-695">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="de0f3-696">O `break` instrução é para suporte à depuração.</span><span class="sxs-lookup"><span data-stu-id="de0f3-696">The `break` instruction is for debugging support.</span></span> <span data-ttu-id="de0f3-697">Ele sinaliza a CLI para informar o depurador um ponto de interrupção foi ultrapassado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-697">It signals the CLI to inform the debugger that a break point has been tripped.</span></span> <span data-ttu-id="de0f3-698">Ele tem nenhum outro efeito sobre o estado do interpretador.</span><span class="sxs-lookup"><span data-stu-id="de0f3-698">It has no other effect on the interpreter state.</span></span>  
  
 <span data-ttu-id="de0f3-699">O `break` instrução tem o menor possível tamanho habilitar código de instrução de aplicação de patches com um ponto de interrupção e gerando mínimo perturbação para o código ao redor.</span><span class="sxs-lookup"><span data-stu-id="de0f3-699">The `break` instruction has the smallest possible instruction size enabling code patching with a break point and generating minimal disturbance to the surrounding code.</span></span>  
  
 <span data-ttu-id="de0f3-700">O `break` instrução pode interceptar a um depurador, não faça nada ou gerar uma exceção de segurança.</span><span class="sxs-lookup"><span data-stu-id="de0f3-700">The `break` instruction can trap to a debugger, do nothing, or raise a security exception.</span></span> <span data-ttu-id="de0f3-701">O comportamento exato é definido pela implementação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-701">The exact behavior is implementation-defined.</span></span>  
  
 <span data-ttu-id="de0f3-702">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `break` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-702">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `break` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-703">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-703">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-704">Transferirá o controle para uma instrução de destino se <paramref name="value" /> for <see langword="false" />, uma referência nula (<see langword="Nothing" /> no Visual Basic) ou zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-704">Transfers control to a target instruction if <paramref name="value" /> is <see langword="false" />, a null reference (<see langword="Nothing" /> in Visual Basic), or zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-705">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-705">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-706">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-706">Format</span></span>|<span data-ttu-id="de0f3-707">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-707">Assembly Format</span></span>|<span data-ttu-id="de0f3-708">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-708">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-709">39 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-709">39 < `int32` ></span></span>|<span data-ttu-id="de0f3-710">brfalse `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-710">brfalse `target`</span></span><br /><br /> <span data-ttu-id="de0f3-711">brnull `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-711">brnull `target`</span></span><br /><br /> <span data-ttu-id="de0f3-712">brzero `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-712">brzero `target`</span></span>|<span data-ttu-id="de0f3-713">Ramificações para uma instrução de destino no deslocamento especificada se `false`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-713">Branches to a target instruction at the specified offset if `false`.</span></span>|  
  
 <span data-ttu-id="de0f3-714">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-714">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-715">`value` é enviado para a pilha por uma operação anterior.</span><span class="sxs-lookup"><span data-stu-id="de0f3-715">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="de0f3-716">`value` é aparecido da pilha; Se `value` está `false`, ramificar para `target`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-716">`value` is popped from the stack; if `value` is `false`, branch to `target`.</span></span>  
  
 <span data-ttu-id="de0f3-717">O `brfalse` instrução (e seus aliases `brnull` e `brzero`) transfere o controle para a instrução de destino especificado se `value` (do tipo `int32`, `int64`, referência de objeto `O`gerenciado ponteiro `&`, ponteiro transitório `*`, `native int`) é zero (`false`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-717">The `brfalse` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`).</span></span> <span data-ttu-id="de0f3-718">Se `value` for diferente de zero (`true`) a execução continuará na próxima instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-718">If `value` is non-zero (`true`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="de0f3-719">A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-719">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-720">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-720">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de0f3-721">O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-721">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-722">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `brfalse` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-722">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-723">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-723">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-724">Transferirá o controle para uma instrução de destino se <paramref name="value" /> for <see langword="false" />, uma referência nula ou zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-724">Transfers control to a target instruction if <paramref name="value" /> is <see langword="false" />, a null reference, or zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-725">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-725">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-726">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-726">Format</span></span>|<span data-ttu-id="de0f3-727">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-727">Assembly Format</span></span>|<span data-ttu-id="de0f3-728">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-728">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-729">2C <`int8` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-729">2C <`int8` ></span></span>|<span data-ttu-id="de0f3-730">brfalse.s `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-730">brfalse.s `target`</span></span><br /><br /> <span data-ttu-id="de0f3-731">brnull.s `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-731">brnull.s `target`</span></span><br /><br /> <span data-ttu-id="de0f3-732">brzero.s `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-732">brzero.s `target`</span></span>|<span data-ttu-id="de0f3-733">Ramificações para uma instrução de destino no deslocamento especificada se `false`, forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-733">Branches to a target instruction at the specified offset if `false`, short form.</span></span>|  
  
 <span data-ttu-id="de0f3-734">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-734">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-735">`value` é enviado para a pilha por uma operação anterior.</span><span class="sxs-lookup"><span data-stu-id="de0f3-735">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="de0f3-736">`value` é aparecido da pilha; Se `value` está `false`, ramificar para `target`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-736">`value` is popped from the stack; if `value` is `false`, branch to `target`.</span></span>  
  
 <span data-ttu-id="de0f3-737">O `brfalse.s` instrução (e seus aliases `brnull` e `brzero`) transfere o controle para a instrução de destino especificado se `value` (do tipo `int32`, `int64`, referência de objeto `O`gerenciado ponteiro `&`, ponteiro transitório `*`, `native int`) é zero (`false`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-737">The `brfalse.s` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`).</span></span> <span data-ttu-id="de0f3-738">Se `value` for diferente de zero (`true`) a execução continuará na próxima instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-738">If `value` is non-zero (`true`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="de0f3-739">A instrução de destino é representada como uma diferença de 1 byte com sinal desde o início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-739">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-740">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-740">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de0f3-741">O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-741">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-742">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `brfalse.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-742">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse.s` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-743">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-743">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-744">Transfere o controle para uma instrução de destino se <paramref name="value" /> for <see langword="true" />, não nulo ou diferente de zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-744">Transfers control to a target instruction if <paramref name="value" /> is <see langword="true" />, not null, or non-zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-745">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-745">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-746">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-746">Format</span></span>|<span data-ttu-id="de0f3-747">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-747">Assembly Format</span></span>|<span data-ttu-id="de0f3-748">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-748">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-749">3A < `int32` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-749">3A < `int32` ></span></span>|<span data-ttu-id="de0f3-750">brtrue `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-750">brtrue `target`</span></span><br /><br /> <span data-ttu-id="de0f3-751">brinst `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-751">brinst `target`</span></span>|<span data-ttu-id="de0f3-752">Ramificar para uma instrução de destino no deslocamento especificado, se diferente de zero (`true`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-752">Branch to a target instruction at the specified offset if non-zero (`true`).</span></span>|  
  
 <span data-ttu-id="de0f3-753">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-753">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-754">`value` é enviado para a pilha por uma operação anterior.</span><span class="sxs-lookup"><span data-stu-id="de0f3-754">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="de0f3-755">`value` é aparecido da pilha; Se `value` está `true`, ramificar para `target`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-755">`value` is popped from the stack; if `value` is `true`, branch to `target`.</span></span>  
  
 <span data-ttu-id="de0f3-756">O `brtrue` instrução transfere o controle para a instrução de destino especificado se `value` (tipo `native int`) é diferente de zero (`true`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-756">The `brtrue` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`).</span></span> <span data-ttu-id="de0f3-757">Se `value` é zero (`false`) a execução continuará na próxima instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-757">If `value` is zero (`false`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="de0f3-758">Se `value` é uma referência de objeto (tipo `O`), em seguida, `brinst` (um alias para `brtrue`) transfere o controle se ele representa uma instância de um objeto (por exemplo, se ele não é a referência de objeto nulo; consulte <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span><span class="sxs-lookup"><span data-stu-id="de0f3-758">If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span></span>  
  
 <span data-ttu-id="de0f3-759">A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-759">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-760">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-760">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de0f3-761">O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-761">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-762">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `brtrue` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-762">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-763">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-763">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-764">Transfere o controle para uma instrução de destino (forma abreviada) se <paramref name="value" /> for <see langword="true" />, não nulo ou diferente de zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-764">Transfers control to a target instruction (short form) if <paramref name="value" /> is <see langword="true" />, not null, or non-zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-765">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-765">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-766">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-766">Format</span></span>|<span data-ttu-id="de0f3-767">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-767">Assembly Format</span></span>|<span data-ttu-id="de0f3-768">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-768">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-769">2D < `int8` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-769">2D < `int8` ></span></span>|<span data-ttu-id="de0f3-770">brtrue.s `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-770">brtrue.s `target`</span></span><br /><br /> <span data-ttu-id="de0f3-771">brinst.s `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-771">brinst.s `target`</span></span>|<span data-ttu-id="de0f3-772">Ramificar para uma instrução de destino no deslocamento especificado, se diferente de zero (`true`), forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-772">Branch to a target instruction at the specified offset if non-zero (`true`), short form.</span></span>|  
  
 <span data-ttu-id="de0f3-773">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-773">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-774">`value` é enviado para a pilha por uma operação anterior.</span><span class="sxs-lookup"><span data-stu-id="de0f3-774">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="de0f3-775">`value` é aparecido da pilha; Se `value` está `true`, ramificar para `target`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-775">`value` is popped from the stack; if `value` is `true`, branch to `target`.</span></span>  
  
 <span data-ttu-id="de0f3-776">O `brtrue.s` instrução transfere o controle para a instrução de destino especificado se `value` (tipo `native int`) é diferente de zero (`true`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-776">The `brtrue.s` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`).</span></span> <span data-ttu-id="de0f3-777">Se `value` é zero (`false`) a execução continuará na próxima instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-777">If `value` is zero (`false`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="de0f3-778">Se `value` é uma referência de objeto (tipo `O`), em seguida, `brinst` (um alias para `brtrue`) transfere o controle se ele representa uma instância de um objeto (por exemplo, se ele não é a referência de objeto nulo; consulte <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span><span class="sxs-lookup"><span data-stu-id="de0f3-778">If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span></span>  
  
 <span data-ttu-id="de0f3-779">A instrução de destino é representada como uma diferença de 1 byte com sinal desde o início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-779">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-780">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-780">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de0f3-781">O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-781">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-782">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `brtrue.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-782">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue.s` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-783">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-783">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-784">Chama o método indicado pelo descritor de método passado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-784">Calls the method indicated by the passed method descriptor.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-785">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-785">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-786">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-786">Format</span></span>|<span data-ttu-id="de0f3-787">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-787">Assembly Format</span></span>|<span data-ttu-id="de0f3-788">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-788">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-789">28 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-789">28 < `T` ></span></span>|<span data-ttu-id="de0f3-790">chamada `methodDesc`</span><span class="sxs-lookup"><span data-stu-id="de0f3-790">call `methodDesc`</span></span>|<span data-ttu-id="de0f3-791">Chame o método descrito pelo `methodDesc`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-791">Call the method described by `methodDesc`.</span></span>|  
  
 <span data-ttu-id="de0f3-792">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-792">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-793">Argumentos de método `arg1` por meio de `argN` são colocados na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-793">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-794">Argumentos de método `arg1` por meio de `argN` são removidos da pilha; a chamada de método é executada com estes argumentos e o controle é transferido para o método chamado pelo descritor de método.</span><span class="sxs-lookup"><span data-stu-id="de0f3-794">Method arguments `arg1` through `argN` are popped from the stack; the method call is performed with these arguments and control is transferred to the method referred to by the method descriptor.</span></span> <span data-ttu-id="de0f3-795">Ao concluir, um valor de retorno é gerado pelo método de receptor e enviado ao chamador.</span><span class="sxs-lookup"><span data-stu-id="de0f3-795">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
3.  <span data-ttu-id="de0f3-796">O valor de retorno é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-796">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-797">O `call` instrução chama o método indicado pelo descritor de método passado com a instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-797">The `call` instruction calls the method indicated by the method descriptor passed with the instruction.</span></span> <span data-ttu-id="de0f3-798">O descritor de método é um token de metadados que indica o método de chamada e o número, tipo e ordem dos argumentos que foram colocadas na pilha a serem passados para esse método, bem como a convenção de chamada a ser usado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-798">The method descriptor is a metadata token that indicates the method to call and the number, type, and order of the arguments that have been placed on the stack to be passed to that method as well as the calling convention to be used.</span></span> <span data-ttu-id="de0f3-799">O `call` instrução pode ser imediatamente precedida por um `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) instruções para especificar que o estado atual do método deve ser liberado antes de transferir o controle de prefixo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-799">The `call` instruction can be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix instruction to specify that the current method state should be released before transferring control.</span></span> <span data-ttu-id="de0f3-800">Se a chamada transfere o controle para um método de confiança mais alto que o método de origem, o quadro de pilha não é liberado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-800">If the call transfers control to a method of higher trust than the origin method, the stack frame is not released.</span></span> <span data-ttu-id="de0f3-801">Em vez disso, a execução continua silenciosamente como se o `tail` não tinha sido fornecido.</span><span class="sxs-lookup"><span data-stu-id="de0f3-801">Instead, the execution continues silently as if the `tail` had not been supplied.</span></span> <span data-ttu-id="de0f3-802">O token de metadados contém informações suficientes para determinar se a chamada é para um método estático, um método de instância, um método virtual ou uma função global.</span><span class="sxs-lookup"><span data-stu-id="de0f3-802">The metadata token carries sufficient information to determine whether the call is to a static method, an instance method, a virtual method, or a global function.</span></span> <span data-ttu-id="de0f3-803">Em todos esses casos, o endereço de destino é determinado inteiramente do descritor de método (Compare isso com o <xref:System.Reflection.Emit.OpCodes.Callvirt> instrução para chamar métodos virtuais, em que o endereço de destino também depende do tipo de tempo de execução da instância enviado por push de referência antes do <xref:System.Reflection.Emit.OpCodes.Callvirt>).</span><span class="sxs-lookup"><span data-stu-id="de0f3-803">In all of these cases the destination address is determined entirely from the method descriptor (contrast this with the <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction for calling virtual methods, where the destination address also depends upon the runtime type of the instance reference pushed before the <xref:System.Reflection.Emit.OpCodes.Callvirt>).</span></span>  
  
 <span data-ttu-id="de0f3-804">Os argumentos são colocados na pilha na ordem da esquerda para a direita.</span><span class="sxs-lookup"><span data-stu-id="de0f3-804">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="de0f3-805">Ou seja, o primeiro argumento é computado e colocado na pilha, em seguida, o segundo argumento e o terceiro, até que todos os argumentos necessários são sobre a pilha em ordem decrescente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-805">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="de0f3-806">Há três casos especiais importantes:</span><span class="sxs-lookup"><span data-stu-id="de0f3-806">There are three important special cases:</span></span>  
  
 1. <span data-ttu-id="de0f3-807">Chamadas a uma instância (ou virtual) método deve enviar por push essa referência de instância antes de qualquer um dos argumentos visível pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="de0f3-807">Calls to an instance (or virtual) method must push that instance reference before any of the user-visible arguments.</span></span> <span data-ttu-id="de0f3-808">A referência de instância não deve ser uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-808">The instance reference must not be a null reference.</span></span> <span data-ttu-id="de0f3-809">A assinatura realizada nos metadados não contém uma entrada na lista de parâmetros para o `this` ponteiro; em vez disso, ele usa um bit para indicar se o método requer passando o `this` ponteiro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-809">The signature carried in the metadata does not contain an entry in the parameter list for the `this` pointer; instead, it uses a bit to indicate whether the method requires passing the `this` pointer.</span></span>  
  
 2. <span data-ttu-id="de0f3-810">Ele é válido chamar um método virtual usando `call` (em vez de `callvirt`); isso indica que o método deve ser resolvido usando a classe especificada pelo método em vez de como especificado dinamicamente a partir do objeto que está sendo invocado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-810">It is valid to call a virtual method using `call` (rather than `callvirt`); this indicates that the method is to be resolved using the class specified by method rather than as specified dynamically from the object being invoked.</span></span>  
  
 3. <span data-ttu-id="de0f3-811">Observe que um delegado `Invoke` método pode ser chamado com um a `call` ou `callvirt` instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-811">Note that a delegate's `Invoke` method can be called with either the `call` or `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="de0f3-812"><xref:System.Security.SecurityException> poderá ser gerada se a segurança do sistema não concede o acesso do chamador para o método chamado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-812"><xref:System.Security.SecurityException> may be thrown if system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="de0f3-813">A verificação de segurança pode ocorrer quando as instruções da Microsoft Intermediate Language (MSIL) são convertidas em código nativo em vez de em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-813">The security check may occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="de0f3-814">Ao chamar métodos de System. Object em tipos de valor, considere o uso a `constrained` prefixo com o `callvirt` instrução, em vez de emitir um `call` instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-814">When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction instead of emitting a `call` instruction.</span></span> <span data-ttu-id="de0f3-815">Isso remove a necessidade de emitir IL diferente dependendo se o tipo de valor substitui o método, evitando um problema potencial de controle de versão.</span><span class="sxs-lookup"><span data-stu-id="de0f3-815">This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</span></span> <span data-ttu-id="de0f3-816">Considere o uso de `constrained` prefixo ao invocar métodos de interface em tipos de valor, já que o método de tipo de valor implementando o método de interface pode ser alterado usando um `MethodImpl`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-816">Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="de0f3-817">Esses problemas são descritos mais detalhadamente o <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span><span class="sxs-lookup"><span data-stu-id="de0f3-817">These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span></span>  
  
 <span data-ttu-id="de0f3-818">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas de método podem usar o `call` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-818">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `call` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-819">ILGenerator.Emit (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-819">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="de0f3-820">ILGenerator.EmitCall (código de operação, MethodInfo, Type[])</span><span class="sxs-lookup"><span data-stu-id="de0f3-820">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="de0f3-821">O <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> método é fornecido para `varargs` chamadas.</span><span class="sxs-lookup"><span data-stu-id="de0f3-821">The <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> method is provided for `varargs` calls.</span></span> <span data-ttu-id="de0f3-822">Use o <xref:System.Reflection.Emit.ILGenerator.Emit%2A> método para chamadas normais.</span><span class="sxs-lookup"><span data-stu-id="de0f3-822">Use the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method for normal calls.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-823">Chama o método indicado na pilha de avaliação (como um ponteiro para um ponto de entrada) com argumentos descritos por uma convenção de chamada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-823">Calls the method indicated on the evaluation stack (as a pointer to an entry point) with arguments described by a calling convention.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-824">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-824">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-825">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-825">Format</span></span>|<span data-ttu-id="de0f3-826">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-826">Assembly Format</span></span>|<span data-ttu-id="de0f3-827">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-827">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-828">29 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-828">29 < `T` ></span></span>|<span data-ttu-id="de0f3-829">calli `callSiteDescr`</span><span class="sxs-lookup"><span data-stu-id="de0f3-829">calli `callSiteDescr`</span></span>|<span data-ttu-id="de0f3-830">Chama o método apontado com argumentos descritos pela convenção de chamada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-830">Calls the method pointed to with arguments described by the calling convention.</span></span>|  
  
 <span data-ttu-id="de0f3-831">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-831">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-832">Argumentos de método `arg1` por meio de `argN` são colocados na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-832">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-833">O ponteiro de entrada do método é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-833">The method entry pointer is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-834">Argumentos de método `arg1` por meio de `argN` e o ponteiro de entrada do método são removidos da pilha; a chamada para o método é executada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-834">Method arguments `arg1` through `argN` and the method entry pointer are popped from the stack; the call to the method is performed.</span></span> <span data-ttu-id="de0f3-835">Ao concluir, um valor de retorno é gerado pelo método de receptor e enviado ao chamador.</span><span class="sxs-lookup"><span data-stu-id="de0f3-835">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
4.  <span data-ttu-id="de0f3-836">O valor de retorno é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-836">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-837">O `calli` instrução chama o ponteiro de entrada do método com os argumentos `arg1` por meio de `argN`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-837">The `calli` instruction calls the method entry pointer with the arguments `arg1` through `argN`.</span></span> <span data-ttu-id="de0f3-838">Os tipos desses argumentos são descritos pela convenção de chamada específica (`callSiteDesc`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-838">The types of these arguments are described by the specific calling convention (`callSiteDesc`).</span></span> <span data-ttu-id="de0f3-839">O `calli` instrução pode ser imediatamente precedida por um `tail` prefixo (<xref:System.Reflection.Emit.OpCodes.Tailcall>) para especificar que o estado atual do método deve ser liberado antes de transferir o controle.</span><span class="sxs-lookup"><span data-stu-id="de0f3-839">The `calli` instruction may be immediately preceded by a `tail` prefix (<xref:System.Reflection.Emit.OpCodes.Tailcall>) to specify that the current method state should be released before transferring control.</span></span> <span data-ttu-id="de0f3-840">Se a chamada transfere controle para um método de confiança mais alto que o método de origem o quadro de pilha não será liberado; em vez disso, a execução continuará silenciosamente como se o `tail` não tinha sido fornecido.</span><span class="sxs-lookup"><span data-stu-id="de0f3-840">If the call would transfer control to a method of higher trust than the origin method the stack frame will not be released; instead, the execution will continue silently as if the `tail` had not been supplied.</span></span>  
  
 <span data-ttu-id="de0f3-841">O ponteiro de entrada do método deve para ser um ponteiro específico para código nativo (da máquina de destino) que pode ser chamado de forma legítima com os argumentos descritos pela convenção de chamada (um token de metadados para uma assinatura autônoma).</span><span class="sxs-lookup"><span data-stu-id="de0f3-841">The method entry pointer is assumed to be a specific pointer to native code (of the target machine) that can be legitimately called with the arguments described by the calling convention (a metadata token for a stand-alone signature).</span></span> <span data-ttu-id="de0f3-842">Esse ponteiro pode ser criado usando o <xref:System.Reflection.Emit.OpCodes.Ldftn> ou <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> instruções, ou transferida do código nativo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-842">Such a pointer can be created using the <xref:System.Reflection.Emit.OpCodes.Ldftn> or <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> instructions, or passed in from native code.</span></span>  
  
 <span data-ttu-id="de0f3-843">A convenção de chamada não está marcada dinamicamente, portanto, códigos que usam um `calli` instrução não funcionará corretamente se o destino não usa, na verdade, a convenção de chamada especificada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-843">The calling convention is not checked dynamically, so code that uses a `calli` instruction does not work correctly if the destination does not actually use the specified calling convention.</span></span>  
  
 <span data-ttu-id="de0f3-844">Os argumentos são colocados na pilha na ordem da esquerda para a direita.</span><span class="sxs-lookup"><span data-stu-id="de0f3-844">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="de0f3-845">Ou seja, o primeiro argumento é computado e colocado na pilha, em seguida, o segundo argumento e o terceiro, até que todos os argumentos necessários são sobre a pilha em ordem decrescente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-845">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="de0f3-846">A sequência de código de construção de argumento para um método virtual ou instância deve enviar por push essa referência de instância (que não deve ser uma referência nula) antes de qualquer um dos argumentos visível pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="de0f3-846">The argument-building code sequence for an instance or virtual method must push that instance reference (which must not be a null reference) before any of the user-visible arguments.</span></span>  
  
 <span data-ttu-id="de0f3-847"><xref:System.Security.SecurityException> poderá ser gerada se a segurança do sistema não concede o acesso do chamador para o método chamado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-847"><xref:System.Security.SecurityException> may be thrown if the system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="de0f3-848">A verificação de segurança pode ocorrer quando as instruções da Microsoft Intermediate Language (MSIL) são convertidas em código nativo em vez de em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-848">The security check can occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="de0f3-849">O seguinte <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> métodos podem ser usados para executar um `calli` instrução na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-849">The following <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> methods can be used to perform a `calli` instruction on the stack.</span></span> <span data-ttu-id="de0f3-850">Observe que `calli` deve ser chamado por meio do abaixo de métodos em vez de usar o <xref:System.Reflection.Emit.ILGenerator.Emit%2A> classe para inserir a instrução diretamente na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-850">Note that `calli` should be called through the below methods rather than using the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> class to place the instruction directly on the stack.</span></span>  
  
-   <span data-ttu-id="de0f3-851">ILGenerator.EmitCalli (Opcode, CallingConventions, tipo, digite [], Type[]) para chamadas usando uma convenção de chamada gerenciada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-851">ILGenerator.EmitCalli(Opcode, CallingConventions, Type, Type[], Type[]) for calls using a managed calling convention.</span></span>  
  
-   <span data-ttu-id="de0f3-852">ILGenerator.EmitCalli (Opcode, Type[]) CallingConvention, tipo, para chamadas usando uma convenção de chamada não gerenciada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-852">ILGenerator.EmitCalli(Opcode, CallingConvention, Type, Type[]) for calls using an unmanaged calling convention.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-853">Chama um método de associação tardia em um objeto, enviando o valor retornado por push para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-853">Calls a late-bound method on an object, pushing the return value onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-854">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-854">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-855">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-855">Format</span></span>|<span data-ttu-id="de0f3-856">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-856">Assembly Format</span></span>|<span data-ttu-id="de0f3-857">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-857">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-858">6F < `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-858">6F < `T` ></span></span>|<span data-ttu-id="de0f3-859">callvirt `method`</span><span class="sxs-lookup"><span data-stu-id="de0f3-859">callvirt `method`</span></span>|<span data-ttu-id="de0f3-860">Chama um método específico associado `obj`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-860">Calls a specific method associated with `obj`.</span></span>|  
  
 <span data-ttu-id="de0f3-861">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-861">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-862">Uma referência de objeto `obj` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-862">An object reference `obj` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-863">Argumentos de método `arg1` por meio de `argN` são colocados na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-863">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-864">Argumentos de método `arg1` por meio `argN` e a referência de objeto `obj` são removidos da pilha; a chamada de método é executada com estes argumentos e o controle é transferido para o método no `obj` chamado pelo método token de metadados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-864">Method arguments `arg1` through `argN` and the object reference `obj` are popped from the stack; the method call is performed with these arguments and control is transferred to the method in `obj` referred to by the method metadata token.</span></span> <span data-ttu-id="de0f3-865">Ao concluir, um valor de retorno é gerado pelo método de receptor e enviado ao chamador.</span><span class="sxs-lookup"><span data-stu-id="de0f3-865">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
4.  <span data-ttu-id="de0f3-866">O valor de retorno é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-866">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-867">O `callvirt` instrução chama um método de associação tardia em um objeto.</span><span class="sxs-lookup"><span data-stu-id="de0f3-867">The `callvirt` instruction calls a late-bound method on an object.</span></span> <span data-ttu-id="de0f3-868">Ou seja, o método é escolhido com base no tipo de tempo de execução do `obj` em vez da classe de tempo de compilação visível no ponteiro do método.</span><span class="sxs-lookup"><span data-stu-id="de0f3-868">That is, the method is chosen based on the runtime type of `obj` rather than the compile-time class visible in the method pointer.</span></span> <span data-ttu-id="de0f3-869">`Callvirt` pode ser usado para chamar ambos virtual e métodos de instância.</span><span class="sxs-lookup"><span data-stu-id="de0f3-869">`Callvirt` can be used to call both virtual and instance methods.</span></span> <span data-ttu-id="de0f3-870">O `callvirt` instrução pode ser imediatamente precedida por um `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefixo para especificar que o quadro de pilhas atual deve ser liberado antes de transferir o controle.</span><span class="sxs-lookup"><span data-stu-id="de0f3-870">The `callvirt` instruction may be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix to specify that the current stack frame should be released before transferring control.</span></span> <span data-ttu-id="de0f3-871">Se a chamada transfere o controle para um método de confiança superior do método original, o quadro de pilha não será lançado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-871">If the call would transfer control to a method of higher trust than the original method the stack frame will not be released.</span></span>  
  
 <span data-ttu-id="de0f3-872">O token de metadados do método fornece o nome, a classe e a assinatura do método a ser chamado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-872">The method metadata token provides the name, class and signature of the method to call.</span></span> <span data-ttu-id="de0f3-873">A classe associada `obj` é a classe do qual ele é uma instância.</span><span class="sxs-lookup"><span data-stu-id="de0f3-873">The class associated with `obj` is the class of which it is an instance.</span></span> <span data-ttu-id="de0f3-874">Se a classe define um método não estático que corresponde ao nome do método indicado e assinatura, esse método é chamado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-874">If the class defines a non-static method that matches the indicated method name and signature, this method is called.</span></span> <span data-ttu-id="de0f3-875">Caso contrário, todas as classes na cadeia de classe base dessa classe são verificadas em ordem.</span><span class="sxs-lookup"><span data-stu-id="de0f3-875">Otherwise all classes in the base class chain of this class are checked in order.</span></span> <span data-ttu-id="de0f3-876">É um erro se nenhum método for encontrado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-876">It is an error if no method is found.</span></span>  
  
 <span data-ttu-id="de0f3-877">`Callvirt` retira o objeto e os argumentos associados da pilha de avaliação antes de chamar o método.</span><span class="sxs-lookup"><span data-stu-id="de0f3-877">`Callvirt` pops the object and the associated arguments off the evaluation stack before calling the method.</span></span> <span data-ttu-id="de0f3-878">Se o método tiver um valor de retorno, ela é enviada por push na pilha após a conclusão do método.</span><span class="sxs-lookup"><span data-stu-id="de0f3-878">If the method has a return value, it is pushed on the stack upon method completion.</span></span> <span data-ttu-id="de0f3-879">No lado do receptor, o `obj` parâmetro é acessado como argumento de 0, `arg1` como argumento 1 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="de0f3-879">On the callee side, the `obj` parameter is accessed as argument 0, `arg1` as argument 1, and so on.</span></span>  
  
 <span data-ttu-id="de0f3-880">Os argumentos são colocados na pilha na ordem da esquerda para a direita.</span><span class="sxs-lookup"><span data-stu-id="de0f3-880">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="de0f3-881">Ou seja, o primeiro argumento é computado e colocado na pilha, em seguida, o segundo argumento e o terceiro, até que todos os argumentos necessários são sobre a pilha em ordem decrescente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-881">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="de0f3-882">A referência de instância `obj` (sempre necessário para `callvirt`) devem ser colocadas antes de qualquer um dos argumentos visível pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="de0f3-882">The instance reference `obj` (always required for `callvirt`) must be pushed before any of the user-visible arguments.</span></span> <span data-ttu-id="de0f3-883">A assinatura (incluída no token de metadados) não precisa conter uma entrada na lista de parâmetros para este ponteiro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-883">The signature (carried in the metadata token) need not contain an entry in the parameter list for the this pointer.</span></span>  
  
 <span data-ttu-id="de0f3-884">Observe que um método virtual pode também ser chamado usando o <xref:System.Reflection.Emit.OpCodes.Call> instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-884">Note that a virtual method can also be called using the <xref:System.Reflection.Emit.OpCodes.Call> instruction.</span></span>  
  
 <span data-ttu-id="de0f3-885"><xref:System.MissingMethodException> é lançada se um método não estático com o nome indicado e a assinatura não pôde ser encontrado na classe associada `obj` ou qualquer uma das suas classes base.</span><span class="sxs-lookup"><span data-stu-id="de0f3-885"><xref:System.MissingMethodException> is thrown if a non-static method with the indicated name and signature could not be found in the class associated with `obj` or any of its base classes.</span></span> <span data-ttu-id="de0f3-886">Normalmente, isso é detectado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo, em vez de em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-886">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="de0f3-887"><xref:System.NullReferenceException> será gerada se o obj for null.</span><span class="sxs-lookup"><span data-stu-id="de0f3-887"><xref:System.NullReferenceException> is thrown if obj is null.</span></span>  
  
 <span data-ttu-id="de0f3-888"><xref:System.Security.SecurityException> será gerada se a segurança do sistema não concede o acesso do chamador para o método chamado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-888"><xref:System.Security.SecurityException> is thrown if system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="de0f3-889">A verificação de segurança pode ocorrer quando a CIL é convertida em código nativo em vez de em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-889">The security check may occur when the CIL is converted to native code rather than at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="de0f3-890">Ao chamar métodos de System. Object em tipos de valor, considere usar o `constrained` prefixo com o `callvirt` instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-890">When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction.</span></span> <span data-ttu-id="de0f3-891">Isso remove a necessidade de emitir IL diferente dependendo se o tipo de valor substitui o método, evitando um problema potencial de controle de versão.</span><span class="sxs-lookup"><span data-stu-id="de0f3-891">This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</span></span> <span data-ttu-id="de0f3-892">Considere o uso de `constrained` prefixo ao invocar métodos de interface em tipos de valor, já que o método de tipo de valor implementando o método de interface pode ser alterado usando um `MethodImpl`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-892">Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="de0f3-893">Esses problemas são descritos mais detalhadamente o <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span><span class="sxs-lookup"><span data-stu-id="de0f3-893">These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span></span>  
  
 <span data-ttu-id="de0f3-894">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `callvirt` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-894">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `callvirt` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-895">ILGenerator.Emit (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-895">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="de0f3-896">ILGenerator.EmitCall (código de operação, MethodInfo, Type[])</span><span class="sxs-lookup"><span data-stu-id="de0f3-896">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-897">Tenta converter um objeto passado por referência à classe especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-897">Attempts to cast an object passed by reference to the specified class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-898">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-898">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-899">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-899">Format</span></span>|<span data-ttu-id="de0f3-900">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-900">Assembly Format</span></span>|<span data-ttu-id="de0f3-901">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-901">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-902">74 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-902">74 < `T` ></span></span>|<span data-ttu-id="de0f3-903">castclass `class`</span><span class="sxs-lookup"><span data-stu-id="de0f3-903">castclass `class`</span></span>|<span data-ttu-id="de0f3-904">Converte um objeto em um novo objeto do tipo `class`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-904">Casts an object to a new object of type `class`.</span></span>|  
  
 <span data-ttu-id="de0f3-905">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-905">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-906">Uma referência de objeto é inserida na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-906">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-907">A referência de objeto é Aparecida da pilha; o objeto referenciado é convertido conforme o especificado `class`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-907">The object reference is popped from the stack; the referenced object is cast as the specified `class`.</span></span>  
  
3.  <span data-ttu-id="de0f3-908">Se for bem-sucedido, uma nova referência de objeto é inserida na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-908">If successful, a new object reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-909">O `castclass` instrução tentará converter a referência de objeto (tipo `O`) sobre a pilha de uma classe especificada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-909">The `castclass` instruction attempts to cast the object reference (type `O`) atop the stack to a specified class.</span></span> <span data-ttu-id="de0f3-910">A nova classe é especificada por um token de metadados que indica a classe desejada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-910">The new class is specified by a metadata token indicating the desired class.</span></span> <span data-ttu-id="de0f3-911">Se a classe do objeto no topo da pilha não implementa a nova classe (supondo que a nova classe é uma interface) e não é uma classe derivada da nova classe, uma <xref:System.InvalidCastException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-911">If the class of the object on the top of the stack does not implement the new class (assuming the new class is an interface) and is not a derived class of the new class then an <xref:System.InvalidCastException> is thrown.</span></span> <span data-ttu-id="de0f3-912">Se a referência de objeto é uma referência nula, `castclass` é bem-sucedida e retorna o novo objeto como uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-912">If the object reference is a null reference, `castclass` succeeds and returns the new object as a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-913"><xref:System.InvalidCastException> será gerada se o obj não pode ser convertido para a classe.</span><span class="sxs-lookup"><span data-stu-id="de0f3-913"><xref:System.InvalidCastException> is thrown if obj cannot be cast to class.</span></span>  
  
 <span data-ttu-id="de0f3-914"><xref:System.TypeLoadException> será gerada se a classe não pode ser encontrado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-914"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="de0f3-915">Normalmente, isso é detectado quando uma instrução de Microsoft Intermediate Language (MSIL) é convertida em código nativo em vez de em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-915">This is typically detected when a Microsoft Intermediate Language (MSIL)instruction is converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="de0f3-916">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `castclass` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-916">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `castclass` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-917">ILGenerator.Emit (OpCode, tipo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-917">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-918">Compara dois valores.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-918">Compares two values.</span>
          </span>
          <span data-ttu-id="de0f3-919">Se eles forem iguais, o valor inteiro 1 <see langword="(int32" />) será enviado para a pilha de avaliação; caso contrário, 0 (<see langword="int32" />) será enviado para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-919">If they are equal, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-920">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-920">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-921">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-921">Format</span></span>|<span data-ttu-id="de0f3-922">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-922">Assembly Format</span></span>|<span data-ttu-id="de0f3-923">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-923">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-924">FE 01</span><span class="sxs-lookup"><span data-stu-id="de0f3-924">FE 01</span></span>|<span data-ttu-id="de0f3-925">ceq</span><span class="sxs-lookup"><span data-stu-id="de0f3-925">ceq</span></span>|<span data-ttu-id="de0f3-926">Envia por push 1 se `value1` é igual a `value2`; caso contrário envia por push o 0.</span><span class="sxs-lookup"><span data-stu-id="de0f3-926">Pushes 1 if `value1` equals `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="de0f3-927">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-927">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-928">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-928">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-929">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-929">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-930">`value2` e `value1` são removidos da pilha; `value1` é comparado ao `value2`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-930">`value2` and `value1` are popped from the stack; `value1` is compared to `value2`.</span></span>  
  
4.  <span data-ttu-id="de0f3-931">Se `value1` é igual a `value2`, 1 é enviado para a pilha; caso contrário, 0 será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-931">If `value1` is equal to `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-932">O `ceq` instrução compara `value1` e `value2`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-932">The `ceq` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="de0f3-933">Se `value1` é igual a `value2`, em seguida, 1 (do tipo `int32`) é enviado por push na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-933">If `value1` is equal to `value2`, then 1 (of type `int32`) is pushed on the stack.</span></span> <span data-ttu-id="de0f3-934">Caso contrário, 0 (do tipo `int32`) é enviado por push na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-934">Otherwise 0 (of type `int32`) is pushed on the stack.</span></span>  
  
 <span data-ttu-id="de0f3-935">Para o número de ponto flutuante, `ceq` retornará 0 se os números não são ordenados (um ou ambos são NaN).</span><span class="sxs-lookup"><span data-stu-id="de0f3-935">For floating-point number, `ceq` will return 0 if the numbers are unordered (either or both are NaN).</span></span> <span data-ttu-id="de0f3-936">Os valores de infinitos são iguais entre si.</span><span class="sxs-lookup"><span data-stu-id="de0f3-936">The infinite values are equal to themselves.</span></span>  
  
 <span data-ttu-id="de0f3-937">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ceq` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-937">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ceq` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-938">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-938">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-939">Compara dois valores.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-939">Compares two values.</span>
          </span>
          <span data-ttu-id="de0f3-940">Se o primeiro valor for maior que o segundo, o valor inteiro 1 <see langword="(int32" />) será enviado para a pilha de avaliação; caso contrário, 0 (<see langword="int32" />) será enviada para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-940">If the first value is greater than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-941">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-941">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-942">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-942">Format</span></span>|<span data-ttu-id="de0f3-943">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-943">Assembly Format</span></span>|<span data-ttu-id="de0f3-944">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-944">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-945">FE 02</span><span class="sxs-lookup"><span data-stu-id="de0f3-945">FE 02</span></span>|<span data-ttu-id="de0f3-946">cgt</span><span class="sxs-lookup"><span data-stu-id="de0f3-946">cgt</span></span>|<span data-ttu-id="de0f3-947">Envia por push 1 se `value1` é maior que `value2`; caso contrário envia por push o 0.</span><span class="sxs-lookup"><span data-stu-id="de0f3-947">Pushes 1 if `value1` is greater than `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="de0f3-948">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-948">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-949">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-949">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-950">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-950">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-951">`value2` e `value1` são removidos da pilha; `cgt` testa se `value1` é maior que `value2`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-951">`value2` and `value1` are popped from the stack; `cgt` tests if `value1` is greater than `value2`.</span></span>  
  
4.  <span data-ttu-id="de0f3-952">Se `value1` é maior que `value2`, 1 é enviado para a pilha; caso contrário, 0 será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-952">If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-953">O `cgt` instrução compara `value1` e `value2`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-953">The `cgt` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="de0f3-954">Se `value1` estritamente maior que `value2`, então um `int32` valor 1 é empurrado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-954">If `value1` is strictly greater than `value2`, then an `int32` value of 1 is pushed on the stack.</span></span> <span data-ttu-id="de0f3-955">Caso contrário, um `int32` valor 0 é empurrado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-955">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
-   <span data-ttu-id="de0f3-956">Para números de ponto flutuantes, `cgt` retornará 0 se os números não são ordenados (ou seja, se um ou ambos os argumentos são NaN).</span><span class="sxs-lookup"><span data-stu-id="de0f3-956">For floating-point numbers, `cgt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</span></span>  
  
 <span data-ttu-id="de0f3-957">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `cgt` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-957">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-958">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-958">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-959">Compara dois sem sinal ou não ordenados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-959">Compares two unsigned or unordered values.</span>
          </span>
          <span data-ttu-id="de0f3-960">Se o primeiro valor for maior que o segundo, o valor inteiro 1 <see langword="(int32" />) será enviado para a pilha de avaliação; caso contrário, 0 (<see langword="int32" />) será enviada para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-960">If the first value is greater than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-961">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-961">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-962">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-962">Format</span></span>|<span data-ttu-id="de0f3-963">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-963">Assembly Format</span></span>|<span data-ttu-id="de0f3-964">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-964">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-965">FE 03</span><span class="sxs-lookup"><span data-stu-id="de0f3-965">FE 03</span></span>|<span data-ttu-id="de0f3-966">cgt.Un</span><span class="sxs-lookup"><span data-stu-id="de0f3-966">cgt.un</span></span>|<span data-ttu-id="de0f3-967">Envia por push 1 se `value1` é maior que `value2`; caso contrário envia por push 0 (valores sem sinal).</span><span class="sxs-lookup"><span data-stu-id="de0f3-967">Pushes 1 if `value1` is greater than `value2`; else pushes 0 (unsigned values).</span></span>|  
  
 <span data-ttu-id="de0f3-968">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-968">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-969">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-969">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-970">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-970">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-971">`value2` e `value1` são removidos da pilha; `cgt.un` testa se `value1` é maior que `value2`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-971">`value2` and `value1` are popped from the stack; `cgt.un` tests if `value1` is greater than `value2`.</span></span>  
  
4.  <span data-ttu-id="de0f3-972">Se `value1` é maior que `value2`, 1 é enviado para a pilha; caso contrário, 0 será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-972">If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-973">Uma `int32` valor de 1 é empurrado na pilha se qualquer um dos seguintes for `true` :</span><span class="sxs-lookup"><span data-stu-id="de0f3-973">An `int32` value of 1 is pushed on the stack if any of the following is `true` :</span></span>  
  
 <span data-ttu-id="de0f3-974">Para números de ponto flutuante `value1` não for ordenado em relação a `value2`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-974">For floating-point numbers, `value1` is not ordered with respect to `value2`.</span></span>  
  
 <span data-ttu-id="de0f3-975">Para obter valores de inteiro `value1` estritamente maior que `value2` quando considerados como números sem sinal.</span><span class="sxs-lookup"><span data-stu-id="de0f3-975">For integer values, `value1` is strictly greater than `value2` when considered as unsigned numbers.</span></span>  
  
 <span data-ttu-id="de0f3-976">Caso contrário, um `int32` valor 0 é empurrado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-976">Otherwise an `int32` value of 0 is pushed on the stack.</span></span>  
  
 <span data-ttu-id="de0f3-977">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `cgt.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-977">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt.un` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-978">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-978">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-979">Gera <see cref="T:System.ArithmeticException" /> se o valor não for um número finito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-979">Throws <see cref="T:System.ArithmeticException" /> if value is not a finite number.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-980">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-980">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-981">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-981">Format</span></span>|<span data-ttu-id="de0f3-982">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-982">Assembly Format</span></span>|<span data-ttu-id="de0f3-983">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-983">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-984">C3</span><span class="sxs-lookup"><span data-stu-id="de0f3-984">C3</span></span>|<span data-ttu-id="de0f3-985">ckfinite</span><span class="sxs-lookup"><span data-stu-id="de0f3-985">ckfinite</span></span>|<span data-ttu-id="de0f3-986">lançar <xref:System.ArithmeticException> se o valor não é um número finito.</span><span class="sxs-lookup"><span data-stu-id="de0f3-986">throw <xref:System.ArithmeticException> if value is not a finite number.</span></span>|  
  
 <span data-ttu-id="de0f3-987">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-987">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-988">`value` é enviado para a pilha...</span><span class="sxs-lookup"><span data-stu-id="de0f3-988">`value` is pushed onto the stack..</span></span>  
  
2.  <span data-ttu-id="de0f3-989">`value` é aparecido da pilha e o `ckfinite` instrução é executada nele.</span><span class="sxs-lookup"><span data-stu-id="de0f3-989">`value` is popped from the stack and the `ckfinite` instruction is performed on it.</span></span>  
  
3.  <span data-ttu-id="de0f3-990">`value` é enviado de volta para a pilha se nenhuma exceção for lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-990">`value` is pushed back onto the stack if no exception is thrown.</span></span>  
  
 <span data-ttu-id="de0f3-991">O `ckfinite instruction` lança <xref:System.ArithmeticException> se `value` (um número de ponto flutuante) é um valor de "não é um número" (NaN) ou um `+-` valor infinito.</span><span class="sxs-lookup"><span data-stu-id="de0f3-991">The `ckfinite instruction` throws <xref:System.ArithmeticException> if `value` (a floating-point number) is either a "not a number" value (NaN) or a `+-` infinity value.</span></span> <span data-ttu-id="de0f3-992">`Ckfinite` deixa o valor na pilha, se nenhuma exceção for lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-992">`Ckfinite` leaves the value on the stack if no exception is thrown.</span></span> <span data-ttu-id="de0f3-993">Execução não é especificada se `value` não é um número de ponto flutuante.</span><span class="sxs-lookup"><span data-stu-id="de0f3-993">Execution is unspecified if `value` is not a floating-point number.</span></span>  
  
 <span data-ttu-id="de0f3-994"><xref:System.ArithmeticException> será gerada se `value` não é um número 'normal'.</span><span class="sxs-lookup"><span data-stu-id="de0f3-994"><xref:System.ArithmeticException> is thrown if `value` is not a 'normal' number.</span></span>  
  
 <span data-ttu-id="de0f3-995">Observe que uma exceção especial ou uma classe derivada de <xref:System.ArithmeticException> pode ser mais apropriado, passando o valor incorreto para o manipulador de exceção.</span><span class="sxs-lookup"><span data-stu-id="de0f3-995">Note that a special exception or a derived class of <xref:System.ArithmeticException> may be more appropriate, passing the incorrect value to the exception handler.</span></span>  
  
 <span data-ttu-id="de0f3-996">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ckfinite` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-996">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ckfinite` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-997">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-997">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-998">Compara dois valores.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-998">Compares two values.</span>
          </span>
          <span data-ttu-id="de0f3-999">Se o primeiro valor for menor que o segundo, o valor inteiro 1 (<see langword="(int32" />) será enviado para a pilha de avaliação; caso contrário, 0 (<see langword="int32" />) será enviada para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-999">If the first value is less than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1000">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1000">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1001">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1001">Format</span></span>|<span data-ttu-id="de0f3-1002">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1002">Assembly Format</span></span>|<span data-ttu-id="de0f3-1003">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1003">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1004">FE 04</span><span class="sxs-lookup"><span data-stu-id="de0f3-1004">FE 04</span></span>|<span data-ttu-id="de0f3-1005">clt</span><span class="sxs-lookup"><span data-stu-id="de0f3-1005">clt</span></span>|<span data-ttu-id="de0f3-1006">Envia por push 1 se `value1` é menor que `value2`; caso contrário envia por push o 0.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1006">Pushes 1 if `value1` is less than `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="de0f3-1007">O comportamento de transição de pilha, em ordem sequencial, é: `value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1007">The stack transitional behavior, in sequential order, is: `value1` is pushed onto the stack.</span></span>  
  
1.  <span data-ttu-id="de0f3-1008">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1008">`value2` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1009">`value2` e `value1` são removidos da pilha; `clt` testa se `value1` é menor que `value2`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1009">`value2` and `value1` are popped from the stack; `clt` tests if `value1` is less than `value2`.</span></span>  
  
3.  <span data-ttu-id="de0f3-1010">Se `value1` é menor que `value2`, 1 é enviado para a pilha; caso contrário, 0 será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1010">If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1011">O `clt` instrução compara `value1` e `value2`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1011">The `clt` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="de0f3-1012">Se `value1` é estritamente menor que `value2`, então um `int32` valor 1 é empurrado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1012">If `value1` is strictly less than `value2`, then an `int32` value of 1 is pushed on the stack.</span></span> <span data-ttu-id="de0f3-1013">Caso contrário, um `int32` valor 0 é empurrado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1013">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
-   <span data-ttu-id="de0f3-1014">Para números de ponto flutuantes, `clt` retornará 0 se os números não são ordenados (ou seja, se um ou ambos os argumentos são NaN).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1014">For floating-point numbers, `clt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</span></span>  
  
 <span data-ttu-id="de0f3-1015">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `clt` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1015">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1016">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1016">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1017">Compara os valores sem sinal ou não ordenados <paramref name="value1" /> e <paramref name="value2" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1017">Compares the unsigned or unordered values <paramref name="value1" /> and <paramref name="value2" />.</span>
          </span>
          <span data-ttu-id="de0f3-1018">Se <paramref name="value1" /> for menor que <paramref name="value2" />, o valor de inteiro 1 (<see langword="(int32" />) será enviado para a pilha de avaliação; caso contrário, 0 (<see langword="int32" />) será enviado para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1018">If <paramref name="value1" /> is less than <paramref name="value2" />, then the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1019">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1019">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1020">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1020">Format</span></span>|<span data-ttu-id="de0f3-1021">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1021">Assembly Format</span></span>|<span data-ttu-id="de0f3-1022">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1022">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1023">FE 05</span><span class="sxs-lookup"><span data-stu-id="de0f3-1023">FE 05</span></span>|<span data-ttu-id="de0f3-1024">CLT.Un</span><span class="sxs-lookup"><span data-stu-id="de0f3-1024">clt.un</span></span>|<span data-ttu-id="de0f3-1025">Envia por push 1 se `value1` é menor que `value2`; caso contrário envia por push 0 (valores sem sinal).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1025">Pushes 1 if `value1` is less than `value2`; else pushes 0 (unsigned values).</span></span>|  
  
 <span data-ttu-id="de0f3-1026">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1026">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1027">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1027">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1028">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1028">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-1029">`value2` e `value1` são removidos da pilha; `clt.un` testa se `value1` é menor que `value2`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1029">`value2` and `value1` are popped from the stack; `clt.un` tests if `value1` is less than `value2`.</span></span>  
  
4.  <span data-ttu-id="de0f3-1030">Se `value1` é menor que `value2`, 1 é enviado para a pilha; caso contrário, 0 será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1030">If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1031">O `clt.un` instrução compara `value1` e `value2`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1031">The `clt.un` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="de0f3-1032">Um `int32` valor 1 é empurrado na pilha se qualquer um dos seguintes for verdadeiro:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1032">An `int32` value of 1 is pushed on the stack if any of the following is true:</span></span>  
  
-   <span data-ttu-id="de0f3-1033">`value1` é estritamente menor que `value2` (como para `clt`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1033">`value1` is strictly less than `value2` (as for `clt`).</span></span>  
  
-   <span data-ttu-id="de0f3-1034">Para números de ponto flutuante `value1` não for ordenado em relação a `value2`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1034">For floating-point numbers, `value1` is not ordered with respect to `value2`.</span></span>  
  
-   <span data-ttu-id="de0f3-1035">Para obter valores de inteiro `value1` é estritamente menor que `value2` quando considerados como números sem sinal.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1035">For integer values, `value1` is strictly less than `value2` when considered as unsigned numbers.</span></span>  
  
 <span data-ttu-id="de0f3-1036">Caso contrário, um `int32` valor 0 é empurrado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1036">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1037">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `clt.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1037">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt.un` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1038">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1038">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1039">Restringe o tipo no qual uma chamada de método virtual é feita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1039">Constrains the type on which a virtual method call is made.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1040">A tabela a seguir lista a instrução hexadecimal e formato do assembly Microsoft intermediate language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1040">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1041">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1041">Format</span></span>|<span data-ttu-id="de0f3-1042">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1042">Assembly Format</span></span>|<span data-ttu-id="de0f3-1043">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1043">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1044">FE 16 &LT; `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-1044">FE 16 < `T` ></span></span>|<span data-ttu-id="de0f3-1045">restrito.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1045">constrained.</span></span> `thisType`|<span data-ttu-id="de0f3-1046">Chamada de um método virtual em um tipo restrito para ser do tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1046">Call a virtual method on a type constrained to be type `T`.</span></span>|  
  
 <span data-ttu-id="de0f3-1047">O `constrained` prefixo é permitido somente em um `callvirt` instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1047">The `constrained` prefix is permitted only on a `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="de0f3-1048">O estado da pilha no momento de MSIL deve ser da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1048">The state of the MSIL stack at this point must be as follows:</span></span>  
  
1.  <span data-ttu-id="de0f3-1049">Um ponteiro gerenciado, `ptr`, é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1049">A managed pointer, `ptr`, is pushed onto the stack.</span></span> <span data-ttu-id="de0f3-1050">O tipo de `ptr` deve ser um ponteiro gerenciado (`&`) para `thisType`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1050">The type of `ptr` must be a managed pointer (`&`) to `thisType`.</span></span> <span data-ttu-id="de0f3-1051">Observe que isso é diferente do caso de um sem-prefixo `callvirt` instrução, que espera uma referência de `thisType`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1051">Note that this is different from the case of an unprefixed `callvirt` instruction, which expects a reference of `thisType`.</span></span>  
  
2.  <span data-ttu-id="de0f3-1052">Argumentos de método `arg1` por meio `argN` são enviados por push para a pilha, assim como ocorre com sem um prefixo `callvirt` instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1052">Method arguments `arg1` through `argN` are pushed onto the stack, just as with an unprefixed `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="de0f3-1053">O `constrained` prefixo foi projetado para permitir `callvirt` instruções para ser feitas em um uniforme forma independentemente se `thisType` é um tipo de valor ou um tipo de referência.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1053">The `constrained` prefix is designed to allow `callvirt` instructions to be made in a uniform way independent of whether `thisType` is a value type or a reference type.</span></span>  
  
 <span data-ttu-id="de0f3-1054">Quando um `callvirt` `method` instrução tem como prefixo `constrained` `thisType`, a instrução é executada da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1054">When a `callvirt` `method` instruction has been prefixed by `constrained` `thisType`, the instruction is executed as follows:</span></span>  
  
-   <span data-ttu-id="de0f3-1055">Se `thisType` é um tipo de referência (em vez de um tipo de valor), em seguida, `ptr` for desreferenciado e passado como o ponteiro 'this' para o `callvirt` de `method`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1055">If `thisType` is a reference type (as opposed to a value type) then `ptr` is dereferenced and passed as the 'this' pointer to the `callvirt` of `method`.</span></span>  
  
-   <span data-ttu-id="de0f3-1056">Se `thisType` é um tipo de valor e `thisType` implementa `method` , em seguida, `ptr` é passado não modificado como o ponteiro 'this' para uma `call` `method` instruções para a implementação de `method` por `thisType`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1056">If `thisType` is a value type and `thisType` implements `method` then `ptr` is passed unmodified as the 'this' pointer to a `call` `method` instruction, for the implementation of `method` by `thisType`.</span></span>  
  
-   <span data-ttu-id="de0f3-1057">Se `thisType` é um tipo de valor e `thisType` não implementa `method` , em seguida, `ptr` for desreferenciado, box e passado como o ponteiro 'this' para o `callvirt` `method` instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1057">If `thisType` is a value type and `thisType` does not implement `method` then `ptr` is dereferenced, boxed, and passed as the 'this' pointer to the `callvirt` `method` instruction.</span></span>  
  
 <span data-ttu-id="de0f3-1058">Nesse último caso pode ocorrer somente quando `method` foi definido no <xref:System.Object>, <xref:System.ValueType>, ou <xref:System.Enum> e não é substituído por `thisType`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1058">This last case can occur only when `method` was defined on <xref:System.Object>, <xref:System.ValueType>, or <xref:System.Enum> and not overridden by `thisType`.</span></span> <span data-ttu-id="de0f3-1059">Nesse caso, a conversão boxing faz com que uma cópia do objeto original a ser feita.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1059">In this case, the boxing causes a copy of the original object to be made.</span></span> <span data-ttu-id="de0f3-1060">No entanto, porque nenhum dos métodos de <xref:System.Object>, <xref:System.ValueType>, e <xref:System.Enum> modificam o estado do objeto, esse fato não pode ser detectado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1060">However, because none of the methods of <xref:System.Object>, <xref:System.ValueType>, and <xref:System.Enum> modify the state of the object, this fact cannot be detected.</span></span>  
  
 <span data-ttu-id="de0f3-1061">O `constrained` prefixo dá suporte a geradores IL que criar código genérico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1061">The `constrained` prefix supports IL generators that create generic code.</span></span> <span data-ttu-id="de0f3-1062">Normalmente o `callvirt` instrução não é válida em tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1062">Normally the `callvirt` instruction is not valid on value types.</span></span> <span data-ttu-id="de0f3-1063">Em vez disso, é necessário que os compiladores de IL efetivamente executam a 'this' transformação descrita acima no tempo de compilação, dependendo do tipo de `ptr` e o método que está sendo chamado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1063">Instead it is required that IL compilers effectively perform the 'this' transformation outlined above at compile time, depending on the type of `ptr` and the method being called.</span></span> <span data-ttu-id="de0f3-1064">No entanto, quando `ptr` é um tipo genérico que é desconhecido no tempo de compilação, não é possível fazer essa transformação em tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1064">However, when `ptr` is a generic type that is unknown at compile time, it is not possible to make this transformation at compile time.</span></span>  
  
 <span data-ttu-id="de0f3-1065">O `constrained` opcode permite que os compiladores de IL para fazer uma chamada para uma função virtual em um uniforme forma independentemente se `ptr` é um tipo de valor ou um tipo de referência.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1065">The `constrained` opcode allows IL compilers to make a call to a virtual function in a uniform way independent of whether `ptr` is a value type or a reference type.</span></span> <span data-ttu-id="de0f3-1066">Embora ele destina-se para o caso em que `thisType` é uma variável de tipo genérico, o `constrained` prefixo também funciona para tipos não genéricos e podem reduzir a complexidade de gerar chamadas virtuais em idiomas que ocultam a distinção entre tipos de valor e tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1066">Although it is intended for the case where `thisType` is a generic type variable, the `constrained` prefix also works for nongeneric types and can reduce the complexity of generating virtual calls in languages that hide the distinction between value types and reference types.</span></span>  
  
 <span data-ttu-id="de0f3-1067">Usando o `constrained` prefixo também impede os possíveis problemas de controle de versão com tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1067">Using the `constrained` prefix also avoids potential versioning problems with value types.</span></span> <span data-ttu-id="de0f3-1068">Se o `constrained` prefixo não for usado, deverão ser emitido a IL diferente dependendo se ou não um tipo de valor substitui um método de System. Object.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1068">If the `constrained` prefix is not used, different IL must be emitted depending on whether or not a value type overrides a method of System.Object.</span></span> <span data-ttu-id="de0f3-1069">Por exemplo, se um tipo de valor `V` substitui o método ToString (), uma `call` `V.ToString()` instrução é emitida; caso contrário, uma `box` instrução e uma `callvirt` `Object.ToString()` instrução são emitidos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1069">For example, if a value type `V` overrides the Object.ToString() method, a `call` `V.ToString()` instruction is emitted; if it does not, a `box` instruction and a `callvirt` `Object.ToString()` instruction are emitted.</span></span> <span data-ttu-id="de0f3-1070">Um problema de controle de versão pode surgir no primeiro caso, se a substituição é removida posteriormente e no último caso se uma substituição for adicionada posteriormente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1070">A versioning problem can arise in the former case if the override is later removed, and in the latter case if an override is later added.</span></span>  
  
 <span data-ttu-id="de0f3-1071">O `constrained` prefixo também pode ser usado para invocação dos métodos de interface em tipos de valor, porque o método de tipo de valor implementando o método de interface pode ser alterado usando um `MethodImpl`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1071">The `constrained` prefix can also be used for invocation of interface methods on value types, because the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="de0f3-1072">Se o `constrained` prefixo não é usado, o compilador é forçado a escolher qual o valor dos métodos do tipo para associar ao tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1072">If the `constrained` prefix is not used, the compiler is forced to choose which of the value type's methods to bind to at compile time.</span></span> <span data-ttu-id="de0f3-1073">Usando o `constrained` prefixo permite que o MSIL associar o método que implementa o método de interface em tempo de execução, em vez de em tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1073">Using the `constrained` prefix allows the MSIL to bind to the method that implements the interface method at run time, rather than at compile time.</span></span>  
  
 <span data-ttu-id="de0f3-1074">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `constrained` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1074">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `constrained` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1075">ILGenerator.Emit (OpCode, tipo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1075">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1076">Converte o valor na parte superior da pilha de avaliação em <see langword="native int" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1076">Converts the value on top of the evaluation stack to <see langword="native int" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1077">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1077">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1078">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1078">Format</span></span>|<span data-ttu-id="de0f3-1079">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1079">Assembly Format</span></span>|<span data-ttu-id="de0f3-1080">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1080">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1081">D3</span><span class="sxs-lookup"><span data-stu-id="de0f3-1081">D3</span></span>|<span data-ttu-id="de0f3-1082">Conv.i</span><span class="sxs-lookup"><span data-stu-id="de0f3-1082">conv.i</span></span>|<span data-ttu-id="de0f3-1083">Converter em `native int`, enviar por push `native int` na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1083">Convert to `native int`, pushing `native int` on stack.</span></span>|  
  
 <span data-ttu-id="de0f3-1084">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1084">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1085">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1085">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1086">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1086">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="de0f3-1087">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1087">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1088">O `conv.i` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e deixe que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1088">The `conv.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1089">Valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1089">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="de0f3-1090">Valores de ponto flutuante são convertidos para o `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1090">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="de0f3-1091">A conversão de números de ponto flutuante em valores de inteiro trunca o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1091">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="de0f3-1092">Ao converter de um `float64` para um `float32`, precisão pode ser perdida.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1092">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="de0f3-1093">Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou infinito negativo (se `value` é negativo) será retornado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1093">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="de0f3-1094">Se o estouro ocorre conversão de tipo de inteiro de um para outro, os bits de ordem alta serão truncados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1094">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="de0f3-1095">Se o resultado for menor do que um `int32`, o valor será estendido com sinal para preencher o slot.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1095">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="de0f3-1096">Se ocorrer estouro de conversão de um tipo de ponto flutuante para um inteiro, o valor retornado não é especificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1096">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="de0f3-1097">Nenhuma exceção for gerada nunca ao usar esse campo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1097">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="de0f3-1098">Ver <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> para obter instruções equivalentes que gerará uma exceção quando o tipo de resultado não pode representar o valor do resultado corretamente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1098">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="de0f3-1099">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.i` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1099">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1100">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1100">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1101">Converte o valor na parte superior da pilha de avaliação em <see langword="int8" /> e então estende-o (preenche) para <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1101">Converts the value on top of the evaluation stack to <see langword="int8" />, then extends (pads) it to <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1102">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1102">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1103">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1103">Format</span></span>|<span data-ttu-id="de0f3-1104">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1104">Assembly Format</span></span>|<span data-ttu-id="de0f3-1105">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1105">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1106">67</span><span class="sxs-lookup"><span data-stu-id="de0f3-1106">67</span></span>|<span data-ttu-id="de0f3-1107">Conv.I1</span><span class="sxs-lookup"><span data-stu-id="de0f3-1107">conv.i1</span></span>|<span data-ttu-id="de0f3-1108">Converter em `int8`, enviar por push `int32` na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1108">Convert to `int8`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="de0f3-1109">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1109">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1110">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1110">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1111">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1111">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="de0f3-1112">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1112">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1113">O `conv.i1` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e deixe que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1113">The `conv.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1114">Valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1114">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="de0f3-1115">Valores de ponto flutuante são convertidos para o `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1115">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="de0f3-1116">A conversão de números de ponto flutuante em valores de inteiro trunca o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1116">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="de0f3-1117">Ao converter de um `float64` para um `float32`, precisão pode ser perdida.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1117">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="de0f3-1118">Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou infinito negativo (se `value` é negativo) será retornado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1118">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="de0f3-1119">Se o estouro ocorre conversão de tipo de inteiro de um para outro, os bits de ordem alta serão truncados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1119">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="de0f3-1120">Se o resultado for menor do que um `int32`, o valor será estendido com sinal para preencher o slot.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1120">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="de0f3-1121">Se ocorrer estouro de conversão de um tipo de ponto flutuante para um inteiro, o valor retornado não é especificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1121">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="de0f3-1122">Nenhuma exceção for gerada nunca ao usar esse campo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1122">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="de0f3-1123">Ver <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> para obter instruções equivalentes que gerará uma exceção quando o tipo de resultado não pode representar o valor do resultado corretamente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1123">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="de0f3-1124">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.i1` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1124">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i1` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1125">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1125">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1126">Converte o valor na parte superior da pilha de avaliação em <see langword="int16" /> e então estende-o (preenche) para <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1126">Converts the value on top of the evaluation stack to <see langword="int16" />, then extends (pads) it to <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1127">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1127">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1128">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1128">Format</span></span>|<span data-ttu-id="de0f3-1129">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1129">Assembly Format</span></span>|<span data-ttu-id="de0f3-1130">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1130">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1131">68</span><span class="sxs-lookup"><span data-stu-id="de0f3-1131">68</span></span>|<span data-ttu-id="de0f3-1132">Conv.I2</span><span class="sxs-lookup"><span data-stu-id="de0f3-1132">conv.i2</span></span>|<span data-ttu-id="de0f3-1133">Converter em `int16`, enviar por push `int32` na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1133">Convert to `int16`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="de0f3-1134">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1134">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1135">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1135">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1136">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1136">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="de0f3-1137">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1137">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1138">O `conv.i2` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e deixe que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1138">The `conv.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1139">Valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1139">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="de0f3-1140">Valores de ponto flutuante são convertidos para o `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1140">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="de0f3-1141">A conversão de números de ponto flutuante em valores de inteiro trunca o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1141">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="de0f3-1142">Ao converter de um `float64` para um `float32`, precisão pode ser perdida.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1142">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="de0f3-1143">Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou infinito negativo (se `value` é negativo) será retornado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1143">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="de0f3-1144">Se o estouro ocorre conversão de tipo de inteiro de um para outro, os bits de ordem alta serão truncados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1144">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="de0f3-1145">Se o resultado for menor do que um `int32`, o valor será estendido com sinal para preencher o slot.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1145">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="de0f3-1146">Se ocorrer estouro de conversão de um tipo de ponto flutuante para um inteiro, o valor retornado não é especificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1146">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="de0f3-1147">Nenhuma exceção for gerada nunca ao usar esse campo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1147">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="de0f3-1148">Ver <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> para obter instruções equivalentes que gerará uma exceção quando o tipo de resultado não pode representar o valor do resultado corretamente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1148">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="de0f3-1149">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.i2` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1149">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i2` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1150">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1150">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1151">Converte o valor na parte superior da pilha de avaliação em <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1151">Converts the value on top of the evaluation stack to <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1152">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1152">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1153">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1153">Format</span></span>|<span data-ttu-id="de0f3-1154">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1154">Assembly Format</span></span>|<span data-ttu-id="de0f3-1155">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1155">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1156">69</span><span class="sxs-lookup"><span data-stu-id="de0f3-1156">69</span></span>|<span data-ttu-id="de0f3-1157">Conv.i4</span><span class="sxs-lookup"><span data-stu-id="de0f3-1157">conv.i4</span></span>|<span data-ttu-id="de0f3-1158">Converter em `int32`, enviar por push `int32` na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1158">Convert to `int32`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="de0f3-1159">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1159">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1160">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1160">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1161">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1161">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="de0f3-1162">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1162">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1163">O `conv.i4` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e deixe que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1163">The `conv.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1164">Valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1164">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="de0f3-1165">Valores de ponto flutuante são convertidos para o `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1165">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="de0f3-1166">A conversão de números de ponto flutuante em valores de inteiro trunca o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1166">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="de0f3-1167">Ao converter de um `float64` para um `float32`, precisão pode ser perdida.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1167">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="de0f3-1168">Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou infinito negativo (se `value` é negativo) será retornado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1168">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="de0f3-1169">Se o estouro ocorre conversão de tipo de inteiro de um para outro, os bits de ordem alta serão truncados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1169">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="de0f3-1170">Se o resultado for menor do que um `int32`, o valor será estendido com sinal para preencher o slot.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1170">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="de0f3-1171">Se ocorrer estouro de conversão de um tipo de ponto flutuante para um inteiro, o valor retornado não é especificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1171">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="de0f3-1172">Nenhuma exceção for gerada nunca ao usar esse campo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1172">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="de0f3-1173">Ver <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> para obter instruções equivalentes que gerará uma exceção quando o tipo de resultado não pode representar o valor do resultado corretamente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1173">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="de0f3-1174">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.i4` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1174">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i4` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1175">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1175">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1176">Converte o valor na parte superior da pilha de avaliação em <see langword="int64" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1176">Converts the value on top of the evaluation stack to <see langword="int64" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1177">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1177">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1178">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1178">Format</span></span>|<span data-ttu-id="de0f3-1179">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1179">Assembly Format</span></span>|<span data-ttu-id="de0f3-1180">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1180">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1181">6A</span><span class="sxs-lookup"><span data-stu-id="de0f3-1181">6A</span></span>|<span data-ttu-id="de0f3-1182">Conv.I8</span><span class="sxs-lookup"><span data-stu-id="de0f3-1182">conv.i8</span></span>|<span data-ttu-id="de0f3-1183">Converter em `int64`, enviar por push `int64` na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1183">Convert to `int64`, pushing `int64` on stack.</span></span>|  
  
 <span data-ttu-id="de0f3-1184">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1184">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1185">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1185">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1186">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1186">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="de0f3-1187">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1187">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1188">O `conv.i8` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e deixe que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1188">The `conv.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1189">Valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1189">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="de0f3-1190">Valores de ponto flutuante são convertidos para o `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1190">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="de0f3-1191">A conversão de números de ponto flutuante em valores de inteiro trunca o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1191">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="de0f3-1192">Ao converter de um `float64` para um `float32`, precisão pode ser perdida.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1192">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="de0f3-1193">Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou infinito negativo (se `value` é negativo) será retornado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1193">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="de0f3-1194">Se o estouro ocorre conversão de tipo de inteiro de um para outro, os bits de ordem alta serão truncados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1194">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="de0f3-1195">Se o resultado for menor do que um `int32`, o valor será estendido com sinal para preencher o slot.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1195">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="de0f3-1196">Se ocorrer estouro de conversão de um tipo de ponto flutuante para um inteiro, o valor retornado não é especificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1196">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="de0f3-1197">Nenhuma exceção for gerada nunca ao usar esse campo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1197">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="de0f3-1198">Ver <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> para obter instruções equivalentes que gerará uma exceção quando o tipo de resultado não pode representar o valor do resultado corretamente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1198">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="de0f3-1199">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.i8` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1199">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i8` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1200">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1200">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1201">Converte o valor com sinal no topo da pilha de avaliação em <see langword="native int" /> com sinal, gerando <see cref="T:System.OverflowException" /> no estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1201">Converts the signed value on top of the evaluation stack to signed <see langword="native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1202">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1202">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1203">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1203">Format</span></span>|<span data-ttu-id="de0f3-1204">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1204">Assembly Format</span></span>|<span data-ttu-id="de0f3-1205">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1205">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1206">D4</span><span class="sxs-lookup"><span data-stu-id="de0f3-1206">D4</span></span>|<span data-ttu-id="de0f3-1207">conv.ovf.i</span><span class="sxs-lookup"><span data-stu-id="de0f3-1207">conv.ovf.i</span></span>|<span data-ttu-id="de0f3-1208">Converter em um `native int` (na pilha como `native int`) e lançar uma exceção no estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1208">Convert to a `native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de0f3-1209">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1209">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1210">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1210">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1211">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1211">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de0f3-1212">Se ocorrer estouro, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1212">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de0f3-1213">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1213">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1214">O `conv.ovf.i` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1214">The `conv.ovf.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1215">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1215">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de0f3-1216">Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1216">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de0f3-1217">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1217">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de0f3-1218"><xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1218"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-1219">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1219">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1220">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1220">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1221">Converte o valor sem sinal no topo da pilha de avaliação em <see langword="native int" /> com sinal, gerando <see cref="T:System.OverflowException" /> no estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1221">Converts the unsigned value on top of the evaluation stack to signed <see langword="native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1222">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1222">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1223">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1223">Format</span></span>|<span data-ttu-id="de0f3-1224">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1224">Assembly Format</span></span>|<span data-ttu-id="de0f3-1225">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1225">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1226">8A</span><span class="sxs-lookup"><span data-stu-id="de0f3-1226">8A</span></span>|<span data-ttu-id="de0f3-1227">conv.ovf.i.un</span><span class="sxs-lookup"><span data-stu-id="de0f3-1227">conv.ovf.i.un</span></span>|<span data-ttu-id="de0f3-1228">Converte um valor sem sinal em um `native int` (na pilha como `native int`) e lançar uma exceção no estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1228">Converts an unsigned value to a `native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de0f3-1229">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1229">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1230">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1230">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1231">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1231">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de0f3-1232">Se ocorrer estouro, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1232">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de0f3-1233">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1233">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1234">O `conv.ovf.i.un` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1234">The `conv.ovf.i.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1235">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1235">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de0f3-1236">Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1236">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de0f3-1237">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1237">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de0f3-1238"><xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1238"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-1239">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1239">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i.un` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1240">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1240">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1241">Converte o valor com sinal no topo da pilha de avaliação em <see langword="int8" /> com sinal e estende-o para <see langword="int32" />, gerando <see cref="T:System.OverflowException" /> no estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1241">Converts the signed value on top of the evaluation stack to signed <see langword="int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1242">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1242">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1243">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1243">Format</span></span>|<span data-ttu-id="de0f3-1244">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1244">Assembly Format</span></span>|<span data-ttu-id="de0f3-1245">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1245">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1246">B3</span><span class="sxs-lookup"><span data-stu-id="de0f3-1246">B3</span></span>|<span data-ttu-id="de0f3-1247">conv.ovf.i1</span><span class="sxs-lookup"><span data-stu-id="de0f3-1247">conv.ovf.i1</span></span>|<span data-ttu-id="de0f3-1248">Converter em um `int8` (na pilha como `int32`) e lançar uma exceção no estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1248">Convert to an `int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de0f3-1249">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1249">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1250">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1250">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1251">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1251">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de0f3-1252">Se ocorrer estouro, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1252">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de0f3-1253">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1253">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1254">O `conv.ovf.i1` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1254">The `conv.ovf.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1255">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1255">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de0f3-1256">Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1256">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de0f3-1257">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1257">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de0f3-1258"><xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1258"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-1259">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i1` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1259">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1260">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1260">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1261">Converte o valor sem sinal no topo da pilha de avaliação em <see langword="int8" /> com sinal e estende-o para <see langword="int32" />, gerando <see cref="T:System.OverflowException" /> no estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1261">Converts the unsigned value on top of the evaluation stack to signed <see langword="int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1262">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1262">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1263">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1263">Format</span></span>|<span data-ttu-id="de0f3-1264">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1264">Assembly Format</span></span>|<span data-ttu-id="de0f3-1265">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1265">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1266">82</span><span class="sxs-lookup"><span data-stu-id="de0f3-1266">82</span></span>|<span data-ttu-id="de0f3-1267">conv.ovf.i1.un</span><span class="sxs-lookup"><span data-stu-id="de0f3-1267">conv.ovf.i1.un</span></span>|<span data-ttu-id="de0f3-1268">Converte um valor sem sinal em um `int8` (na pilha como `int32`) e lançar uma exceção no estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1268">Converts an unsigned value to an `int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de0f3-1269">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1269">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1270">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1270">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1271">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1271">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de0f3-1272">Se ocorrer estouro, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1272">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de0f3-1273">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1273">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1274">O `conv.ovf.i1.un` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1274">The `conv.ovf.i1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1275">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1275">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de0f3-1276">Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1276">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de0f3-1277">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1277">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de0f3-1278"><xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1278"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-1279">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i1.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1279">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1.un` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1280">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1280">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1281">Converte o valor com sinal no topo da pilha de avaliação em <see langword="int16" /> com sinal e estendendo-o para <see langword="int32" />, gerando <see cref="T:System.OverflowException" /> no estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1281">Converts the signed value on top of the evaluation stack to signed <see langword="int16" /> and extending it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1282">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1282">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1283">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1283">Format</span></span>|<span data-ttu-id="de0f3-1284">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1284">Assembly Format</span></span>|<span data-ttu-id="de0f3-1285">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1285">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1286">B5</span><span class="sxs-lookup"><span data-stu-id="de0f3-1286">B5</span></span>|<span data-ttu-id="de0f3-1287">conv.ovf.i2</span><span class="sxs-lookup"><span data-stu-id="de0f3-1287">conv.ovf.i2</span></span>|<span data-ttu-id="de0f3-1288">Converter em um `int16` (na pilha como `int32`) e lançar uma exceção no estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1288">Convert to an `int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de0f3-1289">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1289">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1290">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1290">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1291">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1291">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de0f3-1292">Se ocorrer estouro, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1292">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de0f3-1293">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1293">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1294">O `conv.ovf.i2` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1294">The `conv.ovf.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1295">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1295">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de0f3-1296">Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1296">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de0f3-1297">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1297">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de0f3-1298"><xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1298"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-1299">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i2` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1299">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1300">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1300">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1301">Converte o valor sem sinal no topo da pilha de avaliação em <see langword="int16" /> com sinal e estende-o para <see langword="int32" />, gerando <see cref="T:System.OverflowException" /> no estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1301">Converts the unsigned value on top of the evaluation stack to signed <see langword="int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1302">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1302">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1303">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1303">Format</span></span>|<span data-ttu-id="de0f3-1304">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1304">Assembly Format</span></span>|<span data-ttu-id="de0f3-1305">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1305">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1306">83</span><span class="sxs-lookup"><span data-stu-id="de0f3-1306">83</span></span>|<span data-ttu-id="de0f3-1307">conv.ovf.i2.un</span><span class="sxs-lookup"><span data-stu-id="de0f3-1307">conv.ovf.i2.un</span></span>|<span data-ttu-id="de0f3-1308">Converte um valor sem sinal em um `int16` (na pilha como `int32`) e lançar uma exceção no estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1308">Converts an unsigned value to an `int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de0f3-1309">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1309">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1310">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1310">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1311">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1311">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de0f3-1312">Se ocorrer estouro, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1312">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de0f3-1313">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1313">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1314">O `conv.ovf.i2.un` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1314">The `conv.ovf.i2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1315">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1315">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de0f3-1316">Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1316">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de0f3-1317">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1317">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de0f3-1318"><xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1318"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-1319">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i2.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1319">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2.un` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1320">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1320">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1321">Converte o valor com sinal no topo da pilha de avaliação em <see langword="int32" /> com sinal, gerando <see cref="T:System.OverflowException" /> no estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1321">Converts the signed value on top of the evaluation stack to signed <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1322">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1322">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1323">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1323">Format</span></span>|<span data-ttu-id="de0f3-1324">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1324">Assembly Format</span></span>|<span data-ttu-id="de0f3-1325">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1325">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1326">B7</span><span class="sxs-lookup"><span data-stu-id="de0f3-1326">B7</span></span>|<span data-ttu-id="de0f3-1327">conv.ovf.i4</span><span class="sxs-lookup"><span data-stu-id="de0f3-1327">conv.ovf.i4</span></span>|<span data-ttu-id="de0f3-1328">Converter em um `int32` (na pilha como `int32`) e lançar uma exceção no estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1328">Convert to an `int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de0f3-1329">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1329">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1330">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1330">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1331">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1331">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de0f3-1332">Se ocorrer estouro, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1332">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de0f3-1333">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1333">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1334">O `conv.ovf.i4` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1334">The `conv.ovf.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1335">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1335">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de0f3-1336">Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1336">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de0f3-1337">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1337">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de0f3-1338"><xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1338"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-1339">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i4` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1339">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1340">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1340">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1341">Converte o valor sem sinal no topo da pilha de avaliação em <see langword="int32" /> com sinal, gerando <see cref="T:System.OverflowException" /> no estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1341">Converts the unsigned value on top of the evaluation stack to signed <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1342">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1342">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1343">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1343">Format</span></span>|<span data-ttu-id="de0f3-1344">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1344">Assembly Format</span></span>|<span data-ttu-id="de0f3-1345">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1345">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1346">84</span><span class="sxs-lookup"><span data-stu-id="de0f3-1346">84</span></span>|<span data-ttu-id="de0f3-1347">conv.ovf.i4.un</span><span class="sxs-lookup"><span data-stu-id="de0f3-1347">conv.ovf.i4.un</span></span>|<span data-ttu-id="de0f3-1348">Converte um valor sem sinal em um `int32` (na pilha como `int32`) e lançar uma exceção no estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1348">Converts an unsigned value to an `int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de0f3-1349">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1349">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1350">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1350">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1351">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1351">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de0f3-1352">Se ocorrer estouro, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1352">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de0f3-1353">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1353">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1354">O `conv.ovf.i4.un` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1354">The `conv.ovf.i4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1355">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1355">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de0f3-1356">Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1356">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de0f3-1357">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1357">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de0f3-1358"><xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1358"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-1359">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i4.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1359">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4.un` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1360">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1360">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1361">Converte o valor com sinal no topo da pilha de avaliação em <see langword="int64" /> com sinal, gerando <see cref="T:System.OverflowException" /> no estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1361">Converts the signed value on top of the evaluation stack to signed <see langword="int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1362">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1362">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1363">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1363">Format</span></span>|<span data-ttu-id="de0f3-1364">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1364">Assembly Format</span></span>|<span data-ttu-id="de0f3-1365">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1365">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1366">B9</span><span class="sxs-lookup"><span data-stu-id="de0f3-1366">B9</span></span>|<span data-ttu-id="de0f3-1367">conv.ovf.i8</span><span class="sxs-lookup"><span data-stu-id="de0f3-1367">conv.ovf.i8</span></span>|<span data-ttu-id="de0f3-1368">Converter em um `int64` (na pilha como `int64`) e lançar uma exceção no estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1368">Convert to an `int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de0f3-1369">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1369">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1370">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1370">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1371">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1371">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de0f3-1372">Se ocorrer estouro, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1372">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de0f3-1373">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1373">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1374">O `conv.ovf.i8` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1374">The `conv.ovf.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1375">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1375">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de0f3-1376">Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1376">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de0f3-1377">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1377">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de0f3-1378"><xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1378"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-1379">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i8` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1379">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1380">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1380">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1381">Converte o valor sem sinal no topo da pilha de avaliação em <see langword="int64" /> com sinal, gerando <see cref="T:System.OverflowException" /> no estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1381">Converts the unsigned value on top of the evaluation stack to signed <see langword="int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1382">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1382">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1383">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1383">Format</span></span>|<span data-ttu-id="de0f3-1384">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1384">Assembly Format</span></span>|<span data-ttu-id="de0f3-1385">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1385">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1386">85</span><span class="sxs-lookup"><span data-stu-id="de0f3-1386">85</span></span>|<span data-ttu-id="de0f3-1387">conv.ovf.i8.un</span><span class="sxs-lookup"><span data-stu-id="de0f3-1387">conv.ovf.i8.un</span></span>|<span data-ttu-id="de0f3-1388">Converte um valor sem sinal em um `int64` (na pilha como `int64`) e lançar uma exceção no estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1388">Converts an unsigned value to an `int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de0f3-1389">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1389">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1390">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1390">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1391">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1391">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de0f3-1392">Se ocorrer estouro, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1392">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de0f3-1393">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1393">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1394">O `conv.ovf.i8.un` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1394">The `conv.ovf.i8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1395">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1395">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de0f3-1396">Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1396">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de0f3-1397">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1397">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de0f3-1398"><xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1398"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-1399">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i8.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1399">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8.un` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1400">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1400">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1401">Converte o valor com sinal no topo da pilha de avaliação em <see langword="unsigned native int" />, gerando <see cref="T:System.OverflowException" /> no estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1401">Converts the signed value on top of the evaluation stack to <see langword="unsigned native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1402">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1402">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1403">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1403">Format</span></span>|<span data-ttu-id="de0f3-1404">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1404">Assembly Format</span></span>|<span data-ttu-id="de0f3-1405">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1405">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1406">D5</span><span class="sxs-lookup"><span data-stu-id="de0f3-1406">D5</span></span>|<span data-ttu-id="de0f3-1407">conv.ovf.u</span><span class="sxs-lookup"><span data-stu-id="de0f3-1407">conv.ovf.u</span></span>|<span data-ttu-id="de0f3-1408">Converter em um `unsigned native int` (na pilha como `native int`) e lançar uma exceção no estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1408">Convert to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de0f3-1409">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1409">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1410">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1410">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1411">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1411">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de0f3-1412">Se ocorrer estouro, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1412">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de0f3-1413">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1413">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1414">O `conv.ovf.u` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1414">The `conv.ovf.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1415">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1415">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de0f3-1416">Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1416">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de0f3-1417">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1417">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de0f3-1418"><xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1418"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-1419">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.u` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1419">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1420">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1420">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1421">Converte o valor sem sinal no topo da pilha de avaliação em <see langword="unsigned native int" />, gerando <see cref="T:System.OverflowException" /> no estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1421">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1422">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1422">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1423">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1423">Format</span></span>|<span data-ttu-id="de0f3-1424">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1424">Assembly Format</span></span>|<span data-ttu-id="de0f3-1425">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1425">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1426">8B</span><span class="sxs-lookup"><span data-stu-id="de0f3-1426">8B</span></span>|<span data-ttu-id="de0f3-1427">conv.ovf.u.un</span><span class="sxs-lookup"><span data-stu-id="de0f3-1427">conv.ovf.u.un</span></span>|<span data-ttu-id="de0f3-1428">Converte un unsigned valor para um `unsigned native int` (na pilha como `native int`) e lançar uma exceção no estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1428">Converts un unsigned value to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de0f3-1429">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1429">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1430">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1430">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1431">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1431">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de0f3-1432">Se ocorrer estouro, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1432">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de0f3-1433">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1433">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1434">O `conv.ovf.u.un` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1434">The `conv.ovf.u.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1435">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1435">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de0f3-1436">Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1436">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de0f3-1437">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1437">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de0f3-1438"><xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1438"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-1439">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.uvf.u.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1439">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.uvf.u.un` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1440">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1440">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1441">Converte o valor com sinal no topo da pilha de avaliação em <see langword="unsigned int8" /> e estende-o para <see langword="int32" />, gerando <see cref="T:System.OverflowException" /> no estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1441">Converts the signed value on top of the evaluation stack to <see langword="unsigned int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1442">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1442">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1443">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1443">Format</span></span>|<span data-ttu-id="de0f3-1444">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1444">Assembly Format</span></span>|<span data-ttu-id="de0f3-1445">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1445">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1446">B4</span><span class="sxs-lookup"><span data-stu-id="de0f3-1446">B4</span></span>|<span data-ttu-id="de0f3-1447">conv.ovf.u1</span><span class="sxs-lookup"><span data-stu-id="de0f3-1447">conv.ovf.u1</span></span>|<span data-ttu-id="de0f3-1448">Converter em um `unsigned int8` (na pilha como `int32`) e lançar uma exceção no estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1448">Convert to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de0f3-1449">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1449">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1450">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1450">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1451">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1451">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de0f3-1452">Se ocorrer estouro, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1452">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de0f3-1453">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1453">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1454">O `conv.ovf.u1` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1454">The `conv.ovf.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1455">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1455">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de0f3-1456">Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1456">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de0f3-1457">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1457">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de0f3-1458"><xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1458"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-1459">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.u1` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1459">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1460">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1460">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1461">Converte o valor sem sinal no topo da pilha de avaliação em <see langword="unsigned int8" /> e estende-o para <see langword="int32" />, gerando <see cref="T:System.OverflowException" /> no estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1461">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1462">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1462">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1463">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1463">Format</span></span>|<span data-ttu-id="de0f3-1464">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1464">Assembly Format</span></span>|<span data-ttu-id="de0f3-1465">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1465">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1466">86</span><span class="sxs-lookup"><span data-stu-id="de0f3-1466">86</span></span>|<span data-ttu-id="de0f3-1467">conv.ovf.u1.un</span><span class="sxs-lookup"><span data-stu-id="de0f3-1467">conv.ovf.u1.un</span></span>|<span data-ttu-id="de0f3-1468">Converte um valor sem sinal em um `unsigned int8` (na pilha como `int32`) e lançar uma exceção no estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1468">Converts an unsigned value to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de0f3-1469">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1469">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1470">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1470">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1471">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1471">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de0f3-1472">Se ocorrer estouro, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1472">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de0f3-1473">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1473">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1474">O `conv.ovf.u1.un` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1474">The `conv.ovf.u1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1475">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1475">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de0f3-1476">Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1476">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de0f3-1477">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1477">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de0f3-1478"><xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1478"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-1479">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.u1.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1479">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1.un` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1480">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1480">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1481">Converte o valor com sinal no topo da pilha de avaliação em <see langword="unsigned int16" /> e estende-o para <see langword="int32" />, gerando <see cref="T:System.OverflowException" /> no estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1481">Converts the signed value on top of the evaluation stack to <see langword="unsigned int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1482">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1482">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1483">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1483">Format</span></span>|<span data-ttu-id="de0f3-1484">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1484">Assembly Format</span></span>|<span data-ttu-id="de0f3-1485">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1485">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1486">B6</span><span class="sxs-lookup"><span data-stu-id="de0f3-1486">B6</span></span>|<span data-ttu-id="de0f3-1487">conv.ovf.u2</span><span class="sxs-lookup"><span data-stu-id="de0f3-1487">conv.ovf.u2</span></span>|<span data-ttu-id="de0f3-1488">Converter em um `unsigned int16` (na pilha como `int32`) e lançar uma exceção no estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1488">Convert to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de0f3-1489">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1489">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1490">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1490">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1491">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1491">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de0f3-1492">Se ocorrer estouro, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1492">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de0f3-1493">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1493">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1494">O `conv.ovf.u2` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1494">The `conv.ovf.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1495">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1495">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de0f3-1496">Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1496">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de0f3-1497">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1497">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de0f3-1498"><xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1498"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-1499">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.u2` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1499">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1500">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1500">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1501">Converte o valor sem sinal no topo da pilha de avaliação em <see langword="unsigned int16" /> e estende-o para <see langword="int32" />, gerando <see cref="T:System.OverflowException" /> no estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1501">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1502">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1502">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1503">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1503">Format</span></span>|<span data-ttu-id="de0f3-1504">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1504">Assembly Format</span></span>|<span data-ttu-id="de0f3-1505">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1505">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1506">87</span><span class="sxs-lookup"><span data-stu-id="de0f3-1506">87</span></span>|<span data-ttu-id="de0f3-1507">conv.ovf.u2.un</span><span class="sxs-lookup"><span data-stu-id="de0f3-1507">conv.ovf.u2.un</span></span>|<span data-ttu-id="de0f3-1508">Converte um valor sem sinal em um `unsigned int16` (na pilha como `int32`) e lançar uma exceção no estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1508">Converts an unsigned value to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de0f3-1509">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1509">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1510">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1510">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1511">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1511">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de0f3-1512">Se ocorrer estouro, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1512">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de0f3-1513">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1513">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1514">O `conv.ovf.u2.un` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1514">The `conv.ovf.u2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1515">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1515">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de0f3-1516">Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1516">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de0f3-1517">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1517">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de0f3-1518"><xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1518"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-1519">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.u2.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1519">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2.un` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1520">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1520">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1521">Converte o valor com sinal no topo da pilha de avaliação em <see langword="unsigned int32" />, gerando <see cref="T:System.OverflowException" /> no estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1521">Converts the signed value on top of the evaluation stack to <see langword="unsigned int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1522">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1522">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1523">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1523">Format</span></span>|<span data-ttu-id="de0f3-1524">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1524">Assembly Format</span></span>|<span data-ttu-id="de0f3-1525">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1525">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1526">B8</span><span class="sxs-lookup"><span data-stu-id="de0f3-1526">B8</span></span>|<span data-ttu-id="de0f3-1527">conv.ovf.u4</span><span class="sxs-lookup"><span data-stu-id="de0f3-1527">conv.ovf.u4</span></span>|<span data-ttu-id="de0f3-1528">Converter em um `unsigned int32` (na pilha como `int32`) e lançar uma exceção no estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1528">Convert to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de0f3-1529">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1529">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1530">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1530">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1531">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1531">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de0f3-1532">Se ocorrer estouro, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1532">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de0f3-1533">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1533">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1534">O `conv.ovf.u4` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1534">The `conv.ovf.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1535">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1535">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de0f3-1536">Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1536">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de0f3-1537">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1537">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de0f3-1538"><xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1538"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-1539">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.u4` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1539">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1540">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1540">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1541">Converte o valor sem sinal no topo da pilha de avaliação em <see langword="unsigned int32" />, gerando <see cref="T:System.OverflowException" /> no estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1541">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1542">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1542">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1543">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1543">Format</span></span>|<span data-ttu-id="de0f3-1544">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1544">Assembly Format</span></span>|<span data-ttu-id="de0f3-1545">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1545">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1546">88</span><span class="sxs-lookup"><span data-stu-id="de0f3-1546">88</span></span>|<span data-ttu-id="de0f3-1547">conv.ovf.u4.un</span><span class="sxs-lookup"><span data-stu-id="de0f3-1547">conv.ovf.u4.un</span></span>|<span data-ttu-id="de0f3-1548">Converte um valor sem sinal em um `unsigned int32` (na pilha como `int32`) e lançar uma exceção no estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1548">Converts an unsigned value to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de0f3-1549">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1549">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1550">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1550">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1551">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1551">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de0f3-1552">Se ocorrer estouro, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1552">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de0f3-1553">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1553">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1554">O `conv.ovf.u4.un` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1554">The `conv.ovf.u4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1555">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1555">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de0f3-1556">Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1556">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de0f3-1557">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1557">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de0f3-1558"><xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1558"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-1559">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.u4.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1559">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4.un` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1560">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1560">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1561">Converte o valor com sinal no topo da pilha de avaliação em <see langword="unsigned int64" />, gerando <see cref="T:System.OverflowException" /> no estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1561">Converts the signed value on top of the evaluation stack to <see langword="unsigned int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1562">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1562">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1563">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1563">Format</span></span>|<span data-ttu-id="de0f3-1564">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1564">Assembly Format</span></span>|<span data-ttu-id="de0f3-1565">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1565">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1566">BA</span><span class="sxs-lookup"><span data-stu-id="de0f3-1566">BA</span></span>|<span data-ttu-id="de0f3-1567">conv.ovf.u8</span><span class="sxs-lookup"><span data-stu-id="de0f3-1567">conv.ovf.u8</span></span>|<span data-ttu-id="de0f3-1568">Converter em um `unsigned int64` (na pilha como `int64`) e lançar uma exceção no estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1568">Convert to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de0f3-1569">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1569">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1570">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1570">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1571">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1571">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de0f3-1572">Se ocorrer estouro, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1572">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de0f3-1573">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1573">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1574">O `conv.ovf.u8` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1574">The `conv.ovf.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1575">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1575">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de0f3-1576">Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1576">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de0f3-1577">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1577">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de0f3-1578"><xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1578"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-1579">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.u8` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1579">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1580">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1580">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1581">Converte o valor sem sinal no topo da pilha de avaliação em <see langword="unsigned int64" />, gerando <see cref="T:System.OverflowException" /> no estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1581">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1582">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1582">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1583">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1583">Format</span></span>|<span data-ttu-id="de0f3-1584">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1584">Assembly Format</span></span>|<span data-ttu-id="de0f3-1585">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1585">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1586">89</span><span class="sxs-lookup"><span data-stu-id="de0f3-1586">89</span></span>|<span data-ttu-id="de0f3-1587">conv.ovf.u8.un</span><span class="sxs-lookup"><span data-stu-id="de0f3-1587">conv.ovf.u8.un</span></span>|<span data-ttu-id="de0f3-1588">Converte um valor sem sinal em um `unsigned int64` (na pilha como `int64`) e lançar uma exceção no estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1588">Converts an unsigned value to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de0f3-1589">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1589">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1590">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1590">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1591">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1591">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de0f3-1592">Se ocorrer estouro, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1592">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de0f3-1593">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1593">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1594">O `conv.ovf.u8.un` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1594">The `conv.ovf.u8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1595">Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1595">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de0f3-1596">Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1596">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de0f3-1597">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1597">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de0f3-1598"><xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1598"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-1599">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.u8.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1599">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8.un` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1600">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1600">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1601">Converte o valor de inteiro sem sinal na parte superior da pilha de avaliação em <see langword="float32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1601">Converts the unsigned integer value on top of the evaluation stack to <see langword="float32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1602">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1602">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1603">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1603">Format</span></span>|<span data-ttu-id="de0f3-1604">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1604">Assembly Format</span></span>|<span data-ttu-id="de0f3-1605">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1605">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1606">76</span><span class="sxs-lookup"><span data-stu-id="de0f3-1606">76</span></span>|<span data-ttu-id="de0f3-1607">conv.r.un</span><span class="sxs-lookup"><span data-stu-id="de0f3-1607">conv.r.un</span></span>|<span data-ttu-id="de0f3-1608">Converter inteiro sem sinal em ponto flutuante, enviar por push `F` na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1608">Convert unsigned integer to floating-point, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="de0f3-1609">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1609">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1610">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1610">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1611">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1611">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="de0f3-1612">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1612">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1613">O `conv.r.un` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e deixe que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1613">The `conv.r.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1614">Valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1614">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="de0f3-1615">Valores de ponto flutuante são convertidos para o `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1615">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="de0f3-1616">A conversão de números de ponto flutuante em valores de inteiro trunca o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1616">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="de0f3-1617">Ao converter de um `float64` para um `float32`, precisão pode ser perdida.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1617">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="de0f3-1618">Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou infinito negativo (se `value` é negativo) será retornado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1618">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="de0f3-1619">Se o estouro ocorre conversão de tipo de inteiro de um para outro, os bits de ordem alta serão truncados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1619">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="de0f3-1620">Se o resultado for menor do que um `int32`, o valor será estendido com sinal para preencher o slot.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1620">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="de0f3-1621">Se ocorrer estouro de conversão de um tipo de ponto flutuante para um número inteiro de `result` retornado é especificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1621">If overflow occurs converting a floating-point type to an integer the `result` returned is unspecified.</span></span> <span data-ttu-id="de0f3-1622">O `conv.r.un` operação assume um inteiro da pilha, interpretará como não assinado e substitui-lo com um número de ponto flutuante para representar o inteiro: ambos um `float32`, se isso for grande o suficiente para representar o inteiro sem perda de precisão, caso contrário um `float64`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1622">The `conv.r.un` operation takes an integer off the stack, interprets it as unsigned, and replaces it with a floating-point number to represent the integer: either a `float32`, if this is wide enough to represent the integer without loss of precision, or else a `float64`.</span></span>  
  
 <span data-ttu-id="de0f3-1623">Nenhuma exceção for gerada nunca ao usar esse campo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1623">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="de0f3-1624">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.r.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1624">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r.un` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1625">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1625">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1626">Converte o valor na parte superior da pilha de avaliação em <see langword="float32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1626">Converts the value on top of the evaluation stack to <see langword="float32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1627">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1627">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1628">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1628">Format</span></span>|<span data-ttu-id="de0f3-1629">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1629">Assembly Format</span></span>|<span data-ttu-id="de0f3-1630">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1630">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1631">6B</span><span class="sxs-lookup"><span data-stu-id="de0f3-1631">6B</span></span>|<span data-ttu-id="de0f3-1632">Conv.R4</span><span class="sxs-lookup"><span data-stu-id="de0f3-1632">conv.r4</span></span>|<span data-ttu-id="de0f3-1633">Converter em `float32`, enviar por push `F` na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1633">Convert to `float32`, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="de0f3-1634">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1634">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1635">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1635">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1636">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1636">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="de0f3-1637">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1637">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1638">O `conv.r4` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e deixe que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1638">The `conv.r4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1639">Valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1639">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="de0f3-1640">Valores de ponto flutuante são convertidos para o `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1640">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="de0f3-1641">A conversão de números de ponto flutuante em valores de inteiro trunca o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1641">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="de0f3-1642">Ao converter de um `float64` para um `float32`, precisão pode ser perdida.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1642">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="de0f3-1643">Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou infinito negativo (se `value` é negativo) será retornado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1643">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="de0f3-1644">Se o estouro ocorre conversão de tipo de inteiro de um para outro, os bits de ordem alta serão truncados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1644">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="de0f3-1645">Se o resultado for menor do que um `int32`, o valor será estendido com sinal para preencher o slot.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1645">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="de0f3-1646">Se ocorrer estouro de conversão de um tipo de ponto flutuante para um inteiro, o valor retornado não é especificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1646">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="de0f3-1647">Nenhuma exceção for gerada nunca ao usar esse campo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1647">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="de0f3-1648">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.r4` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1648">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r4` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1649">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1649">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1650">Converte o valor na parte superior da pilha de avaliação em <see langword="float64" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1650">Converts the value on top of the evaluation stack to <see langword="float64" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1651">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1651">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1652">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1652">Format</span></span>|<span data-ttu-id="de0f3-1653">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1653">Assembly Format</span></span>|<span data-ttu-id="de0f3-1654">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1654">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1655">6C</span><span class="sxs-lookup"><span data-stu-id="de0f3-1655">6C</span></span>|<span data-ttu-id="de0f3-1656">Conv.R8</span><span class="sxs-lookup"><span data-stu-id="de0f3-1656">conv.r8</span></span>|<span data-ttu-id="de0f3-1657">Converter em `float64`, enviar por push `F` na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1657">Convert to `float64`, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="de0f3-1658">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1658">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1659">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1659">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1660">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1660">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="de0f3-1661">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1661">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1662">O `conv.r8` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e deixe que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1662">The `conv.r8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1663">Valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1663">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="de0f3-1664">Valores de ponto flutuante são convertidos para o `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1664">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="de0f3-1665">A conversão de números de ponto flutuante em valores de inteiro trunca o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1665">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="de0f3-1666">Ao converter de um `float64` para um `float32`, precisão pode ser perdida.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1666">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="de0f3-1667">Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou infinito negativo (se `value` é negativo) será retornado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1667">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="de0f3-1668">Se o estouro ocorre conversão de tipo de inteiro de um para outro, os bits de ordem alta serão truncados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1668">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="de0f3-1669">Se o resultado for menor do que um `int32`, o valor será estendido com sinal para preencher o slot.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1669">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="de0f3-1670">Se ocorrer estouro de conversão de um tipo de ponto flutuante para um inteiro, o valor retornado não é especificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1670">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="de0f3-1671">Nenhuma exceção for gerada nunca ao usar esse campo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1671">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="de0f3-1672">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.r8` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1672">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r8` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1673">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1673">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1674">Converte o valor na parte superior da pilha de avaliação em <see langword="unsigned native int" /> e estende-o para <see langword="native int" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1674">Converts the value on top of the evaluation stack to <see langword="unsigned native int" />, and extends it to <see langword="native int" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1675">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1675">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1676">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1676">Format</span></span>|<span data-ttu-id="de0f3-1677">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1677">Assembly Format</span></span>|<span data-ttu-id="de0f3-1678">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1678">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1679">E0</span><span class="sxs-lookup"><span data-stu-id="de0f3-1679">E0</span></span>|<span data-ttu-id="de0f3-1680">Conv.u</span><span class="sxs-lookup"><span data-stu-id="de0f3-1680">conv.u</span></span>|<span data-ttu-id="de0f3-1681">Converter em `unsigned native int`, enviar por push `native int` na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1681">Convert to `unsigned native int`, pushing `native int` on stack.</span></span>|  
  
 <span data-ttu-id="de0f3-1682">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1682">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1683">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1683">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1684">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1684">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="de0f3-1685">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1685">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1686">O `conv.u` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e deixe que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1686">The `conv.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1687">Valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1687">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="de0f3-1688">Valores de ponto flutuante são convertidos para o `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1688">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="de0f3-1689">A conversão de números de ponto flutuante em valores de inteiro trunca o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1689">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="de0f3-1690">Ao converter de um `float64` para um `float32`, precisão pode ser perdida.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1690">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="de0f3-1691">Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou infinito negativo (se `value` é negativo) será retornado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1691">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="de0f3-1692">Se o estouro ocorre conversão de tipo de inteiro de um para outro, os bits de ordem alta serão truncados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1692">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="de0f3-1693">Se o resultado for menor do que um `int32`, o valor será estendido com sinal para preencher o slot.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1693">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="de0f3-1694">Se ocorrer estouro de conversão de um tipo de ponto flutuante para um inteiro, o valor retornado não é especificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1694">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="de0f3-1695">Nenhuma exceção for gerada nunca ao usar esse campo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1695">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="de0f3-1696">Ver <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> para obter instruções equivalentes que gerará uma exceção quando o tipo de resultado não pode representar o valor do resultado corretamente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1696">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="de0f3-1697">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.u` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1697">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1698">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1698">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1699">Converte o valor na parte superior da pilha de avaliação em <see langword="unsigned int8" /> e estende-o para <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1699">Converts the value on top of the evaluation stack to <see langword="unsigned int8" />, and extends it to <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1700">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1700">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1701">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1701">Format</span></span>|<span data-ttu-id="de0f3-1702">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1702">Assembly Format</span></span>|<span data-ttu-id="de0f3-1703">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1703">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1704">D2</span><span class="sxs-lookup"><span data-stu-id="de0f3-1704">D2</span></span>|<span data-ttu-id="de0f3-1705">Conv.U1</span><span class="sxs-lookup"><span data-stu-id="de0f3-1705">conv.u1</span></span>|<span data-ttu-id="de0f3-1706">Converter em `int8`, enviar por push `int32` na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1706">Convert to `int8`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="de0f3-1707">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1707">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1708">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1708">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1709">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1709">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="de0f3-1710">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1710">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1711">O `conv.u1` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e deixe que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1711">The `conv.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1712">Valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1712">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="de0f3-1713">Valores de ponto flutuante são convertidos para o `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1713">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="de0f3-1714">A conversão de números de ponto flutuante em valores de inteiro trunca o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1714">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="de0f3-1715">Ao converter de um `float64` para um `float32`, precisão pode ser perdida.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1715">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="de0f3-1716">Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou infinito negativo (se `value` é negativo) será retornado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1716">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="de0f3-1717">Se o estouro ocorre conversão de tipo de inteiro de um para outro, os bits de ordem alta serão truncados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1717">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="de0f3-1718">Se o resultado for menor do que um `int32`, o valor será estendido com sinal para preencher o slot.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1718">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="de0f3-1719">Se ocorrer estouro de conversão de um tipo de ponto flutuante para um inteiro, o valor retornado não é especificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1719">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="de0f3-1720">Nenhuma exceção for gerada nunca ao usar esse campo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1720">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="de0f3-1721">Ver <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> para obter instruções equivalentes que gerará uma exceção quando o tipo de resultado não pode representar o valor do resultado corretamente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1721">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="de0f3-1722">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.u1` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1722">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u1` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1723">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1723">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1724">Converte o valor na parte superior da pilha de avaliação em <see langword="unsigned int16" /> e estende-o para <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1724">Converts the value on top of the evaluation stack to <see langword="unsigned int16" />, and extends it to <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1725">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1725">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1726">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1726">Format</span></span>|<span data-ttu-id="de0f3-1727">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1727">Assembly Format</span></span>|<span data-ttu-id="de0f3-1728">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1728">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1729">D1</span><span class="sxs-lookup"><span data-stu-id="de0f3-1729">D1</span></span>|<span data-ttu-id="de0f3-1730">Conv.U2</span><span class="sxs-lookup"><span data-stu-id="de0f3-1730">conv.u2</span></span>|<span data-ttu-id="de0f3-1731">Converter em `int16`, enviar por push `int32` na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1731">Convert to `int16`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="de0f3-1732">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1732">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1733">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1733">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1734">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1734">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="de0f3-1735">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1735">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1736">O `conv.u2` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e deixe que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1736">The `conv.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1737">Valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1737">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="de0f3-1738">Valores de ponto flutuante são convertidos para o `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1738">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="de0f3-1739">A conversão de números de ponto flutuante em valores de inteiro trunca o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1739">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="de0f3-1740">Ao converter de um `float64` para um `float32`, precisão pode ser perdida.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1740">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="de0f3-1741">Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou infinito negativo (se `value` é negativo) será retornado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1741">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="de0f3-1742">Se o estouro ocorre conversão de tipo de inteiro de um para outro, os bits de ordem alta serão truncados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1742">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="de0f3-1743">Se o resultado for menor do que um `int32`, o valor será estendido com sinal para preencher o slot.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1743">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="de0f3-1744">Se ocorrer estouro de conversão de um tipo de ponto flutuante para um inteiro, o valor retornado não é especificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1744">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="de0f3-1745">Nenhuma exceção for gerada nunca ao usar esse campo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1745">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="de0f3-1746">Ver <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> para obter instruções equivalentes que gerará uma exceção quando o tipo de resultado não pode representar o valor do resultado corretamente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1746">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="de0f3-1747">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.u2` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1747">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u2` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1748">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1748">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1749">Converte o valor na parte superior da pilha de avaliação em <see langword="unsigned int32" /> e estende-o para <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1749">Converts the value on top of the evaluation stack to <see langword="unsigned int32" />, and extends it to <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1750">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1750">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1751">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1751">Format</span></span>|<span data-ttu-id="de0f3-1752">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1752">Assembly Format</span></span>|<span data-ttu-id="de0f3-1753">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1753">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1754">6D</span><span class="sxs-lookup"><span data-stu-id="de0f3-1754">6D</span></span>|<span data-ttu-id="de0f3-1755">Conv.U4</span><span class="sxs-lookup"><span data-stu-id="de0f3-1755">conv.u4</span></span>|<span data-ttu-id="de0f3-1756">Converter em `unsigned int32`, enviar por push `int32` na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1756">Convert to `unsigned int32`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="de0f3-1757">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1757">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1758">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1758">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1759">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1759">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="de0f3-1760">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1760">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1761">O `conv.u4` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e deixe que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1761">The `conv.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1762">Valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1762">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="de0f3-1763">Valores de ponto flutuante são convertidos para o `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1763">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="de0f3-1764">A conversão de números de ponto flutuante em valores de inteiro trunca o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1764">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="de0f3-1765">Ao converter de um `float64` para um `float32`, precisão pode ser perdida.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1765">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="de0f3-1766">Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou infinito negativo (se `value` é negativo) será retornado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1766">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="de0f3-1767">Se o estouro ocorre conversão de tipo de inteiro de um para outro, os bits de ordem alta serão truncados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1767">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="de0f3-1768">Se o resultado for menor do que um `int32`, o valor será estendido com sinal para preencher o slot.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1768">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="de0f3-1769">Se ocorrer estouro de conversão de um tipo de ponto flutuante para um inteiro, o valor retornado não é especificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1769">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="de0f3-1770">Nenhuma exceção for gerada nunca ao usar esse campo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1770">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="de0f3-1771">Ver <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> para obter instruções equivalentes que gerará uma exceção quando o tipo de resultado não pode representar o valor do resultado corretamente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1771">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="de0f3-1772">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.u4` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1772">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u4` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1773">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1773">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1774">Converte o valor na parte superior da pilha de avaliação em <see langword="unsigned int64" /> e estende-o para <see langword="int64" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1774">Converts the value on top of the evaluation stack to <see langword="unsigned int64" />, and extends it to <see langword="int64" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1775">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1775">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1776">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1776">Format</span></span>|<span data-ttu-id="de0f3-1777">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1777">Assembly Format</span></span>|<span data-ttu-id="de0f3-1778">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1778">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1779">6E</span><span class="sxs-lookup"><span data-stu-id="de0f3-1779">6E</span></span>|<span data-ttu-id="de0f3-1780">Conv.U8</span><span class="sxs-lookup"><span data-stu-id="de0f3-1780">conv.u8</span></span>|<span data-ttu-id="de0f3-1781">Converter em `int64`, enviar por push `int64` na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1781">Convert to `int64`, pushing `int64` on stack.</span></span>|  
  
 <span data-ttu-id="de0f3-1782">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1782">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1783">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1783">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1784">`value` é aparecido da pilha e a conversão de operação é tentada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1784">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="de0f3-1785">Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1785">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1786">O `conv.u8` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e deixe que convertido valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1786">The `conv.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="de0f3-1787">Valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado também será `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1787">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="de0f3-1788">Valores de ponto flutuante são convertidos para o `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1788">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="de0f3-1789">A conversão de números de ponto flutuante em valores de inteiro trunca o número em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1789">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="de0f3-1790">Ao converter de um `float64` para um `float32`, precisão pode ser perdida.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1790">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="de0f3-1791">Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou infinito negativo (se `value` é negativo) será retornado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1791">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="de0f3-1792">Se o estouro ocorre conversão de tipo de inteiro de um para outro, os bits de ordem alta serão truncados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1792">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="de0f3-1793">Se o resultado for menor do que um `int32`, o valor será estendido com sinal para preencher o slot.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1793">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="de0f3-1794">Se ocorrer estouro de conversão de um tipo de ponto flutuante para um inteiro, o valor retornado não é especificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1794">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="de0f3-1795">Nenhuma exceção for gerada nunca ao usar esse campo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1795">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="de0f3-1796">Ver <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> para obter instruções equivalentes que gerará uma exceção quando o tipo de resultado não pode representar o valor do resultado corretamente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1796">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="de0f3-1797">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.u8` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1797">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u8` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1798">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1798">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1799">Copia bytes de número especificados de um endereço de origem para um endereço de destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1799">Copies a specified number bytes from a source address to a destination address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1800">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1800">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1801">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1801">Format</span></span>|<span data-ttu-id="de0f3-1802">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1802">Assembly Format</span></span>|<span data-ttu-id="de0f3-1803">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1803">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1804">FE 17</span><span class="sxs-lookup"><span data-stu-id="de0f3-1804">FE 17</span></span>|<span data-ttu-id="de0f3-1805">cpblk</span><span class="sxs-lookup"><span data-stu-id="de0f3-1805">cpblk</span></span>|<span data-ttu-id="de0f3-1806">Copie dados do bloco de memória de um para outro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1806">Copy data from one memory block to another.</span></span>|  
  
 <span data-ttu-id="de0f3-1807">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1807">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1808">O endereço de destino é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1808">The destination address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1809">O endereço de origem é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1809">The source address is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-1810">O número de bytes a serem copiados é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1810">The number of bytes to copy is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="de0f3-1811">O número de bytes, o endereço de origem e o endereço de destino é removido da pilha; o número especificado de bytes é copiado do endereço de origem para o endereço de destino.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1811">The number of bytes, the source address, and the destination address are popped from the stack; the specified number of bytes are copied from the source address to the destination address.</span></span>  
  
 <span data-ttu-id="de0f3-1812">O `cpblk` instrução copia um número (tipo `unsigned int32`) de bytes de um endereço de origem (do tipo `*`, `native int`, ou `&`) para um endereço de destino (do tipo `*`, `native int`, ou `&`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1812">The `cpblk` instruction copies a number (type `unsigned int32`) of bytes from a source address (of type `*`, `native int`, or `&`) to a destination address (of type `*`, `native int`, or `&`).</span></span> <span data-ttu-id="de0f3-1813">O comportamento de `cpblk` é especificado, se as áreas de origem e de destino se sobrepõem.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1813">The behavior of `cpblk` is unspecified if the source and destination areas overlap.</span></span>  
  
 <span data-ttu-id="de0f3-1814">`cpblk` pressupõe-se de que a origem e destino resolvido são alinhados com o tamanho natural da máquina.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1814">`cpblk` assumes that both the source and destination addressed are aligned to the natural size of the machine.</span></span> <span data-ttu-id="de0f3-1815">O `cpblk` instrução pode ser imediatamente precedida pelo `unaligned.<prefix>` instrução para indicar que a origem ou o destino é não alinhado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1815">The `cpblk` instruction can be immediately preceded by the `unaligned.<prefix>` instruction to indicate that either the source or the destination is unaligned.</span></span>  
  
 <span data-ttu-id="de0f3-1816">A operação do `cpblk` instrução pode ser alterada por um imediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instrução de prefixo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1816">The operation of the `cpblk` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="de0f3-1817"><xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1817"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de0f3-1818">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `cpblk` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1818">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpblk` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1819">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1819">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1820">Copia o tipo de valor localizado no endereço de um objeto de (tipo <see langword="&amp;" />, <see langword="*" /> ou <see langword="native int" />) para o endereço do objeto de destino (tipo <see langword="&amp;" />, <see langword="*" /> ou <see langword="native int" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1820">Copies the value type located at the address of an object (type <see langword="&amp;" />, <see langword="*" /> or <see langword="native int" />) to the address of the destination object (type <see langword="&amp;" />, <see langword="*" /> or <see langword="native int" />).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1821">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1821">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1822">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1822">Format</span></span>|<span data-ttu-id="de0f3-1823">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1823">Assembly Format</span></span>|<span data-ttu-id="de0f3-1824">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1824">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1825">70 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-1825">70 < `T` ></span></span>|<span data-ttu-id="de0f3-1826">cpobj `classTok`</span><span class="sxs-lookup"><span data-stu-id="de0f3-1826">cpobj `classTok`</span></span>|<span data-ttu-id="de0f3-1827">Copia um valor de tipo de um objeto de origem para um objeto de destino.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1827">Copies a value type from a source object to a destination object.</span></span>|  
  
 <span data-ttu-id="de0f3-1828">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1828">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1829">A referência de objeto de destino é enviada para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1829">The destination object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1830">A referência de objeto de origem é enviada para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1830">The source object reference is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-1831">As duas referências de objeto são removidas da pilha; o tipo de valor no endereço do objeto de origem é copiado para o endereço do objeto de destino.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1831">The two object references are popped from the stack; the value type at the address of the source object is copied to the address of the destination object.</span></span>  
  
 <span data-ttu-id="de0f3-1832">O comportamento de `cpobj` for especificado, se as referências não são ponteiros para as instâncias da classe representada pelo token de classe de objeto de origem e destino `classTok` (um `typeref` ou `typedef`), ou se `classTok` não representa um tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1832">The behavior of `cpobj` is unspecified if the source and destination object references are not pointers to instances of the class represented by the class token `classTok` (a `typeref` or `typedef`), or if `classTok` does not represent a value type.</span></span>  
  
 <span data-ttu-id="de0f3-1833"><xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1833"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de0f3-1834">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `cpobj` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1834">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpobj` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1835">ILGenerator.Emit (OpCode, tipo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1835">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1836">Divide dois valores e efetua o push do resultado como um ponto flutuante (tipo <see langword="F" />) ou quociente (tipo <see langword="int32" />) para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1836">Divides two values and pushes the result as a floating-point (type <see langword="F" />) or quotient (type <see langword="int32" />) onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1837">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1837">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1838">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1838">Format</span></span>|<span data-ttu-id="de0f3-1839">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1839">Assembly Format</span></span>|<span data-ttu-id="de0f3-1840">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1840">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1841">5B</span><span class="sxs-lookup"><span data-stu-id="de0f3-1841">5B</span></span>|<span data-ttu-id="de0f3-1842">div</span><span class="sxs-lookup"><span data-stu-id="de0f3-1842">div</span></span>|<span data-ttu-id="de0f3-1843">Divide dois valores para retornar um quociente ou resultado de ponto flutuante.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1843">Divides two values to return a quotient or floating-point result.</span></span>|  
  
 <span data-ttu-id="de0f3-1844">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1844">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1845">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1845">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1846">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1846">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-1847">`value2` e `value1` são removidos da pilha; `value1` é dividida por `value2`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1847">`value2` and `value1` are popped from the stack; `value1` is divided by `value2`.</span></span>  
  
4.  <span data-ttu-id="de0f3-1848">O resultado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1848">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1849">`result` = `value1` div value2 satisfaz as condições a seguir:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1849">`result` = `value1` div value2 satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="de0f3-1850">&#124;`result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, e:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1850">&#124; `result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, and:</span></span>  
  
 <span data-ttu-id="de0f3-1851">entrada (`result`) = +, se entrar (`value1`) = logon (`value2`), ou-, se entrar (`value1`) ~ = logon (`value2`)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1851">sign(`result`) = +, if sign(`value1`) = sign(`value2`), or -, if sign(`value1`) ~= sign(`value2`)</span></span>  
  
 <span data-ttu-id="de0f3-1852">O `div` instrução calcula o resultado e envia por push na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1852">The `div` instruction computes the result and pushes it on the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1853">Divisão de inteiro trunca em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1853">Integer division truncates towards zero.</span></span>  
  
 <span data-ttu-id="de0f3-1854">A divisão de um número finito por zero produz o valor infinito corretamente assinado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1854">Division of a finite number by zero produces the correctly signed infinite value.</span></span>  
  
 <span data-ttu-id="de0f3-1855">Dividindo o zero por zero ou infinito por infinito produz o valor NaN (não um número).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1855">Dividing zero by zero or infinity by infinity produces the NaN (Not-A-Number) value.</span></span> <span data-ttu-id="de0f3-1856">Qualquer número dividido por infinito produzirá um valor igual a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1856">Any number divided by infinity will produce a zero value.</span></span>  
  
 <span data-ttu-id="de0f3-1857">Operações de integrais geram <xref:System.ArithmeticException> se o resultado não pode ser representado no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1857">Integral operations throw <xref:System.ArithmeticException> if the result cannot be represented in the result type.</span></span> <span data-ttu-id="de0f3-1858">Isso pode acontecer se `value1` é o valor negativo máximo e `value2` é -1.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1858">This can happen if `value1` is the maximum negative value, and `value2` is -1.</span></span>  
  
 <span data-ttu-id="de0f3-1859">Operações de integrais geram <xref:System.DivideByZeroException> se `value2` é zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1859">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="de0f3-1860">Observe que, em plataformas Intel um <xref:System.OverflowException> é gerada quando a computação (minint div -1).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1860">Note that on Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint div -1).</span></span> <span data-ttu-id="de0f3-1861">Operações de ponto flutuante nunca geram uma exceção (que eles produzem NaNs ou infinitos em vez disso).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1861">Floating-point operations never throw an exception (they produce NaNs or infinities instead).</span></span>  
  
 <span data-ttu-id="de0f3-1862">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `div` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1862">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1863">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1863">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1864">Divide dois valores de inteiro sem sinal e envia o resultado (<see langword="int32" />) para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1864">Divides two unsigned integer values and pushes the result (<see langword="int32" />) onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1865">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1865">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1866">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1866">Format</span></span>|<span data-ttu-id="de0f3-1867">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1867">Assembly Format</span></span>|<span data-ttu-id="de0f3-1868">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1868">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1869">5C</span><span class="sxs-lookup"><span data-stu-id="de0f3-1869">5C</span></span>|<span data-ttu-id="de0f3-1870">div.Un</span><span class="sxs-lookup"><span data-stu-id="de0f3-1870">div.un</span></span>|<span data-ttu-id="de0f3-1871">Divide dois valores, não assinados, retornando um quociente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1871">Divides two values, unsigned, returning a quotient.</span></span>|  
  
 <span data-ttu-id="de0f3-1872">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1872">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1873">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1873">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1874">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1874">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-1875">`value2` e `value1` são removidos da pilha; `value1` é dividida por `value2`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1875">`value2` and `value1` are popped from the stack; `value1` is divided by `value2`.</span></span>  
  
4.  <span data-ttu-id="de0f3-1876">O resultado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1876">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1877">O `div.un` instrução calcula `value1` dividido pelo `value2`, ambas executadas como números inteiros sem sinal e envios por push o `result` na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1877">The `div.un` instruction computes `value1` divided by `value2`, both taken as unsigned integers, and pushes the `result` on the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1878">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `div.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1878">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div.un` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1879">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1879">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1880">Copia o valor atual mais alto na pilha de avaliação e, em seguida, envia a cópia para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1880">Copies the current topmost value on the evaluation stack, and then pushes the copy onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1881">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1881">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1882">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1882">Format</span></span>|<span data-ttu-id="de0f3-1883">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1883">Assembly Format</span></span>|<span data-ttu-id="de0f3-1884">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1884">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1885">25</span><span class="sxs-lookup"><span data-stu-id="de0f3-1885">25</span></span>|<span data-ttu-id="de0f3-1886">DUP</span><span class="sxs-lookup"><span data-stu-id="de0f3-1886">dup</span></span>|<span data-ttu-id="de0f3-1887">Duplica o valor no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1887">Duplicates the value on the top of the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-1888">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1888">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1889">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1889">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1890">`value` terá o pop desativado da pilha para eliminação de duplicação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1890">`value` is popped off of the stack for duplication.</span></span>  
  
3.  <span data-ttu-id="de0f3-1891">`value` é enviado de volta para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1891">`value` is pushed back onto the stack.</span></span>  
  
4.  <span data-ttu-id="de0f3-1892">Um valor duplicado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1892">A duplicate value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1893">O `dup` instrução duplica o elemento superior da pilha e deixa de dois valores idênticos sobre ele.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1893">The `dup` instruction duplicates the top element of the stack, and leaves two identical values atop it.</span></span>  
  
 <span data-ttu-id="de0f3-1894">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `dup` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1894">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `dup` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1895">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1895">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1896">Transfere o controle da cláusula <see langword="filter" /> de uma exceção para o manipulador de exceção da CLI (Common Language Infrastructure).</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1896">Transfers control from the <see langword="filter" /> clause of an exception back to the Common Language Infrastructure (CLI) exception handler.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1897">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1897">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1898">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1898">Format</span></span>|<span data-ttu-id="de0f3-1899">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1899">Assembly Format</span></span>|<span data-ttu-id="de0f3-1900">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1900">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1901">FE 11</span><span class="sxs-lookup"><span data-stu-id="de0f3-1901">FE 11</span></span>|<span data-ttu-id="de0f3-1902">Endfilter</span><span class="sxs-lookup"><span data-stu-id="de0f3-1902">endfilter</span></span>|<span data-ttu-id="de0f3-1903">Cláusula de filtro de final de tratamento de exceção SEH.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1903">End filter clause of SEH exception handling.</span></span>|  
  
 <span data-ttu-id="de0f3-1904">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1904">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1905">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1905">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1906">`value` é aparecido da pilha; `endfilter` é executado e o controle é transferido para o manipulador de exceção.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1906">`value` is popped from the stack; `endfilter` is executed and control is transferred to the exception handler.</span></span>  
  
 <span data-ttu-id="de0f3-1907">`Value` (que deve ser do tipo `int32` e é parte de um conjunto específico de valores) é retornado da cláusula de filtro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1907">`Value` (which must be of type `int32` and is one of a specific set of values) is returned from the filter clause.</span></span> <span data-ttu-id="de0f3-1908">Ele deve ser um destes:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1908">It should be one of:</span></span>  
  
-   <span data-ttu-id="de0f3-1909">`exception_continue_search` (`value` = 0) para continuar procurando um manipulador de exceção</span><span class="sxs-lookup"><span data-stu-id="de0f3-1909">`exception_continue_search` (`value` = 0) to continue searching for an exception handler</span></span>  
  
-   <span data-ttu-id="de0f3-1910">`exception_execute_handler` (`value` = 1) para iniciar a segunda fase de tratamento de exceções onde, finalmente, blocos são executados até que o manipulador associado com a cláusula de filtro está localizado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1910">`exception_execute_handler` (`value` = 1) to start the second phase of exception handling where finally blocks are run until the handler associated with this filter clause is located.</span></span> <span data-ttu-id="de0f3-1911">Após a descoberta, o manipulador é executado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1911">Upon discovery, the handler is executed.</span></span>  
  
 <span data-ttu-id="de0f3-1912">Outros valores inteiros produzirá resultados não especificados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1912">Other integer values will produce unspecified results.</span></span>  
  
 <span data-ttu-id="de0f3-1913">O ponto de entrada de um filtro, conforme mostrado na tabela de exceção do método, deve ser a primeira instrução no bloco de código do filtro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1913">The entry point of a filter, as shown in the method's exception table, must be the first instruction in the filter's code block.</span></span> <span data-ttu-id="de0f3-1914">O `endfilter` instrução deve ser a última instrução no bloco de código do filtro (portanto, pode haver apenas um `endfilter` para qualquer bloco único filtro).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1914">The `endfilter` instruction must be the last instruction in the filter's code block (hence there can only be one `endfilter` for any single filter block).</span></span> <span data-ttu-id="de0f3-1915">Depois de executar o `endfilter` instrução de controle logicamente fluxos de volta para o mecanismo de tratamento de exceções de CLI.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1915">After executing the `endfilter` instruction, control logically flows back to the CLI exception handling mechanism.</span></span>  
  
 <span data-ttu-id="de0f3-1916">Controle não pode ser transferido para um bloco de filtro, exceto por meio do mecanismo de exceção.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1916">Control cannot be transferred into a filter block except through the exception mechanism.</span></span> <span data-ttu-id="de0f3-1917">Controle não pode ser transferida de um bloco de filtro, exceto por meio do uso de um `throw` instrução ou executando o último `endfilter` instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1917">Control cannot be transferred out of a filter block except through the use of a `throw` instruction or by executing the final `endfilter` instruction.</span></span> <span data-ttu-id="de0f3-1918">Não é possível inserir uma `try` bloquear dentro de um `filter` bloco.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1918">You cannot embed a `try` block within a `filter` block.</span></span> <span data-ttu-id="de0f3-1919">Se uma exceção for lançada dentro do `filter` bloco, isso será interceptado e um valor de 0 (`exception_continue_search`) será retornado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1919">If an exception is thrown inside the `filter` block, it is intercepted and a value of 0 (`exception_continue_search`) is returned.</span></span>  
  
 <span data-ttu-id="de0f3-1920">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `endfilter` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1920">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfilter` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1921">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1921">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1922">Transfere o controle da cláusula <see langword="fault" /> ou <see langword="finally" /> de um bloco de exceção de volta para o manipulador de exceção da CLI (Common Language Infrastructure).</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1922">Transfers control from the <see langword="fault" /> or <see langword="finally" /> clause of an exception block back to the Common Language Infrastructure (CLI) exception handler.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1923">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1923">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1924">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1924">Format</span></span>|<span data-ttu-id="de0f3-1925">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1925">Assembly Format</span></span>|<span data-ttu-id="de0f3-1926">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1926">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1927">DC</span><span class="sxs-lookup"><span data-stu-id="de0f3-1927">DC</span></span>|<span data-ttu-id="de0f3-1928">Endfinally</span><span class="sxs-lookup"><span data-stu-id="de0f3-1928">endfinally</span></span><br /><br /> <span data-ttu-id="de0f3-1929">endfault</span><span class="sxs-lookup"><span data-stu-id="de0f3-1929">endfault</span></span>|<span data-ttu-id="de0f3-1930">Termina a `finally` ou `fault` cláusula de um bloco de exceção.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1930">Ends the `finally` or `fault` clause of an exception block.</span></span>|  
  
 <span data-ttu-id="de0f3-1931">Não há nenhuma pilha de comportamentos de transição para essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1931">There are no stack transition behaviors for this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-1932">`Endfinally` e `endfault` sinalizar o final do `finally` ou `fault` cláusula, portanto, o desenrolamento de pilha que pode continuar até que o manipulador de exceção é invocado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1932">`Endfinally` and `endfault` signal the end of the `finally` or `fault` clause so that stack unwinding can continue until the exception handler is invoked.</span></span> <span data-ttu-id="de0f3-1933">O `endfinally` ou `endfault` instrução transfere o controle volta para o mecanismo de exceção da CLI.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1933">The `endfinally` or `endfault` instruction transfers control back to the CLI exception mechanism.</span></span> <span data-ttu-id="de0f3-1934">Em seguida, o mecanismo procura o próximo `finally` cláusula na cadeia se o bloco protegido foi encerrado com uma instrução de sair.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1934">The mechanism then searches for the next `finally` clause in the chain if the protected block was exited with a leave instruction.</span></span> <span data-ttu-id="de0f3-1935">Se o bloco protegido foi encerrado com uma exceção, a CLI irá procurar o próximo `finally` ou `fault`, ou insira o manipulador de exceção escolhido durante a primeira passagem de tratamento de exceção.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1935">If the protected block was exited with an exception, the CLI will search for the next `finally` or `fault`, or enter the exception handler chosen during the first pass of exception handling.</span></span>  
  
 <span data-ttu-id="de0f3-1936">Uma `endfinally` instrução pode aparecer apenas lexicalmente dentro um `finally` bloco.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1936">An `endfinally` instruction might only appear lexically within a `finally` block.</span></span> <span data-ttu-id="de0f3-1937">Ao contrário o `endfilter` instrução, não há nenhum requisito de que o bloco terminam com um `endfinally` instrução e pode haver tantos `endfinally` instruções dentro do bloco conforme necessário.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1937">Unlike the `endfilter` instruction, there is no requirement that the block end with an `endfinally` instruction, and there can be as many `endfinally` instructions within the block as required.</span></span> <span data-ttu-id="de0f3-1938">Essas mesmas restrições se aplicam para o `endfault` instrução e o `fault` bloco.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1938">These same restrictions apply to the `endfault` instruction and the `fault` block.</span></span>  
  
 <span data-ttu-id="de0f3-1939">Controle não pode ser transferido em uma `finally` (ou `fault`) bloquear, exceto por meio do mecanismo de exceção.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1939">Control cannot be transferred into a `finally` (or `fault`) block except through the exception mechanism.</span></span> <span data-ttu-id="de0f3-1940">Controle não pode ser transferida de um `finally` (ou `fault`) bloquear, exceto por meio do uso de uma `throw` instruções ou executar o `endfinally` (ou `endfault`) instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1940">Control cannot be transferred out of a `finally` (or `fault`) block except through the use of a `throw` instruction or executing the `endfinally` (or `endfault`) instruction.</span></span> <span data-ttu-id="de0f3-1941">Em particular, você não pode "passar-out" de um `finally` (ou `fault`) bloco ou executar uma <xref:System.Reflection.Emit.OpCodes.Ret> ou <xref:System.Reflection.Emit.OpCodes.Leave> instrução dentro de um `finally` (ou `fault`) bloco.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1941">In particular, you cannot "fall out" of a `finally` (or `fault`) block or to execute a <xref:System.Reflection.Emit.OpCodes.Ret> or <xref:System.Reflection.Emit.OpCodes.Leave> instruction within a `finally` (or `fault`) block.</span></span>  
  
 <span data-ttu-id="de0f3-1942">Observe que o `endfault` e `endfinally` instruções são aliases – eles correspondem ao mesmo código de operação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1942">Note that the `endfault` and `endfinally` instructions are aliases - they correspond to the same opcode.</span></span>  
  
 <span data-ttu-id="de0f3-1943">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `endfinally` (`endfault`) opcode, bem como o `ILGenerator` método <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1943">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfinally` (`endfault`) opcode, as well as the `ILGenerator` method <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.</span></span>  
  
-   <span data-ttu-id="de0f3-1944">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1944">ILGenerator.Emit(OpCode)</span></span>  
  
-   <span data-ttu-id="de0f3-1945">ILGenerator.EndExceptionBlock()</span><span class="sxs-lookup"><span data-stu-id="de0f3-1945">ILGenerator.EndExceptionBlock()</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1946">Inicializa um bloco de memória especificado em um endereço específico e em um tamanho e valor inicial especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1946">Initializes a specified block of memory at a specific address to a given size and initial value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1947">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1947">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1948">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1948">Format</span></span>|<span data-ttu-id="de0f3-1949">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1949">Assembly Format</span></span>|<span data-ttu-id="de0f3-1950">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1950">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1951">FE 18</span><span class="sxs-lookup"><span data-stu-id="de0f3-1951">FE 18</span></span>|<span data-ttu-id="de0f3-1952">initblk</span><span class="sxs-lookup"><span data-stu-id="de0f3-1952">initblk</span></span>|<span data-ttu-id="de0f3-1953">Defina cada local em um bloco de memória para um determinado valor.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1953">Set each location in a block of memory to a given value.</span></span>|  
  
 <span data-ttu-id="de0f3-1954">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1954">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1955">Um endereço inicial é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1955">A starting address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1956">Um valor de inicialização é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1956">An initialization value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-1957">O número de bytes a ser inicializado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1957">The number of bytes to initialize is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="de0f3-1958">O número de bytes, o valor de inicialização e o endereço inicial é removido da pilha e a inicialização é executada, de acordo com seus valores.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1958">The number of bytes, the initialization value, and the starting address are popped from the stack, and the initialization is performed as per their values.</span></span>  
  
 <span data-ttu-id="de0f3-1959">O `initblk` instrução define o número (`unsigned int32`) de bytes, começando no endereço especificado (do tipo `native int`, `&`, ou `*`) para o valor de inicialização (do tipo `unsigned int8`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-1959">The `initblk` instruction sets the number (`unsigned int32`) of bytes starting at the specified address (of type `native int`, `&`, or `*`) to the initialization value (of type `unsigned int8`).</span></span> <span data-ttu-id="de0f3-1960">`initblk` pressupõe-se de que o endereço inicial é alinhado ao tamanho natural da máquina.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1960">`initblk` assumes that the starting address is aligned to the natural size of the machine.</span></span>  
  
 <span data-ttu-id="de0f3-1961">A operação do `initblk` instruções podem ser alteradas por um imediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instrução de prefixo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1961">The operation of the `initblk` instructions can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="de0f3-1962"><xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1962"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de0f3-1963">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `initblk` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1963">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initblk` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1964">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1964">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1965">Inicializa cada campo do tipo de valor em um endereço especificado como uma referência nula ou 0 do tipo primitivo apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1965">Initializes each field of the value type at a specified address to a null reference or a 0 of the appropriate primitive type.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1966">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1966">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1967">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1967">Format</span></span>|<span data-ttu-id="de0f3-1968">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1968">Assembly Format</span></span>|<span data-ttu-id="de0f3-1969">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1969">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1970">FE 15 &LT; `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-1970">FE 15 < `T` ></span></span>|<span data-ttu-id="de0f3-1971">`initobj` `typeTok`</span><span class="sxs-lookup"><span data-stu-id="de0f3-1971">`initobj` `typeTok`</span></span>|<span data-ttu-id="de0f3-1972">Inicializa um tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1972">Initializes a value type.</span></span>|  
  
 <span data-ttu-id="de0f3-1973">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1973">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1974">O endereço do tipo de valor para inicializar é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1974">The address of the value type to initialize is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1975">O endereço é aparecido da pilha; o tipo de valor no endereço especificado é inicializado como tipo `typeTok`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1975">The address is popped from the stack; the value type at the specified address is initialized as type `typeTok`.</span></span>  
  
 <span data-ttu-id="de0f3-1976">O `initobj` instrução inicializa cada campo do tipo de valor especificado pelo endereço enviadas por push (do tipo `native int`, `&`, ou `*`) para uma referência nula ou 0 do tipo primitivo apropriado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1976">The `initobj` instruction initializes each field of the value type specified by the pushed address (of type `native int`, `&`, or `*`) to a null reference or a 0 of the appropriate primitive type.</span></span> <span data-ttu-id="de0f3-1977">Depois que esse método é chamado, a instância está pronta para um método de construtor a ser chamado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1977">After this method is called, the instance is ready for a constructor method to be called.</span></span> <span data-ttu-id="de0f3-1978">Se `typeTok` é um tipo de referência, essa instrução tem o mesmo efeito que `ldnull` seguido de `stind.ref`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1978">If `typeTok` is a reference type, this instruction has the same effect as `ldnull` followed by `stind.ref`.</span></span>  
  
 <span data-ttu-id="de0f3-1979">Diferentemente <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` não chama o método de construtor.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1979">Unlike <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` does not call the constructor method.</span></span> <span data-ttu-id="de0f3-1980">`Initobj` é destinado ao inicializar tipos de valor, enquanto `newobj` é usado para alocar e inicializar objetos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1980">`Initobj` is intended for initializing value types, while `newobj` is used to allocate and initialize objects.</span></span>  
  
 <span data-ttu-id="de0f3-1981">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `initobj` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1981">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initobj` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-1982">ILGenerator.Emit (OpCode, tipo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-1982">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-1983">Testa se uma referência de objeto (tipo <see langword="O" />) é uma instância de uma classe específica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-1983">Tests whether an object reference (type <see langword="O" />) is an instance of a particular class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-1984">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1984">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-1985">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-1985">Format</span></span>|<span data-ttu-id="de0f3-1986">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-1986">Assembly Format</span></span>|<span data-ttu-id="de0f3-1987">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-1987">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-1988">75 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-1988">75 < `T` ></span></span>|<span data-ttu-id="de0f3-1989">isinst `class`</span><span class="sxs-lookup"><span data-stu-id="de0f3-1989">isinst `class`</span></span>|<span data-ttu-id="de0f3-1990">Testa se uma referência de objeto é uma instância de `class`, retornando uma referência nula ou uma instância dessa classe ou interface.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1990">Tests if an object reference is an instance of `class`, returning either a null reference or an instance of that class or interface.</span></span>|  
  
 <span data-ttu-id="de0f3-1991">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-1991">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-1992">Uma referência de objeto é inserida na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1992">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-1993">A referência de objeto é Aparecida da pilha e testada para ver se ele é uma instância da classe passada `class`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1993">The object reference is popped from the stack and tested to see if it is an instance of the class passed in `class`.</span></span>  
  
3.  <span data-ttu-id="de0f3-1994">O resultado (uma referência de objeto ou uma referência nula) é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1994">The result (either an object reference or a null reference) is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-1995">`Class` é um token de metadados que indica a classe desejada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1995">`Class` is a metadata token indicating the desired class.</span></span> <span data-ttu-id="de0f3-1996">Se a classe do objeto no topo da pilha implementa `class` (se `class` é uma interface) ou é uma classe derivada de `class` (se `class` é uma classe regular), em seguida, ele é convertido para o tipo `class` e o resultado é empurrado na pilha, exatamente como se <xref:System.Reflection.Emit.OpCodes.Castclass> tivesse sido chamada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1996">If the class of the object on the top of the stack implements `class` (if `class` is an interface) or is a derived class of `class` (if `class` is a regular class) then it is cast to type `class` and the result is pushed on the stack, exactly as though <xref:System.Reflection.Emit.OpCodes.Castclass> had been called.</span></span> <span data-ttu-id="de0f3-1997">Caso contrário, uma referência nula é empurrada na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1997">Otherwise, a null reference is pushed on the stack.</span></span> <span data-ttu-id="de0f3-1998">Se a referência de objeto é uma referência nula, em seguida, `isinst` da mesma forma, retorna uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1998">If the object reference itself is a null reference, then `isinst` likewise returns a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-1999"><xref:System.TypeLoadException> será gerada se a classe não pode ser encontrado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-1999"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="de0f3-2000">Normalmente, isso é detectado quando as instruções da Microsoft Intermediate Language (MSIL) são convertidas em código nativo em vez de em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2000">This is typically detected when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="de0f3-2001">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `isinst` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2001">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `isinst` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2002">ILGenerator.Emit (OpCode, tipo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2002">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2003">Sai do método atual e vai para o método especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2003">Exits current method and jumps to specified method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2004">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2004">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2005">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2005">Format</span></span>|<span data-ttu-id="de0f3-2006">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2006">Assembly Format</span></span>|<span data-ttu-id="de0f3-2007">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2007">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2008">27 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-2008">27 < `T` ></span></span>|<span data-ttu-id="de0f3-2009">jmp `method`</span><span class="sxs-lookup"><span data-stu-id="de0f3-2009">jmp `method`</span></span>|<span data-ttu-id="de0f3-2010">Saia do método atual e ir para o método especificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2010">Exit current method and jump to specified method.</span></span>|  
  
 <span data-ttu-id="de0f3-2011">Não há nenhuma pilha de comportamentos de transição para essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2011">There are no stack transition behaviors for this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-2012">O `jmp` instrução (saltar) transfere o controle para o método especificado pela `method`, que é um token de metadados para uma referência de método.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2012">The `jmp` (jump) instruction transfers control to the method specified by `method`, which is a metadata token for a method reference.</span></span> <span data-ttu-id="de0f3-2013">Os argumentos atuais são transferidos para o método de destino.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2013">The current arguments are transferred to the destination method.</span></span>  
  
 <span data-ttu-id="de0f3-2014">A pilha de avaliação deve estar vazia quando essa instrução é executada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2014">The evaluation stack must be empty when this instruction is executed.</span></span> <span data-ttu-id="de0f3-2015">A convenção de chamada, número e tipo dos argumentos no endereço de destino devem corresponder do método atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2015">The calling convention, number and type of arguments at the destination address must match that of the current method.</span></span>  
  
 <span data-ttu-id="de0f3-2016">O `jmp` instrução não pode ser usada para transferiu o controle de um `try`, `filter`, `catch`, ou `finally` bloco.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2016">The `jmp` instruction cannot be used to transferred control out of a `try`, `filter`, `catch`, or `finally` block.</span></span>  
  
 <span data-ttu-id="de0f3-2017">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `jmp` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2017">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `jmp` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2018">ILGenerator.Emit (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2018">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2019">Carrega um argumento (referenciado por um valor de índice especificado) na pilha.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2019">Loads an argument (referenced by a specified index value) onto the stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2020">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2020">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2021">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2021">Format</span></span>|<span data-ttu-id="de0f3-2022">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2022">Assembly Format</span></span>|<span data-ttu-id="de0f3-2023">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2023">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2024">FE 09 &LT; `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-2024">FE 09 < `unsigned int16` ></span></span>|<span data-ttu-id="de0f3-2025">ldarg `index`</span><span class="sxs-lookup"><span data-stu-id="de0f3-2025">ldarg `index`</span></span>|<span data-ttu-id="de0f3-2026">Carregar o argumento no `index` na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2026">Load argument at `index` onto stack.</span></span>|  
  
 <span data-ttu-id="de0f3-2027">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2027">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2028">O valor do argumento no `index` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2028">The argument value at `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2029">O `ldarg` instrução envia por push o argumento de indexação no `index`, no qual os argumentos são indexados de 0 e versões posteriores, na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2029">The `ldarg` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack.</span></span> <span data-ttu-id="de0f3-2030">O `ldarg` instrução pode ser usada para carregar um tipo de valor ou um valor primitivo à pilha, copiando-os de um argumento de entrada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2030">The `ldarg` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="de0f3-2031">O tipo do valor do argumento é o mesmo que o tipo do argumento, conforme especificado pela assinatura do método atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2031">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="de0f3-2032">Para obter os procedimentos que usam uma lista de argumentos de comprimento variável, o `ldarg` instrução pode ser usada apenas para inicial fixo de argumentos, não os na variável parte da assinatura (consulte a <xref:System.Reflection.Emit.OpCodes.Arglist> instrução para obter mais detalhes).</span><span class="sxs-lookup"><span data-stu-id="de0f3-2032">For procedures that take a variable-length argument list, the `ldarg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details).</span></span>  
  
 <span data-ttu-id="de0f3-2033">Argumentos que contêm um valor inteiro menor que 4 bytes de comprimento são expandidos para o tipo `int32` quando eles são carregados para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2033">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="de0f3-2034">Valores de ponto flutuante são expandidas para seu tamanho nativo (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-2034">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="de0f3-2035">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldarg` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2035">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2036">ILGenerator.Emit (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2036">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2037">Carrega o argumento no índice 0 na pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2037">Loads the argument at index 0 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2038">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2038">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2039">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2039">Format</span></span>|<span data-ttu-id="de0f3-2040">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2040">Assembly Format</span></span>|<span data-ttu-id="de0f3-2041">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2041">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2042">02</span><span class="sxs-lookup"><span data-stu-id="de0f3-2042">02</span></span>|<span data-ttu-id="de0f3-2043">ldarg.0</span><span class="sxs-lookup"><span data-stu-id="de0f3-2043">ldarg.0</span></span>|<span data-ttu-id="de0f3-2044">O argumento 0 na pilha de carga</span><span class="sxs-lookup"><span data-stu-id="de0f3-2044">Load argument 0 onto stack</span></span>|  
  
 <span data-ttu-id="de0f3-2045">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2045">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2046">O valor do argumento no índice 0 é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2046">The argument value at index 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2047">O `ldarg.0` instrução é uma codificação eficiente para carregar o valor do argumento no índice 0.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2047">The `ldarg.0` instruction is an efficient encoding for loading the argument value at index 0.</span></span>  
  
 <span data-ttu-id="de0f3-2048">O `ldarg.0` instrução envia por push o argumento indexado em 0 na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2048">The `ldarg.0` instruction pushes the argument indexed at 0 onto the evaluation stack.</span></span> <span data-ttu-id="de0f3-2049">O `ldarg.0` instrução pode ser usada para carregar um tipo de valor ou um valor primitivo à pilha, copiando-os de um argumento de entrada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2049">The `ldarg.0` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="de0f3-2050">O tipo do valor do argumento é o mesmo que o tipo do argumento, conforme especificado pela assinatura do método atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2050">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="de0f3-2051">Argumentos que contêm um valor inteiro menor que 4 bytes de comprimento são expandidos para o tipo `int32` quando eles são carregados para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2051">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="de0f3-2052">Valores de ponto flutuante são expandidas para seu tamanho nativo (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-2052">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="de0f3-2053">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldarg.0` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2053">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.0` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2054">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2054">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2055">Carrega o argumento no índice 1 na pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2055">Loads the argument at index 1 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2056">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2056">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2057">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2057">Format</span></span>|<span data-ttu-id="de0f3-2058">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2058">Assembly Format</span></span>|<span data-ttu-id="de0f3-2059">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2059">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2060">03</span><span class="sxs-lookup"><span data-stu-id="de0f3-2060">03</span></span>|<span data-ttu-id="de0f3-2061">ldarg.1</span><span class="sxs-lookup"><span data-stu-id="de0f3-2061">ldarg.1</span></span>|<span data-ttu-id="de0f3-2062">Carregar o argumento 1 na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2062">Load argument 1 onto stack.</span></span>|  
  
 <span data-ttu-id="de0f3-2063">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2063">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2064">O valor do argumento no índice 1 é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2064">The argument value at index 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2065">O `ldarg.1` instrução é uma codificação eficiente para carregar o valor do argumento no índice 1.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2065">The `ldarg.1` instruction is an efficient encoding for loading the argument value at index 1.</span></span>  
  
 <span data-ttu-id="de0f3-2066">O `ldarg.1` instrução envia por push o argumento indexado em 1 na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2066">The `ldarg.1` instruction pushes the argument indexed at 1 onto the evaluation stack.</span></span> <span data-ttu-id="de0f3-2067">O `ldarg.1` instrução pode ser usada para carregar um tipo de valor ou um valor primitivo à pilha, copiando-os de um argumento de entrada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2067">The `ldarg.1` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="de0f3-2068">O tipo do valor do argumento é o mesmo que o tipo do argumento, conforme especificado pela assinatura do método atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2068">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="de0f3-2069">Argumentos que contêm um valor inteiro menor que 4 bytes de comprimento são expandidos para o tipo `int32` quando eles são carregados para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2069">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="de0f3-2070">Valores de ponto flutuante são expandidas para seu tamanho nativo (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-2070">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="de0f3-2071">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldarg.1` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2071">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.1` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2072">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2072">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2073">Carrega o argumento no índice 2 na pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2073">Loads the argument at index 2 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2074">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2074">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2075">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2075">Format</span></span>|<span data-ttu-id="de0f3-2076">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2076">Assembly Format</span></span>|<span data-ttu-id="de0f3-2077">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2077">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2078">04</span><span class="sxs-lookup"><span data-stu-id="de0f3-2078">04</span></span>|<span data-ttu-id="de0f3-2079">ldarg.2</span><span class="sxs-lookup"><span data-stu-id="de0f3-2079">ldarg.2</span></span>|<span data-ttu-id="de0f3-2080">Carregar o argumento 2 na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2080">Load argument 2 onto stack.</span></span>|  
  
 <span data-ttu-id="de0f3-2081">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2081">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2082">O valor do argumento no índice 2 é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2082">The argument value at index 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2083">O `ldarg.2` instrução é uma codificação eficiente para carregar o valor do argumento no índice 2.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2083">The `ldarg.2` instruction is an efficient encoding for loading the argument value at index 2.</span></span>  
  
 <span data-ttu-id="de0f3-2084">O `ldarg.2` instrução envia por push o argumento de indexação no 2 na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2084">The `ldarg.2` instruction pushes the argument indexed at 2 onto the evaluation stack.</span></span> <span data-ttu-id="de0f3-2085">O `ldarg.2` instrução pode ser usada para carregar um tipo de valor ou um valor primitivo à pilha, copiando-os de um argumento de entrada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2085">The `ldarg.2` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="de0f3-2086">O tipo do valor do argumento é o mesmo que o tipo do argumento, conforme especificado pela assinatura do método atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2086">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="de0f3-2087">Argumentos que contêm um valor inteiro menor que 4 bytes de comprimento são expandidos para o tipo `int32` quando eles são carregados para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2087">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="de0f3-2088">Valores de ponto flutuante são expandidas para seu tamanho nativo (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-2088">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="de0f3-2089">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldarg.2` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2089">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.2` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2090">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2090">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2091">Carrega o argumento no índice 3 na pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2091">Loads the argument at index 3 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2092">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2092">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2093">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2093">Format</span></span>|<span data-ttu-id="de0f3-2094">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2094">Assembly Format</span></span>|<span data-ttu-id="de0f3-2095">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2095">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2096">05</span><span class="sxs-lookup"><span data-stu-id="de0f3-2096">05</span></span>|<span data-ttu-id="de0f3-2097">ldarg.3</span><span class="sxs-lookup"><span data-stu-id="de0f3-2097">ldarg.3</span></span>|<span data-ttu-id="de0f3-2098">Carregar o argumento 3 na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2098">Load argument 3 onto stack.</span></span>|  
  
 <span data-ttu-id="de0f3-2099">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2099">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2100">O valor do argumento no índice 3 é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2100">The argument value at index 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2101">O `ldarg.3` instrução é uma codificação eficiente para carregar o valor do argumento no índice 3.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2101">The `ldarg.3` instruction is an efficient encoding for loading the argument value at index 3.</span></span>  
  
 <span data-ttu-id="de0f3-2102">O `ldarg.3` instrução envia por push o argumento indexado em 3 na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2102">The `ldarg.3` instruction pushes the argument indexed at 3 onto the evaluation stack.</span></span> <span data-ttu-id="de0f3-2103">O `ldarg.3` instrução pode ser usada para carregar um tipo de valor ou um valor primitivo à pilha, copiando-os de um argumento de entrada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2103">The `ldarg.3` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="de0f3-2104">O tipo do valor do argumento é o mesmo que o tipo do argumento, conforme especificado pela assinatura do método atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2104">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="de0f3-2105">Argumentos que contêm um valor inteiro menor que 4 bytes de comprimento são expandidos para o tipo `int32` quando eles são carregados para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2105">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="de0f3-2106">Valores de ponto flutuante são expandidas para seu tamanho nativo (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-2106">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="de0f3-2107">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldarg.3` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2107">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.3` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2108">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2108">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2109">Carrega o argumento (referenciado por um índice de forma curta especificado) para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2109">Loads the argument (referenced by a specified short form index) onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2110">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2110">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2111">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2111">Format</span></span>|<span data-ttu-id="de0f3-2112">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2112">Assembly Format</span></span>|<span data-ttu-id="de0f3-2113">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2113">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2114">0E < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-2114">0E < `unsigned int8` ></span></span>|<span data-ttu-id="de0f3-2115">ldarg.s `index`</span><span class="sxs-lookup"><span data-stu-id="de0f3-2115">ldarg.s `index`</span></span>|<span data-ttu-id="de0f3-2116">Carregar o argumento no `index` na pilha, de forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2116">Load argument at `index` onto stack, short form.</span></span>|  
  
 <span data-ttu-id="de0f3-2117">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2117">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2118">O valor do argumento no `index` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2118">The argument value at `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2119">O `ldarg.s` instrução é uma codificação eficiente para carregar argumentos indexadas a partir de 4 a 255.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2119">The `ldarg.s` instruction is an efficient encoding for loading arguments indexed from 4 through 255.</span></span>  
  
 <span data-ttu-id="de0f3-2120">O `ldarg.s` instrução envia por push o argumento de indexação no `index`, no qual os argumentos são indexados de 0 e versões posteriores, na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2120">The `ldarg.s` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack.</span></span> <span data-ttu-id="de0f3-2121">O `ldarg.s` instrução pode ser usada para carregar um tipo de valor ou um valor primitivo à pilha, copiando-os de um argumento de entrada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2121">The `ldarg.s` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="de0f3-2122">O tipo do valor do argumento é o mesmo que o tipo do argumento, conforme especificado pela assinatura do método atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2122">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="de0f3-2123">Para obter os procedimentos que usam uma lista de argumentos de comprimento variável, o `ldarg.s` instrução pode ser usada apenas para inicial fixo de argumentos, não os na variável parte da assinatura (consulte a <xref:System.Reflection.Emit.OpCodes.Arglist> instrução para obter mais detalhes).</span><span class="sxs-lookup"><span data-stu-id="de0f3-2123">For procedures that take a variable-length argument list, the `ldarg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details).</span></span>  
  
 <span data-ttu-id="de0f3-2124">Argumentos que contêm um valor inteiro menor que 4 bytes de comprimento são expandidos para o tipo `int32` quando eles são carregados para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2124">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="de0f3-2125">Valores de ponto flutuante são expandidas para seu tamanho nativo (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-2125">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="de0f3-2126">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldarg.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2126">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.s` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2127">ILGenerator.Emit (OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2127">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2128">Carregar um endereço de argumento para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2128">Load an argument address onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2129">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2129">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2130">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2130">Format</span></span>|<span data-ttu-id="de0f3-2131">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2131">Assembly Format</span></span>|<span data-ttu-id="de0f3-2132">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2132">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2133">FE 0A < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-2133">FE 0A < `unsigned int16` ></span></span>|<span data-ttu-id="de0f3-2134">ldarga `index`</span><span class="sxs-lookup"><span data-stu-id="de0f3-2134">ldarga `index`</span></span>|<span data-ttu-id="de0f3-2135">Buscar o endereço de argumento indexado por `index`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2135">Fetch the address of argument indexed by `index`.</span></span>|  
  
 <span data-ttu-id="de0f3-2136">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2136">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2137">O endereço `addr` do argumento indexado por `index` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2137">The address `addr` of the argument indexed by `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2138">O `ldarga` instrução busca o endereço (do tipo `*`) do argumento indexado por `index`, em que os argumentos são indexados de 0 em diante.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2138">The `ldarga` instruction fetches the address (of type `*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards.</span></span> <span data-ttu-id="de0f3-2139">O endereço `addr` é sempre alinhado a um limite natural no computador de destino.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2139">The address `addr` is always aligned to a natural boundary on the target machine.</span></span>  
  
 <span data-ttu-id="de0f3-2140">Para obter os procedimentos que usam uma lista de argumentos de comprimento variável, o `ldarga` instrução pode ser usada apenas para inicial fixo de argumentos, não os na variável parte da assinatura.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2140">For procedures that take a variable-length argument list, the `ldarga` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="de0f3-2141">`ldarga` é usado para passar o parâmetro pelo ref.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2141">`ldarga` is used for by-ref parameter passing.</span></span> <span data-ttu-id="de0f3-2142">Para outros casos <xref:System.Reflection.Emit.OpCodes.Ldarg> e <xref:System.Reflection.Emit.OpCodes.Starg> deve ser usado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2142">For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg> and <xref:System.Reflection.Emit.OpCodes.Starg> should be used.</span></span>  
  
 <span data-ttu-id="de0f3-2143">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldarga` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2143">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2144">ILGenerator.Emit (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2144">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2145">Carregar um endereço de argumento, na forma abreviada, para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2145">Load an argument address, in short form, onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2146">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2146">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2147">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2147">Format</span></span>|<span data-ttu-id="de0f3-2148">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2148">Assembly Format</span></span>|<span data-ttu-id="de0f3-2149">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2149">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2150">0F < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-2150">0F < `unsigned int8` ></span></span>|<span data-ttu-id="de0f3-2151">ldarga.s `index`</span><span class="sxs-lookup"><span data-stu-id="de0f3-2151">ldarga.s `index`</span></span>|<span data-ttu-id="de0f3-2152">Buscar o endereço de argumento indexado por `index`, forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2152">Fetch the address of argument indexed by `index`, short form.</span></span>|  
  
 <span data-ttu-id="de0f3-2153">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2153">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2154">O endereço `addr` do argumento indexado por `index` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2154">The address `addr` of the argument indexed by `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2155">`ldarga.s` (a forma abreviada de `ldarga`) deve ser usado para números de argumento de 0 a 255, e é uma codificação mais eficiente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2155">`ldarga.s` (the short form of `ldarga`) should be used for argument numbers 0 through 255, and is a more efficient encoding.</span></span>  
  
 <span data-ttu-id="de0f3-2156">O `ldarga.s` instrução busca o endereço (do tipo`*`) do argumento indexado por `index`, em que os argumentos são indexados de 0 em diante.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2156">The `ldarga.s` instruction fetches the address (of type`*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards.</span></span> <span data-ttu-id="de0f3-2157">O endereço `addr` é sempre alinhado a um limite natural no computador de destino.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2157">The address `addr` is always aligned to a natural boundary on the target machine.</span></span>  
  
 <span data-ttu-id="de0f3-2158">Para obter os procedimentos que usam uma lista de argumentos de comprimento variável, o `ldarga.s` instrução pode ser usada apenas para inicial fixo de argumentos, não os na variável parte da assinatura.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2158">For procedures that take a variable-length argument list, the `ldarga.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="de0f3-2159">`ldarga.s` é usado para passar o parâmetro pelo ref.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2159">`ldarga.s` is used for by-ref parameter passing.</span></span> <span data-ttu-id="de0f3-2160">Para outros casos <xref:System.Reflection.Emit.OpCodes.Ldarg_S> e <xref:System.Reflection.Emit.OpCodes.Starg_S> deve ser usado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2160">For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg_S> and <xref:System.Reflection.Emit.OpCodes.Starg_S> should be used.</span></span>  
  
 <span data-ttu-id="de0f3-2161">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldarga.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2161">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga.s` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2162">ILGenerator.Emit (OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2162">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2163">Envia por push um valor do tipo <see langword="int32" /> fornecido para a pilha de avaliação como um <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2163">Pushes a supplied value of type <see langword="int32" /> onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2164">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2164">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2165">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2165">Format</span></span>|<span data-ttu-id="de0f3-2166">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2166">Assembly Format</span></span>|<span data-ttu-id="de0f3-2167">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2167">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2168">20 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-2168">20 < `int32` ></span></span>|<span data-ttu-id="de0f3-2169">ldc.i4 `num`</span><span class="sxs-lookup"><span data-stu-id="de0f3-2169">ldc.i4 `num`</span></span>|<span data-ttu-id="de0f3-2170">Envia o valor `num` para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2170">Pushes the value `num` onto the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-2171">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2171">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2172">O valor `num` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2172">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2173">Observe que há codificações curtas (e, portanto, é mais eficientes) especiais para inteiros -128 a 127, especialmente curtos e codificações para -1 a 8.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2173">Note that there are special short (and hence more efficient) encodings for the integers -128 through 127, and especially short encodings for -1 through 8.</span></span> <span data-ttu-id="de0f3-2174">Todas as codificações curtas push inteiros de 4 bytes na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2174">All short encodings push 4 byte integers on the stack.</span></span> <span data-ttu-id="de0f3-2175">Mais codificações são usadas para inteiros de 8 bytes e 4 e 8 números de ponto flutuante de byte, bem como valores de 4 bytes que não cabem nos formulários de curto.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2175">Longer encodings are used for 8 byte integers and 4 and 8 byte floating-point numbers, as well as 4-byte values that do not fit in the short forms.</span></span> <span data-ttu-id="de0f3-2176">Há três maneiras de enviar por push uma constante de inteiro de 8 bytes para a pilha</span><span class="sxs-lookup"><span data-stu-id="de0f3-2176">There are three ways to push an 8 byte integer constant onto the stack</span></span>  
  
 1. <span data-ttu-id="de0f3-2177">Use o <xref:System.Reflection.Emit.OpCodes.Ldc_I8> instrução para constantes que deve ser expressa em mais de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2177">Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I8> instruction for constants that must be expressed in more than 32 bits.</span></span>  
  
 2. <span data-ttu-id="de0f3-2178">Use o <xref:System.Reflection.Emit.OpCodes.Ldc_I4> instruções seguidas por um <xref:System.Reflection.Emit.OpCodes.Conv_I8> para constantes que exigem a 9 para 32 bits.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2178">Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I4> instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that require 9 to 32 bits.</span></span>  
  
 3. <span data-ttu-id="de0f3-2179">Usar uma instrução de forma abreviada, seguida por um <xref:System.Reflection.Emit.OpCodes.Conv_I8> para constantes que podem ser expressos em bits 8 ou menos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2179">Use a short form instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that can be expressed in 8 or fewer bits.</span></span>  
  
 <span data-ttu-id="de0f3-2180">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2180">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2181">ILGenerator.Emit (OpCode, int)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2181">ILGenerator.Emit(OpCode, int)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2182">Envia o valor inteiro de 0 para a pilha de avaliação como um <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2182">Pushes the integer value of 0 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2183">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2183">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2184">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2184">Format</span></span>|<span data-ttu-id="de0f3-2185">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2185">Assembly Format</span></span>|<span data-ttu-id="de0f3-2186">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2186">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2187">16</span><span class="sxs-lookup"><span data-stu-id="de0f3-2187">16</span></span>|<span data-ttu-id="de0f3-2188">ldc.i4.0</span><span class="sxs-lookup"><span data-stu-id="de0f3-2188">ldc.i4.0</span></span>|<span data-ttu-id="de0f3-2189">Envia por push 0 para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2189">Pushes 0 onto the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-2190">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2190">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2191">O valor 0 é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2191">The value 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2192">Isso é uma codificação especial curto para o envio por push do valor inteiro 0.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2192">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="de0f3-2193">Todas as codificações curtas especiais por push inteiros de 4 bytes na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2193">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2194">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.0` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2194">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.0` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2195">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2195">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2196">Envia o valor inteiro 1 por push para a pilha de avaliação como um <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2196">Pushes the integer value of 1 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2197">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2197">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2198">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2198">Format</span></span>|<span data-ttu-id="de0f3-2199">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2199">Assembly Format</span></span>|<span data-ttu-id="de0f3-2200">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2200">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2201">17</span><span class="sxs-lookup"><span data-stu-id="de0f3-2201">17</span></span>|<span data-ttu-id="de0f3-2202">ldc.i4.1</span><span class="sxs-lookup"><span data-stu-id="de0f3-2202">ldc.i4.1</span></span>|<span data-ttu-id="de0f3-2203">Envia por push 1 para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2203">Pushes 1 onto the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-2204">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2204">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2205">O valor 1 é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2205">The value 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2206">Isso é uma codificação especial curto para o envio por push do valor inteiro 0.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2206">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="de0f3-2207">Todas as codificações curtas especiais por push inteiros de 4 bytes na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2207">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2208">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.1` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2208">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.1` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2209">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2209">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2210">Efetua o push do valor inteiro de 2 para a pilha de avaliação como um <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2210">Pushes the integer value of 2 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2211">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2211">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2212">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2212">Format</span></span>|<span data-ttu-id="de0f3-2213">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2213">Assembly Format</span></span>|<span data-ttu-id="de0f3-2214">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2214">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2215">18</span><span class="sxs-lookup"><span data-stu-id="de0f3-2215">18</span></span>|<span data-ttu-id="de0f3-2216">ldc.i4.2</span><span class="sxs-lookup"><span data-stu-id="de0f3-2216">ldc.i4.2</span></span>|<span data-ttu-id="de0f3-2217">Envia por push 2 para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2217">Pushes 2 onto the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-2218">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2218">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2219">O valor 2 é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2219">The value 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2220">Isso é uma codificação especial curto para o envio por push do valor inteiro 0.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2220">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="de0f3-2221">Todas as codificações curtas especiais por push inteiros de 4 bytes na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2221">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2222">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.2` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2222">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.2` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2223">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2223">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2224">Efetua o push do valor inteiro de 3 para a pilha de avaliação como um <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2224">Pushes the integer value of 3 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2225">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2225">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2226">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2226">Format</span></span>|<span data-ttu-id="de0f3-2227">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2227">Assembly Format</span></span>|<span data-ttu-id="de0f3-2228">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2228">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2229">19</span><span class="sxs-lookup"><span data-stu-id="de0f3-2229">19</span></span>|<span data-ttu-id="de0f3-2230">ldc.i4.3</span><span class="sxs-lookup"><span data-stu-id="de0f3-2230">ldc.i4.3</span></span>|<span data-ttu-id="de0f3-2231">Envia por push 3 para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2231">Pushes 3 onto the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-2232">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2232">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2233">O valor 3 é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2233">The value 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2234">Isso é uma codificação especial curto para o envio por push do valor inteiro 0.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2234">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="de0f3-2235">Todas as codificações curtas especiais por push inteiros de 4 bytes na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2235">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2236">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.3` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2236">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.3` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2237">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2237">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2238">Efetua o push do valor inteiro de 4 para a pilha de avaliação como um <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2238">Pushes the integer value of 4 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2239">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2239">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2240">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2240">Format</span></span>|<span data-ttu-id="de0f3-2241">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2241">Assembly Format</span></span>|<span data-ttu-id="de0f3-2242">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2242">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2243">1A</span><span class="sxs-lookup"><span data-stu-id="de0f3-2243">1A</span></span>|<span data-ttu-id="de0f3-2244">ldc.i4.4</span><span class="sxs-lookup"><span data-stu-id="de0f3-2244">ldc.i4.4</span></span>|<span data-ttu-id="de0f3-2245">Envia por push 4 para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2245">Pushes 4 onto the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-2246">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2246">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2247">O valor 4 é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2247">The value 4 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2248">Isso é uma codificação especial curto para o envio por push do valor inteiro 0.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2248">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="de0f3-2249">Todas as codificações curtas especiais por push inteiros de 4 bytes na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2249">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2250">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.4` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2250">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.4` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2251">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2251">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2252">Efetua o push do valor inteiro de 5 para a pilha de avaliação como um <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2252">Pushes the integer value of 5 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2253">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2253">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2254">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2254">Format</span></span>|<span data-ttu-id="de0f3-2255">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2255">Assembly Format</span></span>|<span data-ttu-id="de0f3-2256">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2256">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2257">1B</span><span class="sxs-lookup"><span data-stu-id="de0f3-2257">1B</span></span>|<span data-ttu-id="de0f3-2258">ldc.i4.5</span><span class="sxs-lookup"><span data-stu-id="de0f3-2258">ldc.i4.5</span></span>|<span data-ttu-id="de0f3-2259">Envia por push 5 para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2259">Pushes 5 onto the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-2260">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2260">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2261">O valor 5 é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2261">The value 5 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2262">Isso é uma codificação especial curto para o envio por push do valor inteiro 0.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2262">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="de0f3-2263">Todas as codificações curtas especiais por push inteiros de 4 bytes na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2263">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2264">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.5` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2264">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.5` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2265">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2265">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2266">Efetua o push do valor inteiro de 6 para a pilha de avaliação como um <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2266">Pushes the integer value of 6 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2267">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2267">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2268">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2268">Format</span></span>|<span data-ttu-id="de0f3-2269">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2269">Assembly Format</span></span>|<span data-ttu-id="de0f3-2270">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2270">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2271">1C</span><span class="sxs-lookup"><span data-stu-id="de0f3-2271">1C</span></span>|<span data-ttu-id="de0f3-2272">ldc.i4.6</span><span class="sxs-lookup"><span data-stu-id="de0f3-2272">ldc.i4.6</span></span>|<span data-ttu-id="de0f3-2273">Envia por push 6 para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2273">Pushes 6 onto the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-2274">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2274">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2275">O valor 6 é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2275">The value 6 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2276">Isso é uma codificação especial curto para o envio por push do valor inteiro 0.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2276">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="de0f3-2277">Todas as codificações curtas especiais por push inteiros de 4 bytes na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2277">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2278">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.6` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2278">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.6` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2279">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2279">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2280">Efetua o push do valor inteiro de 7 para a pilha de avaliação como um <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2280">Pushes the integer value of 7 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2281">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2281">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2282">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2282">Format</span></span>|<span data-ttu-id="de0f3-2283">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2283">Assembly Format</span></span>|<span data-ttu-id="de0f3-2284">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2284">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2285">1-D</span><span class="sxs-lookup"><span data-stu-id="de0f3-2285">1D</span></span>|<span data-ttu-id="de0f3-2286">ldc.i4.7</span><span class="sxs-lookup"><span data-stu-id="de0f3-2286">ldc.i4.7</span></span>|<span data-ttu-id="de0f3-2287">Envia por push 7 na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2287">Pushes 7 onto the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-2288">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2288">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2289">O valor 7 é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2289">The value 7 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2290">Isso é uma codificação especial curto para o envio por push do valor inteiro 0.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2290">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="de0f3-2291">Todas as codificações curtas especiais por push inteiros de 4 bytes na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2291">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2292">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.7` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2292">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.7` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2293">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2293">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2294">Efetua o push do valor inteiro de 8 para a pilha de avaliação como um <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2294">Pushes the integer value of 8 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2295">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2295">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2296">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2296">Format</span></span>|<span data-ttu-id="de0f3-2297">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2297">Assembly Format</span></span>|<span data-ttu-id="de0f3-2298">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2298">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2299">1E</span><span class="sxs-lookup"><span data-stu-id="de0f3-2299">1E</span></span>|<span data-ttu-id="de0f3-2300">ldc.i4.8</span><span class="sxs-lookup"><span data-stu-id="de0f3-2300">ldc.i4.8</span></span>|<span data-ttu-id="de0f3-2301">Envia por push 8 para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2301">Pushes 8 onto the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-2302">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2302">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2303">O valor 8 é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2303">The value 8 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2304">Isso é uma codificação especial curto para o envio por push do valor inteiro 0.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2304">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="de0f3-2305">Todas as codificações curtas especiais por push inteiros de 4 bytes na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2305">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2306">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.8` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2306">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.8` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2307">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2307">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2308">Efetua o push do valor de inteiro de -1 para a pilha de avaliação como um <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2308">Pushes the integer value of -1 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2309">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2309">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2310">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2310">Format</span></span>|<span data-ttu-id="de0f3-2311">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2311">Assembly Format</span></span>|<span data-ttu-id="de0f3-2312">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2312">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2313">15</span><span class="sxs-lookup"><span data-stu-id="de0f3-2313">15</span></span>|<span data-ttu-id="de0f3-2314">ldc.i4.m1</span><span class="sxs-lookup"><span data-stu-id="de0f3-2314">ldc.i4.m1</span></span>|<span data-ttu-id="de0f3-2315">Envia por push -1 para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2315">Pushes -1 onto the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-2316">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2316">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2317">O valor -1 é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2317">The value -1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2318">Isso é uma codificação especial curto para o envio por push do valor inteiro 0.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2318">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="de0f3-2319">Todas as codificações curtas especiais por push inteiros de 4 bytes na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2319">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2320">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.m1` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2320">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.m1` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2321">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2321">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2322">Envia o valor de <see langword="int8" /> fornecido para a pilha de avaliação como um <see langword="int32" />, na forma abreviada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2322">Pushes the supplied <see langword="int8" /> value onto the evaluation stack as an <see langword="int32" />, short form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2323">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2323">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2324">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2324">Format</span></span>|<span data-ttu-id="de0f3-2325">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2325">Assembly Format</span></span>|<span data-ttu-id="de0f3-2326">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2326">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2327">1F < `int8` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-2327">1F < `int8` ></span></span>|<span data-ttu-id="de0f3-2328">ldc.i4.s `num`</span><span class="sxs-lookup"><span data-stu-id="de0f3-2328">ldc.i4.s `num`</span></span>|<span data-ttu-id="de0f3-2329">Envia por push `num` para a pilha como `int32`, forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2329">Pushes `num` onto the stack as `int32`, short form.</span></span>|  
  
 <span data-ttu-id="de0f3-2330">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2330">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2331">O valor `num` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2331">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2332">`ldc.i4.s` é uma codificação mais eficiente para enviar os inteiros de -128 a 127 na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2332">`ldc.i4.s` is a more efficient encoding for pushing the integers from -128 to 127 onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de0f3-2333">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2333">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.s` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2334">ILGenerator.Emit (OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2334">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2335">Envia por push um valor do tipo <see langword="int64" /> fornecido para a pilha de avaliação como um <see langword="int64" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2335">Pushes a supplied value of type <see langword="int64" /> onto the evaluation stack as an <see langword="int64" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2336">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2336">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2337">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2337">Format</span></span>|<span data-ttu-id="de0f3-2338">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2338">Assembly Format</span></span>|<span data-ttu-id="de0f3-2339">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2339">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2340">21 < `int64` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-2340">21 < `int64` ></span></span>|<span data-ttu-id="de0f3-2341">ldc.I8 `num`</span><span class="sxs-lookup"><span data-stu-id="de0f3-2341">ldc.i8 `num`</span></span>|<span data-ttu-id="de0f3-2342">Envia por push `num` para a pilha como `int64`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2342">Pushes `num` onto the stack as `int64`.</span></span>|  
  
 <span data-ttu-id="de0f3-2343">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2343">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2344">O valor `num` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2344">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2345">Essa codificação envia um `int64` valor para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2345">This encoding pushes an `int64` value onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2346">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i8` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2346">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i8` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2347">ILGenerator.Emit (OpCode, long)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2347">ILGenerator.Emit(OpCode, long)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2348">Efetua o push de um valor fornecido do tipo <see langword="float32" /> para a pilha de avaliação como tipo <see langword="F" /> (float).</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2348">Pushes a supplied value of type <see langword="float32" /> onto the evaluation stack as type <see langword="F" /> (float).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2349">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2349">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2350">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2350">Format</span></span>|<span data-ttu-id="de0f3-2351">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2351">Assembly Format</span></span>|<span data-ttu-id="de0f3-2352">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2352">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2353">22 < `float32` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-2353">22 < `float32` ></span></span>|<span data-ttu-id="de0f3-2354">ldc.R4 `num`</span><span class="sxs-lookup"><span data-stu-id="de0f3-2354">ldc.r4 `num`</span></span>|<span data-ttu-id="de0f3-2355">Envia por push `num` para a pilha como `F`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2355">Pushes `num` onto the stack as `F`.</span></span>|  
  
 <span data-ttu-id="de0f3-2356">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2356">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2357">O valor `num` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2357">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2358">Essa codificação envia um `float32` valor para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2358">This encoding pushes a `float32` value onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2359">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.r4` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2359">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r4` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2360">ILGenerator.Emit (OpCode, único)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2360">ILGenerator.Emit(OpCode, single)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2361">Efetua o push de um valor fornecido do tipo <see langword="float64" /> para a pilha de avaliação como tipo <see langword="F" /> (float).</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2361">Pushes a supplied value of type <see langword="float64" /> onto the evaluation stack as type <see langword="F" /> (float).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2362">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2362">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2363">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2363">Format</span></span>|<span data-ttu-id="de0f3-2364">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2364">Assembly Format</span></span>|<span data-ttu-id="de0f3-2365">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2365">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2366">23 < `float64` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-2366">23 < `float64` ></span></span>|<span data-ttu-id="de0f3-2367">ldc.R8 `num`</span><span class="sxs-lookup"><span data-stu-id="de0f3-2367">ldc.r8 `num`</span></span>|<span data-ttu-id="de0f3-2368">Envia por push `num` para a pilha como `F`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2368">Pushes `num` onto the stack as `F`.</span></span>|  
  
 <span data-ttu-id="de0f3-2369">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2369">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2370">O valor `num` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2370">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2371">Essa codificação envia um `float64` valor para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2371">This encoding pushes a `float64` value onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2372">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.r8` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2372">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r8` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2373">ILGenerator.Emit (OpCode, double)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2373">ILGenerator.Emit(OpCode, double)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2374">Carrega o elemento a um índice de matriz especificado na parte superior da pilha de avaliação como o tipo especificado na instrução.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2374">Loads the element at a specified array index onto the top of the evaluation stack as the type specified in the instruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2375">A tabela a seguir lista a instrução hexadecimal e formato do assembly Microsoft intermediate language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2375">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2376">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2376">Format</span></span>|<span data-ttu-id="de0f3-2377">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2377">Assembly Format</span></span>|<span data-ttu-id="de0f3-2378">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2378">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2379">A3 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-2379">A3 < `T` ></span></span>|<span data-ttu-id="de0f3-2380">Ldelem `typeTok`</span><span class="sxs-lookup"><span data-stu-id="de0f3-2380">ldelem `typeTok`</span></span>|<span data-ttu-id="de0f3-2381">Carrega o elemento `index` para o topo da pilha como tipo `typeTok`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2381">Loads the element at `index` onto the top of the stack as type `typeTok`.</span></span>|  
  
 <span data-ttu-id="de0f3-2382">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2382">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2383">Uma referência de objeto `array` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2383">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-2384">Um valor de índice `index` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2384">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-2385">`index` e `array` são removidos da pilha; o valor armazenado na posição `index` em `array` é pesquisado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2385">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="de0f3-2386">O valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2386">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2387">O `ldelem` instrução carrega o valor do elemento com índice `index` (tipo `native int`) na matriz unidimensional baseada em zero `array` e o coloca na parte superior da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2387">The `ldelem` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="de0f3-2388">Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2388">Arrays are objects, and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="de0f3-2389">O tipo do valor de retorno é especificado pelo token `typeTok` na instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2389">The type of the return value is specified by the token `typeTok` in the instruction.</span></span>  
  
 <span data-ttu-id="de0f3-2390"><xref:System.NullReferenceException> será gerada se `array` é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2390"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-2391"><xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite superior de `array`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2391"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the upper bound of `array`.</span></span>  
  
 <span data-ttu-id="de0f3-2392">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2392">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2393">ILGenerator.Emit (OpCode, tipo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2393">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2394">Carrega o elemento com o tipo <see langword="native int" /> em um índice de matriz especificado para o topo da pilha de avaliação como um <see langword="native int" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2394">Loads the element with type <see langword="native int" /> at a specified array index onto the top of the evaluation stack as a <see langword="native int" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2395">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2395">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2396">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2396">Format</span></span>|<span data-ttu-id="de0f3-2397">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2397">Assembly Format</span></span>|<span data-ttu-id="de0f3-2398">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2398">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2399">97</span><span class="sxs-lookup"><span data-stu-id="de0f3-2399">97</span></span>|<span data-ttu-id="de0f3-2400">Ldelem.i</span><span class="sxs-lookup"><span data-stu-id="de0f3-2400">ldelem.i</span></span>|<span data-ttu-id="de0f3-2401">Carrega o elemento com o tipo `native int` na `index` para o topo da pilha de como um `native int`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2401">Loads the element with type `native int` at `index` onto the top of the stack as a `native int`.</span></span>|  
  
 <span data-ttu-id="de0f3-2402">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2402">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2403">Uma referência de objeto `array` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2403">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-2404">Um valor de índice `index` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2404">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-2405">`index` e `array` são removidos da pilha; o valor armazenado na posição `index` em `array` é pesquisado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2405">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="de0f3-2406">O valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2406">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2407">O `ldelem.i` instrução carrega o valor do elemento com índice `index` (tipo `native int`) na matriz unidimensional baseada em zero `array` e o coloca na parte superior da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2407">The `ldelem.i` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="de0f3-2408">Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2408">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="de0f3-2409">O valor de retorno `ldelem.i` é `native int`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2409">The return value for `ldelem.i` is `native int`.</span></span>  
  
 <span data-ttu-id="de0f3-2410">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2410">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de0f3-2411"><xref:System.NullReferenceException> será gerada se `array` é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2411"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-2412"><xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2412"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de0f3-2413"><xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2413"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de0f3-2414">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.i` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2414">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2415">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2415">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2416">Carrega o elemento com o tipo <see langword="int8" /> em um índice de matriz especificado para o topo da pilha de avaliação como um <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2416">Loads the element with type <see langword="int8" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2417">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2417">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2418">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2418">Format</span></span>|<span data-ttu-id="de0f3-2419">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2419">Assembly Format</span></span>|<span data-ttu-id="de0f3-2420">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2420">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2421">90</span><span class="sxs-lookup"><span data-stu-id="de0f3-2421">90</span></span>|<span data-ttu-id="de0f3-2422">Ldelem.I1</span><span class="sxs-lookup"><span data-stu-id="de0f3-2422">ldelem.i1</span></span>|<span data-ttu-id="de0f3-2423">Carrega o elemento com o tipo `int8` na `index` para o topo da pilha de como um `int32`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2423">Loads the element with type `int8` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="de0f3-2424">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2424">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2425">Uma referência de objeto `array` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2425">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-2426">Um valor de índice `index` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2426">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-2427">`index` e `array` são removidos da pilha; o valor armazenado na posição `index` em `array` é pesquisado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2427">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="de0f3-2428">O valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2428">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2429">O `ldelem.i1` instrução carrega o valor do elemento com índice `index` (tipo `native int`) na matriz unidimensional baseada em zero `array` e o coloca na parte superior da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2429">The `ldelem.i1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="de0f3-2430">Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2430">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="de0f3-2431">O valor de retorno `ldelem.i1` é `int8`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2431">The return value for `ldelem.i1` is `int8`.</span></span>  
  
 <span data-ttu-id="de0f3-2432">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2432">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de0f3-2433"><xref:System.NullReferenceException> será gerada se `array` é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2433"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-2434"><xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2434"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de0f3-2435"><xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2435"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de0f3-2436">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.i1` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2436">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i1` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2437">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2437">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2438">Carrega o elemento com o tipo <see langword="int16" /> em um índice de matriz especificado para o topo da pilha de avaliação como um <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2438">Loads the element with type <see langword="int16" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2439">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2439">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2440">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2440">Format</span></span>|<span data-ttu-id="de0f3-2441">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2441">Assembly Format</span></span>|<span data-ttu-id="de0f3-2442">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2442">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2443">92</span><span class="sxs-lookup"><span data-stu-id="de0f3-2443">92</span></span>|<span data-ttu-id="de0f3-2444">Ldelem.I2</span><span class="sxs-lookup"><span data-stu-id="de0f3-2444">ldelem.i2</span></span>|<span data-ttu-id="de0f3-2445">Carrega o elemento com o tipo `int16` na `index` para o topo da pilha de como um `int32`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2445">Loads the element with type `int16` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="de0f3-2446">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2446">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2447">Uma referência de objeto `array` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2447">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-2448">Um valor de índice `index` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2448">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-2449">`index` e `array` são removidos da pilha; o valor armazenado na posição `index` em `array` é pesquisado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2449">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="de0f3-2450">O valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2450">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2451">O `ldelem.i2` instrução carrega o valor do elemento com índice `index` (tipo `native int`) na matriz unidimensional baseada em zero `array` e o coloca na parte superior da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2451">The `ldelem.i2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="de0f3-2452">Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2452">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="de0f3-2453">O valor de retorno `ldelem.i2` é `int16`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2453">The return value for `ldelem.i2` is `int16`.</span></span>  
  
 <span data-ttu-id="de0f3-2454">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2454">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de0f3-2455"><xref:System.NullReferenceException> será gerada se `array` é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2455"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-2456"><xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2456"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de0f3-2457"><xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2457"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de0f3-2458">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.i2` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2458">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i2` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2459">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2459">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2460">Carrega o elemento com o tipo <see langword="int32" /> em um índice de matriz especificado para o topo da pilha de avaliação como um <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2460">Loads the element with type <see langword="int32" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2461">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2461">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2462">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2462">Format</span></span>|<span data-ttu-id="de0f3-2463">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2463">Assembly Format</span></span>|<span data-ttu-id="de0f3-2464">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2464">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2465">94</span><span class="sxs-lookup"><span data-stu-id="de0f3-2465">94</span></span>|<span data-ttu-id="de0f3-2466">Ldelem.i4</span><span class="sxs-lookup"><span data-stu-id="de0f3-2466">ldelem.i4</span></span>|<span data-ttu-id="de0f3-2467">Carrega o elemento com o tipo `int32` na `index` para o topo da pilha de como um `int32`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2467">Loads the element with type `int32` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="de0f3-2468">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2468">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2469">Uma referência de objeto `array` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2469">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-2470">Um valor de índice `index` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2470">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-2471">`index` e `array` são removidos da pilha; o valor armazenado na posição `index` em `array` é pesquisado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2471">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="de0f3-2472">O valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2472">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2473">O `ldelem.i4` instrução carrega o valor do elemento com índice `index` (tipo `native int`) na matriz unidimensional baseada em zero `array` e o coloca na parte superior da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2473">The `ldelem.i4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="de0f3-2474">Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2474">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="de0f3-2475">O valor de retorno `ldelem.i4` é `int32`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2475">The return value for `ldelem.i4` is `int32`.</span></span>  
  
 <span data-ttu-id="de0f3-2476">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2476">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de0f3-2477"><xref:System.NullReferenceException> será gerada se `array` é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2477"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-2478"><xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2478"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de0f3-2479"><xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2479"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de0f3-2480">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.i4` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2480">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i4` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2481">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2481">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2482">Carrega o elemento com o tipo <see langword="int64" /> em um índice de matriz especificado para o topo da pilha de avaliação como um <see langword="int64" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2482">Loads the element with type <see langword="int64" /> at a specified array index onto the top of the evaluation stack as an <see langword="int64" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2483">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2483">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2484">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2484">Format</span></span>|<span data-ttu-id="de0f3-2485">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2485">Assembly Format</span></span>|<span data-ttu-id="de0f3-2486">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2486">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2487">96</span><span class="sxs-lookup"><span data-stu-id="de0f3-2487">96</span></span>|<span data-ttu-id="de0f3-2488">Ldelem.I8</span><span class="sxs-lookup"><span data-stu-id="de0f3-2488">ldelem.i8</span></span>|<span data-ttu-id="de0f3-2489">Carrega o elemento com o tipo `int64` na `index` para o topo da pilha de como um `int64`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2489">Loads the element with type `int64` at `index` onto the top of the stack as an `int64`.</span></span>|  
  
 <span data-ttu-id="de0f3-2490">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2490">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2491">Uma referência de objeto `array` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2491">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-2492">Um valor de índice `index` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2492">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-2493">`index` e `array` são removidos da pilha; o valor armazenado na posição `index` em `array` é pesquisado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2493">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="de0f3-2494">O valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2494">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2495">O `ldelem.i8` instrução carrega o valor do elemento com índice `index` (tipo `native int`) na matriz unidimensional baseada em zero `array` e o coloca na parte superior da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2495">The `ldelem.i8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="de0f3-2496">Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2496">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="de0f3-2497">O valor de retorno `ldelem.i8` é `int64`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2497">The return value for `ldelem.i8` is `int64`.</span></span>  
  
 <span data-ttu-id="de0f3-2498">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2498">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de0f3-2499"><xref:System.NullReferenceException> será gerada se `array` é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2499"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-2500"><xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2500"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de0f3-2501"><xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2501"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de0f3-2502">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.i8` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2502">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i8` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2503">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2503">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2504">Carrega o elemento com o tipo <see langword="float32" /> em um índice de matriz especificado para o topo da pilha de avaliação como um tipo <see langword="F" /> (float).</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2504">Loads the element with type <see langword="float32" /> at a specified array index onto the top of the evaluation stack as type <see langword="F" /> (float).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2505">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2505">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2506">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2506">Format</span></span>|<span data-ttu-id="de0f3-2507">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2507">Assembly Format</span></span>|<span data-ttu-id="de0f3-2508">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2508">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2509">98</span><span class="sxs-lookup"><span data-stu-id="de0f3-2509">98</span></span>|<span data-ttu-id="de0f3-2510">Ldelem.R4</span><span class="sxs-lookup"><span data-stu-id="de0f3-2510">ldelem.r4</span></span>|<span data-ttu-id="de0f3-2511">Carrega o elemento com o tipo `float32` na `index` para o topo da pilha de como um tipo `F`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2511">Loads the element with type `float32` at `index` onto the top of the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="de0f3-2512">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2512">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2513">Uma referência de objeto `array` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2513">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-2514">Um valor de índice `index` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2514">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-2515">`index` e `array` são removidos da pilha; o valor armazenado na posição `index` em `array` é pesquisado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2515">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="de0f3-2516">O valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2516">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2517">O `ldelem.r4` instrução carrega o valor do elemento com índice `index` (tipo `native int`) na matriz unidimensional baseada em zero `array` e o coloca na parte superior da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2517">The `ldelem.r4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="de0f3-2518">Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2518">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="de0f3-2519">O valor de retorno `ldelem.r4` é `float32`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2519">The return value for `ldelem.r4` is `float32`.</span></span>  
  
 <span data-ttu-id="de0f3-2520">Valores de ponto flutuante são convertidos para o tipo `F` quando carregado na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2520">Floating-point values are converted to type `F` when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de0f3-2521"><xref:System.NullReferenceException> será gerada se `array` é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2521"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-2522"><xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2522"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de0f3-2523"><xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2523"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de0f3-2524">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.r4` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2524">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r4` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2525">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2525">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2526">Carrega o elemento com o tipo <see langword="float64" /> em um índice de matriz especificado para o topo da pilha de avaliação como um tipo <see langword="F" /> (float).</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2526">Loads the element with type <see langword="float64" /> at a specified array index onto the top of the evaluation stack as type <see langword="F" /> (float).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2527">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2527">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2528">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2528">Format</span></span>|<span data-ttu-id="de0f3-2529">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2529">Assembly Format</span></span>|<span data-ttu-id="de0f3-2530">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2530">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2531">99</span><span class="sxs-lookup"><span data-stu-id="de0f3-2531">99</span></span>|<span data-ttu-id="de0f3-2532">Ldelem.R8</span><span class="sxs-lookup"><span data-stu-id="de0f3-2532">ldelem.r8</span></span>|<span data-ttu-id="de0f3-2533">Carrega o elemento com o tipo `float64` na `index` para o topo da pilha como tipo `F`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2533">Loads the element with type `float64` at `index` onto the top of the stack as type `F`.</span></span>|  
  
 <span data-ttu-id="de0f3-2534">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2534">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2535">Uma referência de objeto `array` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2535">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-2536">Um valor de índice `index` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2536">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-2537">`index` e `array` são removidos da pilha; o valor armazenado na posição `index` em `array` é pesquisado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2537">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="de0f3-2538">O valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2538">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2539">O `ldelem.r8` instrução carrega o valor do elemento com índice `index` (tipo `native int`) na matriz unidimensional baseada em zero `array` e o coloca na parte superior da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2539">The `ldelem.r8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="de0f3-2540">Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2540">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="de0f3-2541">O valor de retorno `ldelem.r8` é `float64`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2541">The return value for `ldelem.r8` is `float64`.</span></span>  
  
 <span data-ttu-id="de0f3-2542">Valores de ponto flutuante são convertidos para o tipo `F` quando carregado na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2542">Floating-point values are converted to type `F` when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de0f3-2543"><xref:System.NullReferenceException> será gerada se `array` é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2543"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-2544"><xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2544"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de0f3-2545"><xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2545"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de0f3-2546">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.r8` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2546">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r8` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2547">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2547">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2548">Carrega o elemento que contém uma referência de objeto em um índice de matriz especificado para o topo da pilha de avaliação como tipo <see langword="O" /> (referência de objeto).</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2548">Loads the element containing an object reference at a specified array index onto the top of the evaluation stack as type <see langword="O" /> (object reference).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2549">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2549">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2550">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2550">Format</span></span>|<span data-ttu-id="de0f3-2551">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2551">Assembly Format</span></span>|<span data-ttu-id="de0f3-2552">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2552">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2553">9A</span><span class="sxs-lookup"><span data-stu-id="de0f3-2553">9A</span></span>|<span data-ttu-id="de0f3-2554">Ldelem.ref</span><span class="sxs-lookup"><span data-stu-id="de0f3-2554">ldelem.ref</span></span>|<span data-ttu-id="de0f3-2555">Carrega o elemento com uma referência de objeto no `index` para o topo da pilha como tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2555">Loads the element with an object reference at `index` onto the top of the stack as type `O`.</span></span>|  
  
 <span data-ttu-id="de0f3-2556">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2556">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2557">Uma referência de objeto `array` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2557">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-2558">Um valor de índice `index` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2558">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-2559">`index` e `array` são removidos da pilha; o valor armazenado na posição `index` em `array` é pesquisado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2559">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="de0f3-2560">O valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2560">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2561">O `ldelem.ref` instrução carrega o valor do elemento com índice `index` (tipo `native int`) na matriz unidimensional baseada em zero `array` e o coloca na parte superior da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2561">The `ldelem.ref` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="de0f3-2562">Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2562">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="de0f3-2563">O valor de retorno `ldelem.ref` é do tipo `O` (referência de objeto).</span><span class="sxs-lookup"><span data-stu-id="de0f3-2563">The return value for `ldelem.ref` is type `O` (object reference).</span></span>  
  
 <span data-ttu-id="de0f3-2564"><xref:System.NullReferenceException> será gerada se `array` é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2564"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-2565"><xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2565"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de0f3-2566"><xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2566"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de0f3-2567">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.ref` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2567">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.ref` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2568">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2568">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2569">Carrega o elemento com o tipo <see langword="unsigned int8" /> em um índice de matriz especificado para o topo da pilha de avaliação como um <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2569">Loads the element with type <see langword="unsigned int8" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2570">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2570">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2571">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2571">Format</span></span>|<span data-ttu-id="de0f3-2572">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2572">Assembly Format</span></span>|<span data-ttu-id="de0f3-2573">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2573">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2574">91</span><span class="sxs-lookup"><span data-stu-id="de0f3-2574">91</span></span>|<span data-ttu-id="de0f3-2575">Ldelem.U1</span><span class="sxs-lookup"><span data-stu-id="de0f3-2575">ldelem.u1</span></span>|<span data-ttu-id="de0f3-2576">Carrega o elemento com o tipo `unsigned int8` na `index` para o topo da pilha de como um `int32`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2576">Loads the element with type `unsigned int8` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="de0f3-2577">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2577">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2578">Uma referência de objeto `array` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2578">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-2579">Um valor de índice `index` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2579">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-2580">`index` e `array` são removidos da pilha; o valor armazenado na posição `index` em `array` é pesquisado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2580">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="de0f3-2581">O valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2581">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2582">O `ldelem.u1` instrução carrega o valor do elemento com índice `index` (tipo `native int`) na matriz unidimensional baseada em zero `array` e o coloca na parte superior da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2582">The `ldelem.u1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="de0f3-2583">Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2583">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="de0f3-2584">O valor de retorno `ldelem.u1` é `int8`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2584">The return value for `ldelem.u1` is `int8`.</span></span>  
  
 <span data-ttu-id="de0f3-2585">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2585">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de0f3-2586"><xref:System.NullReferenceException> será gerada se `array` é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2586"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-2587"><xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2587"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de0f3-2588"><xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2588"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de0f3-2589">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.u1` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2589">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u1` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2590">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2590">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2591">Carrega o elemento com o tipo <see langword="unsigned int16" /> em um índice de matriz especificado para o topo da pilha de avaliação como um <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2591">Loads the element with type <see langword="unsigned int16" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2592">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2592">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2593">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2593">Format</span></span>|<span data-ttu-id="de0f3-2594">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2594">Assembly Format</span></span>|<span data-ttu-id="de0f3-2595">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2595">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2596">93</span><span class="sxs-lookup"><span data-stu-id="de0f3-2596">93</span></span>|<span data-ttu-id="de0f3-2597">Ldelem.U2</span><span class="sxs-lookup"><span data-stu-id="de0f3-2597">ldelem.u2</span></span>|<span data-ttu-id="de0f3-2598">Carrega o elemento com o tipo `unsigned int16` no índice para o topo da pilha de como um `int32`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2598">Loads the element with type `unsigned int16` at index onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="de0f3-2599">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2599">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2600">Uma referência de objeto `array` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2600">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-2601">Um valor de índice `index` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2601">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-2602">`index` e `array` são removidos da pilha; o valor armazenado na posição `index` em `array` é pesquisado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2602">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="de0f3-2603">O valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2603">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2604">O `ldelem.u2` instrução carrega o valor do elemento com índice `index` (tipo `native int`) na matriz unidimensional baseada em zero `array` e o coloca na parte superior da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2604">The `ldelem.u2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="de0f3-2605">Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2605">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="de0f3-2606">O valor de retorno `ldelem.u2` é `int16`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2606">The return value for `ldelem.u2` is `int16`.</span></span>  
  
 <span data-ttu-id="de0f3-2607">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2607">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de0f3-2608"><xref:System.NullReferenceException> será gerada se `array` é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2608"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-2609"><xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2609"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de0f3-2610"><xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2610"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de0f3-2611">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.u2` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2611">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u2` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2612">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2612">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2613">Carrega o elemento com o tipo <see langword="unsigned int32" /> em um índice de matriz especificado para o topo da pilha de avaliação como um <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2613">Loads the element with type <see langword="unsigned int32" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2614">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2614">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2615">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2615">Format</span></span>|<span data-ttu-id="de0f3-2616">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2616">Assembly Format</span></span>|<span data-ttu-id="de0f3-2617">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2617">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2618">95</span><span class="sxs-lookup"><span data-stu-id="de0f3-2618">95</span></span>|<span data-ttu-id="de0f3-2619">Ldelem.U4</span><span class="sxs-lookup"><span data-stu-id="de0f3-2619">ldelem.u4</span></span>|<span data-ttu-id="de0f3-2620">Carrega o elemento com o tipo `unsigned int32` no índice para o topo da pilha de como um `int32`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2620">Loads the element with type `unsigned int32` at index onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="de0f3-2621">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2621">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2622">Uma referência de objeto `array` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2622">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-2623">Um valor de índice `index` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2623">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-2624">`index` e `array` são removidos da pilha; o valor armazenado na posição `index` em `array` é pesquisado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2624">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="de0f3-2625">O valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2625">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2626">O `ldelem.u4` instrução carrega o valor do elemento com índice `index` (tipo `native int`) na matriz unidimensional baseada em zero `array` e o coloca na parte superior da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2626">The `ldelem.u4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="de0f3-2627">Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2627">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="de0f3-2628">O valor de retorno `ldelem.u4` é `int32`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2628">The return value for `ldelem.u4` is `int32`.</span></span>  
  
 <span data-ttu-id="de0f3-2629">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2629">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de0f3-2630"><xref:System.NullReferenceException> será gerada se `array` é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2630"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-2631"><xref:System.ArrayTypeMismatchException> será gerada se a matriz não contém elementos do tipo necessário.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2631"><xref:System.ArrayTypeMismatchException> is thrown if array does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de0f3-2632"><xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2632"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de0f3-2633">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.u4` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2633">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u4` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2634">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2634">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2635">Carrega o endereço do elemento da matriz em um índice de matriz especificado no topo da pilha de avaliação como o tipo <see langword="&amp;" /> (ponteiro gerenciado).</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2635">Loads the address of the array element at a specified array index onto the top of the evaluation stack as type <see langword="&amp;" /> (managed pointer).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2636">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2636">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2637">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2637">Format</span></span>|<span data-ttu-id="de0f3-2638">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2638">Assembly Format</span></span>|<span data-ttu-id="de0f3-2639">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2639">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2640">8F < `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-2640">8F < `T` ></span></span>|<span data-ttu-id="de0f3-2641">faltando ldelema `class`</span><span class="sxs-lookup"><span data-stu-id="de0f3-2641">ldelema `class`</span></span>|<span data-ttu-id="de0f3-2642">Carrega o endereço do elemento na matriz `index` para o topo da pilha de avaliação como tipo `&` (ponteiro gerenciado).</span><span class="sxs-lookup"><span data-stu-id="de0f3-2642">Loads the address of the array element at `index` onto the top of the evaluation stack as type `&` (managed pointer).</span></span>|  
  
 <span data-ttu-id="de0f3-2643">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2643">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2644">Uma referência de objeto `array` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2644">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-2645">Um valor de índice `index` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2645">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-2646">`index` e `array` são removidos da pilha; o endereço armazenado na posição `index` em `array` é pesquisado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2646">`index` and `array` are popped from the stack; the address stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="de0f3-2647">O endereço é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2647">The address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2648">O `ldelema` é usado para recuperar o endereço de um objeto em um índice específico em uma matriz de objetos (do tipo `class`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-2648">The `ldelema` is used to retrieve the address of an object at a particular index in an array of objects (of type `class`).</span></span> <span data-ttu-id="de0f3-2649">O `ldelema` instrução carrega o endereço do valor no índice `index` (tipo `native int`) na matriz unidimensional baseada em zero `array` e o coloca na parte superior da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2649">The `ldelema` instruction loads the address of the value at index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="de0f3-2650">Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2650">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="de0f3-2651">O valor deve ser do tipo `class` transmitido com a instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2651">The value must be of type `class` passed with the instruction.</span></span>  
  
 <span data-ttu-id="de0f3-2652">O valor de retorno `ldelema` é um ponteiro gerenciado (tipo `&`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-2652">The return value for `ldelema` is a managed pointer (type `&`).</span></span>  
  
 <span data-ttu-id="de0f3-2653">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2653">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de0f3-2654"><xref:System.NullReferenceException> será gerada se `array` é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2654"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-2655"><xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2655"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de0f3-2656"><xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2656"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de0f3-2657">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelema` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2657">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelema` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2658">ILGenerator.Emit (OpCode, tipo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2658">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2659">Localiza o valor de um campo no objeto cuja referência está na pilha de avaliação no momento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2659">Finds the value of a field in the object whose reference is currently on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2660">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2660">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2661">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2661">Format</span></span>|<span data-ttu-id="de0f3-2662">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2662">Assembly Format</span></span>|<span data-ttu-id="de0f3-2663">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2663">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2664">7B &LT; `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-2664">7B < `T` ></span></span>|<span data-ttu-id="de0f3-2665">ldfld `field`</span><span class="sxs-lookup"><span data-stu-id="de0f3-2665">ldfld `field`</span></span>|<span data-ttu-id="de0f3-2666">Envia o valor de um campo em um objeto especificado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2666">Pushes the value of a field in a specified object onto the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-2667">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2667">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2668">Uma referência de objeto (ou um ponteiro) é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2668">An object reference (or pointer) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-2669">A referência de objeto (ou ponteiro) é aparecido da pilha; o valor do campo no objeto especificado for encontrado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2669">The object reference (or pointer) is popped from the stack; the value of the specified field in the object is found.</span></span>  
  
3.  <span data-ttu-id="de0f3-2670">O valor armazenado no campo será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2670">The value stored in the field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2671">O `ldfld` instrução envia o valor de um campo localizado em um objeto para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2671">The `ldfld` instruction pushes the value of a field located in an object onto the stack.</span></span> <span data-ttu-id="de0f3-2672">O objeto deve estar na pilha como uma referência de objeto (tipo `O`), um ponteiro gerenciado (tipo `&`), um ponteiro não gerenciado (tipo `native int`), um ponteiro transitório (tipo `*`), ou uma instância de um tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2672">The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type.</span></span> <span data-ttu-id="de0f3-2673">O uso de um ponteiro não gerenciado não é permitido no código verificável.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2673">The use of an unmanaged pointer is not permitted in verifiable code.</span></span> <span data-ttu-id="de0f3-2674">Campo do objeto é especificado por um token de metadados que deve se referir a um membro de campo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2674">The object's field is specified by a metadata token that must refer to a field member.</span></span> <span data-ttu-id="de0f3-2675">O tipo de retorno é o mesmo que aquele associado ao campo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2675">The return type is the same as the one associated with the field.</span></span> <span data-ttu-id="de0f3-2676">O campo pode ser um campo de instância (nesse caso, o objeto não deve ser uma referência nula) ou um campo estático.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2676">The field may be either an instance field (in which case the object must not be a null reference) or a static field.</span></span>  
  
 <span data-ttu-id="de0f3-2677">O `ldfld` instrução pode ser precedida por um ou ambos os <xref:System.Reflection.Emit.OpCodes.Unaligned> e <xref:System.Reflection.Emit.OpCodes.Volatile> prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2677">The `ldfld` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes.</span></span>  
  
 <span data-ttu-id="de0f3-2678"><xref:System.NullReferenceException> será gerada se o objeto é nulo e o campo não é estático.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2678"><xref:System.NullReferenceException> is thrown if the object is null and the field is not static.</span></span>  
  
 <span data-ttu-id="de0f3-2679"><xref:System.MissingFieldException> será gerada se o campo especificado não for encontrado nos metadados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2679"><xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata.</span></span> <span data-ttu-id="de0f3-2680">Normalmente, isso é verificado quando instruções Microsoft Intermediate Language (MSIL) são convertidos em código nativo, não em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2680">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="de0f3-2681">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldfld` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2681">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldfld` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2682">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2682">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2683">Localiza o endereço de um campo no objeto cuja referência está na pilha de avaliação no momento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2683">Finds the address of a field in the object whose reference is currently on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2684">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2684">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2685">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2685">Format</span></span>|<span data-ttu-id="de0f3-2686">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2686">Assembly Format</span></span>|<span data-ttu-id="de0f3-2687">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2687">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2688">7C &LT; `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-2688">7C < `T` ></span></span>|<span data-ttu-id="de0f3-2689">ldflda `field`</span><span class="sxs-lookup"><span data-stu-id="de0f3-2689">ldflda `field`</span></span>|<span data-ttu-id="de0f3-2690">Envia o endereço de `field` em um objeto especificado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2690">Pushes the address of `field` in a specified object onto the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-2691">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2691">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2692">Uma referência de objeto (ou um ponteiro) é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2692">An object reference (or pointer) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-2693">A referência de objeto (ou ponteiro) é aparecido da pilha; o endereço do campo no objeto especificado for encontrado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2693">The object reference (or pointer) is popped from the stack; the address of the specified field in the object is found.</span></span>  
  
3.  <span data-ttu-id="de0f3-2694">O endereço do campo especificado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2694">The address of the specified field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2695">O `ldflda` instrução envia o endereço de um campo localizado em um objeto para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2695">The `ldflda` instruction pushes the address of a field located in an object onto the stack.</span></span> <span data-ttu-id="de0f3-2696">O objeto deve estar na pilha como uma referência de objeto (tipo `O`), um ponteiro gerenciado (tipo `&`), um ponteiro não gerenciado (tipo `native int`), um ponteiro transitório (tipo `*`), ou uma instância de um tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2696">The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type.</span></span> <span data-ttu-id="de0f3-2697">O uso de um ponteiro não gerenciado não é permitido no código verificável.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2697">The use of an unmanaged pointer is not permitted in verifiable code.</span></span> <span data-ttu-id="de0f3-2698">Campo do objeto é especificado por um token de metadados que deve se referir a um membro de campo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2698">The object's field is specified by a metadata token that must refer to a field member.</span></span>  
  
 <span data-ttu-id="de0f3-2699">O valor retornado por `ldflda` é um ponteiro gerenciado (tipo `&`), a menos que o objeto é inserido na pilha como um ponteiro não gerenciado, nesse caso, o endereço de retorno é também um ponteiro não gerenciado (tipo `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-2699">The value returned by `ldflda` is a managed pointer (type `&`) unless the object is pushed onto the stack as an unmanaged pointer, in which case the return address is also an unmanaged pointer (type `native int`).</span></span>  
  
 <span data-ttu-id="de0f3-2700">O `ldflda` instrução pode ser precedida por um ou ambos os <xref:System.Reflection.Emit.OpCodes.Unaligned> e <xref:System.Reflection.Emit.OpCodes.Volatile> prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2700">The `ldflda` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes.</span></span>  
  
 <span data-ttu-id="de0f3-2701"><xref:System.InvalidOperationException> será gerada se o objeto não está dentro do domínio de aplicativo do qual ele está sendo acessado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2701"><xref:System.InvalidOperationException> is thrown if the object is not within the application domain from which it is being accessed.</span></span> <span data-ttu-id="de0f3-2702">O endereço de um campo que não está dentro do domínio do aplicativo ao acessar não foi carregado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2702">The address of a field that is not inside the accessing application domain cannot be loaded.</span></span>  
  
 <span data-ttu-id="de0f3-2703"><xref:System.NullReferenceException> será gerada se o objeto é nulo e o campo não é estático.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2703"><xref:System.NullReferenceException> is thrown if the object is null and the field is not static.</span></span>  
  
 <span data-ttu-id="de0f3-2704"><xref:System.MissingFieldException> será gerada se o campo especificado não for encontrado nos metadados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2704"><xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata.</span></span> <span data-ttu-id="de0f3-2705">Normalmente, isso é verificado quando instruções Microsoft Intermediate Language (MSIL) são convertidos em código nativo, não em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2705">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="de0f3-2706">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldflda` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2706">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldflda` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2707">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2707">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2708">Envia um ponteiro não gerenciado (tipo <see langword="native int" />) para o código nativo implementando um método específico na pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2708">Pushes an unmanaged pointer (type <see langword="native int" />) to the native code implementing a specific method onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2709">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2709">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2710">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2710">Format</span></span>|<span data-ttu-id="de0f3-2711">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2711">Assembly Format</span></span>|<span data-ttu-id="de0f3-2712">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2712">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2713">FE 06 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-2713">FE 06 < `T` ></span></span>|<span data-ttu-id="de0f3-2714">ldftn `method`</span><span class="sxs-lookup"><span data-stu-id="de0f3-2714">ldftn `method`</span></span>|<span data-ttu-id="de0f3-2715">Envia um ponteiro para um método referenciado pelo `method` na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2715">Pushes a pointer to a method referenced by `method` on the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-2716">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2716">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2717">O ponteiro não gerenciado para um método específico é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2717">The unmanaged pointer to a specific method is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2718">O método específico (`method`) pode ser chamado usando o <xref:System.Reflection.Emit.OpCodes.Calli> instrução se ele fizer referência a um método gerenciado (ou um stub que faz a transição de código gerenciado para código não gerenciado).</span><span class="sxs-lookup"><span data-stu-id="de0f3-2718">The specific method (`method`) can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</span></span>  
  
 <span data-ttu-id="de0f3-2719">O valor retornado pontos para código nativo usando o convenção de chamada do CLR.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2719">The value returned points to native code using the CLR calling convention.</span></span> <span data-ttu-id="de0f3-2720">Esse ponteiro de método não deve ser passado para código nativo não gerenciado como uma rotina de retorno de chamada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2720">This method pointer should not be passed to unmanaged native code as a callback routine.</span></span>  
  
 <span data-ttu-id="de0f3-2721">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldftn` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2721">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldftn` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2722">ILGenerator.Emit (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2722">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2723">Carrega um valor do tipo <see langword="native int" /> como um <see langword="native int" /> na pilha de avaliação indiretamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2723">Loads a value of type <see langword="native int" /> as a <see langword="native int" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2724">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2724">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2725">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2725">Format</span></span>|<span data-ttu-id="de0f3-2726">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2726">Assembly Format</span></span>|<span data-ttu-id="de0f3-2727">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2727">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2728">4D</span><span class="sxs-lookup"><span data-stu-id="de0f3-2728">4D</span></span>|<span data-ttu-id="de0f3-2729">ldind.i</span><span class="sxs-lookup"><span data-stu-id="de0f3-2729">ldind.i</span></span>|<span data-ttu-id="de0f3-2730">Carrega o `native int` valor no endereço `addr` para a pilha como um `native int`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2730">Loads the `native int` value at address `addr` onto the stack as a `native int`.</span></span>|  
  
 <span data-ttu-id="de0f3-2731">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2731">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2732">Um endereço será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2732">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-2733">O endereço é aparecido da pilha; o valor localizado no endereço é buscado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2733">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="de0f3-2734">O valor buscado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2734">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2735">O `ldind.i` instrução indiretamente carrega um `native int` o valor do endereço especificado (do tipo `native int`, `&`, ou \*) para a pilha como um `native int`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2735">The `ldind.i` instruction indirectly loads a `native int` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a `native int`.</span></span>  
  
 <span data-ttu-id="de0f3-2736">Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interno correspondente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2736">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="de0f3-2737">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2737">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="de0f3-2738">Valores de ponto flutuante são convertidos em `F` digite quando carregado na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2738">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de0f3-2739">Formado corretamente MSIL Microsoft Intermediate Language () garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2739">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="de0f3-2740">O endereço inserido inicialmente na pilha deve estar alinhado no tamanho natural de objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte a <xref:System.Reflection.Emit.OpCodes.Unaligned> instruções para medidas preventivas de prefixo).</span><span class="sxs-lookup"><span data-stu-id="de0f3-2740">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="de0f3-2741">Os resultados de todas as instruções de MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2741">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="de0f3-2742">Para tipos de dados maiores que 1 byte, a ordenação de bytes é dependente de CPU de destino.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2742">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="de0f3-2743">Código que depende da ordem de bytes pode não ser executado em todas as plataformas.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2743">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="de0f3-2744"><xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2744"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de0f3-2745">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.i` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2745">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2746">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2746">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2747">Carrega um valor do tipo <see langword="int8" /> como um <see langword="int32" /> na pilha de avaliação indiretamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2747">Loads a value of type <see langword="int8" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2748">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2748">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2749">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2749">Format</span></span>|<span data-ttu-id="de0f3-2750">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2750">Assembly Format</span></span>|<span data-ttu-id="de0f3-2751">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2751">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2752">46</span><span class="sxs-lookup"><span data-stu-id="de0f3-2752">46</span></span>|<span data-ttu-id="de0f3-2753">ldind.I1</span><span class="sxs-lookup"><span data-stu-id="de0f3-2753">ldind.i1</span></span>|<span data-ttu-id="de0f3-2754">Carrega o `int8` valor no endereço `addr` para a pilha como um `int32`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2754">Loads the `int8` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="de0f3-2755">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2755">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2756">Um endereço será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2756">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-2757">O endereço é aparecido da pilha; o valor localizado no endereço é buscado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2757">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="de0f3-2758">O valor buscado é enviado para a pilha...</span><span class="sxs-lookup"><span data-stu-id="de0f3-2758">The fetched value is pushed onto the stack..</span></span>  
  
 <span data-ttu-id="de0f3-2759">O `ldind.i1` instrução indiretamente carrega um `int8` o valor do endereço especificado (do tipo `native int`, `&`, ou \*) para a pilha como um `int32`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2759">The `ldind.i1` instruction indirectly loads an `int8` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="de0f3-2760">Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interno correspondente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2760">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="de0f3-2761">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2761">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="de0f3-2762">Valores de ponto flutuante são convertidos em `F` digite quando carregado na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2762">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de0f3-2763">Formado corretamente MSIL Microsoft Intermediate Language () garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2763">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="de0f3-2764">O endereço inserido inicialmente na pilha deve estar alinhado no tamanho natural de objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte a <xref:System.Reflection.Emit.OpCodes.Unaligned> instruções para medidas preventivas de prefixo).</span><span class="sxs-lookup"><span data-stu-id="de0f3-2764">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="de0f3-2765">Os resultados de todas as instruções de MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2765">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="de0f3-2766">Para tipos de dados maiores que 1 byte, a ordenação de bytes é dependente de CPU de destino.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2766">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="de0f3-2767">Código que depende da ordem de bytes pode não ser executado em todas as plataformas.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2767">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="de0f3-2768"><xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2768"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de0f3-2769">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.i1` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2769">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i1` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2770">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2770">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2771">Carrega um valor do tipo <see langword="int16" /> como um <see langword="int32" /> na pilha de avaliação indiretamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2771">Loads a value of type <see langword="int16" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2772">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2772">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2773">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2773">Format</span></span>|<span data-ttu-id="de0f3-2774">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2774">Assembly Format</span></span>|<span data-ttu-id="de0f3-2775">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2775">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2776">48</span><span class="sxs-lookup"><span data-stu-id="de0f3-2776">48</span></span>|<span data-ttu-id="de0f3-2777">ldind.I2</span><span class="sxs-lookup"><span data-stu-id="de0f3-2777">ldind.i2</span></span>|<span data-ttu-id="de0f3-2778">Carrega o `int16` valor no endereço `addr` para a pilha como um `int32`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2778">Loads the `int16` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="de0f3-2779">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2779">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2780">Um endereço será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2780">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-2781">O endereço é aparecido da pilha; o valor localizado no endereço é buscado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2781">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="de0f3-2782">O valor buscado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2782">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2783">O `ldind.i2` instrução indiretamente carrega um `int16` o valor do endereço especificado (do tipo `native int`, `&`, ou \*) para a pilha como um `int32`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2783">The `ldind.i2` instruction indirectly loads an `int16` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="de0f3-2784">Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interno correspondente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2784">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="de0f3-2785">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2785">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="de0f3-2786">Valores de ponto flutuante são convertidos em `F` digite quando carregado na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2786">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de0f3-2787">Formado corretamente MSIL Microsoft Intermediate Language () garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2787">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="de0f3-2788">O endereço inserido inicialmente na pilha deve estar alinhado no tamanho natural de objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte a <xref:System.Reflection.Emit.OpCodes.Unaligned> instruções para medidas preventivas de prefixo).</span><span class="sxs-lookup"><span data-stu-id="de0f3-2788">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="de0f3-2789">Os resultados de todas as instruções de MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2789">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="de0f3-2790">Para tipos de dados maiores que 1 byte, a ordenação de bytes é dependente de CPU de destino.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2790">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="de0f3-2791">Código que depende da ordem de bytes pode não ser executado em todas as plataformas.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2791">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="de0f3-2792"><xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2792"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de0f3-2793">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.i2` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2793">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i2` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2794">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2794">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2795">Carrega um valor do tipo <see langword="int32" /> como um <see langword="int32" /> na pilha de avaliação indiretamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2795">Loads a value of type <see langword="int32" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2796">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2796">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2797">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2797">Format</span></span>|<span data-ttu-id="de0f3-2798">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2798">Assembly Format</span></span>|<span data-ttu-id="de0f3-2799">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2799">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2800">4A</span><span class="sxs-lookup"><span data-stu-id="de0f3-2800">4A</span></span>|<span data-ttu-id="de0f3-2801">ldind.i4</span><span class="sxs-lookup"><span data-stu-id="de0f3-2801">ldind.i4</span></span>|<span data-ttu-id="de0f3-2802">Carrega o `int32` valor no endereço `addr` para a pilha como um `int32`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2802">Loads the `int32` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="de0f3-2803">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2803">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2804">Um endereço será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2804">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-2805">O endereço é aparecido da pilha; o valor localizado no endereço é buscado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2805">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="de0f3-2806">O valor buscado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2806">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2807">O `ldind.i4` instrução indiretamente carrega um `int32` o valor do endereço especificado (do tipo `native int`, `&`, ou \*) para a pilha como um `int32`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2807">The `ldind.i4` instruction indirectly loads an `int32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="de0f3-2808">Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interno correspondente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2808">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="de0f3-2809">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2809">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="de0f3-2810">Valores de ponto flutuante são convertidos em `F` digite quando carregado na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2810">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de0f3-2811">Formado corretamente MSIL Microsoft Intermediate Language () garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2811">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="de0f3-2812">O endereço inserido inicialmente na pilha deve estar alinhado no tamanho natural de objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte a <xref:System.Reflection.Emit.OpCodes.Unaligned> instruções para medidas preventivas de prefixo).</span><span class="sxs-lookup"><span data-stu-id="de0f3-2812">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="de0f3-2813">Os resultados de todas as instruções de MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2813">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="de0f3-2814">Para tipos de dados maiores que 1 byte, a ordenação de bytes é dependente de CPU de destino.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2814">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="de0f3-2815">Código que depende da ordem de bytes pode não ser executado em todas as plataformas.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2815">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="de0f3-2816"><xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2816"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de0f3-2817">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.i4` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2817">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i4` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2818">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2818">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2819">Carrega um valor do tipo <see langword="int64" /> como um <see langword="int64" /> na pilha de avaliação indiretamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2819">Loads a value of type <see langword="int64" /> as an <see langword="int64" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2820">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2820">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2821">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2821">Format</span></span>|<span data-ttu-id="de0f3-2822">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2822">Assembly Format</span></span>|<span data-ttu-id="de0f3-2823">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2823">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2824">4C</span><span class="sxs-lookup"><span data-stu-id="de0f3-2824">4C</span></span>|<span data-ttu-id="de0f3-2825">ldind.I8</span><span class="sxs-lookup"><span data-stu-id="de0f3-2825">ldind.i8</span></span>|<span data-ttu-id="de0f3-2826">Carrega o `int64` valor no endereço `addr` para a pilha como um `int64`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2826">Loads the `int64` value at address `addr` onto the stack as an `int64`.</span></span>|  
  
 <span data-ttu-id="de0f3-2827">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2827">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2828">Um endereço será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2828">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-2829">O endereço é aparecido da pilha; o valor localizado no endereço é buscado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2829">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="de0f3-2830">O valor buscado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2830">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2831">O `ldind.i8` instrução indiretamente carrega um `int64` o valor do endereço especificado (do tipo `native int`, `&`, ou \*) para a pilha como um `int64`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2831">The `ldind.i8` instruction indirectly loads an `int64` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int64`.</span></span>  
  
 <span data-ttu-id="de0f3-2832">Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interno correspondente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2832">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="de0f3-2833">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2833">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="de0f3-2834">Valores de ponto flutuante são convertidos em `F` digite quando carregado na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2834">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de0f3-2835">Formado corretamente MSIL Microsoft Intermediate Language () garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2835">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="de0f3-2836">O endereço inserido inicialmente na pilha deve estar alinhado no tamanho natural de objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte a <xref:System.Reflection.Emit.OpCodes.Unaligned> instruções para medidas preventivas de prefixo).</span><span class="sxs-lookup"><span data-stu-id="de0f3-2836">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="de0f3-2837">Os resultados de todas as instruções de MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2837">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="de0f3-2838">Para tipos de dados maiores que 1 byte, a ordenação de bytes é dependente de CPU de destino.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2838">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="de0f3-2839">Código que depende da ordem de bytes pode não ser executado em todas as plataformas.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2839">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="de0f3-2840"><xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2840"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de0f3-2841">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.i8` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2841">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i8` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2842">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2842">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2843">Carrega um valor do tipo <see langword="float32" /> como um tipo <see langword="F" /> (float) para a pilha de avaliação indiretamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2843">Loads a value of type <see langword="float32" /> as a type <see langword="F" /> (float) onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2844">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2844">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2845">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2845">Format</span></span>|<span data-ttu-id="de0f3-2846">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2846">Assembly Format</span></span>|<span data-ttu-id="de0f3-2847">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2847">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2848">4E</span><span class="sxs-lookup"><span data-stu-id="de0f3-2848">4E</span></span>|<span data-ttu-id="de0f3-2849">ldind.R4</span><span class="sxs-lookup"><span data-stu-id="de0f3-2849">ldind.r4</span></span>|<span data-ttu-id="de0f3-2850">Carrega o `float32` valor no endereço `addr` para a pilha como um tipo `F`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2850">Loads the `float32` value at address `addr` onto the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="de0f3-2851">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2851">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2852">Um endereço será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2852">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-2853">O endereço é aparecido da pilha; o valor localizado no endereço é buscado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2853">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="de0f3-2854">O valor buscado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2854">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2855">O `ldind.r4` instrução indiretamente carrega um `float32` o valor do endereço especificado (do tipo `native int`, `&`, ou \*) para a pilha como um tipo `F`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2855">The `ldind.r4` instruction indirectly loads a `float32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a type `F`.</span></span>  
  
 <span data-ttu-id="de0f3-2856">Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interno correspondente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2856">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="de0f3-2857">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2857">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="de0f3-2858">Valores de ponto flutuante são convertidos em `F` digite quando carregado na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2858">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de0f3-2859">Formado corretamente MSIL Microsoft Intermediate Language () garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2859">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="de0f3-2860">O endereço inserido inicialmente na pilha deve estar alinhado no tamanho natural de objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte a <xref:System.Reflection.Emit.OpCodes.Unaligned> instruções para medidas preventivas de prefixo).</span><span class="sxs-lookup"><span data-stu-id="de0f3-2860">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="de0f3-2861">Os resultados de todas as instruções de MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2861">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="de0f3-2862">Para tipos de dados maiores que 1 byte, a ordenação de bytes é dependente de CPU de destino.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2862">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="de0f3-2863">Código que depende da ordem de bytes pode não ser executado em todas as plataformas.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2863">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="de0f3-2864"><xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2864"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de0f3-2865">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.r4` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2865">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r4` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2866">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2866">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2867">Carrega um valor do tipo <see langword="float64" /> como um tipo <see langword="F" /> (float) para a pilha de avaliação indiretamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2867">Loads a value of type <see langword="float64" /> as a type <see langword="F" /> (float) onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2868">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2868">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2869">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2869">Format</span></span>|<span data-ttu-id="de0f3-2870">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2870">Assembly Format</span></span>|<span data-ttu-id="de0f3-2871">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2871">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2872">4F</span><span class="sxs-lookup"><span data-stu-id="de0f3-2872">4F</span></span>|<span data-ttu-id="de0f3-2873">ldind.R8</span><span class="sxs-lookup"><span data-stu-id="de0f3-2873">ldind.r8</span></span>|<span data-ttu-id="de0f3-2874">Carrega o `float64` valor no endereço `addr` para a pilha como um tipo `F`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2874">Loads the `float64` value at address `addr` onto the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="de0f3-2875">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2875">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2876">Um endereço será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2876">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-2877">O endereço é aparecido da pilha; o valor localizado no endereço é buscado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2877">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="de0f3-2878">O valor buscado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2878">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2879">O `ldind.r8` instrução indiretamente carrega um `float64` o valor do endereço especificado (do tipo `native int`, `&`, ou \*) para a pilha como um `float64`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2879">The `ldind.r8` instruction indirectly loads a `float64` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a `float64`.</span></span>  
  
 <span data-ttu-id="de0f3-2880">Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interno correspondente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2880">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="de0f3-2881">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2881">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="de0f3-2882">Valores de ponto flutuante são convertidos em `F` digite quando carregado na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2882">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de0f3-2883">Formado corretamente MSIL Microsoft Intermediate Language () garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2883">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="de0f3-2884">O endereço inserido inicialmente na pilha deve estar alinhado no tamanho natural de objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte a <xref:System.Reflection.Emit.OpCodes.Unaligned> instruções para medidas preventivas de prefixo).</span><span class="sxs-lookup"><span data-stu-id="de0f3-2884">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="de0f3-2885">Os resultados de todas as instruções de MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2885">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="de0f3-2886">Para tipos de dados maiores que 1 byte, a ordenação de bytes é dependente de CPU de destino.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2886">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="de0f3-2887">Código que depende da ordem de bytes pode não ser executado em todas as plataformas.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2887">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="de0f3-2888"><xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2888"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de0f3-2889">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.r8` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2889">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r8` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2890">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2890">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2891">Carrega uma referência de objeto como um tipo <see langword="O" /> (referência de objeto) para a pilha de avaliação indiretamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2891">Loads an object reference as a type <see langword="O" /> (object reference) onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2892">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2892">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2893">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2893">Format</span></span>|<span data-ttu-id="de0f3-2894">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2894">Assembly Format</span></span>|<span data-ttu-id="de0f3-2895">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2895">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2896">50</span><span class="sxs-lookup"><span data-stu-id="de0f3-2896">50</span></span>|<span data-ttu-id="de0f3-2897">ldind.ref</span><span class="sxs-lookup"><span data-stu-id="de0f3-2897">ldind.ref</span></span>|<span data-ttu-id="de0f3-2898">Carrega a referência de objeto no endereço `addr` à pilha como um tipo `O`</span><span class="sxs-lookup"><span data-stu-id="de0f3-2898">Loads the object reference at address `addr` onto the stack as a type `O`</span></span>|  
  
 <span data-ttu-id="de0f3-2899">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2899">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2900">Um endereço será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2900">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-2901">O endereço é aparecido da pilha; a referência de objeto localizada no endereço é buscada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2901">The address is popped from the stack; the object reference located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="de0f3-2902">A referência de busca é enviada para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2902">The fetched reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2903">O `ldind.ref` instrução indiretamente carrega a referência de objeto, o endereço especificado (do tipo `native int`, `&`, ou \*) para a pilha como tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2903">The `ldind.ref` instruction indirectly loads the object reference the specified address (of type `native int`, `&`, or \*) onto the stack as type `O`.</span></span>  
  
 <span data-ttu-id="de0f3-2904">Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interno correspondente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2904">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="de0f3-2905">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2905">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="de0f3-2906">Valores de ponto flutuante são convertidos em `F` digite quando carregado na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2906">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de0f3-2907">Formado corretamente MSIL Microsoft Intermediate Language () garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2907">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="de0f3-2908">O endereço inserido inicialmente na pilha deve estar alinhado no tamanho natural de objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte a <xref:System.Reflection.Emit.OpCodes.Unaligned> instruções para medidas preventivas de prefixo).</span><span class="sxs-lookup"><span data-stu-id="de0f3-2908">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="de0f3-2909">Os resultados de todas as instruções de MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2909">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="de0f3-2910">Para tipos de dados maiores que 1 byte, a ordenação de bytes é dependente de CPU de destino.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2910">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="de0f3-2911">Código que depende da ordem de bytes pode não ser executado em todas as plataformas.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2911">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="de0f3-2912"><xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2912"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de0f3-2913">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.ref` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2913">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.ref` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2914">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2914">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2915">Carrega um valor do tipo <see langword="unsigned int8" /> como um <see langword="int32" /> na pilha de avaliação indiretamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2915">Loads a value of type <see langword="unsigned int8" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2916">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2916">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2917">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2917">Format</span></span>|<span data-ttu-id="de0f3-2918">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2918">Assembly Format</span></span>|<span data-ttu-id="de0f3-2919">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2919">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2920">47</span><span class="sxs-lookup"><span data-stu-id="de0f3-2920">47</span></span>|<span data-ttu-id="de0f3-2921">ldind.U1</span><span class="sxs-lookup"><span data-stu-id="de0f3-2921">ldind.u1</span></span>|<span data-ttu-id="de0f3-2922">Carrega o `unsigned int8` valor no endereço `addr` para a pilha como um `int32`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2922">Loads the `unsigned int8` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="de0f3-2923">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2923">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2924">Um endereço será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2924">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-2925">O endereço é aparecido da pilha; o valor localizado no endereço é buscado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2925">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="de0f3-2926">O valor buscado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2926">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2927">O `ldind.u1` instrução indiretamente carrega um `unsigned int8` o valor do endereço especificado (do tipo`native int`, `&`, ou \*) para a pilha como um `int32`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2927">The `ldind.u1` instruction indirectly loads an `unsigned int8` value from the specified address (of type`native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="de0f3-2928">Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interno correspondente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2928">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="de0f3-2929">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2929">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="de0f3-2930">Valores de ponto flutuante são convertidos em `F` digite quando carregado na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2930">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de0f3-2931">Formado corretamente MSIL Microsoft Intermediate Language () garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2931">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="de0f3-2932">O endereço inserido inicialmente na pilha deve estar alinhado no tamanho natural de objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte a <xref:System.Reflection.Emit.OpCodes.Unaligned> instruções para medidas preventivas de prefixo).</span><span class="sxs-lookup"><span data-stu-id="de0f3-2932">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="de0f3-2933">Os resultados de todas as instruções de MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2933">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="de0f3-2934">Para tipos de dados maiores que 1 byte, a ordenação de bytes é dependente de CPU de destino.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2934">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="de0f3-2935">Código que depende da ordem de bytes pode não ser executado em todas as plataformas.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2935">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="de0f3-2936"><xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2936"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de0f3-2937">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.u1` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2937">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u1` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2938">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2938">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2939">Carrega um valor do tipo <see langword="unsigned int16" /> como um <see langword="int32" /> na pilha de avaliação indiretamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2939">Loads a value of type <see langword="unsigned int16" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2940">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2940">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2941">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2941">Format</span></span>|<span data-ttu-id="de0f3-2942">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2942">Assembly Format</span></span>|<span data-ttu-id="de0f3-2943">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2943">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2944">49</span><span class="sxs-lookup"><span data-stu-id="de0f3-2944">49</span></span>|<span data-ttu-id="de0f3-2945">ldind.U2</span><span class="sxs-lookup"><span data-stu-id="de0f3-2945">ldind.u2</span></span>|<span data-ttu-id="de0f3-2946">Carrega o `unsigned int16` valor no endereço `addr` para a pilha como um `int32`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2946">Loads the `unsigned int16` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="de0f3-2947">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2947">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2948">Um endereço será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2948">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-2949">O endereço é aparecido da pilha; o valor localizado no endereço é buscado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2949">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="de0f3-2950">O valor buscado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2950">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2951">O `ldind.u2` instrução indiretamente carrega um `unsigned int16` o valor do endereço especificado (do tipo `native int`, `&`, ou \*) para a pilha como um `int32`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2951">The `ldind.u2` instruction indirectly loads an `unsigned int16` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="de0f3-2952">Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interno correspondente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2952">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="de0f3-2953">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2953">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="de0f3-2954">Valores de ponto flutuante são convertidos em `F` digite quando carregado na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2954">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de0f3-2955">Formado corretamente MSIL Microsoft Intermediate Language () garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2955">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="de0f3-2956">O endereço inserido inicialmente na pilha deve estar alinhado no tamanho natural de objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte a <xref:System.Reflection.Emit.OpCodes.Unaligned> instruções para medidas preventivas de prefixo).</span><span class="sxs-lookup"><span data-stu-id="de0f3-2956">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="de0f3-2957">Os resultados de todas as instruções de MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2957">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="de0f3-2958">Para tipos de dados maiores que 1 byte, a ordenação de bytes é dependente de CPU de destino.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2958">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="de0f3-2959">Código que depende da ordem de bytes pode não ser executado em todas as plataformas.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2959">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="de0f3-2960"><xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2960"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de0f3-2961">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.u2` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2961">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u2` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2962">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2962">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2963">Carrega um valor do tipo <see langword="unsigned int32" /> como um <see langword="int32" /> na pilha de avaliação indiretamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2963">Loads a value of type <see langword="unsigned int32" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2964">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2964">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2965">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2965">Format</span></span>|<span data-ttu-id="de0f3-2966">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2966">Assembly Format</span></span>|<span data-ttu-id="de0f3-2967">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2967">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2968">4B</span><span class="sxs-lookup"><span data-stu-id="de0f3-2968">4B</span></span>|<span data-ttu-id="de0f3-2969">ldind.U4</span><span class="sxs-lookup"><span data-stu-id="de0f3-2969">ldind.u4</span></span>|<span data-ttu-id="de0f3-2970">Carrega o `unsigned int32` valor no endereço `addr` para a pilha como um `int32`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2970">Loads the `unsigned int32` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="de0f3-2971">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2971">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2972">Um endereço será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2972">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-2973">O endereço é aparecido da pilha; o valor localizado no endereço é buscado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2973">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="de0f3-2974">O valor buscado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2974">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2975">O `ldind.u4` instrução indiretamente carrega um `unsigned int32` o valor do endereço especificado (do tipo `native int`, `&`, ou \*) para a pilha como um `int32`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2975">The `ldind.u4` instruction indirectly loads an `unsigned int32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="de0f3-2976">Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interno correspondente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2976">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="de0f3-2977">Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2977">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="de0f3-2978">Valores de ponto flutuante são convertidos em `F` digite quando carregado na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2978">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de0f3-2979">Formado corretamente MSIL Microsoft Intermediate Language () garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2979">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="de0f3-2980">O endereço inserido inicialmente na pilha deve estar alinhado no tamanho natural de objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte a <xref:System.Reflection.Emit.OpCodes.Unaligned> instruções para medidas preventivas de prefixo).</span><span class="sxs-lookup"><span data-stu-id="de0f3-2980">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="de0f3-2981">Os resultados de todas as instruções de MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2981">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="de0f3-2982">Para tipos de dados maiores que 1 byte, a ordenação de bytes é dependente de CPU de destino.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2982">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="de0f3-2983">Código que depende da ordem de bytes pode não ser executado em todas as plataformas.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2983">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="de0f3-2984"><xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2984"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de0f3-2985">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.u4` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2985">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u4` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-2986">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-2986">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-2987">Efetua o push do número de elementos de uma matriz unidimensional de base zero para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-2987">Pushes the number of elements of a zero-based, one-dimensional array onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-2988">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2988">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-2989">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-2989">Format</span></span>|<span data-ttu-id="de0f3-2990">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-2990">Assembly Format</span></span>|<span data-ttu-id="de0f3-2991">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-2991">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-2992">8E</span><span class="sxs-lookup"><span data-stu-id="de0f3-2992">8E</span></span>|<span data-ttu-id="de0f3-2993">ldlen</span><span class="sxs-lookup"><span data-stu-id="de0f3-2993">ldlen</span></span>|<span data-ttu-id="de0f3-2994">Envia por push o comprimento (do tipo `natural unsigned int`) de uma matriz na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2994">Pushes the length (of type `natural unsigned int`) of an array on the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-2995">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-2995">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-2996">Uma referência de objeto para uma matriz é enviada para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2996">An object reference to an array is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-2997">A referência de matriz é Aparecida da pilha e o comprimento é computado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2997">The array reference is popped from the stack and the length is computed.</span></span>  
  
3.  <span data-ttu-id="de0f3-2998">O comprimento é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2998">The length is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-2999">Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-2999">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="de0f3-3000">O comprimento é retornado como um `natural unsigned int`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3000">The length is returned as a `natural unsigned int`.</span></span>  
  
 <span data-ttu-id="de0f3-3001"><xref:System.NullReferenceException> será gerada se a referência de matriz é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3001"><xref:System.NullReferenceException> is thrown if the array reference is a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-3002">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldlen` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3002">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldlen` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3003">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3003">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3004">Carrega a variável local em um índice específico na pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3004">Loads the local variable at a specific index onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3005">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3005">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3006">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3006">Format</span></span>|<span data-ttu-id="de0f3-3007">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3007">Assembly Format</span></span>|<span data-ttu-id="de0f3-3008">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3008">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3009">FE 0C &LT; `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-3009">FE 0C < `unsigned int16` ></span></span>|<span data-ttu-id="de0f3-3010">Ldloc `index`</span><span class="sxs-lookup"><span data-stu-id="de0f3-3010">ldloc `index`</span></span>|<span data-ttu-id="de0f3-3011">Carrega a variável local no índice `index` na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3011">Loads the local variable at index `index` onto stack.</span></span>|  
  
 <span data-ttu-id="de0f3-3012">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3012">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3013">O valor da variável local no índice especificado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3013">The local variable value at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3014">O `ldloc` instrução envia por push o conteúdo do número de variável local no índice passado na pilha de avaliação, onde as variáveis locais são numerados de 0 em diante.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3014">The `ldloc` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</span></span> <span data-ttu-id="de0f3-3015">Antes de inserir o método somente se o sinalizador de inicialização no método for verdadeiro, as variáveis locais são inicializadas como 0.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3015">Local variables are initialized to 0 before entering the method only if the initialize flag on the method is true.</span></span> <span data-ttu-id="de0f3-3016">Há 65.535 (2 ^ 16 - 1) as variáveis locais possíveis (0-65.534).</span><span class="sxs-lookup"><span data-stu-id="de0f3-3016">There are 65,535 (2^16-1) local variables possible (0-65,534).</span></span> <span data-ttu-id="de0f3-3017">65.535 de índice não é válido, pois implementações provavelmente usará um inteiro de 2 bytes para controlar o índice de um locais, juntamente com o número total de locais para um determinado método.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3017">Index 65,535 is not valid since likely implementations will use a 2-byte integer to track both a local's index, along with the total number of locals for a given method.</span></span> <span data-ttu-id="de0f3-3018">Se um índice de 65535 tivesse sido feito válido, ele exigiria um inteiro maior controlar o número de locais em um método desse tipo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3018">If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</span></span>  
  
 <span data-ttu-id="de0f3-3019">O `ldloc.0`, `ldloc.1`, `ldloc.2`, e `ldloc.3` instruções fornecem uma codificação eficiente para acessar as primeiras quatro variáveis locais.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3019">The `ldloc.0`, `ldloc.1`, `ldloc.2`, and `ldloc.3` instructions provide an efficient encoding for accessing the first four local variables.</span></span>  
  
 <span data-ttu-id="de0f3-3020">O tipo do valor é igual ao tipo da variável local, que é especificado no cabeçalho de método.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3020">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="de0f3-3021">Consulte partição I. Local variáveis que são menores que 4 bytes de comprimento é expandido para o tipo `int32` quando eles são carregados para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3021">See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="de0f3-3022">Valores de ponto flutuante são expandidas para seu tamanho nativo (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-3022">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="de0f3-3023">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas de método podem usar o `ldloc` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3023">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3024">ILGenerator.Emit (OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3024">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="de0f3-3025">ILGenerator.Emit (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3025">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3026">Carrega a variável local no índice 0 na pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3026">Loads the local variable at index 0 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3027">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3027">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3028">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3028">Format</span></span>|<span data-ttu-id="de0f3-3029">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3029">Assembly Format</span></span>|<span data-ttu-id="de0f3-3030">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3030">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3031">06</span><span class="sxs-lookup"><span data-stu-id="de0f3-3031">06</span></span>|<span data-ttu-id="de0f3-3032">Ldloc.0</span><span class="sxs-lookup"><span data-stu-id="de0f3-3032">ldloc.0</span></span>|<span data-ttu-id="de0f3-3033">Carrega a variável local no índice 0 na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3033">Loads the local variable at index 0 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="de0f3-3034">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3034">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3035">O valor da variável local no índice 0 é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3035">The local variable value at the index 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3036">`ldloc.0` é uma codificação especialmente eficiente para <xref:System.Reflection.Emit.OpCodes.Ldloc>, permitindo o acesso à variável local no índice 0.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3036">`ldloc.0` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 0.</span></span>  
  
 <span data-ttu-id="de0f3-3037">O tipo do valor é igual ao tipo da variável local, que é especificado no cabeçalho de método.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3037">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="de0f3-3038">Variáveis locais que são menores que 4 bytes de comprimento são expandidas para o tipo `int32` quando eles são carregados para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3038">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="de0f3-3039">Valores de ponto flutuante são expandidas para seu tamanho nativo (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-3039">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="de0f3-3040">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldloc.0` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3040">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.0` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3041">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3041">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3042">Carrega a variável local no índice 1 para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3042">Loads the local variable at index 1 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3043">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3043">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3044">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3044">Format</span></span>|<span data-ttu-id="de0f3-3045">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3045">Assembly Format</span></span>|<span data-ttu-id="de0f3-3046">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3046">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3047">07</span><span class="sxs-lookup"><span data-stu-id="de0f3-3047">07</span></span>|<span data-ttu-id="de0f3-3048">Ldloc.1</span><span class="sxs-lookup"><span data-stu-id="de0f3-3048">ldloc.1</span></span>|<span data-ttu-id="de0f3-3049">Carrega a variável local no índice 1 para a pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3049">Loads the local variable at index 1 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="de0f3-3050">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3050">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3051">O valor da variável local no índice 1 é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3051">The local variable value at the index 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3052">`ldloc.1` é uma codificação especialmente eficiente para <xref:System.Reflection.Emit.OpCodes.Ldloc>, permitindo o acesso à variável local no índice 1.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3052">`ldloc.1` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 1.</span></span>  
  
 <span data-ttu-id="de0f3-3053">O tipo do valor é igual ao tipo da variável local, que é especificado no cabeçalho de método.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3053">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="de0f3-3054">Variáveis locais que são menores que 4 bytes de comprimento são expandidas para o tipo `int32` quando eles são carregados para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3054">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="de0f3-3055">Valores de ponto flutuante são expandidas para seu tamanho nativo (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-3055">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="de0f3-3056">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldloc.1` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3056">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.1` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3057">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3057">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3058">Carrega a variável local no índice 2 para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3058">Loads the local variable at index 2 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3059">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3059">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3060">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3060">Format</span></span>|<span data-ttu-id="de0f3-3061">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3061">Assembly Format</span></span>|<span data-ttu-id="de0f3-3062">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3062">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3063">08</span><span class="sxs-lookup"><span data-stu-id="de0f3-3063">08</span></span>|<span data-ttu-id="de0f3-3064">Ldloc.2</span><span class="sxs-lookup"><span data-stu-id="de0f3-3064">ldloc.2</span></span>|<span data-ttu-id="de0f3-3065">Carrega a variável local no índice 2 para a pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3065">Loads the local variable at index 2 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="de0f3-3066">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3066">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3067">O valor da variável local no índice 2 é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3067">The local variable value at the index 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3068">`ldloc.2` é uma codificação especialmente eficiente para <xref:System.Reflection.Emit.OpCodes.Ldloc>, permitindo o acesso à variável local no índice 2.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3068">`ldloc.2` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 2.</span></span>  
  
 <span data-ttu-id="de0f3-3069">O tipo do valor é igual ao tipo da variável local, que é especificado no cabeçalho de método.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3069">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="de0f3-3070">Variáveis locais que são menores que 4 bytes de comprimento são expandidas para o tipo `int32` quando eles são carregados para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3070">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="de0f3-3071">Valores de ponto flutuante são expandidas para seu tamanho nativo (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-3071">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="de0f3-3072">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldloc.2` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3072">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.2` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3073">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3073">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3074">Carrega a variável local no índice 3 para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3074">Loads the local variable at index 3 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3075">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3075">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3076">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3076">Format</span></span>|<span data-ttu-id="de0f3-3077">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3077">Assembly Format</span></span>|<span data-ttu-id="de0f3-3078">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3078">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3079">09</span><span class="sxs-lookup"><span data-stu-id="de0f3-3079">09</span></span>|<span data-ttu-id="de0f3-3080">Ldloc.3</span><span class="sxs-lookup"><span data-stu-id="de0f3-3080">ldloc.3</span></span>|<span data-ttu-id="de0f3-3081">Carrega a variável local no índice 3 para a pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3081">Loads the local variable at index 3 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="de0f3-3082">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3082">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3083">O valor da variável local no índice 3 é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3083">The local variable value at the index 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3084">`ldloc.3` é uma codificação especialmente eficiente para <xref:System.Reflection.Emit.OpCodes.Ldloc>, permitindo o acesso à variável local no índice 3.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3084">`ldloc.3` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 3.</span></span>  
  
 <span data-ttu-id="de0f3-3085">O tipo do valor é igual ao tipo da variável local, que é especificado no cabeçalho de método.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3085">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="de0f3-3086">Variáveis locais que são menores que 4 bytes de comprimento são expandidas para o tipo `int32` quando eles são carregados para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3086">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="de0f3-3087">Valores de ponto flutuante são expandidas para seu tamanho nativo (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-3087">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="de0f3-3088">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldloc.3` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3088">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.3` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3089">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3089">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3090">Carrega a variável local em um índice específico na pilha de avaliação, de forma abreviada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3090">Loads the local variable at a specific index onto the evaluation stack, short form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3091">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3091">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3092">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3092">Format</span></span>|<span data-ttu-id="de0f3-3093">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3093">Assembly Format</span></span>|<span data-ttu-id="de0f3-3094">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3094">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3095">11 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-3095">11 < `unsigned int8` ></span></span>|<span data-ttu-id="de0f3-3096">Ldloc.s `index`</span><span class="sxs-lookup"><span data-stu-id="de0f3-3096">ldloc.s `index`</span></span>|<span data-ttu-id="de0f3-3097">Carrega a variável local no índice `index` na pilha, de forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3097">Loads the local variable at index `index` onto stack, short form.</span></span>|  
  
 <span data-ttu-id="de0f3-3098">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3098">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3099">O valor da variável local no índice especificado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3099">The local variable value at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3100">O `ldloc.s` instrução envia por push o conteúdo do número de variável local no índice passado na pilha de avaliação, onde as variáveis locais são numerados de 0 em diante.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3100">The `ldloc.s` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</span></span> <span data-ttu-id="de0f3-3101">Antes do método de inserção, se o sinalizador de inicialização no método for true, as variáveis locais são inicializadas como 0.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3101">Local variables are initialized to 0 before entering the method if the initialize flag on the method is true.</span></span> <span data-ttu-id="de0f3-3102">Há 256 (2 ^ 8) as variáveis locais possíveis (0 a 255) na forma abreviada, que é uma codificação mais eficiente que `ldloc`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3102">There are 256 (2^8) local variables possible (0-255) in the short form, which is a more efficient encoding than `ldloc`.</span></span>  
  
 <span data-ttu-id="de0f3-3103">O tipo do valor é igual ao tipo da variável local, que é especificado no cabeçalho de método.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3103">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="de0f3-3104">Consulte partição I. Local variáveis que são menores que 4 bytes de comprimento é expandido para o tipo `int32` quando eles são carregados para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3104">See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="de0f3-3105">Valores de ponto flutuante são expandidas para seu tamanho nativo (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-3105">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="de0f3-3106">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas de método podem usar o `ldloc.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3106">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc.s` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3107">ILGenerator.Emit (OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3107">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="de0f3-3108">ILGenerator.Emit (OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3108">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3109">Carrega o endereço da variável local em um índice específico para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3109">Loads the address of the local variable at a specific index onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3110">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3110">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3111">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3111">Format</span></span>|<span data-ttu-id="de0f3-3112">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3112">Assembly Format</span></span>|<span data-ttu-id="de0f3-3113">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3113">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3114">FE OD &LT; `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-3114">FE OD < `unsigned int16` ></span></span>|<span data-ttu-id="de0f3-3115">ldloca `index`</span><span class="sxs-lookup"><span data-stu-id="de0f3-3115">ldloca `index`</span></span>|<span data-ttu-id="de0f3-3116">Carrega o endereço da variável local em `index` na pilha de avaliação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3116">Loads the address of the local variable at `index` onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="de0f3-3117">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3117">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3118">O endereço armazenado na variável local no índice especificado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3118">The address stored in the local variable at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3119">O `ldloca` instrução envia o endereço do número de variável local no índice passado para a pilha, em que as variáveis locais são numeradas de 0 em diante.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3119">The `ldloca` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="de0f3-3120">O valor enviado por push na pilha já alinhado corretamente para uso com instruções, como <xref:System.Reflection.Emit.OpCodes.Ldind_I> e <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3120">The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span></span> <span data-ttu-id="de0f3-3121">O resultado é um ponteiro transitório (tipo `*`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-3121">The result is a transient pointer (type `*`).</span></span>  
  
 <span data-ttu-id="de0f3-3122">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldloca` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3122">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3123">ILGenerator.Emit (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3123">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3124">Carrega o endereço da variável local em um índice específico para a pilha de avaliação, em forma abreviada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3124">Loads the address of the local variable at a specific index onto the evaluation stack, short form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3125">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3125">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3126">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3126">Format</span></span>|<span data-ttu-id="de0f3-3127">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3127">Assembly Format</span></span>|<span data-ttu-id="de0f3-3128">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3128">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3129">12 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-3129">12 < `unsigned int8` ></span></span>|<span data-ttu-id="de0f3-3130">ldloca.s `index`</span><span class="sxs-lookup"><span data-stu-id="de0f3-3130">ldloca.s `index`</span></span>|<span data-ttu-id="de0f3-3131">Carrega o endereço da variável local em `index` na pilha de avaliação, de forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3131">Loads the address of the local variable at `index` onto the evaluation stack, short form.</span></span>|  
  
 <span data-ttu-id="de0f3-3132">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3132">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3133">O endereço armazenado na variável local no índice especificado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3133">The address stored in the local variable at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3134">O `ldloca.s` instrução envia o endereço do número de variável local no índice passado para a pilha, em que as variáveis locais são numeradas de 0 em diante.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3134">The `ldloca.s` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="de0f3-3135">O valor enviado por push na pilha já alinhado corretamente para uso com instruções, como <xref:System.Reflection.Emit.OpCodes.Ldind_I> e <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3135">The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span></span> <span data-ttu-id="de0f3-3136">O resultado é um ponteiro transitório (tipo `*`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-3136">The result is a transient pointer (type `*`).</span></span>  
  
 <span data-ttu-id="de0f3-3137">O `ldloca.s` instrução fornece uma codificação eficiente para uso com as variáveis locais de 0 a 255.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3137">The `ldloca.s` instruction provides an efficient encoding for use with the local variables 0 through 255.</span></span>  
  
 <span data-ttu-id="de0f3-3138">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldloca.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3138">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca.s` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3139">ILGenerator.Emit (OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3139">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3140">Envia uma referência nula (tipo <see langword="O" />) para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3140">Pushes a null reference (type <see langword="O" />) onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3141">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3141">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3142">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3142">Format</span></span>|<span data-ttu-id="de0f3-3143">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3143">Assembly Format</span></span>|<span data-ttu-id="de0f3-3144">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3144">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3145">14</span><span class="sxs-lookup"><span data-stu-id="de0f3-3145">14</span></span>|<span data-ttu-id="de0f3-3146">ldnull</span><span class="sxs-lookup"><span data-stu-id="de0f3-3146">ldnull</span></span>|<span data-ttu-id="de0f3-3147">Enviar por push uma referência nula para a pilha</span><span class="sxs-lookup"><span data-stu-id="de0f3-3147">push a null reference onto the stack</span></span>|  
  
 <span data-ttu-id="de0f3-3148">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3148">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3149">Uma referência de objeto nulo é enviada para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3149">A null object reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3150">`ldnull` envia uma referência nula (tipo `O`) na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3150">`ldnull` pushes a null reference (type `O`) on the stack.</span></span> <span data-ttu-id="de0f3-3151">Isso é usado para inicializar locais antes que eles são preenchidos com dados, ou quando eles se tornam preteridos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3151">This is used to initialize locations before they are populated with data, or when they become deprecated.</span></span>  
  
 <span data-ttu-id="de0f3-3152">`ldnull` Fornece uma referência nula que é independente de tamanho.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3152">`ldnull` provides a null reference that is size-independent.</span></span>  
  
 <span data-ttu-id="de0f3-3153">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldnull` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3153">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldnull` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3154">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3154">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3155">Copia o objeto de tipo de valor apontado por um endereço na parte superior da pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3155">Copies the value type object pointed to by an address to the top of the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3156">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3156">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3157">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3157">Format</span></span>|<span data-ttu-id="de0f3-3158">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3158">Assembly Format</span></span>|<span data-ttu-id="de0f3-3159">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3159">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3160">71 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-3160">71 < `T` ></span></span>|<span data-ttu-id="de0f3-3161">ldobj `class`</span><span class="sxs-lookup"><span data-stu-id="de0f3-3161">ldobj `class`</span></span>|<span data-ttu-id="de0f3-3162">Instância de cópia do tipo de valor `class` na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3162">Copy instance of value type `class` to the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-3163">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3163">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3164">O endereço de um objeto de tipo de valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3164">The address of a value type object is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3165">O endereço é aparecido da pilha e a instância nesse endereço específico é pesquisada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3165">The address is popped from the stack and the instance at that particular address is looked up.</span></span>  
  
3.  <span data-ttu-id="de0f3-3166">O valor do objeto armazenado nesse endereço será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3166">The value of the object stored at that address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3167">O `ldobj` instrução é usada para passar um tipo de valor como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3167">The `ldobj` instruction is used to pass a value type as a parameter.</span></span>  
  
 <span data-ttu-id="de0f3-3168">O `ldobj` instrução copia o valor apontado por `addrOfValObj` (do tipo `&`, `*`, ou `native int`) na parte superior da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3168">The `ldobj` instruction copies the value pointed to by `addrOfValObj` (of type `&`, `*`, or `native int`) to the top of the stack.</span></span> <span data-ttu-id="de0f3-3169">O número de bytes copiados depende do tamanho da classe (conforme especificado pelo `class` parâmetro).</span><span class="sxs-lookup"><span data-stu-id="de0f3-3169">The number of bytes copied depends on the size of the class (as specified by the `class` parameter).</span></span> <span data-ttu-id="de0f3-3170">O `class` parâmetro é um token de metadados que representa o tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3170">The `class` parameter is a metadata token representing the value type.</span></span>  
  
 <span data-ttu-id="de0f3-3171">A operação do `ldobj` instrução pode ser alterada por um imediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instrução de prefixo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3171">The operation of the `ldobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="de0f3-3172"><xref:System.TypeLoadException> será gerada se a classe não pode ser encontrado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3172"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="de0f3-3173">Normalmente, isso é detectado quando a instrução de Microsoft Intermediate Language (MSIL) é convertida em código nativo em vez de em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3173">This is typically detected when the Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="de0f3-3174">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldobj` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3174">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldobj` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3175">ILGenerator.Emit (OpCode, tipo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3175">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3176">Envia por push o valor de um campo estático para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3176">Pushes the value of a static field onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3177">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3177">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3178">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3178">Format</span></span>|<span data-ttu-id="de0f3-3179">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3179">Assembly Format</span></span>|<span data-ttu-id="de0f3-3180">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3180">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3181">7E < `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-3181">7E < `T` ></span></span>|<span data-ttu-id="de0f3-3182">ldsfld `field`</span><span class="sxs-lookup"><span data-stu-id="de0f3-3182">ldsfld `field`</span></span>|<span data-ttu-id="de0f3-3183">Enviar por push o valor de `field` na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3183">Push the value of `field` on the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-3184">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3184">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3185">O valor de campo específico é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3185">The value of the specific field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3186">O `ldsfld` instrução envia o valor de um estático (compartilhado entre todas as instâncias de uma classe) campo na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3186">The `ldsfld` instruction pushes the value of a static (shared among all instances of a class) field on the stack.</span></span> <span data-ttu-id="de0f3-3187">O tipo de retorno é que associado com o token de metadados passado `field`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3187">The return type is that associated with the passed metadata token `field`.</span></span>  
  
 <span data-ttu-id="de0f3-3188">O `ldsfld` instrução pode ter um <xref:System.Reflection.Emit.OpCodes.Volatile> prefixo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3188">The `ldsfld` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix.</span></span>  
  
 <span data-ttu-id="de0f3-3189">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldsfld` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3189">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsfld` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3190">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3190">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3191">Efetua o push do endereço de um campo estático para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3191">Pushes the address of a static field onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3192">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3192">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3193">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3193">Format</span></span>|<span data-ttu-id="de0f3-3194">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3194">Assembly Format</span></span>|<span data-ttu-id="de0f3-3195">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3195">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3196">7F < `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-3196">7F < `T` ></span></span>|<span data-ttu-id="de0f3-3197">ldsflda `field`</span><span class="sxs-lookup"><span data-stu-id="de0f3-3197">ldsflda `field`</span></span>|<span data-ttu-id="de0f3-3198">Enviar por push o endereço do `field` na pilha</span><span class="sxs-lookup"><span data-stu-id="de0f3-3198">Push the address of `field` on the stack</span></span>|  
  
 <span data-ttu-id="de0f3-3199">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3199">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3200">O endereço de um campo específico é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3200">The address of a specific field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3201">O `ldsflda` instrução envia o endereço de um estático (compartilhado entre todas as instâncias de uma classe) campo na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3201">The `ldsflda` instruction pushes the address of a static (shared among all instances of a class) field on the stack.</span></span> <span data-ttu-id="de0f3-3202">O endereço pode ser representado como um ponteiro transitório (tipo `*`) se o token de metadados `field` se refere a um tipo cuja memória é gerenciada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3202">The address may be represented as a transient pointer (type `*`) if the metadata token `field` refers to a type whose memory is managed.</span></span> <span data-ttu-id="de0f3-3203">Caso contrário, ele corresponde a um ponteiro não gerenciado (tipo `native int`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-3203">Otherwise, it corresponds to an unmanaged pointer (type `native int`).</span></span> <span data-ttu-id="de0f3-3204">Observe que `field` pode ser estático global com um endereço de virtual relativo atribuído (o deslocamento do campo do endereço base no qual o arquivo PE que contém é carregado na memória) em que a memória é não gerenciada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3204">Note that `field` may be a static global with an assigned relative virtual address (the offset of the field from the base address at which its containing PE file is loaded into memory) where the memory is unmanaged.</span></span>  
  
 <span data-ttu-id="de0f3-3205">O `ldsflda` instrução pode ter um <xref:System.Reflection.Emit.OpCodes.Volatile> prefixo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3205">The `ldsflda` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix.</span></span>  
  
 <span data-ttu-id="de0f3-3206"><xref:System.MissingFieldException> será gerada se o campo não for encontrado nos metadados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3206"><xref:System.MissingFieldException> is thrown if field is not found in the metadata.</span></span> <span data-ttu-id="de0f3-3207">Normalmente, isso é verificado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo, não em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3207">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at runtime.</span></span>  
  
 <span data-ttu-id="de0f3-3208">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldsflda` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3208">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsflda` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3209">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3209">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3210">Envia por push uma nova referência de objeto para uma literal de cadeia de caracteres armazenada nos metadados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3210">Pushes a new object reference to a string literal stored in the metadata.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3211">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3211">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3212">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3212">Format</span></span>|<span data-ttu-id="de0f3-3213">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3213">Assembly Format</span></span>|<span data-ttu-id="de0f3-3214">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3214">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3215">72 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-3215">72 < `T` ></span></span>|<span data-ttu-id="de0f3-3216">ldstr `mdToken`</span><span class="sxs-lookup"><span data-stu-id="de0f3-3216">ldstr `mdToken`</span></span>|<span data-ttu-id="de0f3-3217">Envia um objeto de cadeia de caracteres para o token de cadeia de caracteres de metadados `mdToken`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3217">Pushes a string object for the metadata string token `mdToken`.</span></span>|  
  
 <span data-ttu-id="de0f3-3218">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3218">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3219">Uma referência de objeto para uma cadeia de caracteres é enviada para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3219">An object reference to a string is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3220">O `ldstr` instrução envia por push uma referência de objeto (tipo `O`) para um novo objeto de cadeia de caracteres que representa a cadeia de caracteres literal armazenada nos metadados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3220">The `ldstr` instruction pushes an object reference (type `O`) to a new string object representing the specific string literal stored in the metadata.</span></span> <span data-ttu-id="de0f3-3221">O `ldstr` instrução aloca a quantidade necessária de memória e executa qualquer conversão de formato necessário para converter a cadeia de caracteres literal do formulário usado no arquivo para o formato de cadeia de caracteres necessário em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3221">The `ldstr` instruction allocates the requisite amount of memory and performs any format conversion required to convert the string literal from the form used in the file to the string format required at runtime.</span></span>  
  
 <span data-ttu-id="de0f3-3222">O Common Language Infrastructure (CLI) garante que o resultado de dois `ldstr` as instruções referentes a dois tokens de metadados que têm a mesma sequência de caracteres de retorno exatamente o mesmo objeto de cadeia de caracteres (um processo conhecido como "centralização da cadeia de caracteres").</span><span class="sxs-lookup"><span data-stu-id="de0f3-3222">The Common Language Infrastructure (CLI) guarantees that the result of two `ldstr` instructions referring to two metadata tokens that have the same sequence of characters return precisely the same string object (a process known as "string interning").</span></span>  
  
 <span data-ttu-id="de0f3-3223">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldstr` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3223">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldstr` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3224">ILGenerator.Emit (cadeia de caracteres de OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3224">ILGenerator.Emit(OpCode, string)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3225">Converte um token de metadados em sua representação de tempo de execução, enviando-o por push para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3225">Converts a metadata token to its runtime representation, pushing it onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3226">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3226">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3227">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3227">Format</span></span>|<span data-ttu-id="de0f3-3228">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3228">Assembly Format</span></span>|<span data-ttu-id="de0f3-3229">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3229">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3230">D0 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-3230">D0 < `T` ></span></span>|<span data-ttu-id="de0f3-3231">Ldtoken `token`</span><span class="sxs-lookup"><span data-stu-id="de0f3-3231">ldtoken `token`</span></span>|<span data-ttu-id="de0f3-3232">Converte um token de metadados em sua representação de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3232">Converts a metadata token to its runtime representation.</span></span>|  
  
 <span data-ttu-id="de0f3-3233">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3233">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3234">O token passado é convertido em um `RuntimeHandle` e enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3234">The passed token is converted to a `RuntimeHandle` and pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3235">O `ldtoken` envios por push de instrução um `RuntimeHandle` para o token de metadados especificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3235">The `ldtoken` instruction pushes a `RuntimeHandle` for the specified metadata token.</span></span> <span data-ttu-id="de0f3-3236">Um `RuntimeHandle` pode ser uma `fieldref/fielddef`, um `methodref/methoddef`, ou um `typeref/typedef`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3236">A `RuntimeHandle` can be a `fieldref/fielddef`, a `methodref/methoddef`, or a `typeref/typedef`.</span></span>  
  
 <span data-ttu-id="de0f3-3237">O valor enviado por push na pilha pode ser usado em chamadas para `Reflection` métodos na biblioteca de classes do sistema.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3237">The value pushed on the stack can be used in calls to `Reflection` methods in the system class library.</span></span>  
  
 <span data-ttu-id="de0f3-3238">Para obter informações sobre identificadores de tempo de execução, consulte as seguintes classes: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, e <xref:System.RuntimeMethodHandle>.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3238">For information on runtime handles, see the following classes: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, and <xref:System.RuntimeMethodHandle>.</span></span>  
  
 <span data-ttu-id="de0f3-3239">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas de método podem usar o `ldtoken` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3239">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldtoken` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3240">ILGenerator.Emit (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3240">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="de0f3-3241">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3241">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
-   <span data-ttu-id="de0f3-3242">ILGenerator.Emit (OpCode, tipo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3242">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3243">Efetua o push de um ponteiro não gerenciado (tipo <see langword="native int" />) para o código nativo implementando um método virtual específico associado ao objeto especificado para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3243">Pushes an unmanaged pointer (type <see langword="native int" />) to the native code implementing a particular virtual method associated with a specified object onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3244">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3244">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3245">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3245">Format</span></span>|<span data-ttu-id="de0f3-3246">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3246">Assembly Format</span></span>|<span data-ttu-id="de0f3-3247">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3247">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3248">FE 07 &LT; `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-3248">FE 07 < `T` ></span></span>|<span data-ttu-id="de0f3-3249">ldvirtftn `method`</span><span class="sxs-lookup"><span data-stu-id="de0f3-3249">ldvirtftn `method`</span></span>|<span data-ttu-id="de0f3-3250">Envia o ponteiro para um método do objeto virtual `method` na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3250">Pushes the pointer to an object's virtual method `method` on the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-3251">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3251">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3252">Uma referência de objeto é inserida na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3252">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3253">A referência de objeto é Aparecida da pilha e o endereço do ponto de entrada para o método (conforme especificado pelo token de metadados `method`) é pesquisado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3253">The object reference is popped from the stack and the address of the entry point to the method (as specified by the metadata token `method`) is looked up.</span></span>  
  
3.  <span data-ttu-id="de0f3-3254">O ponteiro para `method` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3254">The pointer to `method` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3255">O ponteiro não gerenciado resultante enviado para a pilha, o `ldvirtftn` instrução pode ser chamada usando o <xref:System.Reflection.Emit.OpCodes.Calli> instrução se ele fizer referência a um método gerenciado (ou um stub que faz a transição de código gerenciado para código não gerenciado).</span><span class="sxs-lookup"><span data-stu-id="de0f3-3255">The resulting unmanaged pointer pushed onto the stack by the `ldvirtftn` instruction can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</span></span>  
  
 <span data-ttu-id="de0f3-3256">Pontos de ponteiro não gerenciado para código nativo usando o convenção de chamada do CLR.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3256">The unmanaged pointer points to native code using the CLR calling convention.</span></span> <span data-ttu-id="de0f3-3257">Esse ponteiro de método não deve ser passado para código nativo não gerenciado como uma rotina de retorno de chamada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3257">This method pointer should not be passed to unmanaged native code as a callback routine.</span></span>  
  
 <span data-ttu-id="de0f3-3258">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldvirtftn` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3258">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldvirtftn` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3259">ILGenerator.Emit (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3259">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3260">Sai de uma região protegida de código, transferindo o controle incondicionalmente para uma instrução de destino específica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3260">Exits a protected region of code, unconditionally transferring control to a specific target instruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3261">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3261">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3262">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3262">Format</span></span>|<span data-ttu-id="de0f3-3263">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3263">Assembly Format</span></span>|<span data-ttu-id="de0f3-3264">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3264">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3265">DD < `int32` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-3265">DD < `int32` ></span></span>|<span data-ttu-id="de0f3-3266">sair `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-3266">leave `target`</span></span>|<span data-ttu-id="de0f3-3267">Sai de uma região protegida de código.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3267">Exits a protected region of code.</span></span>|  
  
 <span data-ttu-id="de0f3-3268">Não há nenhum comportamento de transição de pilha especificado para essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3268">There is no stack transition behavior specified for this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-3269">O `leave` instrução transfere o controle incondicionalmente para a instrução de destino específico, representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3269">The `leave` instruction unconditionally transfers control to the specific target instruction, represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-3270">O `leave` instrução é semelhante de `br` instrução, mas ele pode ser usado para sair um `try`, `filter`, ou `catch` bloquear enquanto as instruções de ramificação comum só podem ser usadas em tal um bloco para transferir o controle dentro do -lo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3270">The `leave` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</span></span> <span data-ttu-id="de0f3-3271">O `leave` instrução esvazia a pilha de avaliação e garante que o valor apropriado ao redor `finally` blocos são executados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3271">The `leave` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.</span></span>  
  
 <span data-ttu-id="de0f3-3272">Não é possível usar um `leave` instruções para sair um `finally` bloco.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3272">You cannot use a `leave` instruction to exit a `finally` block.</span></span> <span data-ttu-id="de0f3-3273">Para facilitar a geração de código para os manipuladores de exceção é válido a partir de um bloco catch para usar um `leave` instrução para transferir o controle para qualquer instrução em associado `try` bloco.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3273">To ease code generation for exception handlers it is valid from within a catch block to use a `leave` instruction to transfer control to any instruction within the associated `try` block.</span></span>  
  
 <span data-ttu-id="de0f3-3274">Se uma instrução tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3274">If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="de0f3-3275">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas de método podem usar o `leave` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3275">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `leave` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3276">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3276">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3277">Sai de uma região protegida de código, transferindo o controle incondicionalmente para uma instrução de destino (forma abreviada).</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3277">Exits a protected region of code, unconditionally transferring control to a target instruction (short form).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3278">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3278">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3279">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3279">Format</span></span>|<span data-ttu-id="de0f3-3280">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3280">Assembly Format</span></span>|<span data-ttu-id="de0f3-3281">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3281">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3282">ALEMANHA &LT; `int8` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-3282">DE < `int8` ></span></span>|<span data-ttu-id="de0f3-3283">Leave.s `target`</span><span class="sxs-lookup"><span data-stu-id="de0f3-3283">leave.s `target`</span></span>|<span data-ttu-id="de0f3-3284">Sair de uma região protegida de código, de forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3284">Exit a protected region of code, short form.</span></span>|  
  
 <span data-ttu-id="de0f3-3285">Não há nenhum comportamento de transição de pilha especificado para essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3285">There is no stack transition behavior specified for this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-3286">O `leave.s` instrução transfere o controle incondicionalmente para a instrução de destino transmitido, representada como uma diferença de 1 byte com sinal desde o início da instrução após a instrução atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3286">The `leave.s` instruction unconditionally transfers control to the passed target instruction, represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de0f3-3287">O `leave.s` instrução é semelhante de `br` instrução, mas ele pode ser usado para sair um `try`, `filter`, ou `catch` bloquear enquanto as instruções de ramificação comum só podem ser usadas em tal um bloco para transferir o controle dentro do -lo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3287">The `leave.s` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</span></span> <span data-ttu-id="de0f3-3288">O `leave.s` instrução esvazia a pilha de avaliação e garante que o valor apropriado ao redor `finally` blocos são executados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3288">The `leave.s` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.</span></span>  
  
 <span data-ttu-id="de0f3-3289">Não é possível usar um `leave.s` instruções para sair um `finally` bloco.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3289">You cannot use a `leave.s` instruction to exit a `finally` block.</span></span> <span data-ttu-id="de0f3-3290">Para facilitar a geração de código para os manipuladores de exceção é válido a partir de um bloco catch para usar um `leave.s` instrução para transferir o controle para qualquer instrução em associado `try` bloco.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3290">To ease code generation for exception handlers it is valid from within a catch block to use a `leave.s` instruction to transfer control to any instruction within the associated `try` block.</span></span>  
  
 <span data-ttu-id="de0f3-3291">Se uma instrução tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3291">If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="de0f3-3292">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `leave.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3292">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `leave.s` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3293">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3293">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3294">Aloca um determinado número de bytes do pool de memória dinâmica local e envia o endereço (um ponteiro transitório, tipo <see langword="*" />) do primeiro byte alocado à pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3294">Allocates a certain number of bytes from the local dynamic memory pool and pushes the address (a transient pointer, type <see langword="*" />) of the first allocated byte onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3295">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3295">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3296">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3296">Format</span></span>|<span data-ttu-id="de0f3-3297">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3297">Assembly Format</span></span>|<span data-ttu-id="de0f3-3298">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3298">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3299">FE 0F</span><span class="sxs-lookup"><span data-stu-id="de0f3-3299">FE 0F</span></span>|<span data-ttu-id="de0f3-3300">localloc</span><span class="sxs-lookup"><span data-stu-id="de0f3-3300">localloc</span></span>|<span data-ttu-id="de0f3-3301">Alocar espaço de heap local.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3301">Allocate space from the local heap.</span></span>|  
  
 <span data-ttu-id="de0f3-3302">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3302">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3303">O número de bytes a ser alocada é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3303">The number of bytes to be allocated is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3304">O número de bytes é aparecido da pilha; uma quantidade de correspondente ao tamanho de memória é alocada da heap local.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3304">The number of bytes is popped from the stack; an amount of memory corresponding to the size is allocated from the local heap.</span></span>  
  
3.  <span data-ttu-id="de0f3-3305">Um ponteiro para o primeiro byte da memória alocada será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3305">A pointer to the first byte of the allocated memory is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3306">O `localloc` instrução aloca `size` (tipo `natural unsigned int`) pool de bytes de memória dinâmica local e retorna o endereço (um ponteiro transitório, tipo `*`) do primeiro byte alocado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3306">The `localloc` instruction allocates `size` (type `natural unsigned int`) bytes from the local dynamic memory pool and returns the address (a transient pointer, type `*`) of the first allocated byte.</span></span> <span data-ttu-id="de0f3-3307">O bloco de memória retornada será inicializada como 0 somente se o sinalizador de inicialização no método é `true`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3307">The block of memory returned is initialized to 0 only if the initialize flag on the method is `true`.</span></span> <span data-ttu-id="de0f3-3308">Quando o método atual é executado um <xref:System.Reflection.Emit.OpCodes.Ret>, o pool de memória local é disponibilizado para reutilização.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3308">When the current method executes a <xref:System.Reflection.Emit.OpCodes.Ret>, the local memory pool is made available for reuse.</span></span>  
  
 <span data-ttu-id="de0f3-3309">O endereço resultante é alinhado para que qualquer tipo de dados primitivos pode ser armazenado lá usando o `stind` instruções (como <xref:System.Reflection.Emit.OpCodes.Stind_I4>) e carregados usando o `ldind` instruções (como <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).</span><span class="sxs-lookup"><span data-stu-id="de0f3-3309">The resulting address is aligned so that any primitive data type can be stored there using the `stind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Stind_I4>) and loaded using the `ldind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).</span></span>  
  
 <span data-ttu-id="de0f3-3310">O `localloc` instrução não pode ocorrer dentro de um `filter`, `catch`, `finally`, ou `fault` bloco.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3310">The `localloc` instruction cannot occur within a `filter`, `catch`, `finally`, or `fault` block.</span></span>  
  
 <span data-ttu-id="de0f3-3311"><xref:System.StackOverflowException> será gerada se não houver memória suficiente para atender à solicitação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3311"><xref:System.StackOverflowException> is thrown if there is insufficient memory to service the request.</span></span>  
  
 <span data-ttu-id="de0f3-3312">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `localloc` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3312">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `localloc` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3313">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3313">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3314">Envia uma referência tipada a uma instância de um tipo específico para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3314">Pushes a typed reference to an instance of a specific type onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3315">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3315">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3316">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3316">Format</span></span>|<span data-ttu-id="de0f3-3317">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3317">Assembly Format</span></span>|<span data-ttu-id="de0f3-3318">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3318">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3319">C6 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-3319">C6 < `T` ></span></span>|<span data-ttu-id="de0f3-3320">Mkrefany `class`</span><span class="sxs-lookup"><span data-stu-id="de0f3-3320">mkrefany `class`</span></span>|<span data-ttu-id="de0f3-3321">Envia uma referência tipada do tipo `class` à pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3321">Pushes a typed reference of type `class` onto the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-3322">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3322">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3323">Um ponteiro para parte dos dados é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3323">A pointer to piece of data is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3324">O ponteiro é aparecido e convertido em uma referência de tipo do tipo `class`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3324">The pointer is popped and converted to a typed reference of type `class`.</span></span>  
  
3.  <span data-ttu-id="de0f3-3325">A referência de tipo é enviada para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3325">The typed reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3326">O `mkrefany` instrução fornece suporte à passagem de referências de tipadas dinâmico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3326">The `mkrefany` instruction supports the passing of dynamically typed references.</span></span> <span data-ttu-id="de0f3-3327">O ponteiro deve ser do tipo `&`, `*`, ou `native int`, mantenha o endereço válido de uma parte dos dados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3327">The pointer must be of type `&`, `*`, or `native int`, and hold the valid address of a piece of data.</span></span> <span data-ttu-id="de0f3-3328">`Class` o token de classe que descreve o tipo de dados referenciados pelo ponteiro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3328">`Class` is the class token describing the type of the data referenced by the pointer.</span></span> <span data-ttu-id="de0f3-3329">`Mkrefany` envia uma referência tipada na pilha, fornecendo um descritor de opaco do ponteiro e o tipo `class`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3329">`Mkrefany` pushes a typed reference on the stack, providing an opaque descriptor of the pointer and the type `class`.</span></span>  
  
 <span data-ttu-id="de0f3-3330">A operação válida apenas permitida após uma referência tipada é passá-lo para um método que requer uma referência tipada como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3330">The only valid operation permitted upon a typed reference is to pass it to a method that requires a typed reference as a parameter.</span></span> <span data-ttu-id="de0f3-3331">O receptor pode usar o <xref:System.Reflection.Emit.OpCodes.Refanytype> e <xref:System.Reflection.Emit.OpCodes.Refanyval> instruções para recuperar o tipo (classe) e o endereço, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3331">The callee can then use the <xref:System.Reflection.Emit.OpCodes.Refanytype> and <xref:System.Reflection.Emit.OpCodes.Refanyval> instructions to retrieve the type (class) and the address respectively.</span></span>  
  
 <span data-ttu-id="de0f3-3332"><xref:System.TypeLoadException> será gerada se `class` não pode ser encontrado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3332"><xref:System.TypeLoadException> is thrown if `class` cannot be found.</span></span> <span data-ttu-id="de0f3-3333">Normalmente, isso é detectado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo em vez de em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3333">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="de0f3-3334">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `mkrefany` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3334">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mkrefany` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3335">ILGenerator.Emit (OpCode, tipo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3335">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3336">Multiplica dois valores e efetua o push do resultado na pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3336">Multiplies two values and pushes the result on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3337">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3337">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3338">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3338">Format</span></span>|<span data-ttu-id="de0f3-3339">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3339">Assembly Format</span></span>|<span data-ttu-id="de0f3-3340">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3340">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3341">5A</span><span class="sxs-lookup"><span data-stu-id="de0f3-3341">5A</span></span>|<span data-ttu-id="de0f3-3342">mul</span><span class="sxs-lookup"><span data-stu-id="de0f3-3342">mul</span></span>|<span data-ttu-id="de0f3-3343">Multiplica dois valores na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3343">Multiplies two values on the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-3344">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3344">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3345">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3345">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3346">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3346">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-3347">`value2` e `value1` são removidos da pilha; `value1` é multiplicado pelo `value2`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3347">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`.</span></span>  
  
4.  <span data-ttu-id="de0f3-3348">O resultado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3348">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3349">O `mul` instrução multiplica `value1` por `value2` e envia o resultado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3349">The `mul` instruction multiplies `value1` by `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="de0f3-3350">Operações de inteiros truncam silenciosamente os bits superiores no estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3350">Integer operations silently truncate the upper bits on overflow.</span></span>  
  
 <span data-ttu-id="de0f3-3351">Consulte <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> para um número inteiro específico multiplicar a operação com a manipulação de estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3351">See <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> for an integer-specific multiply operation with overflow handling.</span></span>  
  
 <span data-ttu-id="de0f3-3352">Para tipos de ponto flutuantes, 0 \* infinito = NaN.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3352">For floating-point types, 0 \* infinity = NaN.</span></span>  
  
 <span data-ttu-id="de0f3-3353">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `mul` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3353">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3354">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3354">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3355">Multiplica dois valores inteiros, executa uma verificação de estouro e envia por push o resultado na pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3355">Multiplies two integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3356">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3356">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3357">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3357">Format</span></span>|<span data-ttu-id="de0f3-3358">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3358">Assembly Format</span></span>|<span data-ttu-id="de0f3-3359">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3359">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3360">D8</span><span class="sxs-lookup"><span data-stu-id="de0f3-3360">D8</span></span>|<span data-ttu-id="de0f3-3361">mul.OVF</span><span class="sxs-lookup"><span data-stu-id="de0f3-3361">mul.ovf</span></span>|<span data-ttu-id="de0f3-3362">Multiplica dois valores inteiros na pilha com uma verificação de estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3362">Multiplies two integer values on the stack with an overflow check.</span></span>|  
  
 <span data-ttu-id="de0f3-3363">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3363">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3364">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3364">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3365">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3365">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-3366">`value2` e `value1` são removidos da pilha; `value1` é multiplicado pelo `value2`, com uma verificação de estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3366">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check.</span></span>  
  
4.  <span data-ttu-id="de0f3-3367">O resultado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3367">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3368">O `mul.ovf` instrução multiplica o número inteiro `value1` por inteiro `value2` e envia o resultado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3368">The `mul.ovf` instruction multiplies integer `value1` by integer `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="de0f3-3369">Uma exceção é lançada se o resultado não cabem no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3369">An exception is thrown if the result will not fit in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-3370"><xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3370"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-3371">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `mul.ovf` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3371">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3372">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3372">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3373">Multiplica dois valores de inteiro sem sinal, executa uma verificação de estouro e efetua o push do resultado para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3373">Multiplies two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3374">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3374">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3375">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3375">Format</span></span>|<span data-ttu-id="de0f3-3376">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3376">Assembly Format</span></span>|<span data-ttu-id="de0f3-3377">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3377">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3378">D9</span><span class="sxs-lookup"><span data-stu-id="de0f3-3378">D9</span></span>|<span data-ttu-id="de0f3-3379">mul.ovf.un</span><span class="sxs-lookup"><span data-stu-id="de0f3-3379">mul.ovf.un</span></span>|<span data-ttu-id="de0f3-3380">Multiplica dois valores sem sinal na pilha com uma verificação de estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3380">Multiplies two unsigned values on the stack with an overflow check.</span></span>|  
  
 <span data-ttu-id="de0f3-3381">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3381">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3382">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3382">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3383">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3383">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-3384">`value2` e `value1` são removidos da pilha; `value1` é multiplicado pelo `value2`, com uma verificação de estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3384">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check.</span></span>  
  
4.  <span data-ttu-id="de0f3-3385">O resultado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3385">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3386">O `mul.ovf.un` instrução multiplica o inteiro sem sinal `value1` por inteiro sem sinal `value2` e envia o resultado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3386">The `mul.ovf.un` instruction multiplies unsigned integer `value1` by unsigned integer `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="de0f3-3387">Uma exceção é lançada se o resultado não cabem no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3387">An exception is thrown if the result will not fit in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-3388"><xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3388"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-3389">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `mul.ovf.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3389">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3390">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3390">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3391">Nega um valor e efetua o push do resultado para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3391">Negates a value and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3392">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3392">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3393">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3393">Format</span></span>|<span data-ttu-id="de0f3-3394">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3394">Assembly Format</span></span>|<span data-ttu-id="de0f3-3395">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3395">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3396">65</span><span class="sxs-lookup"><span data-stu-id="de0f3-3396">65</span></span>|<span data-ttu-id="de0f3-3397">Neg</span><span class="sxs-lookup"><span data-stu-id="de0f3-3397">neg</span></span>|<span data-ttu-id="de0f3-3398">Nega o valor atualmente no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3398">Negates the value currently on top of the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-3399">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3399">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3400">Um valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3400">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3401">Um valor é aparecido da pilha e negado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3401">A value is popped from the stack and negated.</span></span>  
  
3.  <span data-ttu-id="de0f3-3402">O resultado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3402">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3403">O `neg` nega o valor de instrução e envia o resultado no topo da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3403">The `neg` instruction negates value and pushes the result on top of the stack.</span></span> <span data-ttu-id="de0f3-3404">O tipo de retorno é o mesmo que o tipo de operando.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3404">The return type is the same as the operand type.</span></span>  
  
 <span data-ttu-id="de0f3-3405">Negação de valores integrais é o padrão do complemento de dois negação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3405">Negation of integral values is standard two's complement negation.</span></span> <span data-ttu-id="de0f3-3406">Em particular, eliminando o número mais negativo (que não tem um equivalente positivo) produz o número mais negativo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3406">In particular, negating the most negative number (which does not have a positive counterpart) yields the most negative number.</span></span> <span data-ttu-id="de0f3-3407">Para detectar esse uso de estouro de <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> instrução em vez disso (ou seja, subtrair de 0).</span><span class="sxs-lookup"><span data-stu-id="de0f3-3407">To detect this overflow use the <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> instruction instead (that is, subtract from 0).</span></span>  
  
 <span data-ttu-id="de0f3-3408">Negando a um número de ponto flutuante não será possível estourar e negando NaN retorna NaN.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3408">Negating a floating-point number cannot overflow, and negating NaN returns NaN.</span></span>  
  
 <span data-ttu-id="de0f3-3409">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `neg` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3409">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `neg` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3410">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3410">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3411">Envia por push uma referência de objeto para uma nova matriz unidimensional baseada em zero, cujos elementos são de um tipo específico na pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3411">Pushes an object reference to a new zero-based, one-dimensional array whose elements are of a specific type onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3412">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3412">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3413">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3413">Format</span></span>|<span data-ttu-id="de0f3-3414">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3414">Assembly Format</span></span>|<span data-ttu-id="de0f3-3415">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3415">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3416">8D < `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-3416">8D < `T` ></span></span>|<span data-ttu-id="de0f3-3417">newarr `etype`</span><span class="sxs-lookup"><span data-stu-id="de0f3-3417">newarr `etype`</span></span>|<span data-ttu-id="de0f3-3418">Cria uma nova matriz com elementos do tipo `etype`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3418">Creates a new array with elements of type `etype`.</span></span>|  
  
 <span data-ttu-id="de0f3-3419">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3419">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3420">O número de elementos na matriz é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3420">The number of elements in the array is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3421">O número de elementos é aparecido da pilha e a matriz é criada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3421">The number of elements is popped from the stack and the array is created.</span></span>  
  
3.  <span data-ttu-id="de0f3-3422">Uma referência de objeto para a nova matriz é enviada para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3422">An object reference to the new array is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3423">O `newarr` instrução envia por push uma referência de objeto (tipo `O`) para uma nova matriz unidimensional, com base em zero cujos elementos são do tipo `etype` (um token de metadados que descreve o tipo).</span><span class="sxs-lookup"><span data-stu-id="de0f3-3423">The `newarr` instruction pushes an object reference (type `O`) to a new zero-based, one-dimensional array whose elements are of type `etype` (a metadata token describing the type).</span></span> <span data-ttu-id="de0f3-3424">O número de elementos na nova matriz deve ser especificado como um `native int`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3424">The number of elements in the new array should be specified as a `native int`.</span></span> <span data-ttu-id="de0f3-3425">Intervalo de índices de matriz válida do zero para o número máximo de elementos, menos um.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3425">Valid array indexes range from zero to the maximum number of elements minus one.</span></span>  
  
 <span data-ttu-id="de0f3-3426">Os elementos de uma matriz podem ser qualquer tipo, incluindo tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3426">The elements of an array can be any type, including value types.</span></span>  
  
 <span data-ttu-id="de0f3-3427">Matrizes unidimensionais, com base em zero de números são criados usando um token de metadados, fazendo referência ao tipo de valor apropriado (<xref:System.Int32>e assim por diante).</span><span class="sxs-lookup"><span data-stu-id="de0f3-3427">Zero-based, one-dimensional arrays of numbers are created using a metadata token referencing the appropriate value type (<xref:System.Int32>, and so on).</span></span> <span data-ttu-id="de0f3-3428">Elementos da matriz serão inicializados como 0 do tipo apropriado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3428">Elements of the array are initialized to 0 of the appropriate type.</span></span>  
  
 <span data-ttu-id="de0f3-3429">Matrizes unidimensionais NonZero-com base e matrizes multidimensionais são criadas usando <xref:System.Reflection.Emit.OpCodes.Newobj> em vez de `newarr`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3429">Nonzero-based one-dimensional arrays and multidimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newobj> rather than `newarr`.</span></span> <span data-ttu-id="de0f3-3430">Normalmente, eles são criados usando os métodos do <xref:System.Array> classe no .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3430">More commonly, they are created using the methods of the <xref:System.Array> class in the .NET Framework.</span></span>  
  
 <span data-ttu-id="de0f3-3431"><xref:System.OutOfMemoryException> será gerada se não houver memória suficiente para atender à solicitação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3431"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="de0f3-3432"><xref:System.OverflowException> será gerada se `numElems` é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3432"><xref:System.OverflowException> is thrown if `numElems` is less than 0.</span></span>  
  
 <span data-ttu-id="de0f3-3433">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `newarr` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3433">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newarr` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3434">ILGenerator.Emit (OpCode, tipo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3434">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3435">Cria um novo objeto ou uma nova instância de um tipo de valor, enviando por push uma referência de objeto (tipo <see langword="O" />) para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3435">Creates a new object or a new instance of a value type, pushing an object reference (type <see langword="O" />) onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3436">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3436">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3437">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3437">Format</span></span>|<span data-ttu-id="de0f3-3438">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3438">Assembly Format</span></span>|<span data-ttu-id="de0f3-3439">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3439">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3440">73 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-3440">73 < `T` ></span></span>|<span data-ttu-id="de0f3-3441">newobj `ctor`</span><span class="sxs-lookup"><span data-stu-id="de0f3-3441">newobj `ctor`</span></span>|<span data-ttu-id="de0f3-3442">Aloca um tipo de valor ou objeto não inicializado e chama o método de construtor `ctor`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3442">Allocates an uninitialized object or value type and calls the constructor method `ctor`.</span></span>|  
  
 <span data-ttu-id="de0f3-3443">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3443">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3444">Argumentos `arg1` por meio de `argn` são empurrados na pilha na sequência.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3444">Arguments `arg1` through `argn` are pushed on the stack in sequence.</span></span>  
  
2.  <span data-ttu-id="de0f3-3445">Argumentos `argn` por meio `arg1` são removidos da pilha e passadas para `ctor` para a criação do objeto.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3445">Arguments `argn` through `arg1` are popped from the stack and passed to `ctor` for object creation.</span></span>  
  
3.  <span data-ttu-id="de0f3-3446">Uma referência ao novo objeto é inserida na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3446">A reference to the new object is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3447">O `newobj` instrução cria um novo objeto ou uma nova instância de um tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3447">The `newobj` instruction creates a new object or a new instance of a value type.</span></span> <span data-ttu-id="de0f3-3448">`Ctor` é um token de metadados (um `methodref` ou `methoddef` que deve ser marcada como um construtor) que indica o nome, a classe e a assinatura do construtor para chamar.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3448">`Ctor` is a metadata token (a `methodref` or `methoddef` that must be marked as a constructor) that indicates the name, class and signature of the constructor to call.</span></span>  
  
 <span data-ttu-id="de0f3-3449">O `newobj` instrução aloca uma nova instância da classe associada `ctor` e inicializa todos os campos na nova instância como 0 (do tipo adequado) ou referências nulas conforme apropriado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3449">The `newobj` instruction allocates a new instance of the class associated with `ctor` and initializes all the fields in the new instance to 0 (of the proper type) or null references as appropriate.</span></span> <span data-ttu-id="de0f3-3450">Depois, ele chama o construtor `ctor` com os argumentos fornecidos, juntamente com a instância recém-criada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3450">It then calls the constructor `ctor` with the given arguments along with the newly created instance.</span></span> <span data-ttu-id="de0f3-3451">Depois que o construtor for chamado, o agora inicializadas de referência de objeto (tipo `O`) é enviado por push na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3451">After the constructor has been called, the now initialized object reference (type `O`) is pushed on the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3452">Do ponto de vista do construtor, o objeto não inicializado é o argumento de 0 e os outros argumentos passados para newobj seguem na ordem.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3452">From the constructor's point of view, the uninitialized object is argument 0 and the other arguments passed to newobj follow in order.</span></span>  
  
 <span data-ttu-id="de0f3-3453">Todas as matrizes unidimensionais, com base em zero são criadas usando <xref:System.Reflection.Emit.OpCodes.Newarr>, e não `newobj`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3453">All zero-based, one-dimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newarr>, not `newobj`.</span></span> <span data-ttu-id="de0f3-3454">Por outro lado, todas as outras matrizes (mais de uma dimensão, ou unidimensional, mas não em zero) são criadas usando `newobj`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3454">On the other hand, all other arrays (more than one dimension, or one-dimensional but not zero-based) are created using `newobj`.</span></span>  
  
 <span data-ttu-id="de0f3-3455">Tipos de valor não são geralmente criados usando `newobj`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3455">Value types are not usually created using `newobj`.</span></span> <span data-ttu-id="de0f3-3456">Normalmente, eles são alocados como argumentos ou variáveis locais, usando `newarr` (para matrizes unidimensionais, com base em zero), ou como campos de objetos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3456">They are usually allocated either as arguments or local variables, using `newarr` (for zero-based, one-dimensional arrays), or as fields of objects.</span></span> <span data-ttu-id="de0f3-3457">Uma vez alocado, eles são inicializados usando <xref:System.Reflection.Emit.OpCodes.Initobj>.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3457">Once allocated, they are initialized using <xref:System.Reflection.Emit.OpCodes.Initobj>.</span></span> <span data-ttu-id="de0f3-3458">No entanto, o `newobj` instrução pode ser usada para criar uma nova instância de um tipo de valor na pilha, que, em seguida, pode ser passada como um argumento, armazenado em um local e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3458">However, the `newobj` instruction can be used to create a new instance of a value type on the stack, that can then be passed as an argument, stored in a local, and so on.</span></span>  
  
 <span data-ttu-id="de0f3-3459"><xref:System.OutOfMemoryException> será gerada se não houver memória suficiente para atender à solicitação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3459"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="de0f3-3460"><xref:System.MissingMethodException> será gerada se um método construtor `ctor` com o nome indicado, classe e a assinatura não pôde ser encontrados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3460"><xref:System.MissingMethodException> is thrown if a constructor method `ctor` with the indicated name, class and signature could not be found.</span></span> <span data-ttu-id="de0f3-3461">Normalmente, isso é detectado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo, em vez de em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3461">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="de0f3-3462">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `newobj` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3462">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newobj` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3463">ILGenerator.Emit (OpCode, ConstructorInfo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3463">ILGenerator.Emit(OpCode, ConstructorInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3464">Preencherá o espaço se os opcodes forem corrigidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3464">Fills space if opcodes are patched.</span>
          </span>
          <span data-ttu-id="de0f3-3465">Nenhuma operação significativa será executada, embora um ciclo de processamento possa ser consumido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3465">No meaningful operation is performed although a processing cycle can be consumed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3466">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3466">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3467">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3467">Format</span></span>|<span data-ttu-id="de0f3-3468">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3468">Assembly Format</span></span>|<span data-ttu-id="de0f3-3469">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3469">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3470">00</span><span class="sxs-lookup"><span data-stu-id="de0f3-3470">00</span></span>|<span data-ttu-id="de0f3-3471">Nop</span><span class="sxs-lookup"><span data-stu-id="de0f3-3471">nop</span></span>|<span data-ttu-id="de0f3-3472">Executa uma operação sem comportamento.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3472">Performs an operation without behavior.</span></span>|  
  
 <span data-ttu-id="de0f3-3473">Não há nenhum comportamento de transição de pilha definido para essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3473">There is no stack transitional behavior defined for this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-3474">O `nop` operação não fará nada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3474">The `nop` operation does nothing.</span></span> <span data-ttu-id="de0f3-3475">Ele destina-se para preencher o espaço se opcodes forem corrigidos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3475">It is intended to fill in space if opcodes are patched.</span></span>  
  
 <span data-ttu-id="de0f3-3476">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `nop` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3476">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `nop` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3477">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3477">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3478">Calcula o complemento bit a bit do valor de inteiro na parte superior da pilha e efetua o push o resultado para a pilha de avaliação como o mesmo tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3478">Computes the bitwise complement of the integer value on top of the stack and pushes the result onto the evaluation stack as the same type.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3479">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3479">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3480">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3480">Format</span></span>|<span data-ttu-id="de0f3-3481">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3481">Assembly Format</span></span>|<span data-ttu-id="de0f3-3482">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3482">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3483">66</span><span class="sxs-lookup"><span data-stu-id="de0f3-3483">66</span></span>|<span data-ttu-id="de0f3-3484">not</span><span class="sxs-lookup"><span data-stu-id="de0f3-3484">not</span></span>|<span data-ttu-id="de0f3-3485">Calcula o complemento bit a bit de um valor.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3485">Computes the bitwise complement of a value.</span></span>|  
  
 <span data-ttu-id="de0f3-3486">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3486">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3487">`value` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3487">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3488">`value` é aparecido da pilha e o bit a bit complemento computado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3488">`value` is popped from the stack and its bitwise complement computed.</span></span>  
  
3.  <span data-ttu-id="de0f3-3489">O resultado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3489">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3490">O `not` instrução calcula o complemento bit a bit de um valor inteiro e envia o resultado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3490">The `not` instruction computes the bitwise complement of an integer value and pushes the result onto the stack.</span></span> <span data-ttu-id="de0f3-3491">O tipo de retorno é o mesmo que o tipo de operando.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3491">The return type is the same as the operand type.</span></span>  
  
 <span data-ttu-id="de0f3-3492">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `not` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3492">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `not` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3493">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3493">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3494">Computa o complemento bit a bit dos dois valores de inteiro na parte superior da pilha e efetua o push do resultado para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3494">Compute the bitwise complement of the two integer values on top of the stack and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3495">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3495">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3496">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3496">Format</span></span>|<span data-ttu-id="de0f3-3497">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3497">Assembly Format</span></span>|<span data-ttu-id="de0f3-3498">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3498">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3499">60</span><span class="sxs-lookup"><span data-stu-id="de0f3-3499">60</span></span>|<span data-ttu-id="de0f3-3500">ou</span><span class="sxs-lookup"><span data-stu-id="de0f3-3500">or</span></span>|<span data-ttu-id="de0f3-3501">Calcula o bit a bit ou de dois valores de inteiro, retorna um inteiro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3501">Computes the bitwise OR of two integer values, returns an integer.</span></span>|  
  
 <span data-ttu-id="de0f3-3502">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3502">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3503">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3503">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3504">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3504">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-3505">`value2` e `value1` são removidos da pilha e seu OR bit a bit computado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3505">`value2` and `value1` are popped from the stack and their bitwise OR computed.</span></span>  
  
4.  <span data-ttu-id="de0f3-3506">O resultado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3506">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3507">O `or` instrução calcula o OR bit a bit de dois valores sobre a pilha, enviar por push o resultado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3507">The `or` instruction computes the bitwise OR of two values atop the stack, pushing the result onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3508">`Or` é uma operação de inteiro específico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3508">`Or` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="de0f3-3509">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `or` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3509">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `or` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3510">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3510">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3511">Remove o valor atualmente no topo da pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3511">Removes the value currently on top of the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3512">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3512">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3513">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3513">Format</span></span>|<span data-ttu-id="de0f3-3514">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3514">Assembly Format</span></span>|<span data-ttu-id="de0f3-3515">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3515">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3516">26</span><span class="sxs-lookup"><span data-stu-id="de0f3-3516">26</span></span>|<span data-ttu-id="de0f3-3517">pop</span><span class="sxs-lookup"><span data-stu-id="de0f3-3517">pop</span></span>|<span data-ttu-id="de0f3-3518">Exibe o valor superior da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3518">Pops the top value from the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-3519">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3519">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3520">Valor superior é aparecido da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3520">The top value is popped from the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3521">O `pop` instrução remove o elemento superior da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3521">The `pop` instruction removes the top element from the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3522">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `pop` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3522">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `pop` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3523">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3523">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3524">Esta é uma instrução reservada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3524">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3525">Esta é uma instrução reservada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3525">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3526">Esta é uma instrução reservada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3526">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3527">Esta é uma instrução reservada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3527">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3528">Esta é uma instrução reservada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3528">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3529">Esta é uma instrução reservada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3529">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3530">Esta é uma instrução reservada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3530">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3531">Esta é uma instrução reservada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3531">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3532">Especifica que a operação de endereço da matriz subsequente não executa nenhuma verificação de tipo no tempo de execução e que ela retorna um ponteiro gerenciado cuja mutabilidade é restrita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3532">Specifies that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer whose mutability is restricted.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3533">A tabela a seguir lista a instrução hexadecimal e formato do assembly Microsoft intermediate language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3533">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3534">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3534">Format</span></span>|<span data-ttu-id="de0f3-3535">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3535">Assembly Format</span></span>|<span data-ttu-id="de0f3-3536">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3536">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3537">FE 1E</span><span class="sxs-lookup"><span data-stu-id="de0f3-3537">FE 1E</span></span>|<span data-ttu-id="de0f3-3538">somente leitura.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3538">readonly.</span></span>|<span data-ttu-id="de0f3-3539">Especifique que a operação de endereço da matriz subsequente não executará nenhuma verificação de tipo em tempo de execução e que ele retorna um ponteiro gerenciado com Mutabilidade restrita.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3539">Specify that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer with restricted mutability.</span></span>|  
  
 <span data-ttu-id="de0f3-3540">Esse prefixo só pode aparecer imediatamente anterior a `ldelema` instrução e chamadas para especiais `Address` método nas matrizes.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3540">This prefix can only appear immediately preceding the `ldelema` instruction and calls to the special `Address` method on arrays.</span></span> <span data-ttu-id="de0f3-3541">Seu efeito sobre a operação subsequente é dupla:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3541">Its effect on the subsequent operation is twofold:</span></span>  
  
1.  <span data-ttu-id="de0f3-3542">Em tempo de execução, nenhuma operação de verificação de tipo é executada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3542">At run time, no type check operation is performed.</span></span> <span data-ttu-id="de0f3-3543">Observe que, normalmente, há uma verificação de tipo implícito para o `ldelema` e `stelem` matrizes de tipo de instruções quando usado na referência.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3543">Note that there is normally an implicit type check for the `ldelema` and `stelem` instructions when used on reference type arrays.</span></span> <span data-ttu-id="de0f3-3544">Nunca há uma verificação de tipo de tempo de execução para classes de valor, portanto, `readonly` nesse caso, será não operacional.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3544">There is never a run-time type check for value classes, so `readonly` is a no-op in that case.</span></span>  
  
2.  <span data-ttu-id="de0f3-3545">O verificador trata o resultado da operação de endereço como um ponteiro gerenciado com Mutabilidade restrita.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3545">The verifier treats the result of the address-of operation as a managed pointer with restricted mutability.</span></span>  
  
 <span data-ttu-id="de0f3-3546">O ponteiro deve ter restringido Mutabilidade porque a definição de tipo controla se o valor pode ser modificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3546">The pointer is said to have restricted mutability because the defining type controls whether the value can be mutated.</span></span> <span data-ttu-id="de0f3-3547">Para classes de valor que não expõem nenhum campos públicos ou métodos que atualizam o valor em vigor, o ponteiro é somente leitura (portanto, o nome do prefixo).</span><span class="sxs-lookup"><span data-stu-id="de0f3-3547">For value classes that expose no public fields or methods that update the value in place, the pointer is read-only (hence the name of the prefix).</span></span> <span data-ttu-id="de0f3-3548">Em particular, as classes que representam tipos primitivos (por exemplo, System.Int32) não expõem modificadores e, portanto, são somente leitura.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3548">In particular, the classes representing primitive types (for example, System.Int32) do not expose mutators and thus are read-only.</span></span>  
  
 <span data-ttu-id="de0f3-3549">Um ponteiro gerenciado restringido dessa maneira pode ser usado apenas das seguintes maneiras:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3549">A managed pointer restricted in this fashion can be used only in the following ways:</span></span>  
  
-   <span data-ttu-id="de0f3-3550">Como o `object` parâmetro para o `ldfld`, `ldflda`, `stfld`, `call`, ou`constrained callvirt` instruções.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3550">As the `object` parameter for the `ldfld`, `ldflda`, `stfld`, `call`, or`constrained callvirt` instructions.</span></span>  
  
-   <span data-ttu-id="de0f3-3551">Como o `pointer` parâmetro para o `ldobj` instrução ou a um do `ldind` instruções.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3551">As the `pointer` parameter to the `ldobj` instruction or to one of the `ldind` instructions.</span></span>  
  
-   <span data-ttu-id="de0f3-3552">Como o `source` parâmetro para o `cpobj` instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3552">As the `source` parameter to the `cpobj` instruction.</span></span>  
  
 <span data-ttu-id="de0f3-3553">Todas as outras operações não permitidas, incluindo o `stobj`, `initobj`, ou `mkrefany` operações ou qualquer um do `stind` instruções.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3553">All other operations disallowed, including the `stobj`, `initobj`, or `mkrefany` operations, or any of the `stind` instructions.</span></span>  
  
 <span data-ttu-id="de0f3-3554">A finalidade de `readonly` prefixo é para evitar uma verificação de tipo ao buscar um elemento de uma matriz em código genérico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3554">The purpose of the `readonly` prefix is to avoid a type check when fetching an element from an array in generic code.</span></span> <span data-ttu-id="de0f3-3555">Por exemplo, a expressão `arr[i].m()`, em que o tipo de elemento da matriz `arr` é um tipo genérico que foi restrita a ter uma interface com o método `m`, pode compilar a seguir MSIL.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3555">For example, the expression `arr[i].m()`, where the element type of the array `arr` is a generic type that has been constrained to have an interface with method `m`, might compile to the following MSIL.</span></span>  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 <span data-ttu-id="de0f3-3556">Sem o `readonly` prefixo, o `ldelema` instrução deve executar uma verificação de tipo no caso no qual! 0 foi um tipo de referência.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3556">Without the `readonly` prefix, the `ldelema` instruction would perform a type check in the case where !0 was a reference type.</span></span> <span data-ttu-id="de0f3-3557">Não só é essa verificação de tipo ineficiente, mas ele é semanticamente incorreto.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3557">Not only is this type check inefficient, but it is semantically incorrect.</span></span> <span data-ttu-id="de0f3-3558">A verificação de tipo para `ldelema` é uma correspondência exata, que é muito forte.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3558">The type check for `ldelema` is an exact match, which is too strong.</span></span> <span data-ttu-id="de0f3-3559">Se a matriz mantido subclasses do tipo! 0, o código acima poderia falhar a verificação de tipo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3559">If the array held subclasses of type !0, the code above would fail the type check.</span></span>  
  
 <span data-ttu-id="de0f3-3560">O endereço do elemento da matriz é buscado, em vez do elemento em si, para ter um identificador para o `arr[i]` que funciona para ambos os tipos de valor e tipos de referência e, portanto, pode ser passada para o `constrained callvirt` instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3560">The address of the array element is fetched, instead of the element itself, in order to have a handle for `arr[i]` that works for both value types and reference types, and thus can be passed to the `constrained callvirt` instruction.</span></span>  
  
 <span data-ttu-id="de0f3-3561">Em geral, seria não é seguro ignorar a verificação de tempo de execução se a matriz mantidos elementos de um tipo de referência.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3561">In general it would be unsafe to skip the run-time check if the array held elements of a reference type.</span></span> <span data-ttu-id="de0f3-3562">Para estar seguro, é necessário garantir que nenhuma modificação na matriz é feitas por este ponteiro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3562">To be safe, it is necessary to ensure that no modifications to the array are made through this pointer.</span></span> <span data-ttu-id="de0f3-3563">As regras do verificador garantem isso.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3563">The verifier rules ensure this.</span></span> <span data-ttu-id="de0f3-3564">O ponteiro gerenciado restrito pode ser passado como o objeto de chamadas de método de instância, portanto, não é estritamente falando somente leitura para tipos de valor, mas não há nenhum problema de segurança de tipo para tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3564">The restricted managed pointer can be passed as the object of instance method calls, so it is not strictly speaking read-only for value types, but there is no type safety problem for value types.</span></span>  
  
 <span data-ttu-id="de0f3-3565">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `readonly` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3565">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `readonly` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3566">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3566">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3567">Recupera o token de tipo inserido em uma referência tipada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3567">Retrieves the type token embedded in a typed reference.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3568">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3568">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3569">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3569">Format</span></span>|<span data-ttu-id="de0f3-3570">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3570">Assembly Format</span></span>|<span data-ttu-id="de0f3-3571">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3571">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3572">FE 1D</span><span class="sxs-lookup"><span data-stu-id="de0f3-3572">FE 1D</span></span>|<span data-ttu-id="de0f3-3573">refanytype</span><span class="sxs-lookup"><span data-stu-id="de0f3-3573">refanytype</span></span>|<span data-ttu-id="de0f3-3574">Envia o token do tipo armazenado em uma referência tipada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3574">Pushes the type token stored in a typed reference.</span></span>|  
  
 <span data-ttu-id="de0f3-3575">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3575">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3576">Uma referência de tipo de valor é enviada para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3576">A value type reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3577">A referência de tipo é Aparecida da pilha e recuperar seu token de tipo correspondente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3577">The typed reference is popped from the stack and its corresponding type token retrieved.</span></span>  
  
3.  <span data-ttu-id="de0f3-3578">O token de tipo é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3578">The type token is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3579">Uma referência tipada contém um token de tipo e um endereço para uma instância do objeto.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3579">A typed reference contains a type token and an address to an object instance.</span></span>  
  
 <span data-ttu-id="de0f3-3580">O `refanytype` instrução recupera o token de tipo inserido na referência tipada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3580">The `refanytype` instruction retrieves the type token embedded in the typed reference.</span></span> <span data-ttu-id="de0f3-3581">Consulte o <xref:System.Reflection.Emit.OpCodes.Mkrefany> digitado de instrução para obter informações sobre a criação de referências.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3581">See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for information on creating typed references.</span></span>  
  
 <span data-ttu-id="de0f3-3582">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `refanytype` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3582">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanytype` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3583">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3583">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3584">Recupera o endereço (tipo <see langword="&amp;" />) inserido em uma referência tipada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3584">Retrieves the address (type <see langword="&amp;" />) embedded in a typed reference.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3585">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3585">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3586">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3586">Format</span></span>|<span data-ttu-id="de0f3-3587">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3587">Assembly Format</span></span>|<span data-ttu-id="de0f3-3588">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3588">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3589">C2 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-3589">C2 < `T` ></span></span>|<span data-ttu-id="de0f3-3590">refanyval `type`</span><span class="sxs-lookup"><span data-stu-id="de0f3-3590">refanyval `type`</span></span>|<span data-ttu-id="de0f3-3591">Envia o endereço armazenado em uma referência tipada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3591">Pushes the address stored in a typed reference.</span></span>|  
  
 <span data-ttu-id="de0f3-3592">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3592">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3593">Uma referência de tipo de valor é enviada para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3593">A value type reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3594">A referência de tipo é Aparecida da pilha e o endereço correspondente recuperado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3594">The typed reference is popped from the stack and the corresponding address retrieved.</span></span>  
  
3.  <span data-ttu-id="de0f3-3595">O endereço é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3595">The address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3596">Uma referência tipada contém um token de tipo e um endereço para uma instância do objeto.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3596">A typed reference contains a type token and an address to an object instance.</span></span>  
  
 <span data-ttu-id="de0f3-3597">O `refanyval` instrução recupera o endereço inserido na uma referência tipada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3597">The `refanyval` instruction retrieves the address embedded in the a typed reference.</span></span> <span data-ttu-id="de0f3-3598">O tipo inserido na referência do tipo fornecida na pilha deve corresponder ao tipo especificado pelo `type` (token de metadados, ou uma `typedef` ou um `typeref`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-3598">The type embedded in the typed reference supplied on the stack must match the type specified by `type` (a metadata token, either a `typedef` or a `typeref`).</span></span> <span data-ttu-id="de0f3-3599">Consulte o <xref:System.Reflection.Emit.OpCodes.Mkrefany> a instrução para o conteúdo relacionado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3599">See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for related content.</span></span>  
  
 <span data-ttu-id="de0f3-3600"><xref:System.InvalidCastException> será gerada se `type` não é idêntico ao tipo armazenado na referência de tipo (nesse caso, `type` é a classe fornecida para o <xref:System.Reflection.Emit.OpCodes.Mkrefany> instrução construído disse referência tipada).</span><span class="sxs-lookup"><span data-stu-id="de0f3-3600"><xref:System.InvalidCastException> is thrown if `type` is not identical to the type stored in the type reference (in this case, `type` is the class supplied to the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction that constructed said typed reference).</span></span>  
  
 <span data-ttu-id="de0f3-3601"><xref:System.TypeLoadException> será gerada se `type` não pode ser encontrado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3601"><xref:System.TypeLoadException> is thrown if `type` cannot be found.</span></span>  
  
 <span data-ttu-id="de0f3-3602">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `refanyval` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3602">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanyval` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3603">ILGenerator.Emit (OpCode, tipo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3603">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3604">Divide dois valores e efetua o push do restante para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3604">Divides two values and pushes the remainder onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3605">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3605">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3606">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3606">Format</span></span>|<span data-ttu-id="de0f3-3607">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3607">Assembly Format</span></span>|<span data-ttu-id="de0f3-3608">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3608">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3609">5D</span><span class="sxs-lookup"><span data-stu-id="de0f3-3609">5D</span></span>|<span data-ttu-id="de0f3-3610">REM</span><span class="sxs-lookup"><span data-stu-id="de0f3-3610">rem</span></span>|<span data-ttu-id="de0f3-3611">Envia por push o resto da divisão `value1` por `value2` à pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3611">Pushes the remainder of dividing `value1` by `value2` onto the stack.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="de0f3-3612">ReplaceThisText</span><span class="sxs-lookup"><span data-stu-id="de0f3-3612">ReplaceThisText</span></span>  
  
 <span data-ttu-id="de0f3-3613">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3613">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3614">Um `value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3614">A `value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3615">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3615">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-3616">`value2` e `value1` são removidos da pilha e o restante `value1` `div` `value2` computado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3616">`value2` and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed.</span></span>  
  
4.  <span data-ttu-id="de0f3-3617">O resultado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3617">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3618">`result` = `value1` `rem` `value2` satisfaz as condições a seguir:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3618">`result` = `value1` `rem` `value2` satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="de0f3-3619">`result` = `value1` - `value2` `×` (`value1` `div` `value2`), e:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3619">`result` = `value1` - `value2` `×` (`value1` `div` `value2`), and:</span></span>  
  
 <span data-ttu-id="de0f3-3620">0 = &#124; `result` &#124; < &#124; `value2` &#124;, entrada (`result`) = logon (`value1`), onde `div` é a instrução de divisão que trunca em direção a zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3620">0 = &#124; `result` &#124; < &#124; `value2` &#124;, sign(`result`) = sign(`value1`), where `div` is the division instruction that truncates towards zero.</span></span>  
  
 <span data-ttu-id="de0f3-3621">Se `value2` for zero ou `value1` é infinito, o resultado é NaN.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3621">If `value2` is zero or `value1` is infinity the result is NaN.</span></span> <span data-ttu-id="de0f3-3622">Se `value2` é infinito, o resultado é `value1` (negada para `-infinity`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-3622">If `value2` is infinity, the result is `value1` (negated for `-infinity`).</span></span>  
  
 <span data-ttu-id="de0f3-3623">Operações de integrais geram <xref:System.DivideByZeroException> se `value2` é zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3623">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="de0f3-3624">Observe que, nas plataformas Intel com base em um <xref:System.OverflowException> é gerada quando a computação (minint `rem` -1).</span><span class="sxs-lookup"><span data-stu-id="de0f3-3624">Note that on the Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint `rem` -1).</span></span>  
  
 <span data-ttu-id="de0f3-3625">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `rem` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3625">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3626">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3626">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3627">Divide dois valores sem sinal e efetua o push do restante para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3627">Divides two unsigned values and pushes the remainder onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3628">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3628">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3629">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3629">Format</span></span>|<span data-ttu-id="de0f3-3630">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3630">Assembly Format</span></span>|<span data-ttu-id="de0f3-3631">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3631">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3632">5E</span><span class="sxs-lookup"><span data-stu-id="de0f3-3632">5E</span></span>|<span data-ttu-id="de0f3-3633">REM.Un</span><span class="sxs-lookup"><span data-stu-id="de0f3-3633">rem.un</span></span>|<span data-ttu-id="de0f3-3634">Envia por push o resto da divisão sem sinal `value1` por sem sinal `value2` à pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3634">Pushes the remainder of dividing unsigned `value1` by unsigned `value2` onto the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-3635">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3635">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3636">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3636">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3637">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3637">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-3638">`value2` e `value1` são removidos da pilha e o restante `value1` `div` `value2` computado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3638">`value2` and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed.</span></span>  
  
4.  <span data-ttu-id="de0f3-3639">O resultado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3639">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3640">`result` = `value1` `rem.un` `value2` satisfaz as condições a seguir:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3640">`result` = `value1` `rem.un` `value2` satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="de0f3-3641">`result` = `value1` - `value2` x (`value1` `div.un` `value2`), e:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3641">`result` = `value1` - `value2` x(`value1` `div.un` `value2`), and:</span></span>  
  
 <span data-ttu-id="de0f3-3642">0 = `result`  <  `value2`, onde `div.un` é a instrução de divisão sem sinal.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3642">0 = `result` < `value2`, where `div.un` is the unsigned division instruction.</span></span>  
  
 <span data-ttu-id="de0f3-3643">O `rem.un` calcula a instrução `result` e envia por push na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3643">The `rem.un` instruction computes `result` and pushes it on the stack.</span></span> <span data-ttu-id="de0f3-3644">`Rem.un` trata os seus argumentos como inteiros sem sinal, enquanto <xref:System.Reflection.Emit.OpCodes.Rem> trata-os inteiros com sinal como.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3644">`Rem.un` treats its arguments as unsigned integers, while <xref:System.Reflection.Emit.OpCodes.Rem> treats them as signed integers.</span></span>  
  
 <span data-ttu-id="de0f3-3645">`Rem.un` não é especificado para números de ponto flutuante.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3645">`Rem.un` is unspecified for floating-point numbers.</span></span>  
  
 <span data-ttu-id="de0f3-3646">Operações de integrais geram <xref:System.DivideByZeroException> se `value2` é zero.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3646">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="de0f3-3647">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `rem.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3647">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem.un` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3648">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3648">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3649">Retorna do método atual, enviando um valor retornado (se houver) da pilha de avaliação do computador chamado para a pilha de avaliação do chamador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3649">Returns from the current method, pushing a return value (if present) from the callee's evaluation stack onto the caller's evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3650">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3650">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3651">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3651">Format</span></span>|<span data-ttu-id="de0f3-3652">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3652">Assembly Format</span></span>|<span data-ttu-id="de0f3-3653">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3653">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3654">2A</span><span class="sxs-lookup"><span data-stu-id="de0f3-3654">2A</span></span>|<span data-ttu-id="de0f3-3655">RET</span><span class="sxs-lookup"><span data-stu-id="de0f3-3655">ret</span></span>|<span data-ttu-id="de0f3-3656">Retorna um método, possivelmente, retornando um valor.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3656">Returns from method, possibly returning a value.</span></span>|  
  
 <span data-ttu-id="de0f3-3657">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3657">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3658">O valor de retorno é aparecido da pilha de avaliação do receptor.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3658">The return value is popped from the callee evaluation stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3659">O valor de retorno obtido na etapa 1 é empurrado na pilha de avaliação do chamador.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3659">The return value obtained in step 1 is pushed onto the caller evaluation stack.</span></span>  
  
 <span data-ttu-id="de0f3-3660">Se o valor retornado não estiver presente na pilha de avaliação do receptor, nenhum valor é retornado (não há comportamentos de transição de pilha para o chamador ou receptor da chamada de método).</span><span class="sxs-lookup"><span data-stu-id="de0f3-3660">If the return value is not present on the callee evaluation stack, no value is returned (no stack transition behaviors for either the callee or caller method).</span></span>  
  
 <span data-ttu-id="de0f3-3661">O tipo do valor de retorno, se houver, do método atual determina o tipo de valor a ser obtido da parte superior da pilha e copiado para a pilha do método que chamou o método atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3661">The type of the return value, if any, of the current method determines the type of value to be fetched from the top of the stack and copied onto the stack of the method that called the current method.</span></span> <span data-ttu-id="de0f3-3662">A pilha de avaliação para o método atual deve estar vazia, exceto para o valor a ser retornado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3662">The evaluation stack for the current method must be empty except for the value to be returned.</span></span>  
  
 <span data-ttu-id="de0f3-3663">O `ret` instrução não pode ser usada para transferir o controle de um`try`, `filter`, `catch`, ou `finally` bloco.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3663">The `ret` instruction cannot be used to transfer control out of a`try`, `filter`, `catch`, or `finally` block.</span></span> <span data-ttu-id="de0f3-3664">De dentro uma `try` ou `catch`, use o <xref:System.Reflection.Emit.OpCodes.Leave> instrução com um destino de um `ret` instrução que está fora de todos os blocos de exceção.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3664">From within a `try` or `catch`, use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction with a destination of a `ret` instruction that is outside all enclosing exception blocks.</span></span> <span data-ttu-id="de0f3-3665">Porque o `filter` e `finally` blocos logicamente são parte da manipulação de exceção e não o método em que seu código é inserido, instruções de linguagem intermediária da Microsoft (MSIL) gerada corretamente não executam um método de retorno de dentro de um `filter` ou `finally`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3665">Because the `filter` and `finally` blocks are logically part of exception handling and not the method in which their code is embedded, correctly generated Microsoft Intermediate Language (MSIL) instructions do not perform a method return from within a `filter` or `finally`.</span></span>  
  
 <span data-ttu-id="de0f3-3666">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ret` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3666">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ret` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3667">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3667">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3668">Gera novamente a exceção atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3668">Rethrows the current exception.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3669">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3669">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3670">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3670">Format</span></span>|<span data-ttu-id="de0f3-3671">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3671">Assembly Format</span></span>|<span data-ttu-id="de0f3-3672">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3672">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3673">FE 1A</span><span class="sxs-lookup"><span data-stu-id="de0f3-3673">FE 1A</span></span>|<span data-ttu-id="de0f3-3674">relançar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3674">rethrow</span></span>|<span data-ttu-id="de0f3-3675">Relança a exceção atual</span><span class="sxs-lookup"><span data-stu-id="de0f3-3675">Rethrows the current exception</span></span>|  
  
 <span data-ttu-id="de0f3-3676">Nenhum comportamento de transição de pilha é definido para essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3676">No stack transition behavior is defined for this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-3677">O `rethrow` instrução só é permitida dentro do corpo de um `catch` manipulador.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3677">The `rethrow` instruction is only permitted within the body of a `catch` handler.</span></span> <span data-ttu-id="de0f3-3678">Ele gera a mesma exceção foi capturada por este manipulador.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3678">It throws the same exception that was caught by this handler.</span></span>  
  
 <span data-ttu-id="de0f3-3679">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `rethrow` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3679">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rethrow` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3680">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3680">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3681">Desloca um valor de inteiro para a esquerda (em zeros) por um número especificado de bits, efetuando o push do resultado para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3681">Shifts an integer value to the left (in zeroes) by a specified number of bits, pushing the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3682">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3682">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3683">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3683">Format</span></span>|<span data-ttu-id="de0f3-3684">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3684">Assembly Format</span></span>|<span data-ttu-id="de0f3-3685">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3685">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3686">62</span><span class="sxs-lookup"><span data-stu-id="de0f3-3686">62</span></span>|<span data-ttu-id="de0f3-3687">Shl</span><span class="sxs-lookup"><span data-stu-id="de0f3-3687">shl</span></span>|<span data-ttu-id="de0f3-3688">Desloca um número inteiro para a esquerda (mudando sua zeros).</span><span class="sxs-lookup"><span data-stu-id="de0f3-3688">Shifts an integer to the left (shifting in zeros).</span></span>|  
  
 <span data-ttu-id="de0f3-3689">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3689">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3690">Um valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3690">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3691">A quantidade de bits a ser deslocado é enviada para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3691">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-3692">O número de bits a ser deslocado e o valor são removidos da pilha; o valor é deslocados para a esquerda pelo número especificado de bits.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3692">The number of bits to be shifted and the value are popped from the stack; the value is shifted left by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="de0f3-3693">O resultado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3693">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3694">O `shl` instrução desloca o valor (tipo `int32`, `int64` ou `native int`) à esquerda pelo número especificado de bits.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3694">The `shl` instruction shifts the value (type `int32`, `int64` or `native int`) left by the specified number of bits.</span></span> <span data-ttu-id="de0f3-3695">O número de bits é um valor do tipo `int32` ou `native int`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3695">The number of bits is a value of type `int32` or `native int`.</span></span> <span data-ttu-id="de0f3-3696">O valor de retorno é especificado, se o número de bits de deslocamento é maior que ou igual à largura (em bits) do valor fornecido.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3696">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="de0f3-3697">`Shl` Insere um bit zero na última posição inferior em cada turno.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3697">`Shl` inserts a zero bit in the lowest position on each shift.</span></span>  
  
 <span data-ttu-id="de0f3-3698">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `shl` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3698">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shl` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3699">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3699">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3700">Desloca um valor de inteiro (no logon) para a direita em um número especificado de bits, efetuando o push do resultado para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3700">Shifts an integer value (in sign) to the right by a specified number of bits, pushing the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3701">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3701">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3702">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3702">Format</span></span>|<span data-ttu-id="de0f3-3703">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3703">Assembly Format</span></span>|<span data-ttu-id="de0f3-3704">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3704">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3705">63</span><span class="sxs-lookup"><span data-stu-id="de0f3-3705">63</span></span>|<span data-ttu-id="de0f3-3706">SHR</span><span class="sxs-lookup"><span data-stu-id="de0f3-3706">shr</span></span>|<span data-ttu-id="de0f3-3707">Desloca um número inteiro para a direita (mudando sua entrada).</span><span class="sxs-lookup"><span data-stu-id="de0f3-3707">Shifts an integer to the right (shifting in sign).</span></span>|  
  
 <span data-ttu-id="de0f3-3708">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3708">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3709">Um valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3709">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3710">A quantidade de bits a ser deslocado é enviada para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3710">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-3711">O número de bits a ser deslocado e o valor são removidos da pilha; o valor é deslocado à direita pelo número especificado de bits.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3711">The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="de0f3-3712">O resultado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3712">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3713">O `shr.un` instrução desloca o valor (tipo `int32`, `int64` ou `native int`) à direita pelo número especificado de bits.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3713">The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits.</span></span> <span data-ttu-id="de0f3-3714">O número de bits é um valor do tipo `int32` ou `native int`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3714">The number of bits is a value of type `int32` or `native int`.</span></span> <span data-ttu-id="de0f3-3715">O valor de retorno é especificado, se o número de bits de deslocamento é maior que ou igual à largura (em bits) do valor fornecido.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3715">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="de0f3-3716">`Shr` replica a ordem de alta bit em cada turno, preservando o sinal do valor original na `result`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3716">`Shr` replicates the high order bit on each shift, preserving the sign of the original value in the `result`.</span></span>  
  
 <span data-ttu-id="de0f3-3717">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `shr` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3717">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3718">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3718">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3719">Desloca um valor inteiro sem sinal (em zeros) para a direita em um número especificado de bits, efetuando o push do resultado para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3719">Shifts an unsigned integer value (in zeroes) to the right by a specified number of bits, pushing the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3720">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3720">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3721">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3721">Format</span></span>|<span data-ttu-id="de0f3-3722">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3722">Assembly Format</span></span>|<span data-ttu-id="de0f3-3723">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3723">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3724">64</span><span class="sxs-lookup"><span data-stu-id="de0f3-3724">64</span></span>|<span data-ttu-id="de0f3-3725">SHR.Un</span><span class="sxs-lookup"><span data-stu-id="de0f3-3725">shr.un</span></span>|<span data-ttu-id="de0f3-3726">Desloca um número inteiro para a direita (mudando em zeros).</span><span class="sxs-lookup"><span data-stu-id="de0f3-3726">Shifts an integer to the right (shifting in zeroes).</span></span>|  
  
 <span data-ttu-id="de0f3-3727">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3727">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3728">Um valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3728">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3729">A quantidade de bits a ser deslocado é enviada para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3729">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-3730">O número de bits a ser deslocado e o valor são removidos da pilha; o valor é deslocado à direita pelo número especificado de bits.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3730">The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="de0f3-3731">O resultado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3731">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3732">O `shr.un` instrução desloca o valor (tipo `int32`, `int64` ou `native int`) à direita pelo número especificado de bits.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3732">The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits.</span></span> <span data-ttu-id="de0f3-3733">O número de bits é um valor do tipo `int32`, `int64` ou `native int`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3733">The number of bits is a value of type `int32`, `int64` or `native int`.</span></span> <span data-ttu-id="de0f3-3734">O valor de retorno é especificado, se o número de bits de deslocamento é maior que ou igual à largura (em bits) do valor fornecido.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3734">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="de0f3-3735">`Shr.un` Insere um bit zero em posição mais elevada em cada turno.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3735">`Shr.un` inserts a zero bit in the highest position on each shift.</span></span>  
  
 <span data-ttu-id="de0f3-3736">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `shr.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3736">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr.un` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3737">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3737">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3738">Envia o tamanho, em bytes, de um tipo de valor fornecido para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3738">Pushes the size, in bytes, of a supplied value type onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3739">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3739">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3740">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3740">Format</span></span>|<span data-ttu-id="de0f3-3741">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3741">Assembly Format</span></span>|<span data-ttu-id="de0f3-3742">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3742">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3743">FE 1C &LT; `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-3743">FE 1C < `T` ></span></span>|<span data-ttu-id="de0f3-3744">sizeof `valType`</span><span class="sxs-lookup"><span data-stu-id="de0f3-3744">sizeof `valType`</span></span>|<span data-ttu-id="de0f3-3745">Enviar por push o tamanho, em bytes, de um tipo de valor como um `unsigned int32`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3745">Push the size, in bytes, of a value type as an `unsigned int32`.</span></span>|  
  
 <span data-ttu-id="de0f3-3746">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3746">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3747">O tamanho (em bytes) do tipo de valor fornecido (`valType`) é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3747">The size (in bytes) of the supplied value type (`valType`) is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3748">`valType` deve ser um token de metadados (um `typeref` ou `typedef`) que especifica um tipo de valor, o tipo de referência ou o parâmetro de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3748">`valType` must be a metadata token (a `typeref` or `typedef`) that specifies a value type, reference type, or generic type parameter.</span></span>  
  
 <span data-ttu-id="de0f3-3749">Para um tipo de referência, o tamanho retornado é o tamanho de um valor de referência do tipo (4 bytes em sistemas de 32 bits), não o tamanho dos dados armazenados em objetos referenciados pelo valor de referência.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3749">For a reference type, the size returned is the size of a reference value of the corresponding type (4 bytes on 32-bit systems), not the size of the data stored in objects referred to by the reference value.</span></span> <span data-ttu-id="de0f3-3750">Um parâmetro de tipo genérico pode ser usado somente no corpo do tipo ou método que o define.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3750">A generic type parameter can be used only in the body of the type or method that defines it.</span></span> <span data-ttu-id="de0f3-3751">Quando esse tipo ou método é instanciado, o parâmetro de tipo genérico é substituído por um tipo de valor ou tipo de referência.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3751">When that type or method is instantiated, the generic type parameter is replaced by a value type or reference type.</span></span>  
  
 <span data-ttu-id="de0f3-3752">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `sizeof` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3752">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sizeof` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3753">ILGenerator.Emit (OpCode, tipo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3753">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3754">Armazena o valor localizado no topo da pilha de avaliação no slot de argumento em um índice especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3754">Stores the value on top of the evaluation stack in the argument slot at a specified index.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3755">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3755">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3756">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3756">Format</span></span>|<span data-ttu-id="de0f3-3757">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3757">Assembly Format</span></span>|<span data-ttu-id="de0f3-3758">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3758">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3759">FE 0B &LT; `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-3759">FE 0B < `unsigned int16` ></span></span>|<span data-ttu-id="de0f3-3760">StarG `num`</span><span class="sxs-lookup"><span data-stu-id="de0f3-3760">starg `num`</span></span>|<span data-ttu-id="de0f3-3761">Exibe o valor superior da pilha e armazena-o no slot de argumento `num`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3761">Pops the top value from the stack and stores it in argument slot `num`.</span></span>|  
  
 <span data-ttu-id="de0f3-3762">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3762">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3763">O valor atualmente no topo da pilha é exibido e colocado no slot de argumento `num`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3763">The value currently on top of the stack is popped and placed in argument slot `num`.</span></span>  
  
 <span data-ttu-id="de0f3-3764">O `starg` instrução retira um valor da pilha e a coloca no slot de argumento `num`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3764">The `starg` instruction pops a value from the stack and places it in argument slot `num`.</span></span> <span data-ttu-id="de0f3-3765">O tipo do valor deve corresponder ao tipo do argumento, conforme especificado na assinatura do método atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3765">The type of the value must match the type of the argument, as specified in the current method's signature.</span></span>  
  
 <span data-ttu-id="de0f3-3766">Para obter os procedimentos que usam uma lista de argumentos de variável, o `starg` instrução pode ser usada apenas para inicial fixo de argumentos, não os na variável parte da assinatura.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3766">For procedures that take a variable argument list, the `starg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="de0f3-3767">Execução de um repositório em argumentos que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme se move da pilha para o argumento.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3767">Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</span></span> <span data-ttu-id="de0f3-3768">Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo `F`) para o tamanho associado com o argumento.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3768">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="de0f3-3769">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `starg` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3769">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `starg` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3770">ILGenerator.Emit (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3770">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3771">Armazena o valor localizado no topo da pilha de avaliação no slot de argumento em um índice especificado, de forma abreviada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3771">Stores the value on top of the evaluation stack in the argument slot at a specified index, short form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3772">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3772">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3773">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3773">Format</span></span>|<span data-ttu-id="de0f3-3774">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3774">Assembly Format</span></span>|<span data-ttu-id="de0f3-3775">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3775">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3776">10 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-3776">10 < `unsigned int8` ></span></span>|<span data-ttu-id="de0f3-3777">StarG.s `num`</span><span class="sxs-lookup"><span data-stu-id="de0f3-3777">starg.s `num`</span></span>|<span data-ttu-id="de0f3-3778">Exibe o valor superior da pilha e armazena-o no slot de argumento `num`, forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3778">Pops the top value from the stack and stores it in argument slot `num`, short form.</span></span>|  
  
 <span data-ttu-id="de0f3-3779">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3779">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3780">O valor atualmente no topo da pilha é exibido e colocado no slot de argumento `num`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3780">The value currently on top of the stack is popped and placed in argument slot `num`.</span></span>  
  
 <span data-ttu-id="de0f3-3781">O `starg.s` instrução retira um valor da pilha e a coloca no slot de argumento `num`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3781">The `starg.s` instruction pops a value from the stack and places it in argument slot `num`.</span></span> <span data-ttu-id="de0f3-3782">O tipo do valor deve corresponder ao tipo do argumento, conforme especificado na assinatura do método atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3782">The type of the value must match the type of the argument, as specified in the current method's signature.</span></span>  
  
 <span data-ttu-id="de0f3-3783">O `starg.s` instrução fornece uma codificação eficiente para uso com os 256 primeiros argumentos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3783">The `starg.s` instruction provides an efficient encoding for use with the first 256 arguments.</span></span>  
  
 <span data-ttu-id="de0f3-3784">Para obter os procedimentos que usam uma lista de argumentos de variável, o `starg.s` instrução pode ser usada apenas para inicial fixo de argumentos, não os na variável parte da assinatura.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3784">For procedures that take a variable argument list, the `starg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="de0f3-3785">Execução de um repositório em argumentos que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme se move da pilha para o argumento.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3785">Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</span></span> <span data-ttu-id="de0f3-3786">Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo `F`) para o tamanho associado com o argumento.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3786">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="de0f3-3787">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `starg.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3787">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `starg.s` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3788">ILGenerator.Emit (OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3788">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3789">Substitui o elemento de matriz de um índice especificado pelo valor na pilha de avaliação, cujo tipo é especificado na instrução.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3789">Replaces the array element at a given index with the value on the evaluation stack, whose type is specified in the instruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3790">A tabela a seguir lista a instrução hexadecimal e formato do assembly Microsoft intermediate language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3790">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3791">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3791">Format</span></span>|<span data-ttu-id="de0f3-3792">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3792">Assembly Format</span></span>|<span data-ttu-id="de0f3-3793">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3793">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3794">A4 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-3794">A4 < `T` ></span></span>|<span data-ttu-id="de0f3-3795">Stelem `typeTok`</span><span class="sxs-lookup"><span data-stu-id="de0f3-3795">stelem `typeTok`</span></span>|<span data-ttu-id="de0f3-3796">Substitui o elemento de matriz no índice fornecido com um valor do tipo `typeTok` na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3796">Replaces the array element at the supplied index with a value of type `typeTok` on the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-3797">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3797">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3798">Uma referência de objeto para uma matriz, `array`, é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3798">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3799">Um valor de índice `index`, para um elemento em `array` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3799">An index value, `index`, to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-3800">Um valor do tipo especificado na instrução é enviada por push à pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3800">A value of the type specified in the instruction is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="de0f3-3801">O valor, o índice e a referência de matriz são removidos da pilha; o valor é colocado no elemento da matriz no índice especificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3801">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="de0f3-3802">O `stelem` instrução substitui o valor do elemento no índice fornecido com base em zero na matriz unidimensional `array` com o valor.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3802">The `stelem` instruction replaces the value of the element at the supplied zero-based index in the one-dimensional array `array` with the value.</span></span> <span data-ttu-id="de0f3-3803">O valor tem o tipo especificado pelo token `typeTok` na instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3803">The value has the type specified by the token `typeTok` in the instruction.</span></span>  
  
 <span data-ttu-id="de0f3-3804">Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3804">Arrays are objects, and hence represented by a value of type `O`.</span></span> <span data-ttu-id="de0f3-3805">O índice é tipo `native int`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3805">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="de0f3-3806"><xref:System.NullReferenceException> será gerada se `array` é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3806"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-3807"><xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3807"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de0f3-3808"><xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3808"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de0f3-3809">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stelem` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3809">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3810">ILGenerator.Emit (OpCode, tipo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3810">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3811">Substitui o elemento de matriz em um determinado índice pelo valor <see langword="native int" /> na pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3811">Replaces the array element at a given index with the <see langword="native int" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3812">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3812">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3813">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3813">Format</span></span>|<span data-ttu-id="de0f3-3814">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3814">Assembly Format</span></span>|<span data-ttu-id="de0f3-3815">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3815">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3816">9B</span><span class="sxs-lookup"><span data-stu-id="de0f3-3816">9B</span></span>|<span data-ttu-id="de0f3-3817">stelem.i</span><span class="sxs-lookup"><span data-stu-id="de0f3-3817">stelem.i</span></span>|<span data-ttu-id="de0f3-3818">Substitui um elemento de matriz no índice fornecido com o `native int` valor na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3818">Replaces an array element at the supplied index with the `native int` value on the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-3819">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3819">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3820">Uma referência de objeto para uma matriz, `array`, é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3820">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3821">Um índice válido para um elemento em `array` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3821">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-3822">Um valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3822">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="de0f3-3823">O valor, o índice e a referência de matriz são removidos da pilha; o valor é colocado no elemento da matriz no índice especificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3823">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="de0f3-3824">O `stelem.i` instrução substitui o valor do elemento `index` na matriz unidimensional `array` com o `native int` valor inserido na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3824">The `stelem.i` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `native int` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3825">Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3825">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="de0f3-3826">O índice é tipo `native int`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3826">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="de0f3-3827"><xref:System.NullReferenceException> será gerada se `array` é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3827"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-3828"><xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3828"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de0f3-3829"><xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3829"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de0f3-3830">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stelem.i` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3830">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3831">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3831">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3832">Substitui o elemento de matriz em um determinado índice pelo valor <see langword="int8" /> na pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3832">Replaces the array element at a given index with the <see langword="int8" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3833">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3833">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3834">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3834">Format</span></span>|<span data-ttu-id="de0f3-3835">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3835">Assembly Format</span></span>|<span data-ttu-id="de0f3-3836">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3836">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3837">9C</span><span class="sxs-lookup"><span data-stu-id="de0f3-3837">9C</span></span>|<span data-ttu-id="de0f3-3838">stelem.i1</span><span class="sxs-lookup"><span data-stu-id="de0f3-3838">stelem.i1</span></span>|<span data-ttu-id="de0f3-3839">Substitui um elemento de matriz no índice fornecido com o `int8` valor na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3839">Replaces an array element at the supplied index with the `int8` value on the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-3840">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3840">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3841">Uma referência de objeto para uma matriz, `array`, é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3841">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3842">Um índice válido para um elemento em `array` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3842">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-3843">Um valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3843">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="de0f3-3844">O valor, o índice e a referência de matriz são removidos da pilha; o valor é colocado no elemento da matriz no índice especificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3844">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="de0f3-3845">O `stelem.i1` instrução substitui o valor do elemento `index` na matriz unidimensional `array` com o `int8` valor inserido na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3845">The `stelem.i1` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int8` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3846">Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3846">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="de0f3-3847">O índice é tipo `native int`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3847">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="de0f3-3848"><xref:System.NullReferenceException> será gerada se `array` é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3848"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-3849"><xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3849"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de0f3-3850"><xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3850"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de0f3-3851">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stelem.i1` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3851">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i1` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3852">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3852">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3853">Substitui o elemento de matriz em um determinado índice pelo valor <see langword="int16" /> na pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3853">Replaces the array element at a given index with the <see langword="int16" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3854">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3854">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3855">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3855">Format</span></span>|<span data-ttu-id="de0f3-3856">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3856">Assembly Format</span></span>|<span data-ttu-id="de0f3-3857">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3857">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3858">9D</span><span class="sxs-lookup"><span data-stu-id="de0f3-3858">9D</span></span>|<span data-ttu-id="de0f3-3859">stelem.i2</span><span class="sxs-lookup"><span data-stu-id="de0f3-3859">stelem.i2</span></span>|<span data-ttu-id="de0f3-3860">Substitui um elemento de matriz no índice fornecido com o `int16` valor na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3860">Replaces an array element at the supplied index with the `int16` value on the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-3861">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3861">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3862">Uma referência de objeto para uma matriz, `array`, é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3862">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3863">Um índice válido para um elemento em `array` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3863">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-3864">Um valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3864">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="de0f3-3865">O valor, o índice e a referência de matriz são removidos da pilha; o valor é colocado no elemento da matriz no índice especificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3865">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="de0f3-3866">O `stelem.i2` instrução substitui o valor do elemento `index` na matriz unidimensional `array` com o `int16` valor inserido na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3866">The `stelem.i2` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int16` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3867">Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3867">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="de0f3-3868">O índice é tipo `native int`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3868">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="de0f3-3869"><xref:System.NullReferenceException> será gerada se `array` é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3869"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-3870"><xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3870"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de0f3-3871"><xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3871"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de0f3-3872">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stelem.i2` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3872">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i2` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3873">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3873">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3874">Substitui o elemento de matriz em um determinado índice pelo valor <see langword="int32" /> na pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3874">Replaces the array element at a given index with the <see langword="int32" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3875">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3875">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3876">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3876">Format</span></span>|<span data-ttu-id="de0f3-3877">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3877">Assembly Format</span></span>|<span data-ttu-id="de0f3-3878">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3878">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3879">9E</span><span class="sxs-lookup"><span data-stu-id="de0f3-3879">9E</span></span>|<span data-ttu-id="de0f3-3880">stelem.i4</span><span class="sxs-lookup"><span data-stu-id="de0f3-3880">stelem.i4</span></span>|<span data-ttu-id="de0f3-3881">Substitui um elemento de matriz no índice fornecido com o `int32` valor na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3881">Replaces an array element at the supplied index with the `int32` value on the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-3882">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3882">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3883">Uma referência de objeto para uma matriz, `array`, é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3883">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3884">Um índice válido para um elemento em `array` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3884">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-3885">Um valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3885">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="de0f3-3886">O valor, o índice e a referência de matriz são removidos da pilha; o valor é colocado no elemento da matriz no índice especificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3886">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="de0f3-3887">O `stelem.i4` instrução substitui o valor do elemento `index` na matriz unidimensional `array` com o `int32` valor inserido na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3887">The `stelem.i4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int32` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3888">Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3888">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="de0f3-3889">O índice é tipo `native int`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3889">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="de0f3-3890"><xref:System.NullReferenceException> será gerada se `array` é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3890"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-3891"><xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3891"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de0f3-3892"><xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3892"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de0f3-3893">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stelem.i4` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3893">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i4` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3894">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3894">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3895">Substitui o elemento de matriz em um determinado índice pelo valor <see langword="int64" /> na pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3895">Replaces the array element at a given index with the <see langword="int64" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3896">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3896">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3897">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3897">Format</span></span>|<span data-ttu-id="de0f3-3898">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3898">Assembly Format</span></span>|<span data-ttu-id="de0f3-3899">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3899">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3900">9F</span><span class="sxs-lookup"><span data-stu-id="de0f3-3900">9F</span></span>|<span data-ttu-id="de0f3-3901">stelem.i8</span><span class="sxs-lookup"><span data-stu-id="de0f3-3901">stelem.i8</span></span>|<span data-ttu-id="de0f3-3902">Substitui um elemento de matriz no índice fornecido com o `int64` valor na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3902">Replaces an array element at the supplied index with the `int64` value on the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-3903">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3903">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3904">Uma referência de objeto para uma matriz, `array`, é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3904">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3905">Um índice válido para um elemento em `array` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3905">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-3906">Um valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3906">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="de0f3-3907">O valor, o índice e a referência de matriz são removidos da pilha; o valor é colocado no elemento da matriz no índice especificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3907">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="de0f3-3908">O `stelem.i8` instrução substitui o valor do elemento `index` na matriz unidimensional `array` com o `int64` valor inserido na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3908">The `stelem.i8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int64` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3909">Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3909">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="de0f3-3910">O índice é tipo `native int`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3910">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="de0f3-3911"><xref:System.NullReferenceException> será gerada se `array` é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3911"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-3912"><xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3912"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de0f3-3913"><xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3913"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de0f3-3914">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stelem.i8` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3914">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i8` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3915">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3915">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3916">Substitui o elemento de matriz em um determinado índice pelo valor <see langword="float32" /> na pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3916">Replaces the array element at a given index with the <see langword="float32" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3917">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3917">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3918">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3918">Format</span></span>|<span data-ttu-id="de0f3-3919">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3919">Assembly Format</span></span>|<span data-ttu-id="de0f3-3920">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3920">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3921">A0</span><span class="sxs-lookup"><span data-stu-id="de0f3-3921">A0</span></span>|<span data-ttu-id="de0f3-3922">stelem.r4</span><span class="sxs-lookup"><span data-stu-id="de0f3-3922">stelem.r4</span></span>|<span data-ttu-id="de0f3-3923">Substitui um elemento de matriz no índice fornecido com o `float32` valor na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3923">Replaces an array element at the supplied index with the `float32` value on the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-3924">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3924">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3925">Uma referência de objeto para uma matriz, `array`, é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3925">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3926">Um índice válido para um elemento em `array` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3926">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-3927">Um valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3927">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="de0f3-3928">O valor, o índice e a referência de matriz são removidos da pilha; o valor é colocado no elemento da matriz no índice especificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3928">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="de0f3-3929">O `stelem.r4` instrução substitui o valor do elemento `index` na matriz unidimensional `array` com o `float32` valor inserido na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3929">The `stelem.r4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float32` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3930">Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3930">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="de0f3-3931">O índice é tipo `native int`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3931">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="de0f3-3932"><xref:System.NullReferenceException> será gerada se `array` é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3932"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-3933"><xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3933"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de0f3-3934"><xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3934"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de0f3-3935">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stelem.r4` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3935">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r4` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3936">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3936">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3937">Substitui o elemento de matriz em um determinado índice pelo valor <see langword="float64" /> na pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3937">Replaces the array element at a given index with the <see langword="float64" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3938">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3938">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3939">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3939">Format</span></span>|<span data-ttu-id="de0f3-3940">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3940">Assembly Format</span></span>|<span data-ttu-id="de0f3-3941">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3941">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3942">A1</span><span class="sxs-lookup"><span data-stu-id="de0f3-3942">A1</span></span>|<span data-ttu-id="de0f3-3943">Stelem.R8</span><span class="sxs-lookup"><span data-stu-id="de0f3-3943">stelem.r8</span></span>|<span data-ttu-id="de0f3-3944">Substitui um elemento de matriz no índice fornecido com o `float64` valor na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3944">Replaces an array element at the supplied index with the `float64` value on the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-3945">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3945">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3946">Uma referência de objeto para uma matriz, `array`, é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3946">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3947">Um índice válido para um elemento em `array` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3947">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-3948">Um valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3948">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="de0f3-3949">O valor, o índice e a referência de matriz são removidos da pilha; o valor é colocado no elemento da matriz no índice especificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3949">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="de0f3-3950">O `stelem.r8` instrução substitui o valor do elemento `index` na matriz unidimensional `array` com o `float64` valor inserido na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3950">The `stelem.r8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float64` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3951">Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3951">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="de0f3-3952">O índice é tipo `native int`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3952">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="de0f3-3953"><xref:System.NullReferenceException> será gerada se `array` é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3953"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-3954"><xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3954"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de0f3-3955"><xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3955"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de0f3-3956">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stelem.r8` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3956">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r8` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3957">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3957">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3958">Substitui o elemento da matriz de um determinado índice com o valor de referência de objeto (tipo <see langword="O" />) na pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3958">Replaces the array element at a given index with the object ref value (type <see langword="O" />) on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3959">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3959">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3960">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3960">Format</span></span>|<span data-ttu-id="de0f3-3961">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3961">Assembly Format</span></span>|<span data-ttu-id="de0f3-3962">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3962">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3963">A2</span><span class="sxs-lookup"><span data-stu-id="de0f3-3963">A2</span></span>|<span data-ttu-id="de0f3-3964">stelem.ref</span><span class="sxs-lookup"><span data-stu-id="de0f3-3964">stelem.ref</span></span>|<span data-ttu-id="de0f3-3965">Substitui um elemento de matriz no índice fornecido com o `ref` valor (tipo `O`) na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3965">Replaces an array element at the supplied index with the `ref` value (type `O`) on the stack.</span></span>|  
  
 <span data-ttu-id="de0f3-3966">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3966">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3967">Uma referência de objeto para uma matriz, `array`, é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3967">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3968">Um índice válido para um elemento em `array` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3968">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-3969">Um valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3969">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="de0f3-3970">O valor, o índice e a referência de matriz são removidos da pilha; o valor é colocado no elemento da matriz no índice especificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3970">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="de0f3-3971">O `stelem.ref` instrução substitui o valor do elemento no índice fornecido na matriz unidimensional `array` com o `ref` (tipo `O`) valor inserido na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3971">The `stelem.ref` instruction replaces the value of the element at the supplied index in the one-dimensional array `array` with the `ref` (type `O`) value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-3972">Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3972">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="de0f3-3973">O índice é tipo `native int`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3973">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="de0f3-3974">Observe que `stelem.ref` converte implicitamente o valor fornecido para o tipo de elemento `array` antes de atribuir o valor para o elemento da matriz.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3974">Note that `stelem.ref` implicitly casts the supplied value to the element type of `array` before assigning the value to the array element.</span></span> <span data-ttu-id="de0f3-3975">Essa conversão pode falhar, mesmo para o código verificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3975">This cast can fail, even for verified code.</span></span> <span data-ttu-id="de0f3-3976">Portanto, o `stelem.ref` instrução pode lançar <xref:System.InvalidCastException>.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3976">Thus the `stelem.ref` instruction can throw <xref:System.InvalidCastException>.</span></span> <span data-ttu-id="de0f3-3977">Para matrizes unidimensionais que não são com base em zero em matrizes multidimensionais, o <xref:System.Array> classe fornece um <xref:System.Array.SetValue%2A> método.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3977">For one-dimensional arrays that aren't zero-based and for multidimensional arrays, the <xref:System.Array> class provides a <xref:System.Array.SetValue%2A> method.</span></span>  
  
 <span data-ttu-id="de0f3-3978"><xref:System.NullReferenceException> será gerada se `array` é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3978"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-3979"><xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3979"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de0f3-3980"><xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3980"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de0f3-3981">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stelem.ref` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3981">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.ref` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-3982">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-3982">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-3983">Substitui o valor armazenado no campo de uma referência de objeto ou de um ponteiro por um novo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-3983">Replaces the value stored in the field of an object reference or pointer with a new value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-3984">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3984">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-3985">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-3985">Format</span></span>|<span data-ttu-id="de0f3-3986">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-3986">Assembly Format</span></span>|<span data-ttu-id="de0f3-3987">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-3987">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-3988">7D < `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-3988">7D < `T` ></span></span>|<span data-ttu-id="de0f3-3989">stfld `field`</span><span class="sxs-lookup"><span data-stu-id="de0f3-3989">stfld `field`</span></span>|<span data-ttu-id="de0f3-3990">Substitui o valor de `field` do objeto com um novo valor.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3990">Replaces the value of `field` of the object with a new value.</span></span>|  
  
 <span data-ttu-id="de0f3-3991">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-3991">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-3992">Uma referência de objeto ou um ponteiro é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3992">An object reference or pointer is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-3993">Um valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3993">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-3994">O valor e o ponteiro/referência de objeto são removidos da pilha; o valor de `field` no objeto é substituído com o valor fornecido.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3994">The value and the object reference/pointer are popped from the stack; the value of `field` in the object is replaced with the supplied value.</span></span>  
  
 <span data-ttu-id="de0f3-3995">O `stfld` instrução substitui o valor de um campo de um objeto (tipo `O`) ou por meio de um ponteiro (tipo `native int`, `&`, ou `*`) com um valor fornecido.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3995">The `stfld` instruction replaces the value of a field of an object (type `O`) or via a pointer (type `native int`, `&`, or `*`) with a given value.</span></span> <span data-ttu-id="de0f3-3996">`Field` é um token de metadados que se refere a um campo de referência de membro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3996">`Field` is a metadata token that refers to a field member reference.</span></span> <span data-ttu-id="de0f3-3997">O `stfld` instrução pode ter um prefixo de um ou ambos <xref:System.Reflection.Emit.OpCodes.Unaligned> e <xref:System.Reflection.Emit.OpCodes.Volatile>.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3997">The `stfld` instruction can have a prefix of either or both of <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile>.</span></span>  
  
 <span data-ttu-id="de0f3-3998"><xref:System.NullReferenceException> será gerada se o ponteiro ou referência de objeto é uma referência nula e o campo não é estático.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3998"><xref:System.NullReferenceException> is thrown if the object reference or pointer is a null reference and the field isn't static.</span></span>  
  
 <span data-ttu-id="de0f3-3999"><xref:System.MissingFieldException> será gerada se `field` não for encontrado nos metadados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-3999"><xref:System.MissingFieldException> is thrown if `field` is not found in the metadata.</span></span> <span data-ttu-id="de0f3-4000">Normalmente, isso é verificado quando a instrução de Microsoft Intermediate Language (MSIL) é convertida em código nativo, não em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4000">This is typically checked when the Microsoft Intermediate Language (MSIL) instruction is converted to native code, not at runtime.</span></span>  
  
 <span data-ttu-id="de0f3-4001">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stfld` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4001">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stfld` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-4002">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4002">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-4003">Armazena um valor do tipo <see langword="native int" /> em um endereço fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4003">Stores a value of type <see langword="native int" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4004">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4004">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-4005">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-4005">Format</span></span>|<span data-ttu-id="de0f3-4006">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-4006">Assembly Format</span></span>|<span data-ttu-id="de0f3-4007">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-4007">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-4008">DF</span><span class="sxs-lookup"><span data-stu-id="de0f3-4008">DF</span></span>|<span data-ttu-id="de0f3-4009">stind.i</span><span class="sxs-lookup"><span data-stu-id="de0f3-4009">stind.i</span></span>|<span data-ttu-id="de0f3-4010">Armazena um `native int` valor em um determinado endereço.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4010">Stores a `native int` value at a given address.</span></span>|  
  
 <span data-ttu-id="de0f3-4011">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4011">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-4012">Um endereço será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4012">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-4013">Um valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4013">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-4014">O valor e o endereço são removidos da pilha; o valor é armazenado no endereço.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4014">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="de0f3-4015">O `stind.i` instrução armazena uma `native int` valor no endereço fornecido (tipo `native int`, `*`, ou `&`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-4015">The `stind.i` instruction stores a `native int` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="de0f3-4016">Tipo de operação segura requer que o `stind.i` instrução a ser usado de maneira consistente com o tipo do ponteiro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4016">Type safe operation requires that the `stind.i` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="de0f3-4017">A operação do `stind.i` instrução pode ser alterada por um imediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instrução de prefixo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4017">The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="de0f3-4018"><xref:System.NullReferenceException> será gerada se `addr` não são alinhados naturalmente para o tipo de argumento implicado, o sufixo de instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4018"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="de0f3-4019">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stind.i` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4019">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-4020">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4020">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-4021">Armazena um valor do tipo <see langword="int8" /> em um endereço fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4021">Stores a value of type <see langword="int8" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4022">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4022">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-4023">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-4023">Format</span></span>|<span data-ttu-id="de0f3-4024">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-4024">Assembly Format</span></span>|<span data-ttu-id="de0f3-4025">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-4025">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-4026">52</span><span class="sxs-lookup"><span data-stu-id="de0f3-4026">52</span></span>|<span data-ttu-id="de0f3-4027">stind.I1</span><span class="sxs-lookup"><span data-stu-id="de0f3-4027">stind.i1</span></span>|<span data-ttu-id="de0f3-4028">Armazena um `int8` valor em um determinado endereço.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4028">Stores an `int8` value at a given address.</span></span>|  
  
 <span data-ttu-id="de0f3-4029">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4029">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-4030">Um endereço será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4030">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-4031">Um valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4031">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-4032">O valor e o endereço são removidos da pilha; o valor é armazenado no endereço.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4032">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="de0f3-4033">O `stind.i1` instrução armazena uma `int8` valor no endereço fornecido (tipo `native int`, `*`, ou `&`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-4033">The `stind.i1` instruction stores an `int8` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="de0f3-4034">Tipo de operação segura requer que o `stind.i1` instrução a ser usado de maneira consistente com o tipo do ponteiro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4034">Type safe operation requires that the `stind.i1` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="de0f3-4035">A operação do `stind.i1` instrução pode ser alterada por um imediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instrução de prefixo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4035">The operation of the `stind.i1` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="de0f3-4036"><xref:System.NullReferenceException> será gerada se `addr` não são alinhados naturalmente para o tipo de argumento implicado, o sufixo de instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4036"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="de0f3-4037">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stind.i1` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4037">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i1` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-4038">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4038">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-4039">Armazena um valor do tipo <see langword="int16" /> em um endereço fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4039">Stores a value of type <see langword="int16" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4040">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4040">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-4041">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-4041">Format</span></span>|<span data-ttu-id="de0f3-4042">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-4042">Assembly Format</span></span>|<span data-ttu-id="de0f3-4043">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-4043">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-4044">53</span><span class="sxs-lookup"><span data-stu-id="de0f3-4044">53</span></span>|<span data-ttu-id="de0f3-4045">stind.I2</span><span class="sxs-lookup"><span data-stu-id="de0f3-4045">stind.i2</span></span>|<span data-ttu-id="de0f3-4046">Armazena um `int16` valor em um determinado endereço.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4046">Stores an `int16` value at a given address.</span></span>|  
  
 <span data-ttu-id="de0f3-4047">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4047">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-4048">Um endereço será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4048">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-4049">Um valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4049">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-4050">O valor e o endereço são removidos da pilha; o valor é armazenado no endereço.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4050">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="de0f3-4051">O `stind.i2` instrução armazena uma `int16` valor no endereço fornecido (tipo `native int`, `*`, ou `&`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-4051">The `stind.i2` instruction stores an `int16` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="de0f3-4052">Tipo de operação segura requer que o `stind.2i` instrução a ser usado de maneira consistente com o tipo do ponteiro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4052">Type safe operation requires that the `stind.2i` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="de0f3-4053">A operação do `stind.i2` instrução pode ser alterada por um imediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instrução de prefixo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4053">The operation of the `stind.i2` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="de0f3-4054"><xref:System.NullReferenceException> será gerada se `addr` não são alinhados naturalmente para o tipo de argumento implicado, o sufixo de instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4054"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="de0f3-4055">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stind.i2` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4055">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i2` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-4056">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4056">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-4057">Armazena um valor do tipo <see langword="int32" /> em um endereço fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4057">Stores a value of type <see langword="int32" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4058">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4058">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-4059">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-4059">Format</span></span>|<span data-ttu-id="de0f3-4060">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-4060">Assembly Format</span></span>|<span data-ttu-id="de0f3-4061">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-4061">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-4062">54</span><span class="sxs-lookup"><span data-stu-id="de0f3-4062">54</span></span>|<span data-ttu-id="de0f3-4063">stind.i4</span><span class="sxs-lookup"><span data-stu-id="de0f3-4063">stind.i4</span></span>|<span data-ttu-id="de0f3-4064">Armazena um `int32` valor em um determinado endereço.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4064">Stores an `int32` value at a given address.</span></span>|  
  
 <span data-ttu-id="de0f3-4065">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4065">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-4066">Um endereço será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4066">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-4067">Um valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4067">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-4068">O valor e o endereço são removidos da pilha; o valor é armazenado no endereço.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4068">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="de0f3-4069">O `stind.i4` instrução armazena uma `int32` valor no endereço fornecido (tipo `native int`, `*`, ou `&`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-4069">The `stind.i4` instruction stores an `int32` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="de0f3-4070">Tipo de operação segura requer que o `stind.i4` instrução a ser usado de maneira consistente com o tipo do ponteiro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4070">Type safe operation requires that the `stind.i4` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="de0f3-4071">A operação do `stind.i4` instrução pode ser alterada por um imediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instrução de prefixo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4071">The operation of the `stind.i4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="de0f3-4072"><xref:System.NullReferenceException> será gerada se `addr` não são alinhados naturalmente para o tipo de argumento implicado, o sufixo de instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4072"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="de0f3-4073">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stind.i4` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4073">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i4` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-4074">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4074">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-4075">Armazena um valor do tipo <see langword="int64" /> em um endereço fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4075">Stores a value of type <see langword="int64" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4076">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4076">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-4077">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-4077">Format</span></span>|<span data-ttu-id="de0f3-4078">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-4078">Assembly Format</span></span>|<span data-ttu-id="de0f3-4079">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-4079">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-4080">55</span><span class="sxs-lookup"><span data-stu-id="de0f3-4080">55</span></span>|<span data-ttu-id="de0f3-4081">stind.I8</span><span class="sxs-lookup"><span data-stu-id="de0f3-4081">stind.i8</span></span>|<span data-ttu-id="de0f3-4082">Armazena um `int64` valor em um determinado endereço.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4082">Stores an `int64` value at a given address.</span></span>|  
  
 <span data-ttu-id="de0f3-4083">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4083">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-4084">Um endereço será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4084">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-4085">Um valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4085">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-4086">O valor e o endereço são removidos da pilha; o valor é armazenado no endereço.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4086">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="de0f3-4087">O `stind.i8` instrução armazena uma `int64` valor no endereço fornecido (tipo `native int`, `*`, ou `&`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-4087">The `stind.i8` instruction stores an `int64` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="de0f3-4088">Tipo de operação segura requer que o `stind.i8` instrução a ser usado de maneira consistente com o tipo do ponteiro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4088">Type safe operation requires that the `stind.i8` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="de0f3-4089">A operação do `stind.i` instrução pode ser alterada por um imediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instrução de prefixo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4089">The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="de0f3-4090"><xref:System.NullReferenceException> será gerada se `addr` não são alinhados naturalmente para o tipo de argumento implicado, o sufixo de instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4090"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="de0f3-4091">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stind.i8` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4091">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i8` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-4092">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4092">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-4093">Armazena um valor do tipo <see langword="float32" /> em um endereço fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4093">Stores a value of type <see langword="float32" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4094">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4094">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-4095">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-4095">Format</span></span>|<span data-ttu-id="de0f3-4096">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-4096">Assembly Format</span></span>|<span data-ttu-id="de0f3-4097">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-4097">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-4098">56</span><span class="sxs-lookup"><span data-stu-id="de0f3-4098">56</span></span>|<span data-ttu-id="de0f3-4099">stind.R4</span><span class="sxs-lookup"><span data-stu-id="de0f3-4099">stind.r4</span></span>|<span data-ttu-id="de0f3-4100">Armazena um `float32` valor em um determinado endereço.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4100">Stores a `float32` value at a given address.</span></span>|  
  
 <span data-ttu-id="de0f3-4101">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4101">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-4102">Um endereço será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4102">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-4103">Um valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4103">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-4104">O valor e o endereço são removidos da pilha; o valor é armazenado no endereço.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4104">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="de0f3-4105">O `stind.r4` instrução armazena uma `float32` valor no endereço fornecido (tipo `native int`, `*`, ou `&`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-4105">The `stind.r4` instruction stores a `float32` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="de0f3-4106">Tipo de operação segura requer que o `stind.r4` instrução a ser usado de maneira consistente com o tipo do ponteiro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4106">Type safe operation requires that the `stind.r4` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="de0f3-4107">A operação do `stind.r4` instrução pode ser alterada por um imediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instrução de prefixo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4107">The operation of the `stind.r4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="de0f3-4108"><xref:System.NullReferenceException> será gerada se `addr` não são alinhados naturalmente para o tipo de argumento implicado, o sufixo de instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4108"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="de0f3-4109">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stind.r4` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4109">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r4` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-4110">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4110">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-4111">Armazena um valor do tipo <see langword="float64" /> em um endereço fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4111">Stores a value of type <see langword="float64" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4112">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4112">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-4113">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-4113">Format</span></span>|<span data-ttu-id="de0f3-4114">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-4114">Assembly Format</span></span>|<span data-ttu-id="de0f3-4115">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-4115">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-4116">57</span><span class="sxs-lookup"><span data-stu-id="de0f3-4116">57</span></span>|<span data-ttu-id="de0f3-4117">stind.R8</span><span class="sxs-lookup"><span data-stu-id="de0f3-4117">stind.r8</span></span>|<span data-ttu-id="de0f3-4118">Armazena um `float64` valor em um determinado endereço.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4118">Stores a `float64` value at a given address.</span></span>|  
  
 <span data-ttu-id="de0f3-4119">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4119">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-4120">Um endereço será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4120">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-4121">Um valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4121">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-4122">O valor e o endereço são removidos da pilha; o valor é armazenado no endereço.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4122">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="de0f3-4123">O `stind.r8` instrução armazena uma `float64` valor no endereço fornecido (tipo `native int`, `*`, ou `&`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-4123">The `stind.r8` instruction stores a `float64` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="de0f3-4124">Tipo de operação segura requer que o `stind.r8` instrução a ser usado de maneira consistente com o tipo do ponteiro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4124">Type safe operation requires that the `stind.r8` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="de0f3-4125">A operação do `stind.r8` instrução pode ser alterada por um imediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instrução de prefixo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4125">The operation of the `stind.r8` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="de0f3-4126"><xref:System.NullReferenceException> será gerada se `addr` não são alinhados naturalmente para o tipo de argumento implicado, o sufixo de instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4126"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="de0f3-4127">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stind.r8` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4127">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r8` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-4128">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4128">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-4129">Armazena um valor de referência de objeto em um endereço fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4129">Stores a object reference value at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4130">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4130">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-4131">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-4131">Format</span></span>|<span data-ttu-id="de0f3-4132">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-4132">Assembly Format</span></span>|<span data-ttu-id="de0f3-4133">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-4133">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-4134">51</span><span class="sxs-lookup"><span data-stu-id="de0f3-4134">51</span></span>|<span data-ttu-id="de0f3-4135">stind.ref</span><span class="sxs-lookup"><span data-stu-id="de0f3-4135">stind.ref</span></span>|<span data-ttu-id="de0f3-4136">Armazena uma referência de objeto (tipo `O`) valor em um determinado endereço.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4136">Stores an object reference (type `O`) value at a given address.</span></span>|  
  
 <span data-ttu-id="de0f3-4137">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4137">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-4138">Um endereço será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4138">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-4139">Um valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4139">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-4140">O valor e o endereço são removidos da pilha; o valor é armazenado no endereço.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4140">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="de0f3-4141">O `stind.ref` instrução armazena um valor de referência de objeto no endereço fornecido (tipo `native int`, `*`, ou `&`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-4141">The `stind.ref` instruction stores an object reference value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="de0f3-4142">Tipo de operação segura requer que o `stind.ref` instrução a ser usado de maneira consistente com o tipo do ponteiro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4142">Type safe operation requires that the `stind.ref` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="de0f3-4143">A operação do `stind.ref` instrução pode ser alterada por um imediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instrução de prefixo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4143">The operation of the `stind.ref` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="de0f3-4144"><xref:System.NullReferenceException> será gerada se `addr` não são alinhados naturalmente para o tipo de argumento implicado, o sufixo de instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4144"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="de0f3-4145">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stind.ref` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4145">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.ref` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-4146">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4146">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-4147">Exibe o valor atual da parte superior da pilha de avaliação e a armazena em uma lista de variáveis locais em um índice especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4147">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a specified index.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4148">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4148">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-4149">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-4149">Format</span></span>|<span data-ttu-id="de0f3-4150">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-4150">Assembly Format</span></span>|<span data-ttu-id="de0f3-4151">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-4151">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-4152">FE 0E &LT; `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-4152">FE 0E < `unsigned int16` ></span></span>|<span data-ttu-id="de0f3-4153">stloc `index`</span><span class="sxs-lookup"><span data-stu-id="de0f3-4153">stloc `index`</span></span>|<span data-ttu-id="de0f3-4154">Exibe um valor da pilha e o armazena na variável local `index`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4154">Pops a value from the stack and stores it in local variable `index`.</span></span>|  
  
 <span data-ttu-id="de0f3-4155">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4155">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-4156">Um valor é aparecido da pilha e colocado na variável local `index`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4156">A value is popped off of the stack and placed in local variable `index`.</span></span>  
  
 <span data-ttu-id="de0f3-4157">O `stloc` instrução exibe o valor superior da pilha de avaliação e será movida para o número de variável local `index`, onde as variáveis locais são numerados de 0 em diante.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4157">The `stloc` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="de0f3-4158">O tipo do valor deve corresponder ao tipo da variável local, conforme especificado na assinatura de local do método atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4158">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="de0f3-4159">Armazenando em locais que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme se move da pilha para a variável local.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4159">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="de0f3-4160">Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo `F`) para o tamanho associado com o argumento.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4160">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="de0f3-4161">Instruções de Microsoft Intermediate Language (MSIL) correto exigem que `index` ser um índice de local válido.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4161">Correct Microsoft Intermediate Language (MSIL) instructions require that `index` be a valid local index.</span></span> <span data-ttu-id="de0f3-4162">Para o `stloc` instrução de `index` deve estar no intervalo de 0 a 65534 inclusivo (especificamente, 65535 não é válido).</span><span class="sxs-lookup"><span data-stu-id="de0f3-4162">For the `stloc` instruction, `index` must lie in the range 0 to 65534 inclusive (specifically, 65535 is not valid).</span></span> <span data-ttu-id="de0f3-4163">O motivo para exceto 65535 é pragmático: implementações provavelmente usará um inteiro de 2 bytes para controlar o índice do local, bem como o número total de locais para um determinado método.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4163">The reason for excluding 65535 is pragmatic: likely implementations will use a 2-byte integer to track both a local's index, as well as the total number of locals for a given method.</span></span> <span data-ttu-id="de0f3-4164">Se um índice de 65535 tivesse sido feito válido, ele exigiria um inteiro maior controlar o número de locais em um método desse tipo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4164">If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</span></span>  
  
 <span data-ttu-id="de0f3-4165">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas de método podem usar o `stloc` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4165">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-4166">ILGenerator.Emit (OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4166">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="de0f3-4167">ILGenerator.Emit (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4167">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-4168">Exibe o valor atual da parte superior da pilha de avaliação e armazena em uma lista de variáveis local no índice 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4168">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 0.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4169">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4169">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-4170">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-4170">Format</span></span>|<span data-ttu-id="de0f3-4171">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-4171">Assembly Format</span></span>|<span data-ttu-id="de0f3-4172">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-4172">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-4173">0A</span><span class="sxs-lookup"><span data-stu-id="de0f3-4173">0A</span></span>|<span data-ttu-id="de0f3-4174">stloc.0</span><span class="sxs-lookup"><span data-stu-id="de0f3-4174">stloc.0</span></span>|<span data-ttu-id="de0f3-4175">Retira um valor da pilha em 0 de variável local.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4175">Pops a value from the stack into local variable 0.</span></span>|  
  
 <span data-ttu-id="de0f3-4176">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4176">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-4177">Um valor é aparecido da pilha e colocado na variável local indexada por 0.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4177">A value is popped off of the stack and placed in the local variable indexed by 0.</span></span>  
  
 <span data-ttu-id="de0f3-4178">O `stloc.0` instrução exibe o valor superior da pilha de avaliação e será movida para a variável local indexada por 0.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4178">The `stloc.0` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 0.</span></span> <span data-ttu-id="de0f3-4179">O tipo do valor deve corresponder ao tipo da variável local, conforme especificado na assinatura de local do método atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4179">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="de0f3-4180">`stloc.0` é uma codificação especialmente eficiente para armazenar valores na variável local 0.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4180">`stloc.0` is an especially efficient encoding for storing values in local variable 0.</span></span>  
  
 <span data-ttu-id="de0f3-4181">Armazenando em locais que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme se move da pilha para a variável local.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4181">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="de0f3-4182">Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo `F`) para o tamanho associado com o argumento.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4182">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="de0f3-4183">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stloc.0` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4183">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.0` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-4184">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4184">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-4185">Exibe o valor atual da parte superior da pilha de avaliação e armazena em uma lista de variáveis local no índice 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4185">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 1.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4186">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4186">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-4187">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-4187">Format</span></span>|<span data-ttu-id="de0f3-4188">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-4188">Assembly Format</span></span>|<span data-ttu-id="de0f3-4189">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-4189">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-4190">0B</span><span class="sxs-lookup"><span data-stu-id="de0f3-4190">0B</span></span>|<span data-ttu-id="de0f3-4191">stloc.1</span><span class="sxs-lookup"><span data-stu-id="de0f3-4191">stloc.1</span></span>|<span data-ttu-id="de0f3-4192">Retira um valor da pilha em 1 de variável local.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4192">Pops a value from the stack into local variable 1.</span></span>|  
  
 <span data-ttu-id="de0f3-4193">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4193">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-4194">Um valor é aparecido da pilha e colocado na variável local indexada por 1.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4194">A value is popped off of the stack and placed in the local variable indexed by 1.</span></span>  
  
 <span data-ttu-id="de0f3-4195">O `stloc.1` instrução exibe o valor superior da pilha de avaliação e será movida para a variável local indexada por 1.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4195">The `stloc.1` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 1.</span></span> <span data-ttu-id="de0f3-4196">O tipo do valor deve corresponder ao tipo da variável local, conforme especificado na assinatura de local do método atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4196">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="de0f3-4197">`stloc.1` é uma codificação especialmente eficiente para armazenar valores na variável local 1.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4197">`stloc.1` is an especially efficient encoding for storing values in local variable 1.</span></span>  
  
 <span data-ttu-id="de0f3-4198">Armazenando em locais que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme se move da pilha para a variável local.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4198">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="de0f3-4199">Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo `F`) para o tamanho associado com o argumento.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4199">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="de0f3-4200">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stloc.1` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4200">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.1` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-4201">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4201">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-4202">Exibe o valor atual da parte superior da pilha de avaliação e armazena-o em uma lista de variáveis local no índice 2.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4202">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 2.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4203">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4203">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-4204">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-4204">Format</span></span>|<span data-ttu-id="de0f3-4205">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-4205">Assembly Format</span></span>|<span data-ttu-id="de0f3-4206">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-4206">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-4207">0C</span><span class="sxs-lookup"><span data-stu-id="de0f3-4207">0C</span></span>|<span data-ttu-id="de0f3-4208">stloc.2</span><span class="sxs-lookup"><span data-stu-id="de0f3-4208">stloc.2</span></span>|<span data-ttu-id="de0f3-4209">Exibe um valor da pilha para a variável local 2</span><span class="sxs-lookup"><span data-stu-id="de0f3-4209">Pops a value from the stack into local variable 2</span></span>|  
  
 <span data-ttu-id="de0f3-4210">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4210">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-4211">Um valor é aparecido da pilha e colocado na variável local indexada por 2.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4211">A value is popped off of the stack and placed in the local variable indexed by 2.</span></span>  
  
 <span data-ttu-id="de0f3-4212">O `stloc.2` instrução exibe o valor superior da pilha de avaliação e será movida para a variável local indexada por 2.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4212">The `stloc.2` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 2.</span></span> <span data-ttu-id="de0f3-4213">O tipo do valor deve corresponder ao tipo da variável local, conforme especificado na assinatura de local do método atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4213">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="de0f3-4214">`stloc.2` é uma codificação especialmente eficiente para armazenar valores em 2 de variável local.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4214">`stloc.2` is an especially efficient encoding for storing values in local variable 2.</span></span>  
  
 <span data-ttu-id="de0f3-4215">Armazenando em locais que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme se move da pilha para a variável local.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4215">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="de0f3-4216">Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo `F`) para o tamanho associado com o argumento.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4216">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="de0f3-4217">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stloc.2` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4217">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.2` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-4218">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4218">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-4219">Exibe o valor atual da parte superior da pilha de avaliação e armazena-o em uma lista de variáveis local no índice 3.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4219">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 3.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4220">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4220">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-4221">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-4221">Format</span></span>|<span data-ttu-id="de0f3-4222">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-4222">Assembly Format</span></span>|<span data-ttu-id="de0f3-4223">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-4223">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-4224">0D</span><span class="sxs-lookup"><span data-stu-id="de0f3-4224">0D</span></span>|<span data-ttu-id="de0f3-4225">stloc.3</span><span class="sxs-lookup"><span data-stu-id="de0f3-4225">stloc.3</span></span>|<span data-ttu-id="de0f3-4226">Exibe um valor da pilha para a variável local 3</span><span class="sxs-lookup"><span data-stu-id="de0f3-4226">Pops a value from the stack into local variable 3</span></span>|  
  
 <span data-ttu-id="de0f3-4227">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4227">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-4228">Um valor é aparecido da pilha e colocado na variável local indexada por 3.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4228">A value is popped off of the stack and placed in the local variable indexed by 3.</span></span>  
  
 <span data-ttu-id="de0f3-4229">O `stloc.3` instrução exibe o valor superior da pilha de avaliação e será movida para a variável local indexada por 3.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4229">The `stloc.3` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 3.</span></span> <span data-ttu-id="de0f3-4230">O tipo do valor deve corresponder ao tipo da variável local, conforme especificado na assinatura de local do método atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4230">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="de0f3-4231">`stloc.3` é uma codificação especialmente eficiente para armazenar valores em 3 de variável local.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4231">`stloc.3` is an especially efficient encoding for storing values in local variable 3.</span></span>  
  
 <span data-ttu-id="de0f3-4232">Armazenando em locais que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme se move da pilha para a variável local.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4232">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="de0f3-4233">Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo `F`) para o tamanho associado com o argumento.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4233">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="de0f3-4234">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stloc.3` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4234">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.3` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-4235">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4235">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-4236">Exibe o valor atual da parte superior da pilha de avaliação e o armazena em uma lista de variáveis locais em <paramref name="index" /> (forma abreviada).</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4236">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at <paramref name="index" /> (short form).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4237">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4237">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-4238">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-4238">Format</span></span>|<span data-ttu-id="de0f3-4239">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-4239">Assembly Format</span></span>|<span data-ttu-id="de0f3-4240">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-4240">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-4241">13 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-4241">13 < `unsigned int8` ></span></span>|<span data-ttu-id="de0f3-4242">stloc.s `index`</span><span class="sxs-lookup"><span data-stu-id="de0f3-4242">stloc.s `index`</span></span>|<span data-ttu-id="de0f3-4243">Exibe um valor da pilha e o armazena na variável local `index`, forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4243">Pops a value from the stack and stores it in local variable `index`, short form.</span></span>|  
  
 <span data-ttu-id="de0f3-4244">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4244">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-4245">Um valor é aparecido da pilha e colocado na variável local `index`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4245">A value is popped off of the stack and placed in local variable `index`.</span></span>  
  
 <span data-ttu-id="de0f3-4246">O `stloc.s` instrução exibe o valor superior da pilha de avaliação e será movida para o número de variável local `index`, onde as variáveis locais são numerados de 0 em diante.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4246">The `stloc.s` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="de0f3-4247">O tipo do valor deve corresponder ao tipo da variável local, conforme especificado na assinatura de local do método atual.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4247">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="de0f3-4248">O `stloc.s` instrução fornece uma codificação eficiente para variáveis locais 0 a 255.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4248">The `stloc.s` instruction provides an efficient encoding for local variables 0 through 255.</span></span>  
  
 <span data-ttu-id="de0f3-4249">Armazenando em locais que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme se move da pilha para a variável local.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4249">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="de0f3-4250">Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo `F`) para o tamanho associado com o argumento.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4250">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="de0f3-4251">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas de método podem usar o `stloc.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4251">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc.s` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-4252">ILGenerator.Emit (OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4252">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="de0f3-4253">ILGenerator.Emit (OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4253">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-4254">Copia um valor do tipo especificado da pilha de avaliação para um endereço de memória fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4254">Copies a value of a specified type from the evaluation stack into a supplied memory address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4255">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4255">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-4256">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-4256">Format</span></span>|<span data-ttu-id="de0f3-4257">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-4257">Assembly Format</span></span>|<span data-ttu-id="de0f3-4258">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-4258">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-4259">81 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-4259">81 < `T` ></span></span>|<span data-ttu-id="de0f3-4260">stobj `class`</span><span class="sxs-lookup"><span data-stu-id="de0f3-4260">stobj `class`</span></span>|<span data-ttu-id="de0f3-4261">Armazena um valor do tipo `class` da pilha na memória.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4261">Stores a value of type `class` from the stack into memory.</span></span>|  
  
 <span data-ttu-id="de0f3-4262">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4262">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-4263">Um endereço será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4263">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-4264">Um objeto do tipo de valor do tipo `class` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4264">A value type object of type `class` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-4265">O objeto e o endereço são removidos da pilha; o objeto de tipo de valor é armazenado no endereço.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4265">The object and the address are popped from the stack; the value type object is stored at the address.</span></span>  
  
 <span data-ttu-id="de0f3-4266">O `stobj` instrução copia o objeto de tipo de valor para o endereço especificado pelo endereço (um ponteiro de tipo `native int`, `*`, ou `&`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-4266">The `stobj` instruction copies the value type object into the address specified by the address (a pointer of type `native int`, `*`, or `&`).</span></span> <span data-ttu-id="de0f3-4267">O número de bytes copiados depende do tamanho da classe representada por `class`, um token de metadados que representa um tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4267">The number of bytes copied depends on the size of the class represented by `class`, a metadata token representing a value type.</span></span>  
  
 <span data-ttu-id="de0f3-4268">A operação do `stobj` instrução pode ser alterada por um imediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instrução de prefixo.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4268">The operation of the `stobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="de0f3-4269"><xref:System.TypeLoadException> será gerada se a classe não pode ser encontrado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4269"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="de0f3-4270">Normalmente, isso é detectado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo em vez de em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4270">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</span></span>  
  
 <span data-ttu-id="de0f3-4271">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stobj` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4271">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stobj` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-4272">ILGenerator.Emit (OpCode, tipo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4272">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-4273">Substitui o valor de um campo estático por um valor da pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4273">Replaces the value of a static field with a value from the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4274">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4274">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-4275">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-4275">Format</span></span>|<span data-ttu-id="de0f3-4276">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-4276">Assembly Format</span></span>|<span data-ttu-id="de0f3-4277">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-4277">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-4278">80 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-4278">80 < `T` ></span></span>|<span data-ttu-id="de0f3-4279">stsfld `field`</span><span class="sxs-lookup"><span data-stu-id="de0f3-4279">stsfld `field`</span></span>|<span data-ttu-id="de0f3-4280">Substitui o valor em `field` com um valor fornecido.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4280">Replaces the value in `field` with a supplied value.</span></span>|  
  
 <span data-ttu-id="de0f3-4281">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4281">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-4282">Um valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4282">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-4283">Um valor é aparecido da pilha e armazenado em `field`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4283">A value is popped from the stack and stored in `field`.</span></span>  
  
 <span data-ttu-id="de0f3-4284">O `stsfld` instrução substitui o valor de um campo estático com um valor da pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4284">The `stsfld` instruction replaces the value of a static field with a value from the stack.</span></span> <span data-ttu-id="de0f3-4285">`field` é um token de metadados que deve se referir a um membro de campo estático.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4285">`field` is a metadata token that must refer to a static field member.</span></span>  
  
 <span data-ttu-id="de0f3-4286">O `stsfld` instrução pode ser prefixada por <xref:System.Reflection.Emit.OpCodes.Volatile>.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4286">The `stsfld` instruction may be prefixed by <xref:System.Reflection.Emit.OpCodes.Volatile>.</span></span>  
  
 <span data-ttu-id="de0f3-4287"><xref:System.MissingFieldException> será gerada se o campo não for encontrado nos metadados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4287"><xref:System.MissingFieldException> is thrown if field is not found in the metadata.</span></span> <span data-ttu-id="de0f3-4288">Normalmente, isso é verificado quando instruções Microsoft Intermediate Language (MSIL) são convertidos em código nativo, não em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4288">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="de0f3-4289">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stsfld` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4289">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stsfld` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-4290">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4290">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-4291">Subtrai um valor de outro e efetua o push do resultado para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4291">Subtracts one value from another and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4292">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4292">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-4293">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-4293">Format</span></span>|<span data-ttu-id="de0f3-4294">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-4294">Assembly Format</span></span>|<span data-ttu-id="de0f3-4295">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-4295">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-4296">59</span><span class="sxs-lookup"><span data-stu-id="de0f3-4296">59</span></span>|<span data-ttu-id="de0f3-4297">sub</span><span class="sxs-lookup"><span data-stu-id="de0f3-4297">sub</span></span>|<span data-ttu-id="de0f3-4298">Subtrai um valor de outro, retornando um novo valor numérico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4298">Subtracts one value from another, returning a new numeric value.</span></span>|  
  
 <span data-ttu-id="de0f3-4299">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4299">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-4300">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4300">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-4301">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4301">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-4302">`value2` e `value1` são removidos da pilha; `value2` é subtraído do `value1`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4302">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1`.</span></span>  
  
4.  <span data-ttu-id="de0f3-4303">O resultado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4303">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-4304">Estouro não é detectado para operações de inteiros (para a manipulação de estouro adequada, consulte <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).</span><span class="sxs-lookup"><span data-stu-id="de0f3-4304">Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).</span></span>  
  
 <span data-ttu-id="de0f3-4305">Subtração de inteiro envolve, em vez de esteja saturado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4305">Integer subtraction wraps, rather than saturates.</span></span> <span data-ttu-id="de0f3-4306">Por exemplo: supondo que os inteiros de 8 bits, onde `value1` é definido como 0 e `value2` é definido como 1, o resultado "encapsulado" será 255.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4306">For example: assuming 8-bit integers, where `value1` is set to 0 and `value2` is set to 1, the "wrapped" result will be 255.</span></span>  
  
 <span data-ttu-id="de0f3-4307">Retorna de estouro de ponto flutuante `+inf` (`PositiveInfinity`) ou `-inf` (`NegativeInfinity`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-4307">Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`).</span></span>  
  
 <span data-ttu-id="de0f3-4308">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `sub` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4308">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-4309">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4309">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-4310">Subtrai um valor de inteiro de outro, executa uma verificação de estouro e efetua o push do resultado para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4310">Subtracts one integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4311">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4311">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-4312">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-4312">Format</span></span>|<span data-ttu-id="de0f3-4313">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-4313">Assembly Format</span></span>|<span data-ttu-id="de0f3-4314">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-4314">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-4315">ACELERADOR DE DESENVOLVIMENTO</span><span class="sxs-lookup"><span data-stu-id="de0f3-4315">DA</span></span>|<span data-ttu-id="de0f3-4316">sub.ovf</span><span class="sxs-lookup"><span data-stu-id="de0f3-4316">sub.ovf</span></span>|<span data-ttu-id="de0f3-4317">Subtrai um valor de inteiro de outro com uma verificação de estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4317">Subtracts one integer value from another with an overflow check.</span></span>|  
  
 <span data-ttu-id="de0f3-4318">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4318">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-4319">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4319">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-4320">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4320">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-4321">`value2` e `value1` são removidos da pilha; `value2` é subtraído de `value1` com uma verificação de estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4321">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="de0f3-4322">O resultado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4322">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-4323"><xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4323"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-4324">Esta operação é executada em inteiros com sinal; para valores de ponto flutuantes, use <xref:System.Reflection.Emit.OpCodes.Sub>.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4324">This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.</span></span>  
  
 <span data-ttu-id="de0f3-4325">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `sub.ovf` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4325">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-4326">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4326">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-4327">Subtrai um valor de inteiro sem sinal de outro, executa uma verificação de estouro e efetua o push do resultado para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4327">Subtracts one unsigned integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4328">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4328">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-4329">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-4329">Format</span></span>|<span data-ttu-id="de0f3-4330">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-4330">Assembly Format</span></span>|<span data-ttu-id="de0f3-4331">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-4331">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-4332">DB</span><span class="sxs-lookup"><span data-stu-id="de0f3-4332">DB</span></span>|<span data-ttu-id="de0f3-4333">sub.ovf.un</span><span class="sxs-lookup"><span data-stu-id="de0f3-4333">sub.ovf.un</span></span>|<span data-ttu-id="de0f3-4334">Subtrai um valor de inteiro sem sinal de outro com uma verificação de estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4334">Subtracts one unsigned integer value from another with an overflow check.</span></span>|  
  
 <span data-ttu-id="de0f3-4335">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4335">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-4336">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4336">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-4337">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4337">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-4338">`value2` e `value1` são removidos da pilha; `value2` é subtraído de `value1` com uma verificação de estouro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4338">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="de0f3-4339">O resultado é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4339">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-4340"><xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4340"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de0f3-4341">Esta operação é executada em inteiros com sinal; para valores de ponto flutuantes, use <xref:System.Reflection.Emit.OpCodes.Sub>.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4341">This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.</span></span>  
  
 <span data-ttu-id="de0f3-4342">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `sub.ovf.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4342">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-4343">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4343">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-4344">Implementa uma tabela de atalhos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4344">Implements a jump table.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4345">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4345">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-4346">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-4346">Format</span></span>|<span data-ttu-id="de0f3-4347">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-4347">Assembly Format</span></span>|<span data-ttu-id="de0f3-4348">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-4348">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-4349">45 < `unsigned int32` >< `int32` >... < `int32` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-4349">45 < `unsigned int32` > < `int32` >... < `int32` ></span></span>|<span data-ttu-id="de0f3-4350">Alternar (`N`, `t1`, `t2`... `tN`)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4350">switch (`N`, `t1`, `t2`... `tN`)</span></span>|<span data-ttu-id="de0f3-4351">Salta para uma das `N` valores.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4351">Jumps to one of `N` values.</span></span>|  
  
 <span data-ttu-id="de0f3-4352">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4352">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-4353">Um valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4353">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-4354">O valor é retirado da pilha e a execução é transferida para a instrução no deslocamento indexado por valor, onde o valor é menor que `N`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4354">The value is popped off the stack and execution is transferred to the instruction at the offset indexed by the value, where the value is less than `N`.</span></span>  
  
 <span data-ttu-id="de0f3-4355">O `switch` instrução implementa uma tabela de atalhos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4355">The `switch` instruction implements a jump table.</span></span> <span data-ttu-id="de0f3-4356">O formato da instrução é um `unsigned int32` que representa o número de destinos `N`, seguido por `N` saltar de valores int32 especificando destinos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4356">The format of the instruction is an `unsigned int32` representing the number of targets `N`, followed by `N` int32 values specifying jump targets.</span></span> <span data-ttu-id="de0f3-4357">Esses destinos são representados como deslocamentos (positivos ou negativos) desde o início da instrução seguindo este `switch` instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4357">These targets are represented as offsets (positive or negative) from the beginning of the instruction following this `switch` instruction.</span></span>  
  
 <span data-ttu-id="de0f3-4358">O `switch` instrução retira um valor da pilha e compara-lo, como um inteiro sem sinal, como `N`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4358">The `switch` instruction pops a value off the stack and compares it, as an unsigned integer, to `N`.</span></span> <span data-ttu-id="de0f3-4359">Se o valor é menor que `N`, a execução será transferida para o destino indexado por valor, em que os destinos são numerados de 0 (por exemplo, um valor de 0 usa o primeiro destino, um valor de 1 usa o destino do segundo e assim por diante).</span><span class="sxs-lookup"><span data-stu-id="de0f3-4359">If value is less than `N`, execution is transferred to the target indexed by value, where targets are numbered from 0 (for example, a value of 0 takes the first target, a value of 1 takes the second target, and so on).</span></span> <span data-ttu-id="de0f3-4360">Se o valor for maior que ou igual a `N`, a execução continuará na próxima instrução (queda).</span><span class="sxs-lookup"><span data-stu-id="de0f3-4360">If the value is greater than or equal to `N`, execution continues at the next instruction (fall through).</span></span>  
  
 <span data-ttu-id="de0f3-4361">Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4361">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="de0f3-4362">O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4362">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span> <span data-ttu-id="de0f3-4363">(Essas transferências são rigorosamente restritas e devem usar a instrução deixe em vez disso).</span><span class="sxs-lookup"><span data-stu-id="de0f3-4363">(Such transfers are severely restricted and must use the leave instruction instead).</span></span>  
  
 <span data-ttu-id="de0f3-4364">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `switch` opcode.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4364">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `switch` opcode.</span></span> <span data-ttu-id="de0f3-4365">O `Label[]` argumento é uma matriz dos rótulos que representam deslocamentos de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4365">The `Label[]` argument is an array of Labels representing 32-bit offsets.</span></span>  
  
-   <span data-ttu-id="de0f3-4366">ILGenerator.Emit(OpCode, Label[])</span><span class="sxs-lookup"><span data-stu-id="de0f3-4366">ILGenerator.Emit(OpCode, Label[])</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="de0f3-4367">O exemplo de código a seguir ilustra o uso do `Switch` opcode para gerar uma tabela de atalhos, usando uma matriz de <xref:System.Reflection.Emit.Label>.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4367">The following code sample illustrates the use of the `Switch` opcode to generate a jump table using an array of <xref:System.Reflection.Emit.Label>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-4368">Executa uma instrução de chamada de método pós-fixada, de modo que o registro de ativação do método atual é removido antes da execução da instrução de chamada real.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4368">Performs a postfixed method call instruction such that the current method's stack frame is removed before the actual call instruction is executed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4369">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4369">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-4370">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-4370">Format</span></span>|<span data-ttu-id="de0f3-4371">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-4371">Assembly Format</span></span>|<span data-ttu-id="de0f3-4372">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-4372">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-4373">FE 14</span><span class="sxs-lookup"><span data-stu-id="de0f3-4373">FE 14</span></span>|<span data-ttu-id="de0f3-4374">parte final.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4374">tail.</span></span>|<span data-ttu-id="de0f3-4375">Chamada subsequente encerra métodos atuais</span><span class="sxs-lookup"><span data-stu-id="de0f3-4375">Subsequent call terminates current methods</span></span>|  
  
 <span data-ttu-id="de0f3-4376">Não há nenhum comportamento de transição de pilha definido para essa instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4376">There is no stack transition behavior defined for this instruction.</span></span>  
  
 <span data-ttu-id="de0f3-4377">O `tail` instrução de prefixo deve preceder imediatamente um <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, ou <xref:System.Reflection.Emit.OpCodes.Callvirt> instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4377">The `tail` prefix instruction must immediately precede a <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, or <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction.</span></span> <span data-ttu-id="de0f3-4378">Ele indica que o quadro de pilha do método atual deve ser removido antes da instrução de chamada é executada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4378">It indicates that the current method's stack frame should be removed before the call instruction is executed.</span></span> <span data-ttu-id="de0f3-4379">Isso também significa que o valor retornado da chamada a seguir também é o valor retornado pelo método atual e a chamada, portanto, pode ser convertida em um salto cruzado-method.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4379">It also implies that the value returned from the following call is also the value returned by the current method, and the call can therefore be converted into a cross-method jump.</span></span>  
  
 <span data-ttu-id="de0f3-4380">A pilha deve estar vazia, exceto para os argumentos que estão sendo transferidos pela chamada a seguir.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4380">The stack must be empty except for the arguments being transferred by the following call.</span></span> <span data-ttu-id="de0f3-4381">A instrução após a instrução de chamada deve ser um ret. Assim é a sequência de códigos são válidas `tail. call` (ou `calli` ou `callvirt`).</span><span class="sxs-lookup"><span data-stu-id="de0f3-4381">The instruction following the call instruction must be a ret. Thus the only valid code sequence is `tail. call` (or `calli` or `callvirt`).</span></span> <span data-ttu-id="de0f3-4382">Instruções de Microsoft Intermediate Language (MSIL) corretas não devem fazer branch para o `call` instrução, mas eles podem ramificar para os próximos <xref:System.Reflection.Emit.OpCodes.Ret>.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4382">Correct Microsoft Intermediate Language (MSIL) instructions must not branch to the `call` instruction, but they may branch to the subsequent <xref:System.Reflection.Emit.OpCodes.Ret>.</span></span>  
  
 <span data-ttu-id="de0f3-4383">O quadro atual não pode ser descartado quando o controle é transferido de código não confiável para código confiável, pois isso poderia comprometer a segurança de identidade do código.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4383">The current frame cannot be discarded when control is transferred from untrusted code to trusted code, since this would jeopardize code identity security.</span></span> <span data-ttu-id="de0f3-4384">Verifica se a segurança do .NET Framework, portanto, pode fazer com que o `tail` devem ser ignorados, deixando um padrão <xref:System.Reflection.Emit.OpCodes.Call> instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4384">The .NET Framework security checks can therefore cause the `tail` to be ignored, leaving a standard <xref:System.Reflection.Emit.OpCodes.Call> instruction.</span></span> <span data-ttu-id="de0f3-4385">Da mesma forma, a fim de permitir que a saída de uma região sincronizada após a chamada retorna, o `tail` prefixo é ignorado quando usado para sair de um método que está marcado como sincronizado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4385">Similarly, in order to allow the exit of a synchronized region to occur after the call returns, the `tail` prefix is ignored when used to exit a method that is marked synchronized.</span></span>  
  
 <span data-ttu-id="de0f3-4386">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `tail` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4386">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `tail` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-4387">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4387">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">
          <span data-ttu-id="de0f3-4388">Uma instância de um objeto Opcode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4388">An instance of an Opcode object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="de0f3-4389">Retornará true ou false se o código de operação fornecido tiver um argumento de byte único.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4389">Returns true or false if the supplied opcode takes a single byte argument.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="de0f3-4390">
            <see langword="True" /> ou <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4390">
              <see langword="True" /> or <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4391">Esse método pode ser usado para localizar os opcodes em MSIL são "forma abreviada," para uso em código otimizado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4391">This method can be used to find which MSIL opcodes are "short form", for use in optimized code.</span></span>  
  
 <span data-ttu-id="de0f3-4392">`TakesSingleByteArgument` Retorna `true` se o <xref:System.Reflection.Emit.OpCode> instância usa um argumento de byte único nos seguintes casos:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4392">`TakesSingleByteArgument` returns `true` if the <xref:System.Reflection.Emit.OpCode> instance takes a single byte argument in the following cases:</span></span>  
  
-   <span data-ttu-id="de0f3-4393">O opcode executa uma instrução de ramificação para um endereço de tamanho de byte (por exemplo, <xref:System.Reflection.Emit.OpCodes.Br_S> e <xref:System.Reflection.Emit.OpCodes.Bgt_S>).</span><span class="sxs-lookup"><span data-stu-id="de0f3-4393">The opcode performs a branch instruction to a byte-sized address (for example, <xref:System.Reflection.Emit.OpCodes.Br_S> and <xref:System.Reflection.Emit.OpCodes.Bgt_S>).</span></span>  
  
-   <span data-ttu-id="de0f3-4394">O código de operação envia um valor de byte para a pilha (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).</span><span class="sxs-lookup"><span data-stu-id="de0f3-4394">The opcode pushes a byte value onto the stack (for example, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).</span></span>  
  
-   <span data-ttu-id="de0f3-4395">O opcode faz referência a uma variável ou um argumento por meio do tamanho de byte "breve formulário" (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> e <xref:System.Reflection.Emit.OpCodes.Stloc_S>).</span><span class="sxs-lookup"><span data-stu-id="de0f3-4395">The opcode references a variable or argument via the byte-sized "short form" (for example, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> and <xref:System.Reflection.Emit.OpCodes.Stloc_S>).</span></span>  
  
 <span data-ttu-id="de0f3-4396">Caso contrário, retornará `false`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4396">Otherwise, it returns `false`.</span></span>  
  
 <span data-ttu-id="de0f3-4397">O exemplo a seguir demonstra o uso de `TakesSingleByteArgument` refletindo para o `OpCodes` classe e testando para ver se cada `OpCode` campo usa um argumento de byte único.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4397">The example below demonstrates the use of `TakesSingleByteArgument` by reflecting on to the `OpCodes` class and testing to see whether each `OpCode` field takes a single-byte argument.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-4398">Gera o objeto de exceção atualmente na pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4398">Throws the exception object currently on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4399">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4399">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-4400">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-4400">Format</span></span>|<span data-ttu-id="de0f3-4401">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-4401">Assembly Format</span></span>|<span data-ttu-id="de0f3-4402">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-4402">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-4403">7A</span><span class="sxs-lookup"><span data-stu-id="de0f3-4403">7A</span></span>|<span data-ttu-id="de0f3-4404">throw</span><span class="sxs-lookup"><span data-stu-id="de0f3-4404">throw</span></span>|<span data-ttu-id="de0f3-4405">Gerencie uma exceção.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4405">Throws an exception.</span></span>|  
  
 <span data-ttu-id="de0f3-4406">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4406">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-4407">Uma referência de objeto (uma exceção) é enviada para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4407">An object reference (to an exception) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-4408">A referência de objeto é Aparecida da pilha e a exceção gerada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4408">The object reference is popped from the stack and the exception thrown.</span></span>  
  
 <span data-ttu-id="de0f3-4409">O `throw` instrução gera o objeto de exceção (tipo `O`) atualmente na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4409">The `throw` instruction throws the exception object (type `O`) currently on the stack.</span></span>  
  
 <span data-ttu-id="de0f3-4410"><xref:System.NullReferenceException> será gerada se a referência de objeto é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4410"><xref:System.NullReferenceException> is thrown if the object reference is a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-4411">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `throw` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4411">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `throw` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-4412">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4412">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-4413">Indica que um endereço atualmente sobre a pilha de avaliação pode não estar alinhado ao tamanho natural da instrução imediatamente após <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" /> ou <see langword="cpblk" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4413">Indicates that an address currently atop the evaluation stack might not be aligned to the natural size of the immediately following <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" />, or <see langword="cpblk" /> instruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4414">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4414">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-4415">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-4415">Format</span></span>|<span data-ttu-id="de0f3-4416">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-4416">Assembly Format</span></span>|<span data-ttu-id="de0f3-4417">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-4417">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-4418">FE 12 &LT; `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-4418">FE 12 < `unsigned int8` ></span></span>|<span data-ttu-id="de0f3-4419">não alinhado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4419">unaligned.</span></span> `alignment`|<span data-ttu-id="de0f3-4420">Indica que a instrução de ponteiro subsequente pode ser não alinhada.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4420">Indicates that the subsequent pointer instruction may be unaligned.</span></span>|  
  
 <span data-ttu-id="de0f3-4421">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4421">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-4422">Um endereço será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4422">An address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-4423">`Unaligned` Especifica que o endereço (um ponteiro não gerenciado, `native int`) na pilha pode não estar alinhado ao tamanho natural de imediatamente após `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, ou `cpblk` instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4423">`Unaligned` specifies that the address (an unmanaged pointer, `native int`) on the stack might not be aligned to the natural size of the immediately following `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="de0f3-4424">Ou seja, para um <xref:System.Reflection.Emit.OpCodes.Ldind_I4> instrução o alinhamento do endereço não pode ser um limite de 4 bytes.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4424">That is, for a <xref:System.Reflection.Emit.OpCodes.Ldind_I4> instruction the alignment of the address may not be to a 4-byte boundary.</span></span> <span data-ttu-id="de0f3-4425">Para `initblk` e `cpblk` o alinhamento padrão é dependente de arquitetura (4 bytes em CPUs de 32 bits, 8 bytes em CPUs de 64 bits).</span><span class="sxs-lookup"><span data-stu-id="de0f3-4425">For `initblk` and `cpblk` the default alignment is architecture dependent (4-byte on 32-bit CPUs, 8-byte on 64-bit CPUs).</span></span> <span data-ttu-id="de0f3-4426">Geradores de código que não restringem a sua saída para um tamanho de palavra de 32 bits devem usar `unaligned` se o alinhamento não for conhecido no tempo de compilação seja 8 bytes.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4426">Code generators that do not restrict their output to a 32-bit word size must use `unaligned` if the alignment is not known at compile time to be 8-byte.</span></span>  
  
 <span data-ttu-id="de0f3-4427">O valor de alinhamento deve ser 1, 2 ou 4 e significa que o código gerado deve presumir que o endereço é um byte, dois bytes, ou quad bytes alinhado, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4427">The value of alignment must be 1, 2, or 4 and means that the generated code should assume that the address is byte, double-byte, or quad-byte aligned, respectively.</span></span> <span data-ttu-id="de0f3-4428">Observe que transitório ponteiros (tipo `*`) sempre são alinhados.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4428">Note that transient pointers (type `*`) are always aligned.</span></span>  
  
 <span data-ttu-id="de0f3-4429">Embora o alinhamento de um `cpblk` instrução logicamente exigiria dois números (um para a origem) e outro para o destino, não há nenhum impacto perceptível no desempenho se apenas o número mais baixo é especificado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4429">While the alignment for a `cpblk` instruction would logically require two numbers (one for the source and one for the destination), there is no noticeable impact on performance if only the lower number is specified.</span></span>  
  
 <span data-ttu-id="de0f3-4430">O `unaligned` e `volatile` prefixos podem ser combinados em qualquer ordem.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4430">The `unaligned` and `volatile` prefixes can be combined in either order.</span></span> <span data-ttu-id="de0f3-4431">Deve preceder imediatamente um `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, ou `cpblk` instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4431">They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="de0f3-4432">Somente o <xref:System.Reflection.Emit.OpCodes.Volatile> é permitido um prefixo para o <xref:System.Reflection.Emit.OpCodes.Ldsfld> e <xref:System.Reflection.Emit.OpCodes.Stsfld> instruções.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4432">Only the <xref:System.Reflection.Emit.OpCodes.Volatile> prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.</span></span>  
  
 <span data-ttu-id="de0f3-4433">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas de método podem usar o `unaligned` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4433">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `unaligned` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-4434">ILGenerator.Emit (OpCode, rótulo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4434">ILGenerator.Emit(OpCode, Label)</span></span>  
  
-   <span data-ttu-id="de0f3-4435">ILGenerator.Emit (Opcode, Byte)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4435">ILGenerator.Emit(Opcode, Byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-4436">Converte a representação demarcada de um tipo de valor em sua forma não marcada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4436">Converts the boxed representation of a value type to its unboxed form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4437">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4437">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-4438">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-4438">Format</span></span>|<span data-ttu-id="de0f3-4439">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-4439">Assembly Format</span></span>|<span data-ttu-id="de0f3-4440">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-4440">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-4441">79 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-4441">79 < `T` ></span></span>|<span data-ttu-id="de0f3-4442">conversão unboxing `valType`</span><span class="sxs-lookup"><span data-stu-id="de0f3-4442">unbox `valType`</span></span>|<span data-ttu-id="de0f3-4443">Extrai os dados de tipo de valor de `obj`, sua boxed representação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4443">Extracts the value type data from `obj`, its boxed representation.</span></span>|  
  
 <span data-ttu-id="de0f3-4444">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4444">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-4445">Uma referência de objeto é inserida na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4445">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-4446">A referência de objeto é Aparecida da pilha e unboxed para um ponteiro de tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4446">The object reference is popped from the stack and unboxed to a value type pointer.</span></span>  
  
3.  <span data-ttu-id="de0f3-4447">O ponteiro de tipo de valor é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4447">The value type pointer is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-4448">Um tipo de valor tem duas representações separadas dentro do Common Language Infrastructure (CLI):</span><span class="sxs-lookup"><span data-stu-id="de0f3-4448">A value type has two separate representations within the Common Language Infrastructure (CLI):</span></span>  
  
-   <span data-ttu-id="de0f3-4449">Uma forma de 'raw' usada quando um tipo de valor é inserido em outro objeto.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4449">A 'raw' form used when a value type is embedded within another object.</span></span>  
  
-   <span data-ttu-id="de0f3-4450">Um formulário 'boxed', onde os dados no tipo de valor são empacotados (convertido) em um objeto para que ele pode existir como uma entidade independente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4450">A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</span></span>  
  
 <span data-ttu-id="de0f3-4451">O `unbox` converte a referência de objeto (tipo `O`), o box a representação de um tipo de valor para um ponteiro de tipo de valor (um ponteiro gerenciado, o tipo `&`), sua unboxed formulário.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4451">The `unbox` instruction converts the object reference (type `O`), the boxed representation of a value type, to a value type pointer (a managed pointer, type `&`), its unboxed form.</span></span> <span data-ttu-id="de0f3-4452">O tipo de valor fornecido (`valType`) é um token de metadados que indica o tipo do tipo de valor contido no objeto Demarcado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4452">The supplied value type (`valType`) is a metadata token indicating the type of value type contained within the boxed object.</span></span>  
  
 <span data-ttu-id="de0f3-4453">Diferentemente <xref:System.Reflection.Emit.OpCodes.Box>, que é necessário para fazer uma cópia de um tipo de valor para uso no objeto, `unbox` não é necessário para copiar o tipo de valor do objeto.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4453">Unlike <xref:System.Reflection.Emit.OpCodes.Box>, which is required to make a copy of a value type for use in the object, `unbox` is not required to copy the value type from the object.</span></span> <span data-ttu-id="de0f3-4454">Normalmente, ele simplesmente calcula o endereço do tipo de valor que já está presente no objeto convertido.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4454">Typically it simply computes the address of the value type that is already present inside of the boxed object.</span></span>  
  
 <span data-ttu-id="de0f3-4455"><xref:System.InvalidCastException> será gerada se o objeto não é convertido como `valType`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4455"><xref:System.InvalidCastException> is thrown if the object is not boxed as `valType`.</span></span>  
  
 <span data-ttu-id="de0f3-4456"><xref:System.NullReferenceException> será gerada se a referência de objeto é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4456"><xref:System.NullReferenceException> is thrown if the object reference is a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-4457"><xref:System.TypeLoadException> será gerada se o valor de tipo `valType` não pode ser encontrado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4457"><xref:System.TypeLoadException> is thrown if the value type `valType` cannot be found.</span></span> <span data-ttu-id="de0f3-4458">Normalmente, isso é detectado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo, em vez de em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4458">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="de0f3-4459">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `unbox` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4459">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-4460">ILGenerator.Emit (OpCode, tipo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4460">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-4461">Converte a representação demarcada de um tipo especificado na instrução em sua forma não demarcada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4461">Converts the boxed representation of a type specified in the instruction to its unboxed form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4462">A tabela a seguir lista a instrução hexadecimal e formato do assembly Microsoft intermediate language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4462">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-4463">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-4463">Format</span></span>|<span data-ttu-id="de0f3-4464">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-4464">Assembly Format</span></span>|<span data-ttu-id="de0f3-4465">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-4465">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-4466">A5 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de0f3-4466">A5 < `T` ></span></span>|<span data-ttu-id="de0f3-4467">unbox.Any `typeTok`</span><span class="sxs-lookup"><span data-stu-id="de0f3-4467">unbox.any `typeTok`</span></span>|<span data-ttu-id="de0f3-4468">Extrair os dados `obj`, sua boxed representação.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4468">Extract the data from `obj`, its boxed representation.</span></span>|  
  
 <span data-ttu-id="de0f3-4469">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4469">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-4470">Uma referência de objeto `obj` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4470">An object reference `obj` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-4471">A referência de objeto é Aparecida da pilha e unboxed para o tipo especificado na instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4471">The object reference is popped from the stack and unboxed to the type specified in the instruction.</span></span>  
  
3.  <span data-ttu-id="de0f3-4472">O tipo de valor ou referência de objeto resultante é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4472">The resulting object reference or value type is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-4473">Quando aplicado a forma boxed do tipo de valor, o `unbox.any` instrução extrai o valor contido `obj` (do tipo `O`) e, portanto, é equivalente a `unbox` seguido por `ldobj`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4473">When applied to the boxed form of a value type, the `unbox.any` instruction extracts the value contained within `obj` (of type `O`), and is therefore equivalent to `unbox` followed by `ldobj`.</span></span>  
  
 <span data-ttu-id="de0f3-4474">Quando aplicado a um tipo de referência, o `unbox.any` instrução tem o mesmo efeito que `castclass` `typeTok`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4474">When applied to a reference type, the `unbox.any` instruction has the same effect as `castclass` `typeTok`.</span></span>  
  
 <span data-ttu-id="de0f3-4475">Se o operando `typeTok` é um parâmetro de tipo genérico, em seguida, o comportamento de tempo de execução é determinado pelo tipo especificado para esse parâmetro de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4475">If the operand `typeTok` is a generic type parameter, then the runtime behavior is determined by the type that is specified for that generic type parameter.</span></span>  
  
 <span data-ttu-id="de0f3-4476"><xref:System.InvalidCastException> será gerada se `obj` não é um tipo Demarcado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4476"><xref:System.InvalidCastException> is thrown if `obj` is not a boxed type.</span></span>  
  
 <span data-ttu-id="de0f3-4477"><xref:System.NullReferenceException> será gerada se `obj` é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4477"><xref:System.NullReferenceException> is thrown if `obj` is a null reference.</span></span>  
  
 <span data-ttu-id="de0f3-4478">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `unbox.any` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4478">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox.any` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-4479">ILGenerator.Emit (OpCode, tipo)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4479">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-4480">Especifica que um endereço atualmente sobre a pilha de avaliação pode ser volátil e os resultados da leitura daquele local não podem ser armazenados em cache ou não é possível suprimir vários repositórios para esse local.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4480">Specifies that an address currently atop the evaluation stack might be volatile, and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4481">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4481">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-4482">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-4482">Format</span></span>|<span data-ttu-id="de0f3-4483">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-4483">Assembly Format</span></span>|<span data-ttu-id="de0f3-4484">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-4484">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-4485">FE 13</span><span class="sxs-lookup"><span data-stu-id="de0f3-4485">FE 13</span></span>|<span data-ttu-id="de0f3-4486">volátil.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4486">volatile.</span></span>|<span data-ttu-id="de0f3-4487">Indica que a referência de ponteiro subsequente é volátil.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4487">Indicates that the subsequent pointer reference is volatile.</span></span>|  
  
 <span data-ttu-id="de0f3-4488">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4488">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-4489">Um endereço será enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4489">An address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-4490">`volatile`.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4490">`volatile`.</span></span> <span data-ttu-id="de0f3-4491">Especifica que o endereço é um endereço voláteis (ou seja, ele pode ser referenciado externamente para o thread atual de execução) e os resultados de leitura de que local não pode ser armazenado em cache ou que vários repositórios para esse local não podem ser suprimidos.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4491">specifies that the address is a volatile address (that is, it can be referenced externally to the current thread of execution) and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</span></span> <span data-ttu-id="de0f3-4492">Marcar um acesso como `volatile` afeta apenas que o único acesso; outros acessos no mesmo local devem ser marcados separadamente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4492">Marking an access as `volatile` affects only that single access; other accesses to the same location must be marked separately.</span></span> <span data-ttu-id="de0f3-4493">Acesso a locais volátil não precisa ser executado atomicamente.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4493">Access to volatile locations need not be performed atomically.</span></span>  
  
 <span data-ttu-id="de0f3-4494">O <xref:System.Reflection.Emit.OpCodes.Unaligned> e `volatile` prefixos podem ser combinados em qualquer ordem.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4494">The <xref:System.Reflection.Emit.OpCodes.Unaligned> and `volatile` prefixes can be combined in either order.</span></span> <span data-ttu-id="de0f3-4495">Deve preceder imediatamente um `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, ou `cpblk` instrução.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4495">They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="de0f3-4496">Somente o `volatile` é permitido um prefixo para o <xref:System.Reflection.Emit.OpCodes.Ldsfld> e <xref:System.Reflection.Emit.OpCodes.Stsfld> instruções.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4496">Only the `volatile` prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.</span></span>  
  
 <span data-ttu-id="de0f3-4497">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `volatile` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4497">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `volatile` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-4498">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4498">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="de0f3-4499">Calcula o XOR bit a bit dos dois valores superiores na pilha de avaliação, efetuando o push do resultado para a pilha de avaliação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de0f3-4499">Computes the bitwise XOR of the top two values on the evaluation stack, pushing the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de0f3-4500">A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4500">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de0f3-4501">Formatar</span><span class="sxs-lookup"><span data-stu-id="de0f3-4501">Format</span></span>|<span data-ttu-id="de0f3-4502">Formato do assembly</span><span class="sxs-lookup"><span data-stu-id="de0f3-4502">Assembly Format</span></span>|<span data-ttu-id="de0f3-4503">Descrição</span><span class="sxs-lookup"><span data-stu-id="de0f3-4503">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de0f3-4504">61</span><span class="sxs-lookup"><span data-stu-id="de0f3-4504">61</span></span>|<span data-ttu-id="de0f3-4505">xor</span><span class="sxs-lookup"><span data-stu-id="de0f3-4505">xor</span></span>|<span data-ttu-id="de0f3-4506">Calcula o XOR bit a bit de dois valores inteiros e retorna um inteiro.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4506">Computes the bitwise XOR of two integer values and returns an integer.</span></span>|  
  
 <span data-ttu-id="de0f3-4507">O comportamento de transição de pilha, em ordem sequencial, é:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4507">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de0f3-4508">`value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4508">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de0f3-4509">`value2` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4509">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de0f3-4510">`value2` e `value1` são removidos da pilha e seus bit a bit XOR computado.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4510">`value2` and `value1` are popped from the stack and their bitwise XOR computed.</span></span>  
  
4.  <span data-ttu-id="de0f3-4511">XOR bit a bit de `value2` e `value1` é enviado para a pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4511">The bitwise XOR of `value2` and `value1` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de0f3-4512">O `xor` instrução calcula o XOR bit a bit dos dois primeiros valores na pilha e deixa o resultado na pilha.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4512">The `xor` instruction computes the bitwise XOR of the top two values on the stack and leaves the result on the stack.</span></span>  
  
 <span data-ttu-id="de0f3-4513">`Xor` é uma operação de inteiro específico.</span><span class="sxs-lookup"><span data-stu-id="de0f3-4513">`Xor` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="de0f3-4514">O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `xor` opcode:</span><span class="sxs-lookup"><span data-stu-id="de0f3-4514">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `xor` opcode:</span></span>  
  
-   <span data-ttu-id="de0f3-4515">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="de0f3-4515">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>