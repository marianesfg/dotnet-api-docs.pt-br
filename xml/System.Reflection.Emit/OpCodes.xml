<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f8e4db44f7324cffdd0c0671b821bcd948f011eb" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53516824" /></Metadata><TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece representações de campo das instruções da MSIL (Microsoft intermediate language) para emissão por membros da classe <see cref="T:System.Reflection.Emit.ILGenerator" /> (como <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter uma descrição detalhada dos opcodes de membro, consulte a documentação de Common Language Infrastructure (CLI), especialmente "partição III: CIL Instruction Set"e" partição II: Definição de metadados e semântica". A documentação está disponível online; confira [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212), no MSDN, e [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552), no site internacional da Ecma.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a construção de um método dinâmico usando <xref:System.Reflection.Emit.ILGenerator> emita `OpCodes` em um <xref:System.Reflection.Emit.MethodBuilder>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Adiciona dois valores e envia o resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|58|adicionar|Adiciona dois valores numéricos, retornando um novo valor numérico.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; `value1` é adicionado ao `value2`.  
  
4.  O resultado é enviado para a pilha.  
  
 Estouro não é detectado para operações de inteiros (para a manipulação de estouro adequada, consulte <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).  
  
 Adição de inteiro envolve, em vez de esteja saturado. Por exemplo, supondo que os inteiros de 8 bits em que `value1` é definido como 255 e `value2` é definido como 1, o resultado encapsulado é 0 em vez de 256.  
  
 Retorna de estouro de ponto flutuante `+inf` (`PositiveInfinity`) ou `-inf` (`NegativeInfinity`).  
  
 Os tipos de operando aceitável e seu tipo de dados de resultado correspondente são listados na tabela a seguir. Se não houver nenhuma entrada para uma combinação de tipo específico (por exemplo, `int32` e `float`; `int32` e `int64`), ele é um inválido MSIL Microsoft Intermediate Language () e gera um erro.  
  
|Operando|tipo de valor1|tipo de value2|tipo de resultado|  
|-------------|-----------------|-----------------|-----------------|  
|adicionar|`int32`|`int32`|`int32`|  
|adicionar|`int32`|`native int`|`native int`|  
|adicionar|`int32`|`&`|`&`|  
|adicionar|`int32`|`*`|`*`|  
|adicionar|`int64`|`int64`|`int64`|  
|adicionar|`native int`|`int32`|`native int`|  
|adicionar|`native int`|`native int`|`native int`|  
|adicionar|`native int`|`&`|`&`|  
|adicionar|`native int`|`*`|`*`|  
|adicionar|`F`|`F`|`F`|  
|adicionar|`&`|`int32`|`&`|  
|adicionar|`&`|`native int`|`&`|  
|adicionar|`*`|`int32`|`*`|  
|adicionar|`*`|`native int`|`*`|  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `add` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Adiciona dois números inteiros, executa uma verificação de estouro e efetua o push do resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|D6|add.ovf|Adiciona dois valores de inteiro com sinal com uma verificação de estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; `value1` é adicionado ao `value2` com uma verificação de estouro.  
  
4.  O resultado é enviado para a pilha.  
  
 <xref:System.OverflowException> será gerada se o resultado não é representado no tipo de resultado.  
  
 Você pode executar esta operação em inteiros com sinal. Para valores de ponto flutuantes, use <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 Os tipos de operando aceitável e seu tipo de dados de resultado correspondente são listados na tabela a seguir. Se não houver nenhuma entrada para uma combinação de tipo específico (por exemplo, `int32` e `float`; `int32` e `int64`), ele é uma instrução inválida do Microsoft Intermediate Language (MSIL) e gera um erro.  
  
|Operando|tipo de valor1|tipo de value2|tipo de resultado|  
|-------------|-----------------|-----------------|-----------------|  
|adicionar|`int32`|`int32`|`int32`|  
|adicionar|`int32`|`native int`|`native int`|  
|adicionar|`int32`|`&`|`&`|  
|adicionar|`int32`|`*`|`*`|  
|adicionar|`int64`|`int64`|`int64`|  
|adicionar|`native int`|`int32`|`native int`|  
|adicionar|`native int`|`native int`|`native int`|  
|adicionar|`native int`|`&`|`&`|  
|adicionar|`native int`|`*`|`*`|  
|adicionar|`F`|`F`|`F`|  
|adicionar|`&`|`int32`|`&`|  
|adicionar|`&`|`native int`|`&`|  
|adicionar|`*`|`int32`|`*`|  
|adicionar|`*`|`native int`|`*`|  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `add.ovf` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Adiciona dois valores de inteiro sem sinal, executa uma verificação de estouro e efetua o push do resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|D7|add.ovf.un|Adiciona dois valores inteiros sem sinal com uma verificação de estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; `value1` é adicionado ao `value2` com uma verificação de estouro.  
  
4.  O resultado é enviado para a pilha.  
  
 <xref:System.OverflowException> será gerada se o resultado não é representado no tipo de resultado.  
  
 Você pode executar esta operação em inteiros com sinal. Para valores de ponto flutuantes, use <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 Os tipos de operando aceitável e seu tipo de dados de resultado correspondente são listados na tabela a seguir. Se não houver nenhuma entrada para uma combinação de tipo específico (por exemplo, `int32` e `float`; `int32` e `int64`), ele é uma instrução inválida do Microsoft Intermediate Language (MSIL) e gera um erro.  
  
|Operando|tipo de valor1|tipo de value2|tipo de resultado|  
|-------------|-----------------|-----------------|-----------------|  
|adicionar|`int32`|`int32`|`int32`|  
|adicionar|`int32`|`native int`|`native int`|  
|adicionar|`int32`|`&`|`&`|  
|adicionar|`int32`|`*`|`*`|  
|adicionar|`int64`|`int64`|`int64`|  
|adicionar|`native int`|`int32`|`native int`|  
|adicionar|`native int`|`native int`|`native int`|  
|adicionar|`native int`|`&`|`&`|  
|adicionar|`native int`|`*`|`*`|  
|adicionar|`F`|`F`|`F`|  
|adicionar|`&`|`int32`|`&`|  
|adicionar|`&`|`native int`|`&`|  
|adicionar|`*`|`int32`|`*`|  
|adicionar|`*`|`native int`|`*`|  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `add.ovf.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Calcula o AND bit a bit de dois valores e efetua o push do resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Instrução|Descrição|  
|------------|-----------------|-----------------|  
|5F|e|Determina o AND bit a bit de dois valores inteiros.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value1` e `value2` são removidos da pilha; o AND bit a bit dos dois valores é computado.  
  
4.  O resultado é enviado para a pilha.  
  
 O `and` instrução calcula o AND bit a bit dos valores de dois primeiros na pilha e deixa o resultado na pilha.  
  
 `And` é uma operação de inteiro específico.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `and` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retorna um ponteiro não gerenciado para a lista de argumentos do método atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 00|arglist|Retorna um identificador de lista de argumento para o método atual.|  
  
 Não há comportamentos de pilha de avaliação são executados por esta operação.  
  
 O `arglist` instrução retorna um identificador opaco (um ponteiro não gerenciado, do tipo `native int`) que representa a lista de argumentos do método atual. Esse identificador é válido somente durante o tempo de vida do método atual. No entanto, você pode, passar o identificador para outros métodos, desde que o método atual está no thread de controle. Você pode executar apenas o `arglist` instrução dentro de um método que usa um número variável de argumentos.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `arglist` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfere o controle para uma instrução de destino se dois valores são iguais.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|3B &LT; `int32` >|beq `target`|Branch para a instrução de destino no deslocamento `target` se os dois valores forem iguais.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; se `value1` é igual a `value2`, a operação de ramificação é executada.  
  
 O `beq` instrução transfere o controle para a instrução de destino especificado se `value1` é igual a `value2`. O efeito é o mesmo que executar uma `ceq` instruções seguidas por um `brtrue` ramificação para a instrução de destino específico. A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.  
  
 Os tipos de operando aceitáveis são encapsulados abaixo:  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.  
  
 O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução (essas transferências são rigorosamente restritas e deve usar o <xref:System.Reflection.Emit.OpCodes.Leave> instrução em vez disso).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `beq` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferirá o controle para uma instrução de destino (forma abreviada) se dois valores forem iguais.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|2E < `int8` >|beq.s `target`|Branch para a instrução de destino no deslocamento `target` se for igual, forma abreviada|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; se `value1` é igual a `value2`, a operação de ramificação é executada.  
  
 O `beq.s` instrução transfere o controle para a instrução de destino especificado se `value1` é igual a `value2`. O efeito é o mesmo que executar uma `ceq` instruções seguidas por um `brtrue` ramificação para a instrução de destino específico. A instrução de destino é representada como uma diferença de 1 byte com sinal desde o início da instrução após a instrução atual.  
  
 Os tipos de operando aceitáveis são encapsulados abaixo:  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.  
  
 O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução (essas transferências são rigorosamente restritas e deve usar o <xref:System.Reflection.Emit.OpCodes.Leave> instrução em vez disso).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `beq.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferirá controle para uma instrução de destino se o primeiro valor for maior ou igual ao segundo valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|3C `<int32>`|bge `target`|Branch para a instrução de destino no deslocamento especificado se o primeiro valor é maior que ou igual ao segundo valor.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; se `value1` é maior que ou igual a `value2`, a operação de ramificação é executada.  
  
 O `bge` instrução transfere o controle para a instrução de destino especificado se `value1` é maior que ou igual a `value2`. O efeito é idêntico ao executar uma `clt.un` instruções seguidas por um `brfalse` ramificação para a instrução de destino específico. A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos. O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bge` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferirá controle para uma instrução de destino (forma abreviada) se o primeiro valor for maior ou igual ao segundo valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|2F `<int8>`|bge.s `target`|Branch para a instrução de destino no deslocamento especificado se o primeiro valor é maior que ou igual ao segundo valor, a forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; se `value1` é maior que ou igual a `value2`, a operação de ramificação é executada.  
  
 O `bge.s` instrução transfere o controle para a instrução de destino especificado se `value1` é maior que ou igual a `value2`. O efeito é idêntico ao executar uma `clt.un` instruções seguidas por um `brfalse` ramificação para a instrução de destino específico. A instrução de destino é representada como uma diferença de 1 byte com sinal desde o início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos. O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bge.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferirá o controle para uma instrução de destino se o primeiro valor for maior que o segundo valor ao comparar valores de inteiro sem sinal ou valores float não ordenados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|41 `<int32>`|bge.Un `target`|Branch para a instrução de destino no deslocamento especificado se o primeiro valor é maior que ou igual ao segundo valor (valores sem sinal).|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; se `value1` é maior que ou igual a `value2`, a operação de ramificação é executada.  
  
 O `bge.un` instrução transfere o controle para a instrução de destino especificado se `value1` é maior que ou igual a `value2`, quando comparados com o inteiro sem sinal ou valores float não ordenados. O efeito é idêntico ao executar uma `clt` instruções seguidas por um `brfalse` ramificação para a instrução de destino específico. A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos. O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bge.un` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferirá o controle para uma instrução de destino (forma abreviada) se o primeiro valor for maior que o segundo valor ao comparar valores de inteiro sem sinal ou valores float não ordenados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|34 < `int8` >|bge.un.s `target`|Branch para a instrução de destino no deslocamento especificado se o primeiro valor é maior que ou igual ao segundo valor (valores sem sinal), forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; se `value1` é maior que ou igual a `value2`, a operação de ramificação é executada.  
  
 O `bge.un.s` instrução transfere o controle para a instrução de destino especificado se `value1` é maior que ou igual a `value2`, quando comparados com o inteiro sem sinal ou valores float não ordenados. O efeito é idêntico ao executar uma `clt` instruções seguidas por um `brfalse` ramificação para a instrução de destino específico. A instrução de destino é representada como uma diferença de 1 byte com sinal desde o início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos. O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bge.un.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferirá controle para uma instrução de destino se o primeiro valor for maior que o segundo valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|3D < `int32` >|bgt `target`|Branch para a instrução de destino no deslocamento especificado se o primeiro valor for maior que o segundo valor.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; se `value1` é maior que `value2`, a operação de ramificação é executada.  
  
 O `bgt` instrução transfere o controle para a instrução de destino especificado se `value1` é maior que `value2`. O efeito é idêntico ao executar uma `cgt` instruções seguidas por um `brtrue` ramificação para a instrução de destino específico. A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos. O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bgt` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferirá controle para uma instrução de destino (forma abreviada) se o primeiro valor for maior que o segundo valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|30 < `int8` >|bgt.s `target`|Branch para a instrução de destino no deslocamento especificado se o primeiro valor for maior que o segundo valor, de forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; se `value1` é maior que `value2`, a operação de ramificação é executada.  
  
 O `bgt.s` instrução transfere o controle para a instrução de destino especificado se `value1` é maior que `value2`. O efeito é idêntico ao executar uma `cgt` instruções seguidas por um `brtrue` ramificação para a instrução de destino específico. A instrução de destino é representada como uma diferença de 1 byte com sinal desde o início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos. O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bgt.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferirá o controle para uma instrução de destino se o primeiro valor for maior que o segundo valor ao comparar valores de inteiro sem sinal ou valores float não ordenados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|42 < `int32` >|bgt.Un `target`|Branch para a instrução de destino no deslocamento especificado se o primeiro valor for maior que o segundo valor (valores sem sinal).|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; se `value1` é maior que `value2`, a operação de ramificação é executada.  
  
 O `bgt.un` instrução transfere o controle para a instrução de destino especificado se `value1` é maior que `value2`, quando comparados com o inteiro sem sinal ou valores float não ordenados. O efeito é idêntico ao executar uma `cgt.un` instruções seguidas por um `brtrue` ramificação para a instrução de destino específico. A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos. O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bgt.un` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferirá o controle para uma instrução de destino (forma abreviada) se o primeiro valor for maior que o segundo valor ao comparar valores de inteiro sem sinal ou valores float não ordenados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|35 < `int8` >|bgt.un.s `target`|Branch para a instrução de destino no deslocamento especificado se o primeiro valor for maior que o segundo valor (valores sem sinal), forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; se `value1` é maior que `value2`, a operação de ramificação é executada.  
  
 O `bgt.un.s` instrução transfere o controle para a instrução de destino especificado se `value1` é maior que `value2`, quando comparados com o inteiro sem sinal ou valores float não ordenados. O efeito é idêntico ao executar uma `cgt.un` instruções seguidas por um `brtrue` ramificação para a instrução de destino específico. A instrução de destino é representada como uma diferença de 1 byte com sinal desde o início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos. O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bgt.un.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferirá controle para uma instrução de destino se o primeiro valor for menor ou igual ao segundo valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|3E `<int32>`|ble `target`|Branch para a instrução de destino no deslocamento especificado se o primeiro valor é menor ou igual ao segundo valor.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; se `value1` é menor que ou igual a `value2`, a operação de ramificação é executada.  
  
 O `ble` instrução transfere o controle para a instrução de destino especificado se `value1` é menor que ou igual a `value2`. O efeito é idêntico ao executar uma `cgt` instrução (`cgt.un` para flutuações) seguido por um `brfalse` ramificação para a instrução de destino específico. A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos. O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ble` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferirá controle para uma instrução de destino (forma abreviada) se o primeiro valor for menor ou igual ao segundo valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|31 `<int8>`|ble.s `target`|Branch para a instrução de destino no deslocamento especificado se o primeiro valor é menor ou igual ao segundo valor, a forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; se `value1` é menor que ou igual a `value2`, a operação de ramificação é executada.  
  
 O `ble.s` instrução transfere o controle para a instrução de destino especificado se `value1` é menor que ou igual a `value2`. O efeito é idêntico ao executar uma `cgt` instrução (`cgt.un` para flutuações) instruções seguidas por um`brfalse` ramificação para a instrução de destino específico. A instrução de destino é representada como uma diferença de 1 byte com sinal desde o início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos. O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ble.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferirá o controle para uma instrução de destino se o primeiro valor for menor ou igual ao segundo valor ao comparar valores de inteiro sem sinal ou valores float não ordenados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|43 `<int32>`|ble.Un `target`|Branch para a instrução de destino no deslocamento especificado se o primeiro valor é menor ou igual ao segundo valor (valores sem sinal).|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; se `value1` é menor que ou igual a `value2`, a operação de ramificação é executada.  
  
 O `ble.un` instrução transfere o controle para a instrução de destino especificado se `value1` é menor que ou igual a `value2`, quando comparados com o inteiro sem sinal ou valores float não ordenados. O efeito é idêntico ao executar uma `cgt.un` instrução (`cgt` para flutuações) seguido por um `brfalse` ramificação para a instrução de destino específico. A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos. O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ble.un` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferirá o controle para uma instrução de destino (forma abreviada) se o primeiro valor for menor ou igual ao segundo valor ao comparar valores de inteiro sem sinal ou valores float não ordenados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|36 `<int8>`|ble.un.s `target`|Branch para a instrução de destino no deslocamento especificado se o primeiro valor é menor ou igual ao segundo valor (valores sem sinal), forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; se `value1` é menor que ou igual a `value2`, a operação de ramificação é executada.  
  
 O `ble.un.s` instrução transfere o controle para a instrução de destino especificado se `value1` é menor que ou igual a `value2`, quando comparados com o inteiro sem sinal ou valores float não ordenados. O efeito é idêntico ao executar uma `cgt.un` instrução (`cgt` para flutuações) seguido por um `brfalse` ramificação para a instrução de destino específico. A instrução de destino é representada como uma diferença de 1 byte com sinal desde o início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos. O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ble.un.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferirá controle para uma instrução de destino se o primeiro valor for menor que o segundo valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|3F < `int32` >|blt `target`|Branch para a instrução de destino no deslocamento especificado se o primeiro valor é menor que o segundo valor.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; se `value1` é menor que `value2`, a operação de ramificação é executada.  
  
 O `blt` instrução transfere o controle para a instrução de destino especificado se `value1` é menor que ou igual a `value2`. O efeito é idêntico ao executar uma `clt` instruções seguidas por um `brtrue` ramificação para a instrução de destino específico. A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos. O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `blt` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferirá controle para uma instrução de destino (forma abreviada) se o primeiro valor for menor que o segundo valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|32 < `int8` >|blt.s `target`|Branch para a instrução de destino no deslocamento especificado se o primeiro valor é menor que o segundo valor, de forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; se `value1` é menor que `value2`, a operação de ramificação é executada.  
  
 O `blt.s` instrução transfere o controle para a instrução de destino especificado se `value1` é menor que `value2`. O efeito é idêntico ao executar uma `clt` instruções seguidas por um `brtrue` ramificação para a instrução de destino específico. A instrução de destino é representada como uma diferença de 1 byte com sinal desde o início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos. O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `blt.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferirá o controle para uma instrução de destino se o primeiro valor for menor que o segundo valor ao comparar valores de inteiro sem sinal ou valores float não ordenados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|44 < `int32` >|blt.Un `target`|Branch para a instrução de destino no deslocamento especificado se o primeiro valor é menor que o segundo valor (valores sem sinal).|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; se `value1` é menor que `value2`, a operação de ramificação é executada.  
  
 O `blt.un` instrução transfere o controle para a instrução de destino especificado se `value1` é menor que `value2`, quando comparados com o inteiro sem sinal ou valores float não ordenados. O efeito é idêntico ao executar uma `clt.un` instruções seguidas por um `brtrue` ramificação para a instrução de destino específico. A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos. O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `blt.un` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferirá o controle para uma instrução de destino (forma abreviada) se o primeiro valor for menor que o segundo valor ao comparar valores de inteiro sem sinal ou valores float não ordenados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|37 < `int8` >|blt.un.s `target`|Branch para a instrução de destino no deslocamento especificado se o primeiro valor é menor que o segundo valor (valores sem sinal), forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; se `value1` é menor que `value2`, a operação de ramificação é executada.  
  
 O `blt.un` instrução transfere o controle para a instrução de destino especificado se `value1` é menor que `value2`, quando comparados com o inteiro sem sinal ou valores float não ordenados. O efeito é idêntico ao executar uma `clt.un` instruções seguidas por um `brtrue` ramificação para a instrução de destino específico. A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos. O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `blt.un.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfere o controle para uma instrução de destino quando dois valores de inteiro sem sinal ou valores de float não ordenados não são iguais.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|40 < `int32` >|bne.Un `target`|Branch para o destino de instrução no deslocamento especificado se dois valores inteiros sem sinal são não igual (valores sem sinal).|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; se `value1` não é igual a `value2`, a operação de ramificação é executada.  
  
 O `bne.un` instrução transfere o controle para a instrução de destino especificado se `value1` não é igual a `value2`, quando comparados com o inteiro sem sinal ou valores float não ordenados. O efeito é idêntico ao executar uma `ceq` instruções seguidas por um `brfalse` ramificação para a instrução de destino específico. A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos. O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bne.un` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfere o controle para uma instrução de destino (forma abreviada) quando dois valores inteiros sem sinal ou valores de float não ordenados não são iguais.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|33 < `int8` >|bne.un.s `target`|Branch para o destino de instrução no deslocamento especificado se dois valores inteiros sem sinal são não igual (valores sem sinal), a forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; se `value1` não é igual a `value2`, a operação de ramificação é executada.  
  
 O `bne.un` instrução transfere o controle para a instrução de destino especificado se `value1` não é igual a `value2`, quando comparados com o inteiro sem sinal ou valores float não ordenados. O efeito é idêntico ao executar uma `ceq` instruções seguidas por um `brfalse` ramificação para a instrução de destino específico. A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos. O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bne.un.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte um tipo de valor em uma referência de objeto (tipo <see langword="O" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|8C < `T` >|Caixa `valTypeToken`|Converter um tipo de valor (do tipo especificado em `valTypeToken`) para uma referência ao objeto true.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um tipo de valor é enviado para a pilha.  
  
2.  O tipo de valor é aparecido da pilha; o `box` operação é executada.  
  
3.  Uma referência de objeto para o tipo de valor "demarcado" resultante é enviada para a pilha.  
  
 Um tipo de valor tem duas representações separadas dentro do Common Language Infrastructure (CLI):  
  
-   Formulário 'raw' usado quando um tipo de valor é inserido em outro objeto ou na pilha.  
  
-   Um formulário 'boxed', onde os dados no tipo de valor são empacotados (convertido) em um objeto para que ele pode existir como uma entidade independente.  
  
 O `box` instrução converte o tipo de valor (não demarcado) 'raw' em uma referência de objeto (tipo `O`). Isso é feito criando um novo objeto e copiar os dados do tipo de valor para o objeto recentemente alocado. `valTypeToken` é um token de metadados que indica o tipo do tipo do valor na pilha.  
  
 <xref:System.OutOfMemoryException> será gerada se não houver memória suficiente para atender à solicitação.  
  
 <xref:System.TypeLoadException> será gerada se a classe não pode ser encontrada. Normalmente, isso é detectado quando a Microsoft Intermediate Language (MSIL) é convertido em código nativo, em vez de em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `box` opcode:  
  
-   ILGenerator.Emit (OpCode, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfere o controle 	incondicionalmente para uma instrução de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|38 < `int32` >|br `target`|Ramificações para uma instrução de destino no deslocamento especificado.|  
  
 Não há comportamentos de pilha de avaliação são executados por esta operação.  
  
 O `br` instrução transfere o controle incondicionalmente para uma instrução de destino. A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos. O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `br` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfere o controle de forma incondicional para uma instrução de destino (forma abreviada).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|2B < `int8` >|br.s `target`|Ramificações para uma instrução de destino no deslocamento especificado, de forma abreviada.|  
  
 Não há comportamentos de pilha de avaliação são executados por esta operação.  
  
 O `br.s` instrução transfere o controle incondicionalmente para uma instrução de destino. A instrução de destino é representada como uma diferença de 1 byte com sinal desde o início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos. O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `br.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sinaliza a CLI (Common Language Infrastructure) para informar o depurador de que um ponto de interrupção foi ultrapassado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|01|break|Informe um depurador um ponto de interrupção foi atingido.|  
  
 Não há comportamentos de pilha de avaliação são executados por esta operação.  
  
 O `break` instrução é para suporte à depuração. Ele sinaliza a CLI para informar o depurador um ponto de interrupção foi ultrapassado. Ele tem nenhum outro efeito sobre o estado do interpretador.  
  
 O `break` instrução tem o menor possível tamanho habilitar código de instrução de aplicação de patches com um ponto de interrupção e gerando mínimo perturbação para o código ao redor.  
  
 O `break` instrução pode interceptar a um depurador, não faça nada ou gerar uma exceção de segurança. O comportamento exato é definido pela implementação.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `break` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferirá o controle para uma instrução de destino se <paramref name="value" /> for <see langword="false" />, uma referência nula (<see langword="Nothing" /> no Visual Basic) ou zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|39 < `int32` >|brfalse `target`<br /><br /> brnull `target`<br /><br /> brzero `target`|Ramificações para uma instrução de destino no deslocamento especificada se `false`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha por uma operação anterior.  
  
2.  `value` é aparecido da pilha; Se `value` está `false`, ramificar para `target`.  
  
 O `brfalse` instrução (e seus aliases `brnull` e `brzero`) transfere o controle para a instrução de destino especificado se `value` (do tipo `int32`, `int64`, referência de objeto `O`gerenciado ponteiro `&`, ponteiro transitório `*`, `native int`) é zero (`false`). Se `value` for diferente de zero (`true`) a execução continuará na próxima instrução.  
  
 A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos. O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `brfalse` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferirá o controle para uma instrução de destino se <paramref name="value" /> for <see langword="false" />, uma referência nula ou zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|2C <`int8` >|brfalse.s `target`<br /><br /> brnull.s `target`<br /><br /> brzero.s `target`|Ramificações para uma instrução de destino no deslocamento especificada se `false`, forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha por uma operação anterior.  
  
2.  `value` é aparecido da pilha; Se `value` está `false`, ramificar para `target`.  
  
 O `brfalse.s` instrução (e seus aliases `brnull` e `brzero`) transfere o controle para a instrução de destino especificado se `value` (do tipo `int32`, `int64`, referência de objeto `O`gerenciado ponteiro `&`, ponteiro transitório `*`, `native int`) é zero (`false`). Se `value` for diferente de zero (`true`) a execução continuará na próxima instrução.  
  
 A instrução de destino é representada como uma diferença de 1 byte com sinal desde o início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos. O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `brfalse.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfere o controle para uma instrução de destino se <paramref name="value" /> for <see langword="true" />, não nulo ou diferente de zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|3A < `int32` >|brtrue `target`<br /><br /> brinst `target`|Ramificar para uma instrução de destino no deslocamento especificado, se diferente de zero (`true`).|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha por uma operação anterior.  
  
2.  `value` é aparecido da pilha; Se `value` está `true`, ramificar para `target`.  
  
 O `brtrue` instrução transfere o controle para a instrução de destino especificado se `value` (tipo `native int`) é diferente de zero (`true`). Se `value` é zero (`false`) a execução continuará na próxima instrução.  
  
 Se `value` é uma referência de objeto (tipo `O`), em seguida, `brinst` (um alias para `brtrue`) transfere o controle se ele representa uma instância de um objeto (por exemplo, se ele não é a referência de objeto nulo; consulte <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 A instrução de destino é representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos. O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `brtrue` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfere o controle para uma instrução de destino (forma abreviada) se <paramref name="value" /> for <see langword="true" />, não nulo ou diferente de zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|2D < `int8` >|brtrue.s `target`<br /><br /> brinst.s `target`|Ramificar para uma instrução de destino no deslocamento especificado, se diferente de zero (`true`), forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha por uma operação anterior.  
  
2.  `value` é aparecido da pilha; Se `value` está `true`, ramificar para `target`.  
  
 O `brtrue.s` instrução transfere o controle para a instrução de destino especificado se `value` (tipo `native int`) é diferente de zero (`true`). Se `value` é zero (`false`) a execução continuará na próxima instrução.  
  
 Se `value` é uma referência de objeto (tipo `O`), em seguida, `brinst` (um alias para `brtrue`) transfere o controle se ele representa uma instância de um objeto (por exemplo, se ele não é a referência de objeto nulo; consulte <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 A instrução de destino é representada como uma diferença de 1 byte com sinal desde o início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos. O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `brtrue.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Chama o método indicado pelo descritor de método passado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|28 < `T` >|Chamada `methodDesc`|Chame o método descrito pelo `methodDesc`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Argumentos de método `arg1` por meio de `argN` são colocados na pilha.  
  
2.  Argumentos de método `arg1` por meio de `argN` são removidos da pilha; a chamada de método é executada com estes argumentos e o controle é transferido para o método chamado pelo descritor de método. Ao concluir, um valor de retorno é gerado pelo método de receptor e enviado ao chamador.  
  
3.  O valor de retorno é enviado para a pilha.  
  
 O `call` instrução chama o método indicado pelo descritor de método passado com a instrução. O descritor de método é um token de metadados que indica o método de chamada e o número, tipo e ordem dos argumentos que foram colocadas na pilha a serem passados para esse método, bem como a convenção de chamada a ser usado. O `call` instrução pode ser imediatamente precedida por um `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) instruções para especificar que o estado atual do método deve ser liberado antes de transferir o controle de prefixo. Se a chamada transfere o controle para um método de confiança mais alto que o método de origem, o quadro de pilha não é liberado. Em vez disso, a execução continua silenciosamente como se o `tail` não tinha sido fornecido. O token de metadados contém informações suficientes para determinar se a chamada é para um método estático, um método de instância, um método virtual ou uma função global. Em todos esses casos, o endereço de destino é determinado inteiramente do descritor de método (Compare isso com o <xref:System.Reflection.Emit.OpCodes.Callvirt> instrução para chamar métodos virtuais, em que o endereço de destino também depende do tipo de tempo de execução da instância enviado por push de referência antes do <xref:System.Reflection.Emit.OpCodes.Callvirt>).  
  
 Os argumentos são colocados na pilha na ordem da esquerda para a direita. Ou seja, o primeiro argumento é computado e colocado na pilha, em seguida, o segundo argumento e o terceiro, até que todos os argumentos necessários são sobre a pilha em ordem decrescente. Há três casos especiais importantes:  
  
 1. Chamadas a uma instância (ou virtual) método deve enviar por push essa referência de instância antes de qualquer um dos argumentos visível pelo usuário. A referência de instância não deve ser uma referência nula. A assinatura realizada nos metadados não contém uma entrada na lista de parâmetros para o `this` ponteiro; em vez disso, ele usa um bit para indicar se o método requer passando o `this` ponteiro.  
  
 2. Ele é válido chamar um método virtual usando `call` (em vez de `callvirt`); isso indica que o método deve ser resolvido usando a classe especificada pelo método em vez de como especificado dinamicamente a partir do objeto que está sendo invocado.  
  
 3. Observe que um delegado `Invoke` método pode ser chamado com um a `call` ou `callvirt` instrução.  
  
 <xref:System.Security.SecurityException> poderá ser gerada se a segurança do sistema não concede o acesso do chamador para o método chamado. A verificação de segurança pode ocorrer quando as instruções da Microsoft Intermediate Language (MSIL) são convertidas em código nativo em vez de em tempo de execução.  
  
> [!NOTE]
>  Ao chamar métodos de System. Object em tipos de valor, considere o uso a `constrained` prefixo com o `callvirt` instrução, em vez de emitir um `call` instrução. Isso remove a necessidade de emitir IL diferente dependendo se o tipo de valor substitui o método, evitando um problema potencial de controle de versão. Considere o uso de `constrained` prefixo ao invocar métodos de interface em tipos de valor, já que o método de tipo de valor implementando o método de interface pode ser alterado usando um `MethodImpl`. Esses problemas são descritos mais detalhadamente o <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas de método podem usar o `call` opcode:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
-   ILGenerator.EmitCall (código de operação, MethodInfo, Type[])  
  
> [!NOTE]
>  O <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> método é fornecido para `varargs` chamadas. Use o <xref:System.Reflection.Emit.ILGenerator.Emit%2A> método para chamadas normais.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Chama o método indicado na pilha de avaliação (como um ponteiro para um ponto de entrada) com argumentos descritos por uma convenção de chamada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|29 < `T` >|calli `callSiteDescr`|Chama o método apontado com argumentos descritos pela convenção de chamada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Argumentos de método `arg1` por meio de `argN` são colocados na pilha.  
  
2.  O ponteiro de entrada do método é enviado para a pilha.  
  
3.  Argumentos de método `arg1` por meio de `argN` e o ponteiro de entrada do método são removidos da pilha; a chamada para o método é executada. Ao concluir, um valor de retorno é gerado pelo método de receptor e enviado ao chamador.  
  
4.  O valor de retorno é enviado para a pilha.  
  
 O `calli` instrução chama o ponteiro de entrada do método com os argumentos `arg1` por meio de `argN`. Os tipos desses argumentos são descritos pela convenção de chamada específica (`callSiteDesc`). O `calli` instrução pode ser imediatamente precedida por um `tail` prefixo (<xref:System.Reflection.Emit.OpCodes.Tailcall>) para especificar que o estado atual do método deve ser liberado antes de transferir o controle. Se a chamada transfere controle para um método de confiança mais alto que o método de origem o quadro de pilha não será liberado; em vez disso, a execução continuará silenciosamente como se o `tail` não tinha sido fornecido.  
  
 O ponteiro de entrada do método deve para ser um ponteiro específico para código nativo (da máquina de destino) que pode ser chamado de forma legítima com os argumentos descritos pela convenção de chamada (um token de metadados para uma assinatura autônoma). Esse ponteiro pode ser criado usando o <xref:System.Reflection.Emit.OpCodes.Ldftn> ou <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> instruções, ou transferida do código nativo.  
  
 A convenção de chamada não está marcada dinamicamente, portanto, códigos que usam um `calli` instrução não funcionará corretamente se o destino não usa, na verdade, a convenção de chamada especificada.  
  
 Os argumentos são colocados na pilha na ordem da esquerda para a direita. Ou seja, o primeiro argumento é computado e colocado na pilha, em seguida, o segundo argumento e o terceiro, até que todos os argumentos necessários são sobre a pilha em ordem decrescente. A sequência de código de construção de argumento para um método virtual ou instância deve enviar por push essa referência de instância (que não deve ser uma referência nula) antes de qualquer um dos argumentos visível pelo usuário.  
  
 <xref:System.Security.SecurityException> poderá ser gerada se a segurança do sistema não concede o acesso do chamador para o método chamado. A verificação de segurança pode ocorrer quando as instruções da Microsoft Intermediate Language (MSIL) são convertidas em código nativo em vez de em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> métodos podem ser usados para executar um `calli` instrução na pilha. Observe que `calli` deve ser chamado por meio do abaixo de métodos em vez de usar o <xref:System.Reflection.Emit.ILGenerator.Emit%2A> classe para inserir a instrução diretamente na pilha.  
  
-   ILGenerator.EmitCalli (Opcode, CallingConventions, tipo, digite [], Type[]) para chamadas usando uma convenção de chamada gerenciada.  
  
-   ILGenerator.EmitCalli (Opcode, Type[]) CallingConvention, tipo, para chamadas usando uma convenção de chamada não gerenciada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Chama um método de associação tardia em um objeto, enviando o valor retornado por push para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|6F < `T` >|callvirt `method`|Chama um método específico associado `obj`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `obj` é enviado para a pilha.  
  
2.  Argumentos de método `arg1` por meio de `argN` são colocados na pilha.  
  
3.  Argumentos de método `arg1` por meio `argN` e a referência de objeto `obj` são removidos da pilha; a chamada de método é executada com estes argumentos e o controle é transferido para o método no `obj` chamado pelo método token de metadados. Ao concluir, um valor de retorno é gerado pelo método de receptor e enviado ao chamador.  
  
4.  O valor de retorno é enviado para a pilha.  
  
 O `callvirt` instrução chama um método de associação tardia em um objeto. Ou seja, o método é escolhido com base no tipo de tempo de execução do `obj` em vez da classe de tempo de compilação visível no ponteiro do método. `Callvirt` pode ser usado para chamar ambos virtual e métodos de instância. O `callvirt` instrução pode ser imediatamente precedida por um `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefixo para especificar que o quadro de pilhas atual deve ser liberado antes de transferir o controle. Se a chamada transfere o controle para um método de confiança superior do método original, o quadro de pilha não será lançado.  
  
 O token de metadados do método fornece o nome, a classe e a assinatura do método a ser chamado. A classe associada `obj` é a classe do qual ele é uma instância. Se a classe define um método não estático que corresponde ao nome do método indicado e assinatura, esse método é chamado. Caso contrário, todas as classes na cadeia de classe base dessa classe são verificadas em ordem. É um erro se nenhum método for encontrado.  
  
 `Callvirt` retira o objeto e os argumentos associados da pilha de avaliação antes de chamar o método. Se o método tiver um valor de retorno, ela é enviada por push na pilha após a conclusão do método. No lado do receptor, o `obj` parâmetro é acessado como argumento de 0, `arg1` como argumento 1 e assim por diante.  
  
 Os argumentos são colocados na pilha na ordem da esquerda para a direita. Ou seja, o primeiro argumento é computado e colocado na pilha, em seguida, o segundo argumento e o terceiro, até que todos os argumentos necessários são sobre a pilha em ordem decrescente. A referência de instância `obj` (sempre necessário para `callvirt`) devem ser colocadas antes de qualquer um dos argumentos visível pelo usuário. A assinatura (incluída no token de metadados) não precisa conter uma entrada na lista de parâmetros para este ponteiro.  
  
 Observe que um método virtual pode também ser chamado usando o <xref:System.Reflection.Emit.OpCodes.Call> instrução.  
  
 <xref:System.MissingMethodException> é lançada se um método não estático com o nome indicado e a assinatura não pôde ser encontrado na classe associada `obj` ou qualquer uma das suas classes base. Normalmente, isso é detectado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo, em vez de em tempo de execução.  
  
 <xref:System.NullReferenceException> será gerada se o obj for null.  
  
 <xref:System.Security.SecurityException> será gerada se a segurança do sistema não concede o acesso do chamador para o método chamado. A verificação de segurança pode ocorrer quando a CIL é convertida em código nativo em vez de em tempo de execução.  
  
> [!NOTE]
>  Ao chamar métodos de System. Object em tipos de valor, considere usar o `constrained` prefixo com o `callvirt` instrução. Isso remove a necessidade de emitir IL diferente dependendo se o tipo de valor substitui o método, evitando um problema potencial de controle de versão. Considere o uso de `constrained` prefixo ao invocar métodos de interface em tipos de valor, já que o método de tipo de valor implementando o método de interface pode ser alterado usando um `MethodImpl`. Esses problemas são descritos mais detalhadamente o <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `callvirt` opcode:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
-   ILGenerator.EmitCall (código de operação, MethodInfo, Type[])  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tenta converter um objeto passado por referência à classe especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|74 < `T` >|castclass `class`|Converte um objeto em um novo objeto do tipo `class`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto é inserida na pilha.  
  
2.  A referência de objeto é Aparecida da pilha; o objeto referenciado é convertido conforme o especificado `class`.  
  
3.  Se for bem-sucedido, uma nova referência de objeto é inserida na pilha.  
  
 O `castclass` instrução tentará converter a referência de objeto (tipo `O`) sobre a pilha de uma classe especificada. A nova classe é especificada por um token de metadados que indica a classe desejada. Se a classe do objeto no topo da pilha não implementa a nova classe (supondo que a nova classe é uma interface) e não é uma classe derivada da nova classe, uma <xref:System.InvalidCastException> é gerada. Se a referência de objeto é uma referência nula, `castclass` é bem-sucedida e retorna o novo objeto como uma referência nula.  
  
 <xref:System.InvalidCastException> será gerada se o obj não pode ser convertido para a classe.  
  
 <xref:System.TypeLoadException> será gerada se a classe não pode ser encontrado. Normalmente, isso é detectado quando uma instrução de Microsoft Intermediate Language (MSIL) é convertida em código nativo em vez de em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `castclass` opcode:  
  
-   ILGenerator.Emit (OpCode, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Compara dois valores. Se eles forem iguais, o valor inteiro 1 <see langword="(int32" />) será enviado para a pilha de avaliação; caso contrário, 0 (<see langword="int32" />) será enviado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 01|ceq|Envia por push 1 se `value1` é igual a `value2`; caso contrário envia por push o 0.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; `value1` é comparado ao `value2`.  
  
4.  Se `value1` é igual a `value2`, 1 é enviado para a pilha; caso contrário, 0 será enviado para a pilha.  
  
 O `ceq` instrução compara `value1` e `value2`. Se `value1` é igual a `value2`, em seguida, 1 (do tipo `int32`) é enviado por push na pilha. Caso contrário, 0 (do tipo `int32`) é enviado por push na pilha.  
  
 Para o número de ponto flutuante, `ceq` retornará 0 se os números não são ordenados (um ou ambos são NaN). Os valores de infinitos são iguais entre si.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ceq` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Compara dois valores. Se o primeiro valor for maior que o segundo, o valor inteiro 1 <see langword="(int32" />) será enviado para a pilha de avaliação; caso contrário, 0 (<see langword="int32" />) será enviada para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 02|cgt|Envia por push 1 se `value1` é maior que `value2`; caso contrário envia por push o 0.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; `cgt` testa se `value1` é maior que `value2`.  
  
4.  Se `value1` é maior que `value2`, 1 é enviado para a pilha; caso contrário, 0 será enviado para a pilha.  
  
 O `cgt` instrução compara `value1` e `value2`. Se `value1` estritamente maior que `value2`, então um `int32` valor 1 é empurrado na pilha. Caso contrário, um `int32` valor 0 é empurrado na pilha.  
  
-   Para números de ponto flutuantes, `cgt` retornará 0 se os números não são ordenados (ou seja, se um ou ambos os argumentos são NaN).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `cgt` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Compara dois sem sinal ou não ordenados. Se o primeiro valor for maior que o segundo, o valor inteiro 1 <see langword="(int32" />) será enviado para a pilha de avaliação; caso contrário, 0 (<see langword="int32" />) será enviada para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 03|cgt.Un|Envia por push 1 se `value1` é maior que `value2`; caso contrário envia por push 0 (valores sem sinal).|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; `cgt.un` testa se `value1` é maior que `value2`.  
  
4.  Se `value1` é maior que `value2`, 1 é enviado para a pilha; caso contrário, 0 será enviado para a pilha.  
  
 Uma `int32` valor de 1 é empurrado na pilha se qualquer um dos seguintes for `true` :  
  
 Para números de ponto flutuante `value1` não for ordenado em relação a `value2`.  
  
 Para obter valores de inteiro `value1` estritamente maior que `value2` quando considerados como números sem sinal.  
  
 Caso contrário, um `int32` valor 0 é empurrado na pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `cgt.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gera <see cref="T:System.ArithmeticException" /> se o valor não for um número finito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|C3|ckfinite|lançar <xref:System.ArithmeticException> se o valor não é um número finito.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha. 
  
2.  `value` é aparecido da pilha e o `ckfinite` instrução é executada nele.  
  
3.  `value` é enviado de volta para a pilha se nenhuma exceção for lançada.  
  
 O `ckfinite instruction` lança <xref:System.ArithmeticException> se `value` (um número de ponto flutuante) é um valor de "não é um número" (NaN) ou um `+-` valor infinito. `Ckfinite` deixa o valor na pilha, se nenhuma exceção for lançada. Execução não é especificada se `value` não é um número de ponto flutuante.  
  
 <xref:System.ArithmeticException> será gerada se `value` não é um número 'normal'.  
  
 Observe que uma exceção especial ou uma classe derivada de <xref:System.ArithmeticException> pode ser mais apropriado, passando o valor incorreto para o manipulador de exceção.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ckfinite` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Compara dois valores. Se o primeiro valor for menor que o segundo, o valor inteiro 1 (<see langword="(int32" />) será enviado para a pilha de avaliação; caso contrário, 0 (<see langword="int32" />) será enviada para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 04|clt|Envia por push 1 se `value1` é menor que `value2`; caso contrário envia por push o 0.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é: `value1` é enviado para a pilha.  
  
1.  `value2` é enviado para a pilha.  
  
2.  `value2` e `value1` são removidos da pilha; `clt` testa se `value1` é menor que `value2`.  
  
3.  Se `value1` é menor que `value2`, 1 é enviado para a pilha; caso contrário, 0 será enviado para a pilha.  
  
 O `clt` instrução compara `value1` e `value2`. Se `value1` é estritamente menor que `value2`, então um `int32` valor 1 é empurrado na pilha. Caso contrário, um `int32` valor 0 é empurrado na pilha.  
  
-   Para números de ponto flutuantes, `clt` retornará 0 se os números não são ordenados (ou seja, se um ou ambos os argumentos são NaN).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `clt` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Compara os valores sem sinal ou não ordenados <paramref name="value1" /> e <paramref name="value2" />. Se <paramref name="value1" /> for menor que <paramref name="value2" />, o valor de inteiro 1 (<see langword="(int32" />) será enviado para a pilha de avaliação; caso contrário, 0 (<see langword="int32" />) será enviado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 05|CLT.Un|Envia por push 1 se `value1` é menor que `value2`; caso contrário envia por push 0 (valores sem sinal).|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; `clt.un` testa se `value1` é menor que `value2`.  
  
4.  Se `value1` é menor que `value2`, 1 é enviado para a pilha; caso contrário, 0 será enviado para a pilha.  
  
 O `clt.un` instrução compara `value1` e `value2`. Um `int32` valor 1 é empurrado na pilha se qualquer um dos seguintes for verdadeiro:  
  
-   `value1` é estritamente menor que `value2` (como para `clt`).  
  
-   Para números de ponto flutuante `value1` não for ordenado em relação a `value2`.  
  
-   Para obter valores de inteiro `value1` é estritamente menor que `value2` quando considerados como números sem sinal.  
  
 Caso contrário, um `int32` valor 0 é empurrado na pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `clt.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restringe o tipo no qual uma chamada de método virtual é feita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista a instrução hexadecimal e formato do assembly Microsoft intermediate language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 16 &LT; `T` >|restrito. `thisType`|Chamada de um método virtual em um tipo restrito para ser do tipo `T`.|  
  
 O `constrained` prefixo é permitido somente em um `callvirt` instrução.  
  
 O estado da pilha no momento de MSIL deve ser da seguinte maneira:  
  
1.  Um ponteiro gerenciado, `ptr`, é enviado para a pilha. O tipo de `ptr` deve ser um ponteiro gerenciado (`&`) para `thisType`. Observe que isso é diferente do caso de um sem-prefixo `callvirt` instrução, que espera uma referência de `thisType`.  
  
2.  Argumentos de método `arg1` por meio `argN` são enviados por push para a pilha, assim como ocorre com sem um prefixo `callvirt` instrução.  
  
 O `constrained` prefixo foi projetado para permitir `callvirt` instruções para ser feitas em um uniforme forma independentemente se `thisType` é um tipo de valor ou um tipo de referência.  
  
 Quando um `callvirt` `method` instrução tem como prefixo `constrained` `thisType`, a instrução é executada da seguinte maneira:  
  
-   Se `thisType` é um tipo de referência (em vez de um tipo de valor), em seguida, `ptr` for desreferenciado e passado como o ponteiro 'this' para o `callvirt` de `method`.  
  
-   Se `thisType` é um tipo de valor e `thisType` implementa `method` , em seguida, `ptr` é passado não modificado como o ponteiro 'this' para uma `call` `method` instruções para a implementação de `method` por `thisType`.  
  
-   Se `thisType` é um tipo de valor e `thisType` não implementa `method` , em seguida, `ptr` for desreferenciado, box e passado como o ponteiro 'this' para o `callvirt` `method` instrução.  
  
 Nesse último caso pode ocorrer somente quando `method` foi definido no <xref:System.Object>, <xref:System.ValueType>, ou <xref:System.Enum> e não é substituído por `thisType`. Nesse caso, a conversão boxing faz com que uma cópia do objeto original a ser feita. No entanto, porque nenhum dos métodos de <xref:System.Object>, <xref:System.ValueType>, e <xref:System.Enum> modificam o estado do objeto, esse fato não pode ser detectado.  
  
 O `constrained` prefixo dá suporte a geradores IL que criar código genérico. Normalmente o `callvirt` instrução não é válida em tipos de valor. Em vez disso, é necessário que os compiladores de IL efetivamente executam a 'this' transformação descrita acima no tempo de compilação, dependendo do tipo de `ptr` e o método que está sendo chamado. No entanto, quando `ptr` é um tipo genérico que é desconhecido no tempo de compilação, não é possível fazer essa transformação em tempo de compilação.  
  
 O `constrained` opcode permite que os compiladores de IL para fazer uma chamada para uma função virtual em um uniforme forma independentemente se `ptr` é um tipo de valor ou um tipo de referência. Embora ele destina-se para o caso em que `thisType` é uma variável de tipo genérico, o `constrained` prefixo também funciona para tipos não genéricos e podem reduzir a complexidade de gerar chamadas virtuais em idiomas que ocultam a distinção entre tipos de valor e tipos de referência.  
  
 Usando o `constrained` prefixo também impede os possíveis problemas de controle de versão com tipos de valor. Se o `constrained` prefixo não for usado, deverão ser emitido a IL diferente dependendo se ou não um tipo de valor substitui um método de System. Object. Por exemplo, se um tipo de valor `V` substitui o método ToString (), uma `call` `V.ToString()` instrução é emitida; caso contrário, uma `box` instrução e uma `callvirt` `Object.ToString()` instrução são emitidos. Um problema de controle de versão pode surgir no primeiro caso, se a substituição é removida posteriormente e no último caso se uma substituição for adicionada posteriormente.  
  
 O `constrained` prefixo também pode ser usado para invocação dos métodos de interface em tipos de valor, porque o método de tipo de valor implementando o método de interface pode ser alterado usando um `MethodImpl`. Se o `constrained` prefixo não é usado, o compilador é forçado a escolher qual o valor dos métodos do tipo para associar ao tempo de compilação. Usando o `constrained` prefixo permite que o MSIL associar o método que implementa o método de interface em tempo de execução, em vez de em tempo de compilação.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `constrained` opcode:  
  
-   ILGenerator.Emit (OpCode, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor na parte superior da pilha de avaliação em <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|D3|Conv.i|Converter em `native int`, enviar por push `native int` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.i` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e deixe que convertido valor no topo da pilha. Valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado também será `native int`). Valores de ponto flutuante são convertidos para o `F` tipo.  
  
 A conversão de números de ponto flutuante em valores de inteiro trunca o número em direção a zero. Ao converter de um `float64` para um `float32`, precisão pode ser perdida. Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou infinito negativo (se `value` é negativo) será retornado. Se o estouro ocorre conversão de tipo de inteiro de um para outro, os bits de ordem alta serão truncados. Se o resultado for menor do que um `int32`, o valor será estendido com sinal para preencher o slot.  
  
 Se ocorrer estouro de conversão de um tipo de ponto flutuante para um inteiro, o valor retornado não é especificado.  
  
 Nenhuma exceção for gerada nunca ao usar esse campo. Ver <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> para obter instruções equivalentes que gerará uma exceção quando o tipo de resultado não pode representar o valor do resultado corretamente.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor na parte superior da pilha de avaliação em <see langword="int8" /> e então estende-o (preenche) para <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|67|Conv.I1|Converter em `int8`, enviar por push `int32` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.i1` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e deixe que convertido valor no topo da pilha. Valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado também será `native int`). Valores de ponto flutuante são convertidos para o `F` tipo.  
  
 A conversão de números de ponto flutuante em valores de inteiro trunca o número em direção a zero. Ao converter de um `float64` para um `float32`, precisão pode ser perdida. Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou infinito negativo (se `value` é negativo) será retornado. Se o estouro ocorre conversão de tipo de inteiro de um para outro, os bits de ordem alta serão truncados. Se o resultado for menor do que um `int32`, o valor será estendido com sinal para preencher o slot.  
  
 Se ocorrer estouro de conversão de um tipo de ponto flutuante para um inteiro, o valor retornado não é especificado.  
  
 Nenhuma exceção for gerada nunca ao usar esse campo. Ver <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> para obter instruções equivalentes que gerará uma exceção quando o tipo de resultado não pode representar o valor do resultado corretamente.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor na parte superior da pilha de avaliação em <see langword="int16" /> e então estende-o (preenche) para <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|68|Conv.I2|Converter em `int16`, enviar por push `int32` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.i2` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e deixe que convertido valor no topo da pilha. Valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado também será `native int`). Valores de ponto flutuante são convertidos para o `F` tipo.  
  
 A conversão de números de ponto flutuante em valores de inteiro trunca o número em direção a zero. Ao converter de um `float64` para um `float32`, precisão pode ser perdida. Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou infinito negativo (se `value` é negativo) será retornado. Se o estouro ocorre conversão de tipo de inteiro de um para outro, os bits de ordem alta serão truncados. Se o resultado for menor do que um `int32`, o valor será estendido com sinal para preencher o slot.  
  
 Se ocorrer estouro de conversão de um tipo de ponto flutuante para um inteiro, o valor retornado não é especificado.  
  
 Nenhuma exceção for gerada nunca ao usar esse campo. Ver <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> para obter instruções equivalentes que gerará uma exceção quando o tipo de resultado não pode representar o valor do resultado corretamente.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor na parte superior da pilha de avaliação em <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|69|Conv.i4|Converter em `int32`, enviar por push `int32` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.i4` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e deixe que convertido valor no topo da pilha. Valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado também será `native int`). Valores de ponto flutuante são convertidos para o `F` tipo.  
  
 A conversão de números de ponto flutuante em valores de inteiro trunca o número em direção a zero. Ao converter de um `float64` para um `float32`, precisão pode ser perdida. Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou infinito negativo (se `value` é negativo) será retornado. Se o estouro ocorre conversão de tipo de inteiro de um para outro, os bits de ordem alta serão truncados. Se o resultado for menor do que um `int32`, o valor será estendido com sinal para preencher o slot.  
  
 Se ocorrer estouro de conversão de um tipo de ponto flutuante para um inteiro, o valor retornado não é especificado.  
  
 Nenhuma exceção for gerada nunca ao usar esse campo. Ver <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> para obter instruções equivalentes que gerará uma exceção quando o tipo de resultado não pode representar o valor do resultado corretamente.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor na parte superior da pilha de avaliação em <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|6A|Conv.I8|Converter em `int64`, enviar por push `int64` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.i8` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e deixe que convertido valor no topo da pilha. Valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado também será `native int`). Valores de ponto flutuante são convertidos para o `F` tipo.  
  
 A conversão de números de ponto flutuante em valores de inteiro trunca o número em direção a zero. Ao converter de um `float64` para um `float32`, precisão pode ser perdida. Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou infinito negativo (se `value` é negativo) será retornado. Se o estouro ocorre conversão de tipo de inteiro de um para outro, os bits de ordem alta serão truncados. Se o resultado for menor do que um `int32`, o valor será estendido com sinal para preencher o slot.  
  
 Se ocorrer estouro de conversão de um tipo de ponto flutuante para um inteiro, o valor retornado não é especificado.  
  
 Nenhuma exceção for gerada nunca ao usar esse campo. Ver <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> para obter instruções equivalentes que gerará uma exceção quando o tipo de resultado não pode representar o valor do resultado corretamente.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor com sinal no topo da pilha de avaliação em <see langword="native int" /> com sinal, gerando <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|D4|conv.ovf.i|Converter em um `native int` (na pilha como `native int`) e lançar uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada. Se ocorrer estouro, uma exceção é lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.ovf.i` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.  
  
 Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).  
  
 <xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor sem sinal no topo da pilha de avaliação em <see langword="native int" /> com sinal, gerando <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|8A|conv.ovf.i.un|Converte um valor sem sinal em um `native int` (na pilha como `native int`) e lançar uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada. Se ocorrer estouro, uma exceção é lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.ovf.i.un` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.  
  
 Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).  
  
 <xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor com sinal no topo da pilha de avaliação em <see langword="int8" /> com sinal e estende-o para <see langword="int32" />, gerando <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|B3|conv.ovf.i1|Converter em um `int8` (na pilha como `int32`) e lançar uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada. Se ocorrer estouro, uma exceção é lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.ovf.i1` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.  
  
 Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).  
  
 <xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor sem sinal no topo da pilha de avaliação em <see langword="int8" /> com sinal e estende-o para <see langword="int32" />, gerando <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|82|conv.ovf.i1.un|Converte um valor sem sinal em um `int8` (na pilha como `int32`) e lançar uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada. Se ocorrer estouro, uma exceção é lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.ovf.i1.un` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.  
  
 Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).  
  
 <xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i1.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor com sinal no topo da pilha de avaliação em <see langword="int16" /> com sinal e estendendo-o para <see langword="int32" />, gerando <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|B5|conv.ovf.i2|Converter em um `int16` (na pilha como `int32`) e lançar uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada. Se ocorrer estouro, uma exceção é lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.ovf.i2` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.  
  
 Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).  
  
 <xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor sem sinal no topo da pilha de avaliação em <see langword="int16" /> com sinal e estende-o para <see langword="int32" />, gerando <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|83|conv.ovf.i2.un|Converte um valor sem sinal em um `int16` (na pilha como `int32`) e lançar uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada. Se ocorrer estouro, uma exceção é lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.ovf.i2.un` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.  
  
 Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).  
  
 <xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i2.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor com sinal no topo da pilha de avaliação em <see langword="int32" /> com sinal, gerando <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|B7|conv.ovf.i4|Converter em um `int32` (na pilha como `int32`) e lançar uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada. Se ocorrer estouro, uma exceção é lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.ovf.i4` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.  
  
 Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).  
  
 <xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor sem sinal no topo da pilha de avaliação em <see langword="int32" /> com sinal, gerando <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|84|conv.ovf.i4.un|Converte um valor sem sinal em um `int32` (na pilha como `int32`) e lançar uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada. Se ocorrer estouro, uma exceção é lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.ovf.i4.un` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.  
  
 Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).  
  
 <xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i4.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor com sinal no topo da pilha de avaliação em <see langword="int64" /> com sinal, gerando <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|B9|conv.ovf.i8|Converter em um `int64` (na pilha como `int64`) e lançar uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada. Se ocorrer estouro, uma exceção é lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.ovf.i8` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.  
  
 Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).  
  
 <xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor sem sinal no topo da pilha de avaliação em <see langword="int64" /> com sinal, gerando <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|85|conv.ovf.i8.un|Converte um valor sem sinal em um `int64` (na pilha como `int64`) e lançar uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada. Se ocorrer estouro, uma exceção é lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.ovf.i8.un` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.  
  
 Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).  
  
 <xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i8.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor com sinal no topo da pilha de avaliação em <see langword="unsigned native int" />, gerando <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|D5|conv.ovf.u|Converter em um `unsigned native int` (na pilha como `native int`) e lançar uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada. Se ocorrer estouro, uma exceção é lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.ovf.u` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.  
  
 Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).  
  
 <xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.u` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor sem sinal no topo da pilha de avaliação em <see langword="unsigned native int" />, gerando <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|8B|conv.ovf.u.un|Converte un unsigned valor para um `unsigned native int` (na pilha como `native int`) e lançar uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada. Se ocorrer estouro, uma exceção é lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.ovf.u.un` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.  
  
 Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).  
  
 <xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.uvf.u.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor com sinal no topo da pilha de avaliação em <see langword="unsigned int8" /> e estende-o para <see langword="int32" />, gerando <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|B4|conv.ovf.u1|Converter em um `unsigned int8` (na pilha como `int32`) e lançar uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada. Se ocorrer estouro, uma exceção é lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.ovf.u1` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.  
  
 Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).  
  
 <xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.u1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor sem sinal no topo da pilha de avaliação em <see langword="unsigned int8" /> e estende-o para <see langword="int32" />, gerando <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|86|conv.ovf.u1.un|Converte um valor sem sinal em um `unsigned int8` (na pilha como `int32`) e lançar uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada. Se ocorrer estouro, uma exceção é lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.ovf.u1.un` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.  
  
 Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).  
  
 <xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.u1.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor com sinal no topo da pilha de avaliação em <see langword="unsigned int16" /> e estende-o para <see langword="int32" />, gerando <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|B6|conv.ovf.u2|Converter em um `unsigned int16` (na pilha como `int32`) e lançar uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada. Se ocorrer estouro, uma exceção é lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.ovf.u2` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.  
  
 Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).  
  
 <xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.u2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor sem sinal no topo da pilha de avaliação em <see langword="unsigned int16" /> e estende-o para <see langword="int32" />, gerando <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|87|conv.ovf.u2.un|Converte um valor sem sinal em um `unsigned int16` (na pilha como `int32`) e lançar uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada. Se ocorrer estouro, uma exceção é lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.ovf.u2.un` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.  
  
 Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).  
  
 <xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.u2.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor com sinal no topo da pilha de avaliação em <see langword="unsigned int32" />, gerando <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|B8|conv.ovf.u4|Converter em um `unsigned int32` (na pilha como `int32`) e lançar uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada. Se ocorrer estouro, uma exceção é lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.ovf.u4` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.  
  
 Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).  
  
 <xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.u4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor sem sinal no topo da pilha de avaliação em <see langword="unsigned int32" />, gerando <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|88|conv.ovf.u4.un|Converte um valor sem sinal em um `unsigned int32` (na pilha como `int32`) e lançar uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada. Se ocorrer estouro, uma exceção é lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.ovf.u4.un` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.  
  
 Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).  
  
 <xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.u4.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor com sinal no topo da pilha de avaliação em <see langword="unsigned int64" />, gerando <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|BA|conv.ovf.u8|Converter em um `unsigned int64` (na pilha como `int64`) e lançar uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada. Se ocorrer estouro, uma exceção é lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.ovf.u8` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.  
  
 Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).  
  
 <xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.u8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor sem sinal no topo da pilha de avaliação em <see langword="unsigned int64" />, gerando <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|89|conv.ovf.u8.un|Converte um valor sem sinal em um `unsigned int64` (na pilha como `int64`) e lançar uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada. Se ocorrer estouro, uma exceção é lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.ovf.u8.un` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e coloca que convertido valor no topo da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção é lançada.  
  
 Conversões de números de ponto flutuante em valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` são usados, caso em que o resultado também será `native int`).  
  
 <xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.u8.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor de inteiro sem sinal na parte superior da pilha de avaliação em <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|76|conv.r.un|Converter inteiro sem sinal em ponto flutuante, enviar por push `F` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.r.un` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e deixe que convertido valor no topo da pilha. Valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado também será `native int`). Valores de ponto flutuante são convertidos para o `F` tipo.  
  
 A conversão de números de ponto flutuante em valores de inteiro trunca o número em direção a zero. Ao converter de um `float64` para um `float32`, precisão pode ser perdida. Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou infinito negativo (se `value` é negativo) será retornado. Se o estouro ocorre conversão de tipo de inteiro de um para outro, os bits de ordem alta serão truncados. Se o resultado for menor do que um `int32`, o valor será estendido com sinal para preencher o slot.  
  
 Se ocorrer estouro de conversão de um tipo de ponto flutuante para um número inteiro de `result` retornado é especificado. O `conv.r.un` operação assume um inteiro da pilha, interpretará como não assinado e substitui-lo com um número de ponto flutuante para representar o inteiro: ambos um `float32`, se isso for grande o suficiente para representar o inteiro sem perda de precisão, caso contrário um `float64`.  
  
 Nenhuma exceção for gerada nunca ao usar esse campo.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.r.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor na parte superior da pilha de avaliação em <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|6B|Conv.R4|Converter em `float32`, enviar por push `F` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.r4` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e deixe que convertido valor no topo da pilha. Valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado também será `native int`). Valores de ponto flutuante são convertidos para o `F` tipo.  
  
 A conversão de números de ponto flutuante em valores de inteiro trunca o número em direção a zero. Ao converter de um `float64` para um `float32`, precisão pode ser perdida. Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou infinito negativo (se `value` é negativo) será retornado. Se o estouro ocorre conversão de tipo de inteiro de um para outro, os bits de ordem alta serão truncados. Se o resultado for menor do que um `int32`, o valor será estendido com sinal para preencher o slot.  
  
 Se ocorrer estouro de conversão de um tipo de ponto flutuante para um inteiro, o valor retornado não é especificado.  
  
 Nenhuma exceção for gerada nunca ao usar esse campo.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor na parte superior da pilha de avaliação em <see langword="float64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|6C|Conv.R8|Converter em `float64`, enviar por push `F` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.r8` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e deixe que convertido valor no topo da pilha. Valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado também será `native int`). Valores de ponto flutuante são convertidos para o `F` tipo.  
  
 A conversão de números de ponto flutuante em valores de inteiro trunca o número em direção a zero. Ao converter de um `float64` para um `float32`, precisão pode ser perdida. Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou infinito negativo (se `value` é negativo) será retornado. Se o estouro ocorre conversão de tipo de inteiro de um para outro, os bits de ordem alta serão truncados. Se o resultado for menor do que um `int32`, o valor será estendido com sinal para preencher o slot.  
  
 Se ocorrer estouro de conversão de um tipo de ponto flutuante para um inteiro, o valor retornado não é especificado.  
  
 Nenhuma exceção for gerada nunca ao usar esse campo.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor na parte superior da pilha de avaliação em <see langword="unsigned native int" /> e estende-o para <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|E0|Conv.u|Converter em `unsigned native int`, enviar por push `native int` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.u` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e deixe que convertido valor no topo da pilha. Valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado também será `native int`). Valores de ponto flutuante são convertidos para o `F` tipo.  
  
 A conversão de números de ponto flutuante em valores de inteiro trunca o número em direção a zero. Ao converter de um `float64` para um `float32`, precisão pode ser perdida. Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou infinito negativo (se `value` é negativo) será retornado. Se o estouro ocorre conversão de tipo de inteiro de um para outro, os bits de ordem alta serão truncados. Se o resultado for menor do que um `int32`, o valor será estendido com sinal para preencher o slot.  
  
 Se ocorrer estouro de conversão de um tipo de ponto flutuante para um inteiro, o valor retornado não é especificado.  
  
 Nenhuma exceção for gerada nunca ao usar esse campo. Ver <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> para obter instruções equivalentes que gerará uma exceção quando o tipo de resultado não pode representar o valor do resultado corretamente.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.u` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor na parte superior da pilha de avaliação em <see langword="unsigned int8" /> e estende-o para <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|D2|Conv.U1|Converter em `int8`, enviar por push `int32` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.u1` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e deixe que convertido valor no topo da pilha. Valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado também será `native int`). Valores de ponto flutuante são convertidos para o `F` tipo.  
  
 A conversão de números de ponto flutuante em valores de inteiro trunca o número em direção a zero. Ao converter de um `float64` para um `float32`, precisão pode ser perdida. Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou infinito negativo (se `value` é negativo) será retornado. Se o estouro ocorre conversão de tipo de inteiro de um para outro, os bits de ordem alta serão truncados. Se o resultado for menor do que um `int32`, o valor será estendido com sinal para preencher o slot.  
  
 Se ocorrer estouro de conversão de um tipo de ponto flutuante para um inteiro, o valor retornado não é especificado.  
  
 Nenhuma exceção for gerada nunca ao usar esse campo. Ver <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> para obter instruções equivalentes que gerará uma exceção quando o tipo de resultado não pode representar o valor do resultado corretamente.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.u1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor na parte superior da pilha de avaliação em <see langword="unsigned int16" /> e estende-o para <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|D1|Conv.U2|Converter em `int16`, enviar por push `int32` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.u2` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e deixe que convertido valor no topo da pilha. Valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado também será `native int`). Valores de ponto flutuante são convertidos para o `F` tipo.  
  
 A conversão de números de ponto flutuante em valores de inteiro trunca o número em direção a zero. Ao converter de um `float64` para um `float32`, precisão pode ser perdida. Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou infinito negativo (se `value` é negativo) será retornado. Se o estouro ocorre conversão de tipo de inteiro de um para outro, os bits de ordem alta serão truncados. Se o resultado for menor do que um `int32`, o valor será estendido com sinal para preencher o slot.  
  
 Se ocorrer estouro de conversão de um tipo de ponto flutuante para um inteiro, o valor retornado não é especificado.  
  
 Nenhuma exceção for gerada nunca ao usar esse campo. Ver <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> para obter instruções equivalentes que gerará uma exceção quando o tipo de resultado não pode representar o valor do resultado corretamente.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.u2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor na parte superior da pilha de avaliação em <see langword="unsigned int32" /> e estende-o para <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|6D|Conv.U4|Converter em `unsigned int32`, enviar por push `int32` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.u4` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e deixe que convertido valor no topo da pilha. Valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado também será `native int`). Valores de ponto flutuante são convertidos para o `F` tipo.  
  
 A conversão de números de ponto flutuante em valores de inteiro trunca o número em direção a zero. Ao converter de um `float64` para um `float32`, precisão pode ser perdida. Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou infinito negativo (se `value` é negativo) será retornado. Se o estouro ocorre conversão de tipo de inteiro de um para outro, os bits de ordem alta serão truncados. Se o resultado for menor do que um `int32`, o valor será estendido com sinal para preencher o slot.  
  
 Se ocorrer estouro de conversão de um tipo de ponto flutuante para um inteiro, o valor retornado não é especificado.  
  
 Nenhuma exceção for gerada nunca ao usar esse campo. Ver <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> para obter instruções equivalentes que gerará uma exceção quando o tipo de resultado não pode representar o valor do resultado corretamente.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.u4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor na parte superior da pilha de avaliação em <see langword="unsigned int64" /> e estende-o para <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|6E|Conv.U8|Converter em `int64`, enviar por push `int64` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e a conversão de operação é tentada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é colocado na pilha.  
  
 O `conv.u8` opcode converte o `value` no topo da pilha para o tipo especificado no opcode e deixe que convertido valor no topo da pilha. Valores inteiros de menos de 4 bytes são estendidos para o `int32` quando eles são carregados na pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado também será `native int`). Valores de ponto flutuante são convertidos para o `F` tipo.  
  
 A conversão de números de ponto flutuante em valores de inteiro trunca o número em direção a zero. Ao converter de um `float64` para um `float32`, precisão pode ser perdida. Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou infinito negativo (se `value` é negativo) será retornado. Se o estouro ocorre conversão de tipo de inteiro de um para outro, os bits de ordem alta serão truncados. Se o resultado for menor do que um `int32`, o valor será estendido com sinal para preencher o slot.  
  
 Se ocorrer estouro de conversão de um tipo de ponto flutuante para um inteiro, o valor retornado não é especificado.  
  
 Nenhuma exceção for gerada nunca ao usar esse campo. Ver <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> para obter instruções equivalentes que gerará uma exceção quando o tipo de resultado não pode representar o valor do resultado corretamente.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.u8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Copia bytes de número especificados de um endereço de origem para um endereço de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 17|cpblk|Copie dados do bloco de memória de um para outro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O endereço de destino é enviado para a pilha.  
  
2.  O endereço de origem é enviado para a pilha.  
  
3.  O número de bytes a serem copiados é enviado para a pilha.  
  
4.  O número de bytes, o endereço de origem e o endereço de destino é removido da pilha; o número especificado de bytes é copiado do endereço de origem para o endereço de destino.  
  
 O `cpblk` instrução copia um número (tipo `unsigned int32`) de bytes de um endereço de origem (do tipo `*`, `native int`, ou `&`) para um endereço de destino (do tipo `*`, `native int`, ou `&`). O comportamento de `cpblk` é especificado, se as áreas de origem e de destino se sobrepõem.  
  
 `cpblk` pressupõe-se de que a origem e destino resolvido são alinhados com o tamanho natural da máquina. O `cpblk` instrução pode ser imediatamente precedida pelo `unaligned.<prefix>` instrução para indicar que a origem ou o destino é não alinhado.  
  
 A operação do `cpblk` instrução pode ser alterada por um imediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instrução de prefixo.  
  
 <xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `cpblk` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Copia o tipo de valor localizado no endereço de um objeto de (tipo <see langword="&amp;" />, <see langword="*" /> ou <see langword="native int" />) para o endereço do objeto de destino (tipo <see langword="&amp;" />, <see langword="*" /> ou <see langword="native int" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|70 < `T` >|cpobj `classTok`|Copia um valor de tipo de um objeto de origem para um objeto de destino.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  A referência de objeto de destino é enviada para a pilha.  
  
2.  A referência de objeto de origem é enviada para a pilha.  
  
3.  As duas referências de objeto são removidas da pilha; o tipo de valor no endereço do objeto de origem é copiado para o endereço do objeto de destino.  
  
 O comportamento de `cpobj` for especificado, se as referências não são ponteiros para as instâncias da classe representada pelo token de classe de objeto de origem e destino `classTok` (um `typeref` ou `typedef`), ou se `classTok` não representa um tipo de valor.  
  
 <xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `cpobj` opcode:  
  
-   ILGenerator.Emit (OpCode, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Divide dois valores e efetua o push do resultado como um ponto flutuante (tipo <see langword="F" />) ou quociente (tipo <see langword="int32" />) para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|5B|div|Divide dois valores para retornar um quociente ou resultado de ponto flutuante.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; `value1` é dividida por `value2`.  
  
4.  O resultado é enviado para a pilha.  
  
 `result` = `value1` div value2 satisfaz as condições a seguir:  
  
 &#124;`result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, e:  
  
 entrada (`result`) = +, se entrar (`value1`) = logon (`value2`), ou-, se entrar (`value1`) ~ = logon (`value2`)  
  
 O `div` instrução calcula o resultado e envia por push na pilha.  
  
 Divisão de inteiro trunca em direção a zero.  
  
 A divisão de um número finito por zero produz o valor infinito corretamente assinado.  
  
 Dividindo o zero por zero ou infinito por infinito produz o valor NaN (não um número). Qualquer número dividido por infinito produzirá um valor igual a zero.  
  
 Operações de integrais geram <xref:System.ArithmeticException> se o resultado não pode ser representado no tipo de resultado. Isso pode acontecer se `value1` é o valor negativo máximo e `value2` é -1.  
  
 Operações de integrais geram <xref:System.DivideByZeroException> se `value2` é zero.  
  
 Observe que, em plataformas Intel um <xref:System.OverflowException> é gerada quando a computação (minint div -1). Operações de ponto flutuante nunca geram uma exceção (que eles produzem NaNs ou infinitos em vez disso).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `div` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Divide dois valores de inteiro sem sinal e envia o resultado (<see langword="int32" />) para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|5C|div.Un|Divide dois valores, não assinados, retornando um quociente.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; `value1` é dividida por `value2`.  
  
4.  O resultado é enviado para a pilha.  
  
 O `div.un` instrução calcula `value1` dividido pelo `value2`, ambas executadas como números inteiros sem sinal e envios por push o `result` na pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `div.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Copia o valor atual mais alto na pilha de avaliação e, em seguida, envia a cópia para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|25|DUP|Duplica o valor no topo da pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` terá o pop desativado da pilha para eliminação de duplicação.  
  
3.  `value` é enviado de volta para a pilha.  
  
4.  Um valor duplicado é enviado para a pilha.  
  
 O `dup` instrução duplica o elemento superior da pilha e deixa de dois valores idênticos sobre ele.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `dup` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfere o controle da cláusula <see langword="filter" /> de uma exceção para o manipulador de exceção da CLI (Common Language Infrastructure).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 11|Endfilter|Cláusula de filtro de final de tratamento de exceção SEH.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha; `endfilter` é executado e o controle é transferido para o manipulador de exceção.  
  
 `Value` (que deve ser do tipo `int32` e é parte de um conjunto específico de valores) é retornado da cláusula de filtro. Ele deve ser um destes:  
  
-   `exception_continue_search` (`value` = 0) para continuar procurando um manipulador de exceção  
  
-   `exception_execute_handler` (`value` = 1) para iniciar a segunda fase de tratamento de exceções onde, finalmente, blocos são executados até que o manipulador associado com a cláusula de filtro está localizado. Após a descoberta, o manipulador é executado.  
  
 Outros valores inteiros produzirá resultados não especificados.  
  
 O ponto de entrada de um filtro, conforme mostrado na tabela de exceção do método, deve ser a primeira instrução no bloco de código do filtro. O `endfilter` instrução deve ser a última instrução no bloco de código do filtro (portanto, pode haver apenas um `endfilter` para qualquer bloco único filtro). Depois de executar o `endfilter` instrução de controle logicamente fluxos de volta para o mecanismo de tratamento de exceções de CLI.  
  
 Controle não pode ser transferido para um bloco de filtro, exceto por meio do mecanismo de exceção. Controle não pode ser transferida de um bloco de filtro, exceto por meio do uso de um `throw` instrução ou executando o último `endfilter` instrução. Não é possível inserir uma `try` bloquear dentro de um `filter` bloco. Se uma exceção for lançada dentro do `filter` bloco, isso será interceptado e um valor de 0 (`exception_continue_search`) será retornado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `endfilter` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfere o controle da cláusula <see langword="fault" /> ou <see langword="finally" /> de um bloco de exceção de volta para o manipulador de exceção da CLI (Common Language Infrastructure).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|DC|Endfinally<br /><br /> endfault|Termina a `finally` ou `fault` cláusula de um bloco de exceção.|  
  
 Não há nenhuma pilha de comportamentos de transição para essa instrução.  
  
 `Endfinally` e `endfault` sinalizar o final do `finally` ou `fault` cláusula, portanto, o desenrolamento de pilha que pode continuar até que o manipulador de exceção é invocado. O `endfinally` ou `endfault` instrução transfere o controle volta para o mecanismo de exceção da CLI. Em seguida, o mecanismo procura o próximo `finally` cláusula na cadeia se o bloco protegido foi encerrado com uma instrução de sair. Se o bloco protegido foi encerrado com uma exceção, a CLI irá procurar o próximo `finally` ou `fault`, ou insira o manipulador de exceção escolhido durante a primeira passagem de tratamento de exceção.  
  
 Uma `endfinally` instrução pode aparecer apenas lexicalmente dentro um `finally` bloco. Ao contrário o `endfilter` instrução, não há nenhum requisito de que o bloco terminam com um `endfinally` instrução e pode haver tantos `endfinally` instruções dentro do bloco conforme necessário. Essas mesmas restrições se aplicam para o `endfault` instrução e o `fault` bloco.  
  
 Controle não pode ser transferido em uma `finally` (ou `fault`) bloquear, exceto por meio do mecanismo de exceção. Controle não pode ser transferida de um `finally` (ou `fault`) bloquear, exceto por meio do uso de uma `throw` instruções ou executar o `endfinally` (ou `endfault`) instrução. Em particular, você não pode "passar-out" de um `finally` (ou `fault`) bloco ou executar uma <xref:System.Reflection.Emit.OpCodes.Ret> ou <xref:System.Reflection.Emit.OpCodes.Leave> instrução dentro de um `finally` (ou `fault`) bloco.  
  
 Observe que o `endfault` e `endfinally` instruções são aliases – eles correspondem ao mesmo código de operação.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `endfinally` (`endfault`) opcode, bem como o `ILGenerator` método <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.  
  
-   ILGenerator.Emit(OpCode)  
  
-   ILGenerator.EndExceptionBlock()  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inicializa um bloco de memória especificado em um endereço específico e em um tamanho e valor inicial especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 18|initblk|Defina cada local em um bloco de memória para um determinado valor.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço inicial é enviado para a pilha.  
  
2.  Um valor de inicialização é enviado para a pilha.  
  
3.  O número de bytes a ser inicializado é enviado para a pilha.  
  
4.  O número de bytes, o valor de inicialização e o endereço inicial é removido da pilha e a inicialização é executada, de acordo com seus valores.  
  
 O `initblk` instrução define o número (`unsigned int32`) de bytes, começando no endereço especificado (do tipo `native int`, `&`, ou `*`) para o valor de inicialização (do tipo `unsigned int8`). `initblk` pressupõe-se de que o endereço inicial é alinhado ao tamanho natural da máquina.  
  
 A operação do `initblk` instruções podem ser alteradas por um imediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instrução de prefixo.  
  
 <xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `initblk` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inicializa cada campo do tipo de valor em um endereço especificado como uma referência nula ou 0 do tipo primitivo apropriado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 15 &LT; `T` >|`initobj` `typeTok`|Inicializa um tipo de valor.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O endereço do tipo de valor para inicializar é enviado para a pilha.  
  
2.  O endereço é aparecido da pilha; o tipo de valor no endereço especificado é inicializado como tipo `typeTok`.  
  
 O `initobj` instrução inicializa cada campo do tipo de valor especificado pelo endereço enviadas por push (do tipo `native int`, `&`, ou `*`) para uma referência nula ou 0 do tipo primitivo apropriado. Depois que esse método é chamado, a instância está pronta para um método de construtor a ser chamado. Se `typeTok` é um tipo de referência, essa instrução tem o mesmo efeito que `ldnull` seguido de `stind.ref`.  
  
 Diferentemente <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` não chama o método de construtor. `Initobj` é destinado ao inicializar tipos de valor, enquanto `newobj` é usado para alocar e inicializar objetos.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `initobj` opcode:  
  
-   ILGenerator.Emit (OpCode, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Testa se uma referência de objeto (tipo <see langword="O" />) é uma instância de uma classe específica.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|75 < `T` >|isinst `class`|Testa se uma referência de objeto é uma instância de `class`, retornando uma referência nula ou uma instância dessa classe ou interface.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto é inserida na pilha.  
  
2.  A referência de objeto é Aparecida da pilha e testada para ver se ele é uma instância da classe passada `class`.  
  
3.  O resultado (uma referência de objeto ou uma referência nula) é enviado para a pilha.  
  
 `Class` é um token de metadados que indica a classe desejada. Se a classe do objeto no topo da pilha implementa `class` (se `class` é uma interface) ou é uma classe derivada de `class` (se `class` é uma classe regular), em seguida, ele é convertido para o tipo `class` e o resultado é empurrado na pilha, exatamente como se <xref:System.Reflection.Emit.OpCodes.Castclass> tivesse sido chamada. Caso contrário, uma referência nula é empurrada na pilha. Se a referência de objeto é uma referência nula, em seguida, `isinst` da mesma forma, retorna uma referência nula.  
  
 <xref:System.TypeLoadException> será gerada se a classe não pode ser encontrado. Normalmente, isso é detectado quando as instruções da Microsoft Intermediate Language (MSIL) são convertidas em código nativo em vez de em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `isinst` opcode:  
  
-   ILGenerator.Emit (OpCode, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sai do método atual e vai para o método especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|27 < `T` >|jmp `method`|Saia do método atual e ir para o método especificado.|  
  
 Não há nenhuma pilha de comportamentos de transição para essa instrução.  
  
 O `jmp` instrução (saltar) transfere o controle para o método especificado pela `method`, que é um token de metadados para uma referência de método. Os argumentos atuais são transferidos para o método de destino.  
  
 A pilha de avaliação deve estar vazia quando essa instrução é executada. A convenção de chamada, número e tipo dos argumentos no endereço de destino devem corresponder do método atual.  
  
 O `jmp` instrução não pode ser usada para transferiu o controle de um `try`, `filter`, `catch`, ou `finally` bloco.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `jmp` opcode:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega um argumento (referenciado por um valor de índice especificado) na pilha.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 09 &LT; `unsigned int16` >|ldarg `index`|Carregar o argumento no `index` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor do argumento no `index` é enviado para a pilha.  
  
 O `ldarg` instrução envia por push o argumento de indexação no `index`, no qual os argumentos são indexados de 0 e versões posteriores, na pilha de avaliação. O `ldarg` instrução pode ser usada para carregar um tipo de valor ou um valor primitivo à pilha, copiando-os de um argumento de entrada. O tipo do valor do argumento é o mesmo que o tipo do argumento, conforme especificado pela assinatura do método atual.  
  
 Para obter os procedimentos que usam uma lista de argumentos de comprimento variável, o `ldarg` instrução pode ser usada apenas para inicial fixo de argumentos, não os na variável parte da assinatura (consulte a <xref:System.Reflection.Emit.OpCodes.Arglist> instrução para obter mais detalhes).  
  
 Argumentos que contêm um valor inteiro menor que 4 bytes de comprimento são expandidos para o tipo `int32` quando eles são carregados para a pilha. Valores de ponto flutuante são expandidas para seu tamanho nativo (tipo `F`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldarg` opcode:  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o argumento no índice 0 na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|02|ldarg.0|O argumento 0 na pilha de carga|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor do argumento no índice 0 é enviado para a pilha.  
  
 O `ldarg.0` instrução é uma codificação eficiente para carregar o valor do argumento no índice 0.  
  
 O `ldarg.0` instrução envia por push o argumento indexado em 0 na pilha de avaliação. O `ldarg.0` instrução pode ser usada para carregar um tipo de valor ou um valor primitivo à pilha, copiando-os de um argumento de entrada. O tipo do valor do argumento é o mesmo que o tipo do argumento, conforme especificado pela assinatura do método atual.  
  
 Argumentos que contêm um valor inteiro menor que 4 bytes de comprimento são expandidos para o tipo `int32` quando eles são carregados para a pilha. Valores de ponto flutuante são expandidas para seu tamanho nativo (tipo `F`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldarg.0` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o argumento no índice 1 na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|03|ldarg.1|Carregar o argumento 1 na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor do argumento no índice 1 é enviado para a pilha.  
  
 O `ldarg.1` instrução é uma codificação eficiente para carregar o valor do argumento no índice 1.  
  
 O `ldarg.1` instrução envia por push o argumento indexado em 1 na pilha de avaliação. O `ldarg.1` instrução pode ser usada para carregar um tipo de valor ou um valor primitivo à pilha, copiando-os de um argumento de entrada. O tipo do valor do argumento é o mesmo que o tipo do argumento, conforme especificado pela assinatura do método atual.  
  
 Argumentos que contêm um valor inteiro menor que 4 bytes de comprimento são expandidos para o tipo `int32` quando eles são carregados para a pilha. Valores de ponto flutuante são expandidas para seu tamanho nativo (tipo `F`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldarg.1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o argumento no índice 2 na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|04|ldarg.2|Carregar o argumento 2 na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor do argumento no índice 2 é enviado para a pilha.  
  
 O `ldarg.2` instrução é uma codificação eficiente para carregar o valor do argumento no índice 2.  
  
 O `ldarg.2` instrução envia por push o argumento de indexação no 2 na pilha de avaliação. O `ldarg.2` instrução pode ser usada para carregar um tipo de valor ou um valor primitivo à pilha, copiando-os de um argumento de entrada. O tipo do valor do argumento é o mesmo que o tipo do argumento, conforme especificado pela assinatura do método atual.  
  
 Argumentos que contêm um valor inteiro menor que 4 bytes de comprimento são expandidos para o tipo `int32` quando eles são carregados para a pilha. Valores de ponto flutuante são expandidas para seu tamanho nativo (tipo `F`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldarg.2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o argumento no índice 3 na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|05|ldarg.3|Carregar o argumento 3 na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor do argumento no índice 3 é enviado para a pilha.  
  
 O `ldarg.3` instrução é uma codificação eficiente para carregar o valor do argumento no índice 3.  
  
 O `ldarg.3` instrução envia por push o argumento indexado em 3 na pilha de avaliação. O `ldarg.3` instrução pode ser usada para carregar um tipo de valor ou um valor primitivo à pilha, copiando-os de um argumento de entrada. O tipo do valor do argumento é o mesmo que o tipo do argumento, conforme especificado pela assinatura do método atual.  
  
 Argumentos que contêm um valor inteiro menor que 4 bytes de comprimento são expandidos para o tipo `int32` quando eles são carregados para a pilha. Valores de ponto flutuante são expandidas para seu tamanho nativo (tipo `F`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldarg.3` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o argumento (referenciado por um índice de forma curta especificado) para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|0E < `unsigned int8` >|ldarg.s `index`|Carregar o argumento no `index` na pilha, de forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor do argumento no `index` é enviado para a pilha.  
  
 O `ldarg.s` instrução é uma codificação eficiente para carregar argumentos indexadas a partir de 4 a 255.  
  
 O `ldarg.s` instrução envia por push o argumento de indexação no `index`, no qual os argumentos são indexados de 0 e versões posteriores, na pilha de avaliação. O `ldarg.s` instrução pode ser usada para carregar um tipo de valor ou um valor primitivo à pilha, copiando-os de um argumento de entrada. O tipo do valor do argumento é o mesmo que o tipo do argumento, conforme especificado pela assinatura do método atual.  
  
 Para obter os procedimentos que usam uma lista de argumentos de comprimento variável, o `ldarg.s` instrução pode ser usada apenas para inicial fixo de argumentos, não os na variável parte da assinatura (consulte a <xref:System.Reflection.Emit.OpCodes.Arglist> instrução para obter mais detalhes).  
  
 Argumentos que contêm um valor inteiro menor que 4 bytes de comprimento são expandidos para o tipo `int32` quando eles são carregados para a pilha. Valores de ponto flutuante são expandidas para seu tamanho nativo (tipo `F`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldarg.s` opcode:  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carregar um endereço de argumento para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 0A < `unsigned int16` >|ldarga `index`|Buscar o endereço de argumento indexado por `index`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O endereço `addr` do argumento indexado por `index` é enviado para a pilha.  
  
 O `ldarga` instrução busca o endereço (do tipo `*`) do argumento indexado por `index`, em que os argumentos são indexados de 0 em diante. O endereço `addr` é sempre alinhado a um limite natural no computador de destino.  
  
 Para obter os procedimentos que usam uma lista de argumentos de comprimento variável, o `ldarga` instrução pode ser usada apenas para inicial fixo de argumentos, não os na variável parte da assinatura.  
  
 `ldarga` é usado para passar o parâmetro pelo ref. Para outros casos <xref:System.Reflection.Emit.OpCodes.Ldarg> e <xref:System.Reflection.Emit.OpCodes.Starg> deve ser usado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldarga` opcode:  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carregar um endereço de argumento, na forma abreviada, para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|0F < `unsigned int8` >|ldarga.s `index`|Buscar o endereço de argumento indexado por `index`, forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O endereço `addr` do argumento indexado por `index` é enviado para a pilha.  
  
 `ldarga.s` (a forma abreviada de `ldarga`) deve ser usado para números de argumento de 0 a 255, e é uma codificação mais eficiente.  
  
 O `ldarga.s` instrução busca o endereço (do tipo`*`) do argumento indexado por `index`, em que os argumentos são indexados de 0 em diante. O endereço `addr` é sempre alinhado a um limite natural no computador de destino.  
  
 Para obter os procedimentos que usam uma lista de argumentos de comprimento variável, o `ldarga.s` instrução pode ser usada apenas para inicial fixo de argumentos, não os na variável parte da assinatura.  
  
 `ldarga.s` é usado para passar o parâmetro pelo ref. Para outros casos <xref:System.Reflection.Emit.OpCodes.Ldarg_S> e <xref:System.Reflection.Emit.OpCodes.Starg_S> deve ser usado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldarga.s` opcode:  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia por push um valor do tipo <see langword="int32" /> fornecido para a pilha de avaliação como um <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|20 < `int32` >|ldc.i4 `num`|Envia o valor `num` para a pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor `num` é enviado para a pilha.  
  
 Observe que há codificações curtas (e, portanto, é mais eficientes) especiais para inteiros -128 a 127, especialmente curtos e codificações para -1 a 8. Todas as codificações curtas push inteiros de 4 bytes na pilha. Mais codificações são usadas para inteiros de 8 bytes e 4 e 8 números de ponto flutuante de byte, bem como valores de 4 bytes que não cabem nos formulários de curto. Há três maneiras de enviar por push uma constante de inteiro de 8 bytes para a pilha  
  
 1. Use o <xref:System.Reflection.Emit.OpCodes.Ldc_I8> instrução para constantes que deve ser expressa em mais de 32 bits.  
  
 2. Use o <xref:System.Reflection.Emit.OpCodes.Ldc_I4> instruções seguidas por um <xref:System.Reflection.Emit.OpCodes.Conv_I8> para constantes que exigem a 9 para 32 bits.  
  
 3. Usar uma instrução de forma abreviada, seguida por um <xref:System.Reflection.Emit.OpCodes.Conv_I8> para constantes que podem ser expressos em bits 8 ou menos.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4` opcode:  
  
-   ILGenerator.Emit (OpCode, int)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia o valor inteiro de 0 para a pilha de avaliação como um <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|16|ldc.i4.0|Envia por push 0 para a pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor 0 é enviado para a pilha.  
  
 Isso é uma codificação especial curto para o envio por push do valor inteiro 0. Todas as codificações curtas especiais por push inteiros de 4 bytes na pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.0` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia o valor inteiro 1 por push para a pilha de avaliação como um <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|17|ldc.i4.1|Envia por push 1 para a pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor 1 é enviado para a pilha.  
  
 Isso é uma codificação especial curto para o envio por push do valor inteiro 0. Todas as codificações curtas especiais por push inteiros de 4 bytes na pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Efetua o push do valor inteiro de 2 para a pilha de avaliação como um <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|18|ldc.i4.2|Envia por push 2 para a pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor 2 é enviado para a pilha.  
  
 Isso é uma codificação especial curto para o envio por push do valor inteiro 0. Todas as codificações curtas especiais por push inteiros de 4 bytes na pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Efetua o push do valor inteiro de 3 para a pilha de avaliação como um <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|19|ldc.i4.3|Envia por push 3 para a pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor 3 é enviado para a pilha.  
  
 Isso é uma codificação especial curto para o envio por push do valor inteiro 0. Todas as codificações curtas especiais por push inteiros de 4 bytes na pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.3` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Efetua o push do valor inteiro de 4 para a pilha de avaliação como um <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|1A|ldc.i4.4|Envia por push 4 para a pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor 4 é enviado para a pilha.  
  
 Isso é uma codificação especial curto para o envio por push do valor inteiro 0. Todas as codificações curtas especiais por push inteiros de 4 bytes na pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Efetua o push do valor inteiro de 5 para a pilha de avaliação como um <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|1B|ldc.i4.5|Envia por push 5 para a pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor 5 é enviado para a pilha.  
  
 Isso é uma codificação especial curto para o envio por push do valor inteiro 0. Todas as codificações curtas especiais por push inteiros de 4 bytes na pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.5` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Efetua o push do valor inteiro de 6 para a pilha de avaliação como um <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|1C|ldc.i4.6|Envia por push 6 para a pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor 6 é enviado para a pilha.  
  
 Isso é uma codificação especial curto para o envio por push do valor inteiro 0. Todas as codificações curtas especiais por push inteiros de 4 bytes na pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.6` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Efetua o push do valor inteiro de 7 para a pilha de avaliação como um <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|1-D|ldc.i4.7|Envia por push 7 na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor 7 é enviado para a pilha.  
  
 Isso é uma codificação especial curto para o envio por push do valor inteiro 0. Todas as codificações curtas especiais por push inteiros de 4 bytes na pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.7` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Efetua o push do valor inteiro de 8 para a pilha de avaliação como um <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|1E|ldc.i4.8|Envia por push 8 para a pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor 8 é enviado para a pilha.  
  
 Isso é uma codificação especial curto para o envio por push do valor inteiro 0. Todas as codificações curtas especiais por push inteiros de 4 bytes na pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Efetua o push do valor de inteiro de -1 para a pilha de avaliação como um <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|15|ldc.i4.m1|Envia por push -1 para a pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor -1 é enviado para a pilha.  
  
 Isso é uma codificação especial curto para o envio por push do valor inteiro 0. Todas as codificações curtas especiais por push inteiros de 4 bytes na pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.m1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia o valor de <see langword="int8" /> fornecido para a pilha de avaliação como um <see langword="int32" />, na forma abreviada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|1F < `int8` >|ldc.i4.s `num`|Envia por push `num` para a pilha como `int32`, forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor `num` é enviado para a pilha.  
  
 `ldc.i4.s` é uma codificação mais eficiente para enviar os inteiros de -128 a 127 na pilha de avaliação.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.s` opcode:  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia por push um valor do tipo <see langword="int64" /> fornecido para a pilha de avaliação como um <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|21 < `int64` >|ldc.I8 `num`|Envia por push `num` para a pilha como `int64`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor `num` é enviado para a pilha.  
  
 Essa codificação envia um `int64` valor para a pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i8` opcode:  
  
-   ILGenerator.Emit (OpCode, long)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Efetua o push de um valor fornecido do tipo <see langword="float32" /> para a pilha de avaliação como tipo <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|22 < `float32` >|ldc.R4 `num`|Envia por push `num` para a pilha como `F`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor `num` é enviado para a pilha.  
  
 Essa codificação envia um `float32` valor para a pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.r4` opcode:  
  
-   ILGenerator.Emit (OpCode, único)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Efetua o push de um valor fornecido do tipo <see langword="float64" /> para a pilha de avaliação como tipo <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|23 < `float64` >|ldc.R8 `num`|Envia por push `num` para a pilha como `F`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor `num` é enviado para a pilha.  
  
 Essa codificação envia um `float64` valor para a pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.r8` opcode:  
  
-   ILGenerator.Emit (OpCode, double)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o elemento a um índice de matriz especificado na parte superior da pilha de avaliação como o tipo especificado na instrução.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista a instrução hexadecimal e formato do assembly Microsoft intermediate language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|A3 < `T` >|Ldelem `typeTok`|Carrega o elemento `index` para o topo da pilha como tipo `typeTok`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `array` é enviado para a pilha.  
  
2.  Um valor de índice `index` é enviado para a pilha.  
  
3.  `index` e `array` são removidos da pilha; o valor armazenado na posição `index` em `array` é pesquisado.  
  
4.  O valor é enviado para a pilha.  
  
 O `ldelem` instrução carrega o valor do elemento com índice `index` (tipo `native int`) na matriz unidimensional baseada em zero `array` e o coloca na parte superior da pilha. Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.  
  
 O tipo do valor de retorno é especificado pelo token `typeTok` na instrução.  
  
 <xref:System.NullReferenceException> será gerada se `array` é uma referência nula.  
  
 <xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite superior de `array`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem` opcode:  
  
-   ILGenerator.Emit (OpCode, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o elemento com o tipo <see langword="native int" /> em um índice de matriz especificado para o topo da pilha de avaliação como um <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|97|Ldelem.i|Carrega o elemento com o tipo `native int` na `index` para o topo da pilha de como um `native int`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `array` é enviado para a pilha.  
  
2.  Um valor de índice `index` é enviado para a pilha.  
  
3.  `index` e `array` são removidos da pilha; o valor armazenado na posição `index` em `array` é pesquisado.  
  
4.  O valor é enviado para a pilha.  
  
 O `ldelem.i` instrução carrega o valor do elemento com índice `index` (tipo `native int`) na matriz unidimensional baseada em zero `array` e o coloca na parte superior da pilha. Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.  
  
 O valor de retorno `ldelem.i` é `native int`.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.  
  
 <xref:System.NullReferenceException> será gerada se `array` é uma referência nula.  
  
 <xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.  
  
 <xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o elemento com o tipo <see langword="int8" /> em um índice de matriz especificado para o topo da pilha de avaliação como um <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|90|Ldelem.I1|Carrega o elemento com o tipo `int8` na `index` para o topo da pilha de como um `int32`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `array` é enviado para a pilha.  
  
2.  Um valor de índice `index` é enviado para a pilha.  
  
3.  `index` e `array` são removidos da pilha; o valor armazenado na posição `index` em `array` é pesquisado.  
  
4.  O valor é enviado para a pilha.  
  
 O `ldelem.i1` instrução carrega o valor do elemento com índice `index` (tipo `native int`) na matriz unidimensional baseada em zero `array` e o coloca na parte superior da pilha. Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.  
  
 O valor de retorno `ldelem.i1` é `int8`.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.  
  
 <xref:System.NullReferenceException> será gerada se `array` é uma referência nula.  
  
 <xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.  
  
 <xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o elemento com o tipo <see langword="int16" /> em um índice de matriz especificado para o topo da pilha de avaliação como um <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|92|Ldelem.I2|Carrega o elemento com o tipo `int16` na `index` para o topo da pilha de como um `int32`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `array` é enviado para a pilha.  
  
2.  Um valor de índice `index` é enviado para a pilha.  
  
3.  `index` e `array` são removidos da pilha; o valor armazenado na posição `index` em `array` é pesquisado.  
  
4.  O valor é enviado para a pilha.  
  
 O `ldelem.i2` instrução carrega o valor do elemento com índice `index` (tipo `native int`) na matriz unidimensional baseada em zero `array` e o coloca na parte superior da pilha. Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.  
  
 O valor de retorno `ldelem.i2` é `int16`.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.  
  
 <xref:System.NullReferenceException> será gerada se `array` é uma referência nula.  
  
 <xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.  
  
 <xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o elemento com o tipo <see langword="int32" /> em um índice de matriz especificado para o topo da pilha de avaliação como um <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|94|Ldelem.i4|Carrega o elemento com o tipo `int32` na `index` para o topo da pilha de como um `int32`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `array` é enviado para a pilha.  
  
2.  Um valor de índice `index` é enviado para a pilha.  
  
3.  `index` e `array` são removidos da pilha; o valor armazenado na posição `index` em `array` é pesquisado.  
  
4.  O valor é enviado para a pilha.  
  
 O `ldelem.i4` instrução carrega o valor do elemento com índice `index` (tipo `native int`) na matriz unidimensional baseada em zero `array` e o coloca na parte superior da pilha. Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.  
  
 O valor de retorno `ldelem.i4` é `int32`.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.  
  
 <xref:System.NullReferenceException> será gerada se `array` é uma referência nula.  
  
 <xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.  
  
 <xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o elemento com o tipo <see langword="int64" /> em um índice de matriz especificado para o topo da pilha de avaliação como um <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|96|Ldelem.I8|Carrega o elemento com o tipo `int64` na `index` para o topo da pilha de como um `int64`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `array` é enviado para a pilha.  
  
2.  Um valor de índice `index` é enviado para a pilha.  
  
3.  `index` e `array` são removidos da pilha; o valor armazenado na posição `index` em `array` é pesquisado.  
  
4.  O valor é enviado para a pilha.  
  
 O `ldelem.i8` instrução carrega o valor do elemento com índice `index` (tipo `native int`) na matriz unidimensional baseada em zero `array` e o coloca na parte superior da pilha. Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.  
  
 O valor de retorno `ldelem.i8` é `int64`.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.  
  
 <xref:System.NullReferenceException> será gerada se `array` é uma referência nula.  
  
 <xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.  
  
 <xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o elemento com o tipo <see langword="float32" /> em um índice de matriz especificado para o topo da pilha de avaliação como um tipo <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|98|Ldelem.R4|Carrega o elemento com o tipo `float32` na `index` para o topo da pilha de como um tipo `F`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `array` é enviado para a pilha.  
  
2.  Um valor de índice `index` é enviado para a pilha.  
  
3.  `index` e `array` são removidos da pilha; o valor armazenado na posição `index` em `array` é pesquisado.  
  
4.  O valor é enviado para a pilha.  
  
 O `ldelem.r4` instrução carrega o valor do elemento com índice `index` (tipo `native int`) na matriz unidimensional baseada em zero `array` e o coloca na parte superior da pilha. Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.  
  
 O valor de retorno `ldelem.r4` é `float32`.  
  
 Valores de ponto flutuante são convertidos para o tipo `F` quando carregado na pilha de avaliação.  
  
 <xref:System.NullReferenceException> será gerada se `array` é uma referência nula.  
  
 <xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.  
  
 <xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o elemento com o tipo <see langword="float64" /> em um índice de matriz especificado para o topo da pilha de avaliação como um tipo <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|99|Ldelem.R8|Carrega o elemento com o tipo `float64` na `index` para o topo da pilha como tipo `F`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `array` é enviado para a pilha.  
  
2.  Um valor de índice `index` é enviado para a pilha.  
  
3.  `index` e `array` são removidos da pilha; o valor armazenado na posição `index` em `array` é pesquisado.  
  
4.  O valor é enviado para a pilha.  
  
 O `ldelem.r8` instrução carrega o valor do elemento com índice `index` (tipo `native int`) na matriz unidimensional baseada em zero `array` e o coloca na parte superior da pilha. Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.  
  
 O valor de retorno `ldelem.r8` é `float64`.  
  
 Valores de ponto flutuante são convertidos para o tipo `F` quando carregado na pilha de avaliação.  
  
 <xref:System.NullReferenceException> será gerada se `array` é uma referência nula.  
  
 <xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.  
  
 <xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o elemento que contém uma referência de objeto em um índice de matriz especificado para o topo da pilha de avaliação como tipo <see langword="O" /> (referência de objeto).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|9A|Ldelem.ref|Carrega o elemento com uma referência de objeto no `index` para o topo da pilha como tipo `O`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `array` é enviado para a pilha.  
  
2.  Um valor de índice `index` é enviado para a pilha.  
  
3.  `index` e `array` são removidos da pilha; o valor armazenado na posição `index` em `array` é pesquisado.  
  
4.  O valor é enviado para a pilha.  
  
 O `ldelem.ref` instrução carrega o valor do elemento com índice `index` (tipo `native int`) na matriz unidimensional baseada em zero `array` e o coloca na parte superior da pilha. Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.  
  
 O valor de retorno `ldelem.ref` é do tipo `O` (referência de objeto).  
  
 <xref:System.NullReferenceException> será gerada se `array` é uma referência nula.  
  
 <xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.  
  
 <xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.ref` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o elemento com o tipo <see langword="unsigned int8" /> em um índice de matriz especificado para o topo da pilha de avaliação como um <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|91|Ldelem.U1|Carrega o elemento com o tipo `unsigned int8` na `index` para o topo da pilha de como um `int32`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `array` é enviado para a pilha.  
  
2.  Um valor de índice `index` é enviado para a pilha.  
  
3.  `index` e `array` são removidos da pilha; o valor armazenado na posição `index` em `array` é pesquisado.  
  
4.  O valor é enviado para a pilha.  
  
 O `ldelem.u1` instrução carrega o valor do elemento com índice `index` (tipo `native int`) na matriz unidimensional baseada em zero `array` e o coloca na parte superior da pilha. Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.  
  
 O valor de retorno `ldelem.u1` é `int8`.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.  
  
 <xref:System.NullReferenceException> será gerada se `array` é uma referência nula.  
  
 <xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.  
  
 <xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.u1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o elemento com o tipo <see langword="unsigned int16" /> em um índice de matriz especificado para o topo da pilha de avaliação como um <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|93|Ldelem.U2|Carrega o elemento com o tipo `unsigned int16` no índice para o topo da pilha de como um `int32`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `array` é enviado para a pilha.  
  
2.  Um valor de índice `index` é enviado para a pilha.  
  
3.  `index` e `array` são removidos da pilha; o valor armazenado na posição `index` em `array` é pesquisado.  
  
4.  O valor é enviado para a pilha.  
  
 O `ldelem.u2` instrução carrega o valor do elemento com índice `index` (tipo `native int`) na matriz unidimensional baseada em zero `array` e o coloca na parte superior da pilha. Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.  
  
 O valor de retorno `ldelem.u2` é `int16`.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.  
  
 <xref:System.NullReferenceException> será gerada se `array` é uma referência nula.  
  
 <xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.  
  
 <xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.u2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o elemento com o tipo <see langword="unsigned int32" /> em um índice de matriz especificado para o topo da pilha de avaliação como um <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|95|Ldelem.U4|Carrega o elemento com o tipo `unsigned int32` no índice para o topo da pilha de como um `int32`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `array` é enviado para a pilha.  
  
2.  Um valor de índice `index` é enviado para a pilha.  
  
3.  `index` e `array` são removidos da pilha; o valor armazenado na posição `index` em `array` é pesquisado.  
  
4.  O valor é enviado para a pilha.  
  
 O `ldelem.u4` instrução carrega o valor do elemento com índice `index` (tipo `native int`) na matriz unidimensional baseada em zero `array` e o coloca na parte superior da pilha. Matrizes são objetos e, portanto, é representado por um valor do tipo `O`.  
  
 O valor de retorno `ldelem.u4` é `int32`.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.  
  
 <xref:System.NullReferenceException> será gerada se `array` é uma referência nula.  
  
 <xref:System.ArrayTypeMismatchException> será gerada se a matriz não contém elementos do tipo necessário.  
  
 <xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.u4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o endereço do elemento da matriz em um índice de matriz especificado no topo da pilha de avaliação como o tipo <see langword="&amp;" /> (ponteiro gerenciado).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|8F < `T` >|faltando ldelema `class`|Carrega o endereço do elemento na matriz `index` para o topo da pilha de avaliação como tipo `&` (ponteiro gerenciado).|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `array` é enviado para a pilha.  
  
2.  Um valor de índice `index` é enviado para a pilha.  
  
3.  `index` e `array` são removidos da pilha; o endereço armazenado na posição `index` em `array` é pesquisado.  
  
4.  O endereço é enviado para a pilha.  
  
 O `ldelema` é usado para recuperar o endereço de um objeto em um índice específico em uma matriz de objetos (do tipo `class`). O `ldelema` instrução carrega o endereço do valor no índice `index` (tipo `native int`) na matriz unidimensional baseada em zero `array` e o coloca na parte superior da pilha. Matrizes são objetos e, portanto, é representado por um valor do tipo `O`. O valor deve ser do tipo `class` transmitido com a instrução.  
  
 O valor de retorno `ldelema` é um ponteiro gerenciado (tipo `&`).  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação.  
  
 <xref:System.NullReferenceException> será gerada se `array` é uma referência nula.  
  
 <xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.  
  
 <xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelema` opcode:  
  
-   ILGenerator.Emit (OpCode, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Localiza o valor de um campo no objeto cuja referência está na pilha de avaliação no momento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|7B &LT; `T` >|ldfld `field`|Envia o valor de um campo em um objeto especificado para a pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto (ou um ponteiro) é enviado para a pilha.  
  
2.  A referência de objeto (ou ponteiro) é aparecido da pilha; o valor do campo no objeto especificado for encontrado.  
  
3.  O valor armazenado no campo será enviado para a pilha.  
  
 O `ldfld` instrução envia o valor de um campo localizado em um objeto para a pilha. O objeto deve estar na pilha como uma referência de objeto (tipo `O`), um ponteiro gerenciado (tipo `&`), um ponteiro não gerenciado (tipo `native int`), um ponteiro transitório (tipo `*`), ou uma instância de um tipo de valor. O uso de um ponteiro não gerenciado não é permitido no código verificável. Campo do objeto é especificado por um token de metadados que deve se referir a um membro de campo. O tipo de retorno é o mesmo que aquele associado ao campo. O campo pode ser um campo de instância (nesse caso, o objeto não deve ser uma referência nula) ou um campo estático.  
  
 O `ldfld` instrução pode ser precedida por um ou ambos os <xref:System.Reflection.Emit.OpCodes.Unaligned> e <xref:System.Reflection.Emit.OpCodes.Volatile> prefixos.  
  
 <xref:System.NullReferenceException> será gerada se o objeto é nulo e o campo não é estático.  
  
 <xref:System.MissingFieldException> será gerada se o campo especificado não for encontrado nos metadados. Normalmente, isso é verificado quando instruções Microsoft Intermediate Language (MSIL) são convertidos em código nativo, não em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldfld` opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Localiza o endereço de um campo no objeto cuja referência está na pilha de avaliação no momento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|7C &LT; `T` >|ldflda `field`|Envia o endereço de `field` em um objeto especificado para a pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto (ou um ponteiro) é enviado para a pilha.  
  
2.  A referência de objeto (ou ponteiro) é aparecido da pilha; o endereço do campo no objeto especificado for encontrado.  
  
3.  O endereço do campo especificado é enviado para a pilha.  
  
 O `ldflda` instrução envia o endereço de um campo localizado em um objeto para a pilha. O objeto deve estar na pilha como uma referência de objeto (tipo `O`), um ponteiro gerenciado (tipo `&`), um ponteiro não gerenciado (tipo `native int`), um ponteiro transitório (tipo `*`), ou uma instância de um tipo de valor. O uso de um ponteiro não gerenciado não é permitido no código verificável. Campo do objeto é especificado por um token de metadados que deve se referir a um membro de campo.  
  
 O valor retornado por `ldflda` é um ponteiro gerenciado (tipo `&`), a menos que o objeto é inserido na pilha como um ponteiro não gerenciado, nesse caso, o endereço de retorno é também um ponteiro não gerenciado (tipo `native int`).  
  
 O `ldflda` instrução pode ser precedida por um ou ambos os <xref:System.Reflection.Emit.OpCodes.Unaligned> e <xref:System.Reflection.Emit.OpCodes.Volatile> prefixos.  
  
 <xref:System.InvalidOperationException> será gerada se o objeto não está dentro do domínio de aplicativo do qual ele está sendo acessado. O endereço de um campo que não está dentro do domínio do aplicativo ao acessar não foi carregado.  
  
 <xref:System.NullReferenceException> será gerada se o objeto é nulo e o campo não é estático.  
  
 <xref:System.MissingFieldException> será gerada se o campo especificado não for encontrado nos metadados. Normalmente, isso é verificado quando instruções Microsoft Intermediate Language (MSIL) são convertidos em código nativo, não em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldflda` opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia um ponteiro não gerenciado (tipo <see langword="native int" />) para o código nativo implementando um método específico na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 06 < `T` >|ldftn `method`|Envia um ponteiro para um método referenciado pelo `method` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O ponteiro não gerenciado para um método específico é enviado para a pilha.  
  
 O método específico (`method`) pode ser chamado usando o <xref:System.Reflection.Emit.OpCodes.Calli> instrução se ele fizer referência a um método gerenciado (ou um stub que faz a transição de código gerenciado para código não gerenciado).  
  
 O valor retornado pontos para código nativo usando o convenção de chamada do CLR. Esse ponteiro de método não deve ser passado para código nativo não gerenciado como uma rotina de retorno de chamada.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldftn` opcode:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega um valor do tipo <see langword="native int" /> como um <see langword="native int" /> na pilha de avaliação indiretamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|4D|ldind.i|Carrega o `native int` valor no endereço `addr` para a pilha como um `native int`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço será enviado para a pilha.  
  
2.  O endereço é aparecido da pilha; o valor localizado no endereço é buscado.  
  
3.  O valor buscado é enviado para a pilha.  
  
 O `ldind.i` instrução indiretamente carrega um `native int` o valor do endereço especificado (do tipo `native int`, `&`, ou *) para a pilha como um `native int`.  
  
 Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interno correspondente.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação. Valores de ponto flutuante são convertidos em `F` digite quando carregado na pilha de avaliação.  
  
 Formado corretamente MSIL Microsoft Intermediate Language () garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.  
  
 O endereço inserido inicialmente na pilha deve estar alinhado no tamanho natural de objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte a <xref:System.Reflection.Emit.OpCodes.Unaligned> instruções para medidas preventivas de prefixo). Os resultados de todas as instruções de MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança. Para tipos de dados maiores que 1 byte, a ordenação de bytes é dependente de CPU de destino. Código que depende da ordem de bytes pode não ser executado em todas as plataformas.  
  
 <xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega um valor do tipo <see langword="int8" /> como um <see langword="int32" /> na pilha de avaliação indiretamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|46|ldind.I1|Carrega o `int8` valor no endereço `addr` para a pilha como um `int32`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço será enviado para a pilha.  
  
2.  O endereço é aparecido da pilha; o valor localizado no endereço é buscado.  
  
3.  O valor buscado é enviado para a pilha. 
  
 O `ldind.i1` instrução indiretamente carrega um `int8` o valor do endereço especificado (do tipo `native int`, `&`, ou *) para a pilha como um `int32`.  
  
 Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interno correspondente.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação. Valores de ponto flutuante são convertidos em `F` digite quando carregado na pilha de avaliação.  
  
 Formado corretamente MSIL Microsoft Intermediate Language () garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.  
  
 O endereço inserido inicialmente na pilha deve estar alinhado no tamanho natural de objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte a <xref:System.Reflection.Emit.OpCodes.Unaligned> instruções para medidas preventivas de prefixo). Os resultados de todas as instruções de MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança. Para tipos de dados maiores que 1 byte, a ordenação de bytes é dependente de CPU de destino. Código que depende da ordem de bytes pode não ser executado em todas as plataformas.  
  
 <xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega um valor do tipo <see langword="int16" /> como um <see langword="int32" /> na pilha de avaliação indiretamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|48|ldind.I2|Carrega o `int16` valor no endereço `addr` para a pilha como um `int32`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço será enviado para a pilha.  
  
2.  O endereço é aparecido da pilha; o valor localizado no endereço é buscado.  
  
3.  O valor buscado é enviado para a pilha.  
  
 O `ldind.i2` instrução indiretamente carrega um `int16` o valor do endereço especificado (do tipo `native int`, `&`, ou *) para a pilha como um `int32`.  
  
 Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interno correspondente.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação. Valores de ponto flutuante são convertidos em `F` digite quando carregado na pilha de avaliação.  
  
 Formado corretamente MSIL Microsoft Intermediate Language () garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.  
  
 O endereço inserido inicialmente na pilha deve estar alinhado no tamanho natural de objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte a <xref:System.Reflection.Emit.OpCodes.Unaligned> instruções para medidas preventivas de prefixo). Os resultados de todas as instruções de MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança. Para tipos de dados maiores que 1 byte, a ordenação de bytes é dependente de CPU de destino. Código que depende da ordem de bytes pode não ser executado em todas as plataformas.  
  
 <xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega um valor do tipo <see langword="int32" /> como um <see langword="int32" /> na pilha de avaliação indiretamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|4A|ldind.i4|Carrega o `int32` valor no endereço `addr` para a pilha como um `int32`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço será enviado para a pilha.  
  
2.  O endereço é aparecido da pilha; o valor localizado no endereço é buscado.  
  
3.  O valor buscado é enviado para a pilha.  
  
 O `ldind.i4` instrução indiretamente carrega um `int32` o valor do endereço especificado (do tipo `native int`, `&`, ou *) para a pilha como um `int32`.  
  
 Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interno correspondente.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação. Valores de ponto flutuante são convertidos em `F` digite quando carregado na pilha de avaliação.  
  
 Formado corretamente MSIL Microsoft Intermediate Language () garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.  
  
 O endereço inserido inicialmente na pilha deve estar alinhado no tamanho natural de objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte a <xref:System.Reflection.Emit.OpCodes.Unaligned> instruções para medidas preventivas de prefixo). Os resultados de todas as instruções de MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança. Para tipos de dados maiores que 1 byte, a ordenação de bytes é dependente de CPU de destino. Código que depende da ordem de bytes pode não ser executado em todas as plataformas.  
  
 <xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega um valor do tipo <see langword="int64" /> como um <see langword="int64" /> na pilha de avaliação indiretamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|4C|ldind.I8|Carrega o `int64` valor no endereço `addr` para a pilha como um `int64`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço será enviado para a pilha.  
  
2.  O endereço é aparecido da pilha; o valor localizado no endereço é buscado.  
  
3.  O valor buscado é enviado para a pilha.  
  
 O `ldind.i8` instrução indiretamente carrega um `int64` o valor do endereço especificado (do tipo `native int`, `&`, ou *) para a pilha como um `int64`.  
  
 Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interno correspondente.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação. Valores de ponto flutuante são convertidos em `F` digite quando carregado na pilha de avaliação.  
  
 Formado corretamente MSIL Microsoft Intermediate Language () garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.  
  
 O endereço inserido inicialmente na pilha deve estar alinhado no tamanho natural de objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte a <xref:System.Reflection.Emit.OpCodes.Unaligned> instruções para medidas preventivas de prefixo). Os resultados de todas as instruções de MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança. Para tipos de dados maiores que 1 byte, a ordenação de bytes é dependente de CPU de destino. Código que depende da ordem de bytes pode não ser executado em todas as plataformas.  
  
 <xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega um valor do tipo <see langword="float32" /> como um tipo <see langword="F" /> (float) para a pilha de avaliação indiretamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|4E|ldind.R4|Carrega o `float32` valor no endereço `addr` para a pilha como um tipo `F`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço será enviado para a pilha.  
  
2.  O endereço é aparecido da pilha; o valor localizado no endereço é buscado.  
  
3.  O valor buscado é enviado para a pilha.  
  
 O `ldind.r4` instrução indiretamente carrega um `float32` o valor do endereço especificado (do tipo `native int`, `&`, ou *) para a pilha como um tipo `F`.  
  
 Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interno correspondente.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação. Valores de ponto flutuante são convertidos em `F` digite quando carregado na pilha de avaliação.  
  
 Formado corretamente MSIL Microsoft Intermediate Language () garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.  
  
 O endereço inserido inicialmente na pilha deve estar alinhado no tamanho natural de objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte a <xref:System.Reflection.Emit.OpCodes.Unaligned> instruções para medidas preventivas de prefixo). Os resultados de todas as instruções de MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança. Para tipos de dados maiores que 1 byte, a ordenação de bytes é dependente de CPU de destino. Código que depende da ordem de bytes pode não ser executado em todas as plataformas.  
  
 <xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega um valor do tipo <see langword="float64" /> como um tipo <see langword="F" /> (float) para a pilha de avaliação indiretamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|4F|ldind.R8|Carrega o `float64` valor no endereço `addr` para a pilha como um tipo `F`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço será enviado para a pilha.  
  
2.  O endereço é aparecido da pilha; o valor localizado no endereço é buscado.  
  
3.  O valor buscado é enviado para a pilha.  
  
 O `ldind.r8` instrução indiretamente carrega um `float64` o valor do endereço especificado (do tipo `native int`, `&`, ou *) para a pilha como um `float64`.  
  
 Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interno correspondente.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação. Valores de ponto flutuante são convertidos em `F` digite quando carregado na pilha de avaliação.  
  
 Formado corretamente MSIL Microsoft Intermediate Language () garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.  
  
 O endereço inserido inicialmente na pilha deve estar alinhado no tamanho natural de objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte a <xref:System.Reflection.Emit.OpCodes.Unaligned> instruções para medidas preventivas de prefixo). Os resultados de todas as instruções de MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança. Para tipos de dados maiores que 1 byte, a ordenação de bytes é dependente de CPU de destino. Código que depende da ordem de bytes pode não ser executado em todas as plataformas.  
  
 <xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega uma referência de objeto como um tipo <see langword="O" /> (referência de objeto) para a pilha de avaliação indiretamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|50|ldind.ref|Carrega a referência de objeto no endereço `addr` à pilha como um tipo `O`|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço será enviado para a pilha.  
  
2.  O endereço é aparecido da pilha; a referência de objeto localizada no endereço é buscada.  
  
3.  A referência de busca é enviada para a pilha.  
  
 O `ldind.ref` instrução indiretamente carrega a referência de objeto, o endereço especificado (do tipo `native int`, `&`, ou *) para a pilha como tipo `O`.  
  
 Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interno correspondente.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação. Valores de ponto flutuante são convertidos em `F` digite quando carregado na pilha de avaliação.  
  
 Formado corretamente MSIL Microsoft Intermediate Language () garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.  
  
 O endereço inserido inicialmente na pilha deve estar alinhado no tamanho natural de objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte a <xref:System.Reflection.Emit.OpCodes.Unaligned> instruções para medidas preventivas de prefixo). Os resultados de todas as instruções de MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança. Para tipos de dados maiores que 1 byte, a ordenação de bytes é dependente de CPU de destino. Código que depende da ordem de bytes pode não ser executado em todas as plataformas.  
  
 <xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.ref` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega um valor do tipo <see langword="unsigned int8" /> como um <see langword="int32" /> na pilha de avaliação indiretamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|47|ldind.U1|Carrega o `unsigned int8` valor no endereço `addr` para a pilha como um `int32`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço será enviado para a pilha.  
  
2.  O endereço é aparecido da pilha; o valor localizado no endereço é buscado.  
  
3.  O valor buscado é enviado para a pilha.  
  
 O `ldind.u1` instrução indiretamente carrega um `unsigned int8` o valor do endereço especificado (do tipo`native int`, `&`, ou *) para a pilha como um `int32`.  
  
 Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interno correspondente.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação. Valores de ponto flutuante são convertidos em `F` digite quando carregado na pilha de avaliação.  
  
 Formado corretamente MSIL Microsoft Intermediate Language () garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.  
  
 O endereço inserido inicialmente na pilha deve estar alinhado no tamanho natural de objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte a <xref:System.Reflection.Emit.OpCodes.Unaligned> instruções para medidas preventivas de prefixo). Os resultados de todas as instruções de MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança. Para tipos de dados maiores que 1 byte, a ordenação de bytes é dependente de CPU de destino. Código que depende da ordem de bytes pode não ser executado em todas as plataformas.  
  
 <xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.u1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega um valor do tipo <see langword="unsigned int16" /> como um <see langword="int32" /> na pilha de avaliação indiretamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|49|ldind.U2|Carrega o `unsigned int16` valor no endereço `addr` para a pilha como um `int32`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço será enviado para a pilha.  
  
2.  O endereço é aparecido da pilha; o valor localizado no endereço é buscado.  
  
3.  O valor buscado é enviado para a pilha.  
  
 O `ldind.u2` instrução indiretamente carrega um `unsigned int16` o valor do endereço especificado (do tipo `native int`, `&`, ou *) para a pilha como um `int32`.  
  
 Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interno correspondente.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação. Valores de ponto flutuante são convertidos em `F` digite quando carregado na pilha de avaliação.  
  
 Formado corretamente MSIL Microsoft Intermediate Language () garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.  
  
 O endereço inserido inicialmente na pilha deve estar alinhado no tamanho natural de objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte a <xref:System.Reflection.Emit.OpCodes.Unaligned> instruções para medidas preventivas de prefixo). Os resultados de todas as instruções de MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança. Para tipos de dados maiores que 1 byte, a ordenação de bytes é dependente de CPU de destino. Código que depende da ordem de bytes pode não ser executado em todas as plataformas.  
  
 <xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.u2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega um valor do tipo <see langword="unsigned int32" /> como um <see langword="int32" /> na pilha de avaliação indiretamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|4B|ldind.U4|Carrega o `unsigned int32` valor no endereço `addr` para a pilha como um `int32`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço será enviado para a pilha.  
  
2.  O endereço é aparecido da pilha; o valor localizado no endereço é buscado.  
  
3.  O valor buscado é enviado para a pilha.  
  
 O `ldind.u4` instrução indiretamente carrega um `unsigned int32` o valor do endereço especificado (do tipo `native int`, `&`, ou *) para a pilha como um `int32`.  
  
 Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interno correspondente.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para o `int32` (não `native int`) quando eles são carregados na pilha de avaliação. Valores de ponto flutuante são convertidos em `F` digite quando carregado na pilha de avaliação.  
  
 Formado corretamente MSIL Microsoft Intermediate Language () garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.  
  
 O endereço inserido inicialmente na pilha deve estar alinhado no tamanho natural de objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte a <xref:System.Reflection.Emit.OpCodes.Unaligned> instruções para medidas preventivas de prefixo). Os resultados de todas as instruções de MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança. Para tipos de dados maiores que 1 byte, a ordenação de bytes é dependente de CPU de destino. Código que depende da ordem de bytes pode não ser executado em todas as plataformas.  
  
 <xref:System.NullReferenceException> pode ser gerada se um endereço inválido for detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.u4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Efetua o push do número de elementos de uma matriz unidimensional de base zero para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|8E|ldlen|Envia por push o comprimento (do tipo `natural unsigned int`) de uma matriz na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto para uma matriz é enviada para a pilha.  
  
2.  A referência de matriz é Aparecida da pilha e o comprimento é computado.  
  
3.  O comprimento é enviado para a pilha.  
  
 Matrizes são objetos e, portanto, é representado por um valor do tipo `O`. O comprimento é retornado como um `natural unsigned int`.  
  
 <xref:System.NullReferenceException> será gerada se a referência de matriz é uma referência nula.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldlen` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega a variável local em um índice específico na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 0C &LT; `unsigned int16` >|Ldloc `index`|Carrega a variável local no índice `index` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor da variável local no índice especificado é enviado para a pilha.  
  
 O `ldloc` instrução envia por push o conteúdo do número de variável local no índice passado na pilha de avaliação, onde as variáveis locais são numerados de 0 em diante. Antes de inserir o método somente se o sinalizador de inicialização no método for verdadeiro, as variáveis locais são inicializadas como 0. Há 65.535 (2 ^ 16 - 1) as variáveis locais possíveis (0-65.534). 65.535 de índice não é válido, pois implementações provavelmente usará um inteiro de 2 bytes para controlar o índice de um locais, juntamente com o número total de locais para um determinado método. Se um índice de 65535 tivesse sido feito válido, ele exigiria um inteiro maior controlar o número de locais em um método desse tipo.  
  
 O `ldloc.0`, `ldloc.1`, `ldloc.2`, e `ldloc.3` instruções fornecem uma codificação eficiente para acessar as primeiras quatro variáveis locais.  
  
 O tipo do valor é igual ao tipo da variável local, que é especificado no cabeçalho de método. Consulte partição I. Local variáveis que são menores que 4 bytes de comprimento é expandido para o tipo `int32` quando eles são carregados para a pilha. Valores de ponto flutuante são expandidas para seu tamanho nativo (tipo `F`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas de método podem usar o `ldloc` opcode:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega a variável local no índice 0 na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|06|Ldloc.0|Carrega a variável local no índice 0 na pilha de avaliação.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor da variável local no índice 0 é enviado para a pilha.  
  
 `ldloc.0` é uma codificação especialmente eficiente para <xref:System.Reflection.Emit.OpCodes.Ldloc>, permitindo o acesso à variável local no índice 0.  
  
 O tipo do valor é igual ao tipo da variável local, que é especificado no cabeçalho de método. Variáveis locais que são menores que 4 bytes de comprimento são expandidas para o tipo `int32` quando eles são carregados para a pilha. Valores de ponto flutuante são expandidas para seu tamanho nativo (tipo `F`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldloc.0` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega a variável local no índice 1 para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|07|Ldloc.1|Carrega a variável local no índice 1 para a pilha de avaliação.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor da variável local no índice 1 é enviado para a pilha.  
  
 `ldloc.1` é uma codificação especialmente eficiente para <xref:System.Reflection.Emit.OpCodes.Ldloc>, permitindo o acesso à variável local no índice 1.  
  
 O tipo do valor é igual ao tipo da variável local, que é especificado no cabeçalho de método. Variáveis locais que são menores que 4 bytes de comprimento são expandidas para o tipo `int32` quando eles são carregados para a pilha. Valores de ponto flutuante são expandidas para seu tamanho nativo (tipo `F`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldloc.1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega a variável local no índice 2 para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|08|Ldloc.2|Carrega a variável local no índice 2 para a pilha de avaliação.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor da variável local no índice 2 é enviado para a pilha.  
  
 `ldloc.2` é uma codificação especialmente eficiente para <xref:System.Reflection.Emit.OpCodes.Ldloc>, permitindo o acesso à variável local no índice 2.  
  
 O tipo do valor é igual ao tipo da variável local, que é especificado no cabeçalho de método. Variáveis locais que são menores que 4 bytes de comprimento são expandidas para o tipo `int32` quando eles são carregados para a pilha. Valores de ponto flutuante são expandidas para seu tamanho nativo (tipo `F`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldloc.2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega a variável local no índice 3 para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|09|Ldloc.3|Carrega a variável local no índice 3 para a pilha de avaliação.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor da variável local no índice 3 é enviado para a pilha.  
  
 `ldloc.3` é uma codificação especialmente eficiente para <xref:System.Reflection.Emit.OpCodes.Ldloc>, permitindo o acesso à variável local no índice 3.  
  
 O tipo do valor é igual ao tipo da variável local, que é especificado no cabeçalho de método. Variáveis locais que são menores que 4 bytes de comprimento são expandidas para o tipo `int32` quando eles são carregados para a pilha. Valores de ponto flutuante são expandidas para seu tamanho nativo (tipo `F`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldloc.3` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega a variável local em um índice específico na pilha de avaliação, de forma abreviada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|11 < `unsigned int8` >|Ldloc.s `index`|Carrega a variável local no índice `index` na pilha, de forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor da variável local no índice especificado é enviado para a pilha.  
  
 O `ldloc.s` instrução envia por push o conteúdo do número de variável local no índice passado na pilha de avaliação, onde as variáveis locais são numerados de 0 em diante. Antes do método de inserção, se o sinalizador de inicialização no método for true, as variáveis locais são inicializadas como 0. Há 256 (2 ^ 8) as variáveis locais possíveis (0 a 255) na forma abreviada, que é uma codificação mais eficiente que `ldloc`.  
  
 O tipo do valor é igual ao tipo da variável local, que é especificado no cabeçalho de método. Consulte partição I. Local variáveis que são menores que 4 bytes de comprimento é expandido para o tipo `int32` quando eles são carregados para a pilha. Valores de ponto flutuante são expandidas para seu tamanho nativo (tipo `F`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas de método podem usar o `ldloc.s` opcode:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o endereço da variável local em um índice específico para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE OD &LT; `unsigned int16` >|ldloca `index`|Carrega o endereço da variável local em `index` na pilha de avaliação.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O endereço armazenado na variável local no índice especificado é enviado para a pilha.  
  
 O `ldloca` instrução envia o endereço do número de variável local no índice passado para a pilha, em que as variáveis locais são numeradas de 0 em diante. O valor enviado por push na pilha já alinhado corretamente para uso com instruções, como <xref:System.Reflection.Emit.OpCodes.Ldind_I> e <xref:System.Reflection.Emit.OpCodes.Stind_I>. O resultado é um ponteiro transitório (tipo `*`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldloca` opcode:  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o endereço da variável local em um índice específico para a pilha de avaliação, em forma abreviada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|12 < `unsigned int8` >|ldloca.s `index`|Carrega o endereço da variável local em `index` na pilha de avaliação, de forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O endereço armazenado na variável local no índice especificado é enviado para a pilha.  
  
 O `ldloca.s` instrução envia o endereço do número de variável local no índice passado para a pilha, em que as variáveis locais são numeradas de 0 em diante. O valor enviado por push na pilha já alinhado corretamente para uso com instruções, como <xref:System.Reflection.Emit.OpCodes.Ldind_I> e <xref:System.Reflection.Emit.OpCodes.Stind_I>. O resultado é um ponteiro transitório (tipo `*`).  
  
 O `ldloca.s` instrução fornece uma codificação eficiente para uso com as variáveis locais de 0 a 255.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldloca.s` opcode:  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia uma referência nula (tipo <see langword="O" />) para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|14|ldnull|Enviar por push uma referência nula para a pilha|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto nulo é enviada para a pilha.  
  
 `ldnull` envia uma referência nula (tipo `O`) na pilha. Isso é usado para inicializar locais antes que eles são preenchidos com dados, ou quando eles se tornam preteridos.  
  
 `ldnull` Fornece uma referência nula que é independente de tamanho.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldnull` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Copia o objeto de tipo de valor apontado por um endereço na parte superior da pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|71 < `T` >|ldobj `class`|Instância de cópia do tipo de valor `class` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O endereço de um objeto de tipo de valor é enviado para a pilha.  
  
2.  O endereço é aparecido da pilha e a instância nesse endereço específico é pesquisada.  
  
3.  O valor do objeto armazenado nesse endereço será enviado para a pilha.  
  
 O `ldobj` instrução é usada para passar um tipo de valor como um parâmetro.  
  
 O `ldobj` instrução copia o valor apontado por `addrOfValObj` (do tipo `&`, `*`, ou `native int`) na parte superior da pilha. O número de bytes copiados depende do tamanho da classe (conforme especificado pelo `class` parâmetro). O `class` parâmetro é um token de metadados que representa o tipo de valor.  
  
 A operação do `ldobj` instrução pode ser alterada por um imediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instrução de prefixo.  
  
 <xref:System.TypeLoadException> será gerada se a classe não pode ser encontrado. Normalmente, isso é detectado quando a instrução de Microsoft Intermediate Language (MSIL) é convertida em código nativo em vez de em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldobj` opcode:  
  
-   ILGenerator.Emit (OpCode, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia por push o valor de um campo estático para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|7E < `T` >|ldsfld `field`|Enviar por push o valor de `field` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor de campo específico é enviado para a pilha.  
  
 O `ldsfld` instrução envia o valor de um estático (compartilhado entre todas as instâncias de uma classe) campo na pilha. O tipo de retorno é que associado com o token de metadados passado `field`.  
  
 O `ldsfld` instrução pode ter um <xref:System.Reflection.Emit.OpCodes.Volatile> prefixo.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldsfld` opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Efetua o push do endereço de um campo estático para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|7F < `T` >|ldsflda `field`|Enviar por push o endereço do `field` na pilha|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O endereço de um campo específico é enviado para a pilha.  
  
 O `ldsflda` instrução envia o endereço de um estático (compartilhado entre todas as instâncias de uma classe) campo na pilha. O endereço pode ser representado como um ponteiro transitório (tipo `*`) se o token de metadados `field` se refere a um tipo cuja memória é gerenciada. Caso contrário, ele corresponde a um ponteiro não gerenciado (tipo `native int`). Observe que `field` pode ser estático global com um endereço de virtual relativo atribuído (o deslocamento do campo do endereço base no qual o arquivo PE que contém é carregado na memória) em que a memória é não gerenciada.  
  
 O `ldsflda` instrução pode ter um <xref:System.Reflection.Emit.OpCodes.Volatile> prefixo.  
  
 <xref:System.MissingFieldException> será gerada se o campo não for encontrado nos metadados. Normalmente, isso é verificado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo, não em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldsflda` opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia por push uma nova referência de objeto para uma literal de cadeia de caracteres armazenada nos metadados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|72 < `T` >|ldstr `mdToken`|Envia um objeto de cadeia de caracteres para o token de cadeia de caracteres de metadados `mdToken`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto para uma cadeia de caracteres é enviada para a pilha.  
  
 O `ldstr` instrução envia por push uma referência de objeto (tipo `O`) para um novo objeto de cadeia de caracteres que representa a cadeia de caracteres literal armazenada nos metadados. O `ldstr` instrução aloca a quantidade necessária de memória e executa qualquer conversão de formato necessário para converter a cadeia de caracteres literal do formulário usado no arquivo para o formato de cadeia de caracteres necessário em tempo de execução.  
  
 O Common Language Infrastructure (CLI) garante que o resultado de dois `ldstr` as instruções referentes a dois tokens de metadados que têm a mesma sequência de caracteres de retorno exatamente o mesmo objeto de cadeia de caracteres (um processo conhecido como "centralização da cadeia de caracteres").  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldstr` opcode:  
  
-   ILGenerator.Emit (cadeia de caracteres de OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte um token de metadados em sua representação de tempo de execução, enviando-o por push para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|D0 < `T` >|Ldtoken `token`|Converte um token de metadados em sua representação de tempo de execução.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O token passado é convertido em um `RuntimeHandle` e enviado para a pilha.  
  
 O `ldtoken` envios por push de instrução um `RuntimeHandle` para o token de metadados especificado. Um `RuntimeHandle` pode ser uma `fieldref/fielddef`, um `methodref/methoddef`, ou um `typeref/typedef`.  
  
 O valor enviado por push na pilha pode ser usado em chamadas para `Reflection` métodos na biblioteca de classes do sistema.  
  
 Para obter informações sobre identificadores de tempo de execução, consulte as seguintes classes: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, e <xref:System.RuntimeMethodHandle>.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas de método podem usar o `ldtoken` opcode:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
-   ILGenerator.Emit (OpCode, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Efetua o push de um ponteiro não gerenciado (tipo <see langword="native int" />) para o código nativo implementando um método virtual específico associado ao objeto especificado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 07 &LT; `T` >|ldvirtftn `method`|Envia o ponteiro para um método do objeto virtual `method` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto é inserida na pilha.  
  
2.  A referência de objeto é Aparecida da pilha e o endereço do ponto de entrada para o método (conforme especificado pelo token de metadados `method`) é pesquisado.  
  
3.  O ponteiro para `method` é enviado para a pilha.  
  
 O ponteiro não gerenciado resultante enviado para a pilha, o `ldvirtftn` instrução pode ser chamada usando o <xref:System.Reflection.Emit.OpCodes.Calli> instrução se ele fizer referência a um método gerenciado (ou um stub que faz a transição de código gerenciado para código não gerenciado).  
  
 Pontos de ponteiro não gerenciado para código nativo usando o convenção de chamada do CLR. Esse ponteiro de método não deve ser passado para código nativo não gerenciado como uma rotina de retorno de chamada.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldvirtftn` opcode:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sai de uma região protegida de código, transferindo o controle incondicionalmente para uma instrução de destino específica.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|DD < `int32` >|sair `target`|Sai de uma região protegida de código.|  
  
 Não há nenhum comportamento de transição de pilha especificado para essa instrução.  
  
 O `leave` instrução transfere o controle incondicionalmente para a instrução de destino específico, representada como uma diferença com sinal de 4 bytes do início da instrução após a instrução atual.  
  
 O `leave` instrução é semelhante de `br` instrução, mas ele pode ser usado para sair um `try`, `filter`, ou `catch` bloquear enquanto as instruções de ramificação comum só podem ser usadas em tal um bloco para transferir o controle dentro do -lo. O `leave` instrução esvazia a pilha de avaliação e garante que o valor apropriado ao redor `finally` blocos são executados.  
  
 Não é possível usar um `leave` instruções para sair um `finally` bloco. Para facilitar a geração de código para os manipuladores de exceção é válido a partir de um bloco catch para usar um `leave` instrução para transferir o controle para qualquer instrução em associado `try` bloco.  
  
 Se uma instrução tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas de método podem usar o `leave` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sai de uma região protegida de código, transferindo o controle incondicionalmente para uma instrução de destino (forma abreviada).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|ALEMANHA &LT; `int8` >|Leave.s `target`|Sair de uma região protegida de código, de forma abreviada.|  
  
 Não há nenhum comportamento de transição de pilha especificado para essa instrução.  
  
 O `leave.s` instrução transfere o controle incondicionalmente para a instrução de destino transmitido, representada como uma diferença de 1 byte com sinal desde o início da instrução após a instrução atual.  
  
 O `leave.s` instrução é semelhante de `br` instrução, mas ele pode ser usado para sair um `try`, `filter`, ou `catch` bloquear enquanto as instruções de ramificação comum só podem ser usadas em tal um bloco para transferir o controle dentro do -lo. O `leave.s` instrução esvazia a pilha de avaliação e garante que o valor apropriado ao redor `finally` blocos são executados.  
  
 Não é possível usar um `leave.s` instruções para sair um `finally` bloco. Para facilitar a geração de código para os manipuladores de exceção é válido a partir de um bloco catch para usar um `leave.s` instrução para transferir o controle para qualquer instrução em associado `try` bloco.  
  
 Se uma instrução tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `leave.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aloca um determinado número de bytes do pool de memória dinâmica local e envia o endereço (um ponteiro transitório, tipo <see langword="*" />) do primeiro byte alocado à pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 0F|localloc|Alocar espaço de heap local.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O número de bytes a ser alocada é enviado para a pilha.  
  
2.  O número de bytes é aparecido da pilha; uma quantidade de correspondente ao tamanho de memória é alocada da heap local.  
  
3.  Um ponteiro para o primeiro byte da memória alocada será enviado para a pilha.  
  
 O `localloc` instrução aloca `size` (tipo `natural unsigned int`) pool de bytes de memória dinâmica local e retorna o endereço (um ponteiro transitório, tipo `*`) do primeiro byte alocado. O bloco de memória retornada será inicializada como 0 somente se o sinalizador de inicialização no método é `true`. Quando o método atual é executado um <xref:System.Reflection.Emit.OpCodes.Ret>, o pool de memória local é disponibilizado para reutilização.  
  
 O endereço resultante é alinhado para que qualquer tipo de dados primitivos pode ser armazenado lá usando o `stind` instruções (como <xref:System.Reflection.Emit.OpCodes.Stind_I4>) e carregados usando o `ldind` instruções (como <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).  
  
 O `localloc` instrução não pode ocorrer dentro de um `filter`, `catch`, `finally`, ou `fault` bloco.  
  
 <xref:System.StackOverflowException> será gerada se não houver memória suficiente para atender à solicitação.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `localloc` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia uma referência tipada a uma instância de um tipo específico para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|C6 < `T` >|Mkrefany `class`|Envia uma referência tipada do tipo `class` à pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um ponteiro para parte dos dados é enviado para a pilha.  
  
2.  O ponteiro é aparecido e convertido em uma referência de tipo do tipo `class`.  
  
3.  A referência de tipo é enviada para a pilha.  
  
 O `mkrefany` instrução fornece suporte à passagem de referências de tipadas dinâmico. O ponteiro deve ser do tipo `&`, `*`, ou `native int`, mantenha o endereço válido de uma parte dos dados. `Class` o token de classe que descreve o tipo de dados referenciados pelo ponteiro. `Mkrefany` envia uma referência tipada na pilha, fornecendo um descritor de opaco do ponteiro e o tipo `class`.  
  
 A operação válida apenas permitida após uma referência tipada é passá-lo para um método que requer uma referência tipada como um parâmetro. O receptor pode usar o <xref:System.Reflection.Emit.OpCodes.Refanytype> e <xref:System.Reflection.Emit.OpCodes.Refanyval> instruções para recuperar o tipo (classe) e o endereço, respectivamente.  
  
 <xref:System.TypeLoadException> será gerada se `class` não pode ser encontrado. Normalmente, isso é detectado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo em vez de em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `mkrefany` opcode:  
  
-   ILGenerator.Emit (OpCode, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Multiplica dois valores e efetua o push do resultado na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|5A|mul|Multiplica dois valores na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; `value1` é multiplicado pelo `value2`.  
  
4.  O resultado é enviado para a pilha.  
  
 O `mul` instrução multiplica `value1` por `value2` e envia o resultado na pilha. Operações de inteiros truncam silenciosamente os bits superiores no estouro.  
  
 Consulte <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> para um número inteiro específico multiplicar a operação com a manipulação de estouro.  
  
 Para tipos de ponto flutuantes, 0 * infinito = NaN.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `mul` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Multiplica dois valores inteiros, executa uma verificação de estouro e envia por push o resultado na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|D8|mul.OVF|Multiplica dois valores inteiros na pilha com uma verificação de estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; `value1` é multiplicado pelo `value2`, com uma verificação de estouro.  
  
4.  O resultado é enviado para a pilha.  
  
 O `mul.ovf` instrução multiplica o número inteiro `value1` por inteiro `value2` e envia o resultado na pilha. Uma exceção é lançada se o resultado não cabem no tipo de resultado.  
  
 <xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `mul.ovf` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Multiplica dois valores de inteiro sem sinal, executa uma verificação de estouro e efetua o push do resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|D9|mul.ovf.un|Multiplica dois valores sem sinal na pilha com uma verificação de estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; `value1` é multiplicado pelo `value2`, com uma verificação de estouro.  
  
4.  O resultado é enviado para a pilha.  
  
 O `mul.ovf.un` instrução multiplica o inteiro sem sinal `value1` por inteiro sem sinal `value2` e envia o resultado na pilha. Uma exceção é lançada se o resultado não cabem no tipo de resultado.  
  
 <xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `mul.ovf.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Nega um valor e efetua o push do resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|65|Neg|Nega o valor atualmente no topo da pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um valor é enviado para a pilha.  
  
2.  Um valor é aparecido da pilha e negado.  
  
3.  O resultado é enviado para a pilha.  
  
 O `neg` nega o valor de instrução e envia o resultado no topo da pilha. O tipo de retorno é o mesmo que o tipo de operando.  
  
 Negação de valores integrais é o padrão do complemento de dois negação. Em particular, eliminando o número mais negativo (que não tem um equivalente positivo) produz o número mais negativo. Para detectar esse uso de estouro de <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> instrução em vez disso (ou seja, subtrair de 0).  
  
 Negando a um número de ponto flutuante não será possível estourar e negando NaN retorna NaN.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `neg` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia por push uma referência de objeto para uma nova matriz unidimensional baseada em zero, cujos elementos são de um tipo específico na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|8D < `T` >|newarr `etype`|Cria uma nova matriz com elementos do tipo `etype`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O número de elementos na matriz é enviado para a pilha.  
  
2.  O número de elementos é aparecido da pilha e a matriz é criada.  
  
3.  Uma referência de objeto para a nova matriz é enviada para a pilha.  
  
 O `newarr` instrução envia por push uma referência de objeto (tipo `O`) para uma nova matriz unidimensional, com base em zero cujos elementos são do tipo `etype` (um token de metadados que descreve o tipo). O número de elementos na nova matriz deve ser especificado como um `native int`. Intervalo de índices de matriz válida do zero para o número máximo de elementos, menos um.  
  
 Os elementos de uma matriz podem ser qualquer tipo, incluindo tipos de valor.  
  
 Matrizes unidimensionais, com base em zero de números são criados usando um token de metadados, fazendo referência ao tipo de valor apropriado (<xref:System.Int32>e assim por diante). Elementos da matriz serão inicializados como 0 do tipo apropriado.  
  
 Matrizes unidimensionais NonZero-com base e matrizes multidimensionais são criadas usando <xref:System.Reflection.Emit.OpCodes.Newobj> em vez de `newarr`. Normalmente, eles são criados usando os métodos do <xref:System.Array> classe no .NET Framework.  
  
 <xref:System.OutOfMemoryException> será gerada se não houver memória suficiente para atender à solicitação.  
  
 <xref:System.OverflowException> será gerada se `numElems` é menor que 0.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `newarr` opcode:  
  
-   ILGenerator.Emit (OpCode, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cria um novo objeto ou uma nova instância de um tipo de valor, enviando por push uma referência de objeto (tipo <see langword="O" />) para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|73 < `T` >|newobj `ctor`|Aloca um tipo de valor ou objeto não inicializado e chama o método de construtor `ctor`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Argumentos `arg1` por meio de `argn` são empurrados na pilha na sequência.  
  
2.  Argumentos `argn` por meio `arg1` são removidos da pilha e passadas para `ctor` para a criação do objeto.  
  
3.  Uma referência ao novo objeto é inserida na pilha.  
  
 O `newobj` instrução cria um novo objeto ou uma nova instância de um tipo de valor. `Ctor` é um token de metadados (um `methodref` ou `methoddef` que deve ser marcada como um construtor) que indica o nome, a classe e a assinatura do construtor para chamar.  
  
 O `newobj` instrução aloca uma nova instância da classe associada `ctor` e inicializa todos os campos na nova instância como 0 (do tipo adequado) ou referências nulas conforme apropriado. Depois, ele chama o construtor `ctor` com os argumentos fornecidos, juntamente com a instância recém-criada. Depois que o construtor for chamado, o agora inicializadas de referência de objeto (tipo `O`) é enviado por push na pilha.  
  
 Do ponto de vista do construtor, o objeto não inicializado é o argumento de 0 e os outros argumentos passados para newobj seguem na ordem.  
  
 Todas as matrizes unidimensionais, com base em zero são criadas usando <xref:System.Reflection.Emit.OpCodes.Newarr>, e não `newobj`. Por outro lado, todas as outras matrizes (mais de uma dimensão, ou unidimensional, mas não em zero) são criadas usando `newobj`.  
  
 Tipos de valor não são geralmente criados usando `newobj`. Normalmente, eles são alocados como argumentos ou variáveis locais, usando `newarr` (para matrizes unidimensionais, com base em zero), ou como campos de objetos. Uma vez alocado, eles são inicializados usando <xref:System.Reflection.Emit.OpCodes.Initobj>. No entanto, o `newobj` instrução pode ser usada para criar uma nova instância de um tipo de valor na pilha, que, em seguida, pode ser passada como um argumento, armazenado em um local e assim por diante.  
  
 <xref:System.OutOfMemoryException> será gerada se não houver memória suficiente para atender à solicitação.  
  
 <xref:System.MissingMethodException> será gerada se um método construtor `ctor` com o nome indicado, classe e a assinatura não pôde ser encontrados. Normalmente, isso é detectado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo, em vez de em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `newobj` opcode:  
  
-   ILGenerator.Emit (OpCode, ConstructorInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Preencherá o espaço se os opcodes forem corrigidos. Nenhuma operação significativa será executada, embora um ciclo de processamento possa ser consumido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|00|Nop|Executa uma operação sem comportamento.|  
  
 Não há nenhum comportamento de transição de pilha definido para essa instrução.  
  
 O `nop` operação não fará nada. Ele destina-se para preencher o espaço se opcodes forem corrigidos.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `nop` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Calcula o complemento bit a bit do valor de inteiro na parte superior da pilha e efetua o push o resultado para a pilha de avaliação como o mesmo tipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|66|not|Calcula o complemento bit a bit de um valor.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value` é enviado para a pilha.  
  
2.  `value` é aparecido da pilha e o bit a bit complemento computado.  
  
3.  O resultado é enviado para a pilha.  
  
 O `not` instrução calcula o complemento bit a bit de um valor inteiro e envia o resultado para a pilha. O tipo de retorno é o mesmo que o tipo de operando.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `not` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Computa o complemento bit a bit dos dois valores de inteiro na parte superior da pilha e efetua o push do resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|60|ou|Calcula o bit a bit ou de dois valores de inteiro, retorna um inteiro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha e seu OR bit a bit computado.  
  
4.  O resultado é enviado para a pilha.  
  
 O `or` instrução calcula o OR bit a bit de dois valores sobre a pilha, enviar por push o resultado para a pilha.  
  
 `Or` é uma operação de inteiro específico.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `or` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Remove o valor atualmente no topo da pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|26|pop|Exibe o valor superior da pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Valor superior é aparecido da pilha.  
  
 O `pop` instrução remove o elemento superior da pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `pop` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esta é uma instrução reservada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esta é uma instrução reservada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esta é uma instrução reservada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esta é uma instrução reservada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esta é uma instrução reservada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esta é uma instrução reservada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esta é uma instrução reservada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esta é uma instrução reservada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que a operação de endereço da matriz subsequente não executa nenhuma verificação de tipo no tempo de execução e que ela retorna um ponteiro gerenciado cuja mutabilidade é restrita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista a instrução hexadecimal e formato do assembly Microsoft intermediate language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 1E|somente leitura.|Especifique que a operação de endereço da matriz subsequente não executará nenhuma verificação de tipo em tempo de execução e que ele retorna um ponteiro gerenciado com Mutabilidade restrita.|  
  
 Esse prefixo só pode aparecer imediatamente anterior a `ldelema` instrução e chamadas para especiais `Address` método nas matrizes. Seu efeito sobre a operação subsequente é dupla:  
  
1.  Em tempo de execução, nenhuma operação de verificação de tipo é executada. Observe que, normalmente, há uma verificação de tipo implícito para o `ldelema` e `stelem` matrizes de tipo de instruções quando usado na referência. Nunca há uma verificação de tipo de tempo de execução para classes de valor, portanto, `readonly` nesse caso, será não operacional.  
  
2.  O verificador trata o resultado da operação de endereço como um ponteiro gerenciado com Mutabilidade restrita.  
  
 O ponteiro deve ter restringido Mutabilidade porque a definição de tipo controla se o valor pode ser modificado. Para classes de valor que não expõem nenhum campos públicos ou métodos que atualizam o valor em vigor, o ponteiro é somente leitura (portanto, o nome do prefixo). Em particular, as classes que representam tipos primitivos (por exemplo, System.Int32) não expõem modificadores e, portanto, são somente leitura.  
  
 Um ponteiro gerenciado restringido dessa maneira pode ser usado apenas das seguintes maneiras:  
  
-   Como o `object` parâmetro para o `ldfld`, `ldflda`, `stfld`, `call`, ou`constrained callvirt` instruções.  
  
-   Como o `pointer` parâmetro para o `ldobj` instrução ou a um do `ldind` instruções.  
  
-   Como o `source` parâmetro para o `cpobj` instrução.  
  
 Todas as outras operações não permitidas, incluindo o `stobj`, `initobj`, ou `mkrefany` operações ou qualquer um do `stind` instruções.  
  
 A finalidade de `readonly` prefixo é para evitar uma verificação de tipo ao buscar um elemento de uma matriz em código genérico. Por exemplo, a expressão `arr[i].m()`, em que o tipo de elemento da matriz `arr` é um tipo genérico que foi restrita a ter uma interface com o método `m`, pode compilar a seguir MSIL.  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 Sem o `readonly` prefixo, o `ldelema` instrução deve executar uma verificação de tipo no caso no qual! 0 foi um tipo de referência. Não só é essa verificação de tipo ineficiente, mas ele é semanticamente incorreto. A verificação de tipo para `ldelema` é uma correspondência exata, que é muito forte. Se a matriz mantido subclasses do tipo! 0, o código acima poderia falhar a verificação de tipo.  
  
 O endereço do elemento da matriz é buscado, em vez do elemento em si, para ter um identificador para o `arr[i]` que funciona para ambos os tipos de valor e tipos de referência e, portanto, pode ser passada para o `constrained callvirt` instrução.  
  
 Em geral, seria não é seguro ignorar a verificação de tempo de execução se a matriz mantidos elementos de um tipo de referência. Para estar seguro, é necessário garantir que nenhuma modificação na matriz é feitas por este ponteiro. As regras do verificador garantem isso. O ponteiro gerenciado restrito pode ser passado como o objeto de chamadas de método de instância, portanto, não é estritamente falando somente leitura para tipos de valor, mas não há nenhum problema de segurança de tipo para tipos de valor.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `readonly` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera o token de tipo inserido em uma referência tipada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 1D|refanytype|Envia o token do tipo armazenado em uma referência tipada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de tipo de valor é enviada para a pilha.  
  
2.  A referência de tipo é Aparecida da pilha e recuperar seu token de tipo correspondente.  
  
3.  O token de tipo é enviado para a pilha.  
  
 Uma referência tipada contém um token de tipo e um endereço para uma instância do objeto.  
  
 O `refanytype` instrução recupera o token de tipo inserido na referência tipada. Consulte o <xref:System.Reflection.Emit.OpCodes.Mkrefany> digitado de instrução para obter informações sobre a criação de referências.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `refanytype` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera o endereço (tipo <see langword="&amp;" />) inserido em uma referência tipada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|C2 < `T` >|refanyval `type`|Envia o endereço armazenado em uma referência tipada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de tipo de valor é enviada para a pilha.  
  
2.  A referência de tipo é Aparecida da pilha e o endereço correspondente recuperado.  
  
3.  O endereço é enviado para a pilha.  
  
 Uma referência tipada contém um token de tipo e um endereço para uma instância do objeto.  
  
 O `refanyval` instrução recupera o endereço inserido na uma referência tipada. O tipo inserido na referência do tipo fornecida na pilha deve corresponder ao tipo especificado pelo `type` (token de metadados, ou uma `typedef` ou um `typeref`). Consulte o <xref:System.Reflection.Emit.OpCodes.Mkrefany> a instrução para o conteúdo relacionado.  
  
 <xref:System.InvalidCastException> será gerada se `type` não é idêntico ao tipo armazenado na referência de tipo (nesse caso, `type` é a classe fornecida para o <xref:System.Reflection.Emit.OpCodes.Mkrefany> instrução construído disse referência tipada).  
  
 <xref:System.TypeLoadException> será gerada se `type` não pode ser encontrado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `refanyval` opcode:  
  
-   ILGenerator.Emit (OpCode, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Divide dois valores e efetua o push do restante para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|5D|REM|Envia por push o resto da divisão `value1` por `value2` à pilha.|  
  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha e o restante `value1` `div` `value2` computado.  
  
4.  O resultado é enviado para a pilha.  
  
 `result` = `value1` `rem` `value2` satisfaz as condições a seguir:  
  
 `result` = `value1` - `value2` `×` (`value1` `div` `value2`), e:  
  
 0 = &#124; `result` &#124; < &#124; `value2` &#124;, entrada (`result`) = logon (`value1`), onde `div` é a instrução de divisão que trunca em direção a zero.  
  
 Se `value2` for zero ou `value1` é infinito, o resultado é NaN. Se `value2` é infinito, o resultado é `value1` (negada para `-infinity`).  
  
 Operações de integrais geram <xref:System.DivideByZeroException> se `value2` é zero.  
  
 Observe que, nas plataformas Intel com base em um <xref:System.OverflowException> é gerada quando a computação (minint `rem` -1).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `rem` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Divide dois valores sem sinal e efetua o push do restante para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|5E|REM.Un|Envia por push o resto da divisão sem sinal `value1` por sem sinal `value2` à pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha e o restante `value1` `div` `value2` computado.  
  
4.  O resultado é enviado para a pilha.  
  
 `result` = `value1` `rem.un` `value2` satisfaz as condições a seguir:  
  
 `result` = `value1` - `value2` x (`value1` `div.un` `value2`), e:  
  
 0 = `result`  <  `value2`, onde `div.un` é a instrução de divisão sem sinal.  
  
 O `rem.un` calcula a instrução `result` e envia por push na pilha. `Rem.un` trata os seus argumentos como inteiros sem sinal, enquanto <xref:System.Reflection.Emit.OpCodes.Rem> trata-os inteiros com sinal como.  
  
 `Rem.un` não é especificado para números de ponto flutuante.  
  
 Operações de integrais geram <xref:System.DivideByZeroException> se `value2` é zero.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `rem.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retorna do método atual, enviando um valor retornado (se houver) da pilha de avaliação do computador chamado para a pilha de avaliação do chamador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|2A|RET|Retorna um método, possivelmente, retornando um valor.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor de retorno é aparecido da pilha de avaliação do receptor.  
  
2.  O valor de retorno obtido na etapa 1 é empurrado na pilha de avaliação do chamador.  
  
 Se o valor retornado não estiver presente na pilha de avaliação do receptor, nenhum valor é retornado (não há comportamentos de transição de pilha para o chamador ou receptor da chamada de método).  
  
 O tipo do valor de retorno, se houver, do método atual determina o tipo de valor a ser obtido da parte superior da pilha e copiado para a pilha do método que chamou o método atual. A pilha de avaliação para o método atual deve estar vazia, exceto para o valor a ser retornado.  
  
 O `ret` instrução não pode ser usada para transferir o controle de um`try`, `filter`, `catch`, ou `finally` bloco. De dentro uma `try` ou `catch`, use o <xref:System.Reflection.Emit.OpCodes.Leave> instrução com um destino de um `ret` instrução que está fora de todos os blocos de exceção. Porque o `filter` e `finally` blocos logicamente são parte da manipulação de exceção e não o método em que seu código é inserido, instruções de linguagem intermediária da Microsoft (MSIL) gerada corretamente não executam um método de retorno de dentro de um `filter` ou `finally`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ret` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gera novamente a exceção atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 1A|Relançar|Relança a exceção atual|  
  
 Nenhum comportamento de transição de pilha é definido para essa instrução.  
  
 O `rethrow` instrução só é permitida dentro do corpo de um `catch` manipulador. Ele gera a mesma exceção foi capturada por este manipulador.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `rethrow` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Desloca um valor de inteiro para a esquerda (em zeros) por um número especificado de bits, efetuando o push do resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|62|Shl|Desloca um número inteiro para a esquerda (mudando sua zeros).|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um valor é enviado para a pilha.  
  
2.  A quantidade de bits a ser deslocado é enviada para a pilha.  
  
3.  O número de bits a ser deslocado e o valor são removidos da pilha; o valor é deslocados para a esquerda pelo número especificado de bits.  
  
4.  O resultado é enviado para a pilha.  
  
 O `shl` instrução desloca o valor (tipo `int32`, `int64` ou `native int`) à esquerda pelo número especificado de bits. O número de bits é um valor do tipo `int32` ou `native int`. O valor de retorno é especificado, se o número de bits de deslocamento é maior que ou igual à largura (em bits) do valor fornecido.  
  
 `Shl` Insere um bit zero na última posição inferior em cada turno.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `shl` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Desloca um valor de inteiro (no logon) para a direita em um número especificado de bits, efetuando o push do resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|63|SHR|Desloca um número inteiro para a direita (mudando sua entrada).|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um valor é enviado para a pilha.  
  
2.  A quantidade de bits a ser deslocado é enviada para a pilha.  
  
3.  O número de bits a ser deslocado e o valor são removidos da pilha; o valor é deslocado à direita pelo número especificado de bits.  
  
4.  O resultado é enviado para a pilha.  
  
 O `shr.un` instrução desloca o valor (tipo `int32`, `int64` ou `native int`) à direita pelo número especificado de bits. O número de bits é um valor do tipo `int32` ou `native int`. O valor de retorno é especificado, se o número de bits de deslocamento é maior que ou igual à largura (em bits) do valor fornecido.  
  
 `Shr` replica a ordem de alta bit em cada turno, preservando o sinal do valor original na `result`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `shr` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Desloca um valor inteiro sem sinal (em zeros) para a direita em um número especificado de bits, efetuando o push do resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|64|SHR.Un|Desloca um número inteiro para a direita (mudando em zeros).|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um valor é enviado para a pilha.  
  
2.  A quantidade de bits a ser deslocado é enviada para a pilha.  
  
3.  O número de bits a ser deslocado e o valor são removidos da pilha; o valor é deslocado à direita pelo número especificado de bits.  
  
4.  O resultado é enviado para a pilha.  
  
 O `shr.un` instrução desloca o valor (tipo `int32`, `int64` ou `native int`) à direita pelo número especificado de bits. O número de bits é um valor do tipo `int32`, `int64` ou `native int`. O valor de retorno é especificado, se o número de bits de deslocamento é maior que ou igual à largura (em bits) do valor fornecido.  
  
 `Shr.un` Insere um bit zero em posição mais elevada em cada turno.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `shr.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia o tamanho, em bytes, de um tipo de valor fornecido para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 1C &LT; `T` >|sizeof `valType`|Enviar por push o tamanho, em bytes, de um tipo de valor como um `unsigned int32`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O tamanho (em bytes) do tipo de valor fornecido (`valType`) é enviado para a pilha.  
  
 `valType` deve ser um token de metadados (um `typeref` ou `typedef`) que especifica um tipo de valor, o tipo de referência ou o parâmetro de tipo genérico.  
  
 Para um tipo de referência, o tamanho retornado é o tamanho de um valor de referência do tipo (4 bytes em sistemas de 32 bits), não o tamanho dos dados armazenados em objetos referenciados pelo valor de referência. Um parâmetro de tipo genérico pode ser usado somente no corpo do tipo ou método que o define. Quando esse tipo ou método é instanciado, o parâmetro de tipo genérico é substituído por um tipo de valor ou tipo de referência.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `sizeof` opcode:  
  
-   ILGenerator.Emit (OpCode, tipo)  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Armazena o valor localizado no topo da pilha de avaliação no slot de argumento em um índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 0B &LT; `unsigned int16` >|StarG `num`|Exibe o valor superior da pilha e armazena-o no slot de argumento `num`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor atualmente no topo da pilha é exibido e colocado no slot de argumento `num`.  
  
 O `starg` instrução retira um valor da pilha e a coloca no slot de argumento `num`. O tipo do valor deve corresponder ao tipo do argumento, conforme especificado na assinatura do método atual.  
  
 Para obter os procedimentos que usam uma lista de argumentos de variável, o `starg` instrução pode ser usada apenas para inicial fixo de argumentos, não os na variável parte da assinatura.  
  
 Execução de um repositório em argumentos que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme se move da pilha para o argumento. Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo `F`) para o tamanho associado com o argumento.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `starg` opcode:  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Armazena o valor localizado no topo da pilha de avaliação no slot de argumento em um índice especificado, de forma abreviada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|10 < `unsigned int8` >|StarG.s `num`|Exibe o valor superior da pilha e armazena-o no slot de argumento `num`, forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor atualmente no topo da pilha é exibido e colocado no slot de argumento `num`.  
  
 O `starg.s` instrução retira um valor da pilha e a coloca no slot de argumento `num`. O tipo do valor deve corresponder ao tipo do argumento, conforme especificado na assinatura do método atual.  
  
 O `starg.s` instrução fornece uma codificação eficiente para uso com os 256 primeiros argumentos.  
  
 Para obter os procedimentos que usam uma lista de argumentos de variável, o `starg.s` instrução pode ser usada apenas para inicial fixo de argumentos, não os na variável parte da assinatura.  
  
 Execução de um repositório em argumentos que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme se move da pilha para o argumento. Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo `F`) para o tamanho associado com o argumento.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `starg.s` opcode:  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Substitui o elemento de matriz de um índice especificado pelo valor na pilha de avaliação, cujo tipo é especificado na instrução.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista a instrução hexadecimal e formato do assembly Microsoft intermediate language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|A4 < `T` >|Stelem `typeTok`|Substitui o elemento de matriz no índice fornecido com um valor do tipo `typeTok` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto para uma matriz, `array`, é enviado para a pilha.  
  
2.  Um valor de índice `index`, para um elemento em `array` é enviado para a pilha.  
  
3.  Um valor do tipo especificado na instrução é enviada por push à pilha.  
  
4.  O valor, o índice e a referência de matriz são removidos da pilha; o valor é colocado no elemento da matriz no índice especificado.  
  
 O `stelem` instrução substitui o valor do elemento no índice fornecido com base em zero na matriz unidimensional `array` com o valor. O valor tem o tipo especificado pelo token `typeTok` na instrução.  
  
 Matrizes são objetos e, portanto, é representado por um valor do tipo `O`. O índice é tipo `native int`.  
  
 <xref:System.NullReferenceException> será gerada se `array` é uma referência nula.  
  
 <xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.  
  
 <xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stelem` opcode:  
  
-   ILGenerator.Emit (OpCode, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Substitui o elemento de matriz em um determinado índice pelo valor <see langword="native int" /> na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|9B|stelem.i|Substitui um elemento de matriz no índice fornecido com o `native int` valor na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto para uma matriz, `array`, é enviado para a pilha.  
  
2.  Um índice válido para um elemento em `array` é enviado para a pilha.  
  
3.  Um valor é enviado para a pilha.  
  
4.  O valor, o índice e a referência de matriz são removidos da pilha; o valor é colocado no elemento da matriz no índice especificado.  
  
 O `stelem.i` instrução substitui o valor do elemento `index` na matriz unidimensional `array` com o `native int` valor inserido na pilha.  
  
 Matrizes são objetos e, portanto, é representado por um valor do tipo `O`. O índice é tipo `native int`.  
  
 <xref:System.NullReferenceException> será gerada se `array` é uma referência nula.  
  
 <xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.  
  
 <xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stelem.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Substitui o elemento de matriz em um determinado índice pelo valor <see langword="int8" /> na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|9C|stelem.i1|Substitui um elemento de matriz no índice fornecido com o `int8` valor na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto para uma matriz, `array`, é enviado para a pilha.  
  
2.  Um índice válido para um elemento em `array` é enviado para a pilha.  
  
3.  Um valor é enviado para a pilha.  
  
4.  O valor, o índice e a referência de matriz são removidos da pilha; o valor é colocado no elemento da matriz no índice especificado.  
  
 O `stelem.i1` instrução substitui o valor do elemento `index` na matriz unidimensional `array` com o `int8` valor inserido na pilha.  
  
 Matrizes são objetos e, portanto, é representado por um valor do tipo `O`. O índice é tipo `native int`.  
  
 <xref:System.NullReferenceException> será gerada se `array` é uma referência nula.  
  
 <xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.  
  
 <xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stelem.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Substitui o elemento de matriz em um determinado índice pelo valor <see langword="int16" /> na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|9D|stelem.i2|Substitui um elemento de matriz no índice fornecido com o `int16` valor na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto para uma matriz, `array`, é enviado para a pilha.  
  
2.  Um índice válido para um elemento em `array` é enviado para a pilha.  
  
3.  Um valor é enviado para a pilha.  
  
4.  O valor, o índice e a referência de matriz são removidos da pilha; o valor é colocado no elemento da matriz no índice especificado.  
  
 O `stelem.i2` instrução substitui o valor do elemento `index` na matriz unidimensional `array` com o `int16` valor inserido na pilha.  
  
 Matrizes são objetos e, portanto, é representado por um valor do tipo `O`. O índice é tipo `native int`.  
  
 <xref:System.NullReferenceException> será gerada se `array` é uma referência nula.  
  
 <xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.  
  
 <xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stelem.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Substitui o elemento de matriz em um determinado índice pelo valor <see langword="int32" /> na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|9E|stelem.i4|Substitui um elemento de matriz no índice fornecido com o `int32` valor na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto para uma matriz, `array`, é enviado para a pilha.  
  
2.  Um índice válido para um elemento em `array` é enviado para a pilha.  
  
3.  Um valor é enviado para a pilha.  
  
4.  O valor, o índice e a referência de matriz são removidos da pilha; o valor é colocado no elemento da matriz no índice especificado.  
  
 O `stelem.i4` instrução substitui o valor do elemento `index` na matriz unidimensional `array` com o `int32` valor inserido na pilha.  
  
 Matrizes são objetos e, portanto, é representado por um valor do tipo `O`. O índice é tipo `native int`.  
  
 <xref:System.NullReferenceException> será gerada se `array` é uma referência nula.  
  
 <xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.  
  
 <xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stelem.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Substitui o elemento de matriz em um determinado índice pelo valor <see langword="int64" /> na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|9F|stelem.i8|Substitui um elemento de matriz no índice fornecido com o `int64` valor na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto para uma matriz, `array`, é enviado para a pilha.  
  
2.  Um índice válido para um elemento em `array` é enviado para a pilha.  
  
3.  Um valor é enviado para a pilha.  
  
4.  O valor, o índice e a referência de matriz são removidos da pilha; o valor é colocado no elemento da matriz no índice especificado.  
  
 O `stelem.i8` instrução substitui o valor do elemento `index` na matriz unidimensional `array` com o `int64` valor inserido na pilha.  
  
 Matrizes são objetos e, portanto, é representado por um valor do tipo `O`. O índice é tipo `native int`.  
  
 <xref:System.NullReferenceException> será gerada se `array` é uma referência nula.  
  
 <xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.  
  
 <xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stelem.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Substitui o elemento de matriz em um determinado índice pelo valor <see langword="float32" /> na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|A0|stelem.r4|Substitui um elemento de matriz no índice fornecido com o `float32` valor na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto para uma matriz, `array`, é enviado para a pilha.  
  
2.  Um índice válido para um elemento em `array` é enviado para a pilha.  
  
3.  Um valor é enviado para a pilha.  
  
4.  O valor, o índice e a referência de matriz são removidos da pilha; o valor é colocado no elemento da matriz no índice especificado.  
  
 O `stelem.r4` instrução substitui o valor do elemento `index` na matriz unidimensional `array` com o `float32` valor inserido na pilha.  
  
 Matrizes são objetos e, portanto, é representado por um valor do tipo `O`. O índice é tipo `native int`.  
  
 <xref:System.NullReferenceException> será gerada se `array` é uma referência nula.  
  
 <xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.  
  
 <xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stelem.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Substitui o elemento de matriz em um determinado índice pelo valor <see langword="float64" /> na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|A1|Stelem.R8|Substitui um elemento de matriz no índice fornecido com o `float64` valor na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto para uma matriz, `array`, é enviado para a pilha.  
  
2.  Um índice válido para um elemento em `array` é enviado para a pilha.  
  
3.  Um valor é enviado para a pilha.  
  
4.  O valor, o índice e a referência de matriz são removidos da pilha; o valor é colocado no elemento da matriz no índice especificado.  
  
 O `stelem.r8` instrução substitui o valor do elemento `index` na matriz unidimensional `array` com o `float64` valor inserido na pilha.  
  
 Matrizes são objetos e, portanto, é representado por um valor do tipo `O`. O índice é tipo `native int`.  
  
 <xref:System.NullReferenceException> será gerada se `array` é uma referência nula.  
  
 <xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.  
  
 <xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stelem.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Substitui o elemento da matriz de um determinado índice com o valor de referência de objeto (tipo <see langword="O" />) na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|A2|stelem.ref|Substitui um elemento de matriz no índice fornecido com o `ref` valor (tipo `O`) na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto para uma matriz, `array`, é enviado para a pilha.  
  
2.  Um índice válido para um elemento em `array` é enviado para a pilha.  
  
3.  Um valor é enviado para a pilha.  
  
4.  O valor, o índice e a referência de matriz são removidos da pilha; o valor é colocado no elemento da matriz no índice especificado.  
  
 O `stelem.ref` instrução substitui o valor do elemento no índice fornecido na matriz unidimensional `array` com o `ref` (tipo `O`) valor inserido na pilha.  
  
 Matrizes são objetos e, portanto, é representado por um valor do tipo `O`. O índice é tipo `native int`.  
  
 Observe que `stelem.ref` converte implicitamente o valor fornecido para o tipo de elemento `array` antes de atribuir o valor para o elemento da matriz. Essa conversão pode falhar, mesmo para o código verificado. Portanto, o `stelem.ref` instrução pode lançar <xref:System.InvalidCastException>. Para matrizes unidimensionais que não são com base em zero em matrizes multidimensionais, o <xref:System.Array> classe fornece um <xref:System.Array.SetValue%2A> método.  
  
 <xref:System.NullReferenceException> será gerada se `array` é uma referência nula.  
  
 <xref:System.IndexOutOfRangeException> será gerada se `index` é negativo ou maior que o limite da `array`.  
  
 <xref:System.ArrayTypeMismatchException> será gerada se `array` não mantém elementos do tipo necessário.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stelem.ref` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Substitui o valor armazenado no campo de uma referência de objeto ou de um ponteiro por um novo valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|7D < `T` >|stfld `field`|Substitui o valor de `field` do objeto com um novo valor.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto ou um ponteiro é enviado para a pilha.  
  
2.  Um valor é enviado para a pilha.  
  
3.  O valor e o ponteiro/referência de objeto são removidos da pilha; o valor de `field` no objeto é substituído com o valor fornecido.  
  
 O `stfld` instrução substitui o valor de um campo de um objeto (tipo `O`) ou por meio de um ponteiro (tipo `native int`, `&`, ou `*`) com um valor fornecido. `Field` é um token de metadados que se refere a um campo de referência de membro. O `stfld` instrução pode ter um prefixo de um ou ambos <xref:System.Reflection.Emit.OpCodes.Unaligned> e <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.NullReferenceException> será gerada se o ponteiro ou referência de objeto é uma referência nula e o campo não é estático.  
  
 <xref:System.MissingFieldException> será gerada se `field` não for encontrado nos metadados. Normalmente, isso é verificado quando a instrução de Microsoft Intermediate Language (MSIL) é convertida em código nativo, não em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stfld` opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Armazena um valor do tipo <see langword="native int" /> em um endereço fornecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|DF|stind.i|Armazena um `native int` valor em um determinado endereço.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço será enviado para a pilha.  
  
2.  Um valor é enviado para a pilha.  
  
3.  O valor e o endereço são removidos da pilha; o valor é armazenado no endereço.  
  
 O `stind.i` instrução armazena uma `native int` valor no endereço fornecido (tipo `native int`, `*`, ou `&`).  
  
 Tipo de operação segura requer que o `stind.i` instrução a ser usado de maneira consistente com o tipo do ponteiro. A operação do `stind.i` instrução pode ser alterada por um imediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instrução de prefixo.  
  
 <xref:System.NullReferenceException> será gerada se `addr` não são alinhados naturalmente para o tipo de argumento implicado, o sufixo de instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stind.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Armazena um valor do tipo <see langword="int8" /> em um endereço fornecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|52|stind.I1|Armazena um `int8` valor em um determinado endereço.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço será enviado para a pilha.  
  
2.  Um valor é enviado para a pilha.  
  
3.  O valor e o endereço são removidos da pilha; o valor é armazenado no endereço.  
  
 O `stind.i1` instrução armazena uma `int8` valor no endereço fornecido (tipo `native int`, `*`, ou `&`).  
  
 Tipo de operação segura requer que o `stind.i1` instrução a ser usado de maneira consistente com o tipo do ponteiro. A operação do `stind.i1` instrução pode ser alterada por um imediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instrução de prefixo.  
  
 <xref:System.NullReferenceException> será gerada se `addr` não são alinhados naturalmente para o tipo de argumento implicado, o sufixo de instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stind.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Armazena um valor do tipo <see langword="int16" /> em um endereço fornecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|53|stind.I2|Armazena um `int16` valor em um determinado endereço.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço será enviado para a pilha.  
  
2.  Um valor é enviado para a pilha.  
  
3.  O valor e o endereço são removidos da pilha; o valor é armazenado no endereço.  
  
 O `stind.i2` instrução armazena uma `int16` valor no endereço fornecido (tipo `native int`, `*`, ou `&`).  
  
 Tipo de operação segura requer que o `stind.2i` instrução a ser usado de maneira consistente com o tipo do ponteiro. A operação do `stind.i2` instrução pode ser alterada por um imediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instrução de prefixo.  
  
 <xref:System.NullReferenceException> será gerada se `addr` não são alinhados naturalmente para o tipo de argumento implicado, o sufixo de instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stind.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Armazena um valor do tipo <see langword="int32" /> em um endereço fornecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|54|stind.i4|Armazena um `int32` valor em um determinado endereço.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço será enviado para a pilha.  
  
2.  Um valor é enviado para a pilha.  
  
3.  O valor e o endereço são removidos da pilha; o valor é armazenado no endereço.  
  
 O `stind.i4` instrução armazena uma `int32` valor no endereço fornecido (tipo `native int`, `*`, ou `&`).  
  
 Tipo de operação segura requer que o `stind.i4` instrução a ser usado de maneira consistente com o tipo do ponteiro. A operação do `stind.i4` instrução pode ser alterada por um imediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instrução de prefixo.  
  
 <xref:System.NullReferenceException> será gerada se `addr` não são alinhados naturalmente para o tipo de argumento implicado, o sufixo de instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stind.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Armazena um valor do tipo <see langword="int64" /> em um endereço fornecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|55|stind.I8|Armazena um `int64` valor em um determinado endereço.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço será enviado para a pilha.  
  
2.  Um valor é enviado para a pilha.  
  
3.  O valor e o endereço são removidos da pilha; o valor é armazenado no endereço.  
  
 O `stind.i8` instrução armazena uma `int64` valor no endereço fornecido (tipo `native int`, `*`, ou `&`).  
  
 Tipo de operação segura requer que o `stind.i8` instrução a ser usado de maneira consistente com o tipo do ponteiro. A operação do `stind.i` instrução pode ser alterada por um imediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instrução de prefixo.  
  
 <xref:System.NullReferenceException> será gerada se `addr` não são alinhados naturalmente para o tipo de argumento implicado, o sufixo de instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stind.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Armazena um valor do tipo <see langword="float32" /> em um endereço fornecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|56|stind.R4|Armazena um `float32` valor em um determinado endereço.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço será enviado para a pilha.  
  
2.  Um valor é enviado para a pilha.  
  
3.  O valor e o endereço são removidos da pilha; o valor é armazenado no endereço.  
  
 O `stind.r4` instrução armazena uma `float32` valor no endereço fornecido (tipo `native int`, `*`, ou `&`).  
  
 Tipo de operação segura requer que o `stind.r4` instrução a ser usado de maneira consistente com o tipo do ponteiro. A operação do `stind.r4` instrução pode ser alterada por um imediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instrução de prefixo.  
  
 <xref:System.NullReferenceException> será gerada se `addr` não são alinhados naturalmente para o tipo de argumento implicado, o sufixo de instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stind.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Armazena um valor do tipo <see langword="float64" /> em um endereço fornecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|57|stind.R8|Armazena um `float64` valor em um determinado endereço.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço será enviado para a pilha.  
  
2.  Um valor é enviado para a pilha.  
  
3.  O valor e o endereço são removidos da pilha; o valor é armazenado no endereço.  
  
 O `stind.r8` instrução armazena uma `float64` valor no endereço fornecido (tipo `native int`, `*`, ou `&`).  
  
 Tipo de operação segura requer que o `stind.r8` instrução a ser usado de maneira consistente com o tipo do ponteiro. A operação do `stind.r8` instrução pode ser alterada por um imediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instrução de prefixo.  
  
 <xref:System.NullReferenceException> será gerada se `addr` não são alinhados naturalmente para o tipo de argumento implicado, o sufixo de instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stind.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Armazena um valor de referência de objeto em um endereço fornecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|51|stind.ref|Armazena uma referência de objeto (tipo `O`) valor em um determinado endereço.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço será enviado para a pilha.  
  
2.  Um valor é enviado para a pilha.  
  
3.  O valor e o endereço são removidos da pilha; o valor é armazenado no endereço.  
  
 O `stind.ref` instrução armazena um valor de referência de objeto no endereço fornecido (tipo `native int`, `*`, ou `&`).  
  
 Tipo de operação segura requer que o `stind.ref` instrução a ser usado de maneira consistente com o tipo do ponteiro. A operação do `stind.ref` instrução pode ser alterada por um imediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instrução de prefixo.  
  
 <xref:System.NullReferenceException> será gerada se `addr` não são alinhados naturalmente para o tipo de argumento implicado, o sufixo de instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stind.ref` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exibe o valor atual da parte superior da pilha de avaliação e a armazena em uma lista de variáveis locais em um índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 0E &LT; `unsigned int16` >|stloc `index`|Exibe um valor da pilha e o armazena na variável local `index`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um valor é aparecido da pilha e colocado na variável local `index`.  
  
 O `stloc` instrução exibe o valor superior da pilha de avaliação e será movida para o número de variável local `index`, onde as variáveis locais são numerados de 0 em diante. O tipo do valor deve corresponder ao tipo da variável local, conforme especificado na assinatura de local do método atual.  
  
 Armazenando em locais que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme se move da pilha para a variável local. Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo `F`) para o tamanho associado com o argumento.  
  
 Instruções de Microsoft Intermediate Language (MSIL) correto exigem que `index` ser um índice de local válido. Para o `stloc` instrução de `index` deve estar no intervalo de 0 a 65534 inclusivo (especificamente, 65535 não é válido). O motivo para exceto 65535 é pragmático: implementações provavelmente usará um inteiro de 2 bytes para controlar o índice do local, bem como o número total de locais para um determinado método. Se um índice de 65535 tivesse sido feito válido, ele exigiria um inteiro maior controlar o número de locais em um método desse tipo.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas de método podem usar o `stloc` opcode:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exibe o valor atual da parte superior da pilha de avaliação e armazena em uma lista de variáveis local no índice 0.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|0A|stloc.0|Retira um valor da pilha em 0 de variável local.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um valor é aparecido da pilha e colocado na variável local indexada por 0.  
  
 O `stloc.0` instrução exibe o valor superior da pilha de avaliação e será movida para a variável local indexada por 0. O tipo do valor deve corresponder ao tipo da variável local, conforme especificado na assinatura de local do método atual.  
  
 `stloc.0` é uma codificação especialmente eficiente para armazenar valores na variável local 0.  
  
 Armazenando em locais que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme se move da pilha para a variável local. Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo `F`) para o tamanho associado com o argumento.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stloc.0` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exibe o valor atual da parte superior da pilha de avaliação e armazena em uma lista de variáveis local no índice 1.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|0B|stloc.1|Retira um valor da pilha em 1 de variável local.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um valor é aparecido da pilha e colocado na variável local indexada por 1.  
  
 O `stloc.1` instrução exibe o valor superior da pilha de avaliação e será movida para a variável local indexada por 1. O tipo do valor deve corresponder ao tipo da variável local, conforme especificado na assinatura de local do método atual.  
  
 `stloc.1` é uma codificação especialmente eficiente para armazenar valores na variável local 1.  
  
 Armazenando em locais que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme se move da pilha para a variável local. Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo `F`) para o tamanho associado com o argumento.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stloc.1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exibe o valor atual da parte superior da pilha de avaliação e armazena-o em uma lista de variáveis local no índice 2.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|0C|stloc.2|Exibe um valor da pilha para a variável local 2|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um valor é aparecido da pilha e colocado na variável local indexada por 2.  
  
 O `stloc.2` instrução exibe o valor superior da pilha de avaliação e será movida para a variável local indexada por 2. O tipo do valor deve corresponder ao tipo da variável local, conforme especificado na assinatura de local do método atual.  
  
 `stloc.2` é uma codificação especialmente eficiente para armazenar valores em 2 de variável local.  
  
 Armazenando em locais que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme se move da pilha para a variável local. Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo `F`) para o tamanho associado com o argumento.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stloc.2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exibe o valor atual da parte superior da pilha de avaliação e armazena-o em uma lista de variáveis local no índice 3.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|0D|stloc.3|Exibe um valor da pilha para a variável local 3|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um valor é aparecido da pilha e colocado na variável local indexada por 3.  
  
 O `stloc.3` instrução exibe o valor superior da pilha de avaliação e será movida para a variável local indexada por 3. O tipo do valor deve corresponder ao tipo da variável local, conforme especificado na assinatura de local do método atual.  
  
 `stloc.3` é uma codificação especialmente eficiente para armazenar valores em 3 de variável local.  
  
 Armazenando em locais que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme se move da pilha para a variável local. Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo `F`) para o tamanho associado com o argumento.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stloc.3` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exibe o valor atual da parte superior da pilha de avaliação e o armazena em uma lista de variáveis locais em <paramref name="index" /> (forma abreviada).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|13 < `unsigned int8` >|stloc.s `index`|Exibe um valor da pilha e o armazena na variável local `index`, forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um valor é aparecido da pilha e colocado na variável local `index`.  
  
 O `stloc.s` instrução exibe o valor superior da pilha de avaliação e será movida para o número de variável local `index`, onde as variáveis locais são numerados de 0 em diante. O tipo do valor deve corresponder ao tipo da variável local, conforme especificado na assinatura de local do método atual.  
  
 O `stloc.s` instrução fornece uma codificação eficiente para variáveis locais 0 a 255.  
  
 Armazenando em locais que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme se move da pilha para a variável local. Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo `F`) para o tamanho associado com o argumento.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas de método podem usar o `stloc.s` opcode:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Copia um valor do tipo especificado da pilha de avaliação para um endereço de memória fornecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|81 < `T` >|stobj `class`|Armazena um valor do tipo `class` da pilha na memória.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço será enviado para a pilha.  
  
2.  Um objeto do tipo de valor do tipo `class` é enviado para a pilha.  
  
3.  O objeto e o endereço são removidos da pilha; o objeto de tipo de valor é armazenado no endereço.  
  
 O `stobj` instrução copia o objeto de tipo de valor para o endereço especificado pelo endereço (um ponteiro de tipo `native int`, `*`, ou `&`). O número de bytes copiados depende do tamanho da classe representada por `class`, um token de metadados que representa um tipo de valor.  
  
 A operação do `stobj` instrução pode ser alterada por um imediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> instrução de prefixo.  
  
 <xref:System.TypeLoadException> será gerada se a classe não pode ser encontrado. Normalmente, isso é detectado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo em vez de em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stobj` opcode:  
  
-   ILGenerator.Emit (OpCode, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Substitui o valor de um campo estático por um valor da pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|80 < `T` >|stsfld `field`|Substitui o valor em `field` com um valor fornecido.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um valor é enviado para a pilha.  
  
2.  Um valor é aparecido da pilha e armazenado em `field`.  
  
 O `stsfld` instrução substitui o valor de um campo estático com um valor da pilha. `field` é um token de metadados que deve se referir a um membro de campo estático.  
  
 O `stsfld` instrução pode ser prefixada por <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.MissingFieldException> será gerada se o campo não for encontrado nos metadados. Normalmente, isso é verificado quando instruções Microsoft Intermediate Language (MSIL) são convertidos em código nativo, não em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stsfld` opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Subtrai um valor de outro e efetua o push do resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|59|sub|Subtrai um valor de outro, retornando um novo valor numérico.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; `value2` é subtraído do `value1`.  
  
4.  O resultado é enviado para a pilha.  
  
 Estouro não é detectado para operações de inteiros (para a manipulação de estouro adequada, consulte <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).  
  
 Subtração de inteiro envolve, em vez de esteja saturado. Por exemplo: supondo que os inteiros de 8 bits, onde `value1` é definido como 0 e `value2` é definido como 1, o resultado "encapsulado" será 255.  
  
 Retorna de estouro de ponto flutuante `+inf` (`PositiveInfinity`) ou `-inf` (`NegativeInfinity`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `sub` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Subtrai um valor de inteiro de outro, executa uma verificação de estouro e efetua o push do resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|ACELERADOR DE DESENVOLVIMENTO|sub.ovf|Subtrai um valor de inteiro de outro com uma verificação de estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; `value2` é subtraído de `value1` com uma verificação de estouro.  
  
4.  O resultado é enviado para a pilha.  
  
 <xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.  
  
 Esta operação é executada em inteiros com sinal; para valores de ponto flutuantes, use <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `sub.ovf` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Subtrai um valor de inteiro sem sinal de outro, executa uma verificação de estouro e efetua o push do resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|DB|sub.ovf.un|Subtrai um valor de inteiro sem sinal de outro com uma verificação de estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha; `value2` é subtraído de `value1` com uma verificação de estouro.  
  
4.  O resultado é enviado para a pilha.  
  
 <xref:System.OverflowException> será gerada se o resultado não pode ser representado no tipo de resultado.  
  
 Esta operação é executada em inteiros com sinal; para valores de ponto flutuantes, use <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `sub.ovf.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Implementa uma tabela de atalhos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|45 < `unsigned int32` >< `int32` >... < `int32` >|Alternar (`N`, `t1`, `t2`... `tN`)|Salta para uma das `N` valores.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um valor é enviado para a pilha.  
  
2.  O valor é retirado da pilha e a execução é transferida para a instrução no deslocamento indexado por valor, onde o valor é menor que `N`.  
  
 O `switch` instrução implementa uma tabela de atalhos. O formato da instrução é um `unsigned int32` que representa o número de destinos `N`, seguido por `N` saltar de valores int32 especificando destinos. Esses destinos são representados como deslocamentos (positivos ou negativos) desde o início da instrução seguindo este `switch` instrução.  
  
 O `switch` instrução retira um valor da pilha e compara-lo, como um inteiro sem sinal, como `N`. Se o valor é menor que `N`, a execução será transferida para o destino indexado por valor, em que os destinos são numerados de 0 (por exemplo, um valor de 0 usa o primeiro destino, um valor de 1 usa o destino do segundo e assim por diante). Se o valor for maior que ou igual a `N`, a execução continuará na próxima instrução (queda).  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro destes prefixos.  
  
 O controle é transferido para dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução. (Essas transferências são rigorosamente restritas e devem usar a instrução deixe em vez disso).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `switch` opcode. O `Label[]` argumento é uma matriz dos rótulos que representam deslocamentos de 32 bits.  
  
-   ILGenerator.Emit(OpCode, Label[])  
  
   
  
## Examples  
 O exemplo de código a seguir ilustra o uso do `Switch` opcode para gerar uma tabela de atalhos, usando uma matriz de <xref:System.Reflection.Emit.Label>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Executa uma instrução de chamada de método pós-fixada, de modo que o registro de ativação do método atual é removido antes da execução da instrução de chamada real.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 14|parte final.|Chamada subsequente encerra métodos atuais|  
  
 Não há nenhum comportamento de transição de pilha definido para essa instrução.  
  
 O `tail` instrução de prefixo deve preceder imediatamente um <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, ou <xref:System.Reflection.Emit.OpCodes.Callvirt> instrução. Ele indica que o quadro de pilha do método atual deve ser removido antes da instrução de chamada é executada. Isso também significa que o valor retornado da chamada a seguir também é o valor retornado pelo método atual e a chamada, portanto, pode ser convertida em um salto cruzado-method.  
  
 A pilha deve estar vazia, exceto para os argumentos que estão sendo transferidos pela chamada a seguir. A instrução após a instrução de chamada deve ser um ret. Assim é a sequência de códigos são válidas `tail. call` (ou `calli` ou `callvirt`). Instruções de Microsoft Intermediate Language (MSIL) corretas não devem fazer branch para o `call` instrução, mas eles podem ramificar para os próximos <xref:System.Reflection.Emit.OpCodes.Ret>.  
  
 O quadro atual não pode ser descartado quando o controle é transferido de código não confiável para código confiável, pois isso poderia comprometer a segurança de identidade do código. Verifica se a segurança do .NET Framework, portanto, pode fazer com que o `tail` devem ser ignorados, deixando um padrão <xref:System.Reflection.Emit.OpCodes.Call> instrução. Da mesma forma, a fim de permitir que a saída de uma região sincronizada após a chamada retorna, o `tail` prefixo é ignorado quando usado para sair de um método que está marcado como sincronizado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `tail` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">Uma instância de um objeto Opcode.</param>
        <summary>Retornará true ou false se o código de operação fornecido tiver um argumento de byte único.</summary>
        <returns><see langword="true" /> ou <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser usado para localizar os opcodes em MSIL são "forma abreviada," para uso em código otimizado.  
  
 `TakesSingleByteArgument` Retorna `true` se o <xref:System.Reflection.Emit.OpCode> instância usa um argumento de byte único nos seguintes casos:  
  
-   O opcode executa uma instrução de ramificação para um endereço de tamanho de byte (por exemplo, <xref:System.Reflection.Emit.OpCodes.Br_S> e <xref:System.Reflection.Emit.OpCodes.Bgt_S>).  
  
-   O código de operação envia um valor de byte para a pilha (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).  
  
-   O opcode faz referência a uma variável ou um argumento por meio do tamanho de byte "breve formulário" (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> e <xref:System.Reflection.Emit.OpCodes.Stloc_S>).  
  
 Caso contrário, retornará `false`.  
  
 O exemplo a seguir demonstra o uso de `TakesSingleByteArgument` refletindo para o `OpCodes` classe e testando para ver se cada `OpCode` campo usa um argumento de byte único.  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gera o objeto de exceção atualmente na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|7A|throw|Gerencie uma exceção.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto (uma exceção) é enviada para a pilha.  
  
2.  A referência de objeto é Aparecida da pilha e a exceção gerada.  
  
 O `throw` instrução gera o objeto de exceção (tipo `O`) atualmente na pilha.  
  
 <xref:System.NullReferenceException> será gerada se a referência de objeto é uma referência nula.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `throw` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica que um endereço atualmente sobre a pilha de avaliação pode não estar alinhado ao tamanho natural da instrução imediatamente após <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" /> ou <see langword="cpblk" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 12 &LT; `unsigned int8` >|não alinhado. `alignment`|Indica que a instrução de ponteiro subsequente pode ser não alinhada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço será enviado para a pilha.  
  
 `Unaligned` Especifica que o endereço (um ponteiro não gerenciado, `native int`) na pilha pode não estar alinhado ao tamanho natural de imediatamente após `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, ou `cpblk` instrução. Ou seja, para um <xref:System.Reflection.Emit.OpCodes.Ldind_I4> instrução o alinhamento do endereço não pode ser um limite de 4 bytes. Para `initblk` e `cpblk` o alinhamento padrão é dependente de arquitetura (4 bytes em CPUs de 32 bits, 8 bytes em CPUs de 64 bits). Geradores de código que não restringem a sua saída para um tamanho de palavra de 32 bits devem usar `unaligned` se o alinhamento não for conhecido no tempo de compilação seja 8 bytes.  
  
 O valor de alinhamento deve ser 1, 2 ou 4 e significa que o código gerado deve presumir que o endereço é um byte, dois bytes, ou quad bytes alinhado, respectivamente. Observe que transitório ponteiros (tipo `*`) sempre são alinhados.  
  
 Embora o alinhamento de um `cpblk` instrução logicamente exigiria dois números (um para a origem) e outro para o destino, não há nenhum impacto perceptível no desempenho se apenas o número mais baixo é especificado.  
  
 O `unaligned` e `volatile` prefixos podem ser combinados em qualquer ordem. Deve preceder imediatamente um `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, ou `cpblk` instrução. Somente o <xref:System.Reflection.Emit.OpCodes.Volatile> é permitido um prefixo para o <xref:System.Reflection.Emit.OpCodes.Ldsfld> e <xref:System.Reflection.Emit.OpCodes.Stsfld> instruções.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas de método podem usar o `unaligned` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
-   ILGenerator.Emit (Opcode, Byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte a representação demarcada de um tipo de valor em sua forma não marcada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|79 < `T` >|conversão unboxing `valType`|Extrai os dados de tipo de valor de `obj`, sua boxed representação.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto é inserida na pilha.  
  
2.  A referência de objeto é Aparecida da pilha e unboxed para um ponteiro de tipo de valor.  
  
3.  O ponteiro de tipo de valor é enviado para a pilha.  
  
 Um tipo de valor tem duas representações separadas dentro do Common Language Infrastructure (CLI):  
  
-   Uma forma de 'raw' usada quando um tipo de valor é inserido em outro objeto.  
  
-   Um formulário 'boxed', onde os dados no tipo de valor são empacotados (convertido) em um objeto para que ele pode existir como uma entidade independente.  
  
 O `unbox` converte a referência de objeto (tipo `O`), o box a representação de um tipo de valor para um ponteiro de tipo de valor (um ponteiro gerenciado, o tipo `&`), sua unboxed formulário. O tipo de valor fornecido (`valType`) é um token de metadados que indica o tipo do tipo de valor contido no objeto Demarcado.  
  
 Diferentemente <xref:System.Reflection.Emit.OpCodes.Box>, que é necessário para fazer uma cópia de um tipo de valor para uso no objeto, `unbox` não é necessário para copiar o tipo de valor do objeto. Normalmente, ele simplesmente calcula o endereço do tipo de valor que já está presente no objeto convertido.  
  
 <xref:System.InvalidCastException> será gerada se o objeto não é convertido como `valType`.  
  
 <xref:System.NullReferenceException> será gerada se a referência de objeto é uma referência nula.  
  
 <xref:System.TypeLoadException> será gerada se o valor de tipo `valType` não pode ser encontrado. Normalmente, isso é detectado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo, em vez de em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `unbox` opcode:  
  
-   ILGenerator.Emit (OpCode, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte a representação demarcada de um tipo especificado na instrução em sua forma não demarcada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista a instrução hexadecimal e formato do assembly Microsoft intermediate language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|A5 < `T` >|unbox.Any `typeTok`|Extrair os dados `obj`, sua boxed representação.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `obj` é enviado para a pilha.  
  
2.  A referência de objeto é Aparecida da pilha e unboxed para o tipo especificado na instrução.  
  
3.  O tipo de valor ou referência de objeto resultante é enviado para a pilha.  
  
 Quando aplicado a forma boxed do tipo de valor, o `unbox.any` instrução extrai o valor contido `obj` (do tipo `O`) e, portanto, é equivalente a `unbox` seguido por `ldobj`.  
  
 Quando aplicado a um tipo de referência, o `unbox.any` instrução tem o mesmo efeito que `castclass` `typeTok`.  
  
 Se o operando `typeTok` é um parâmetro de tipo genérico, em seguida, o comportamento de tempo de execução é determinado pelo tipo especificado para esse parâmetro de tipo genérico.  
  
 <xref:System.InvalidCastException> será gerada se `obj` não é um tipo Demarcado.  
  
 <xref:System.NullReferenceException> será gerada se `obj` é uma referência nula.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `unbox.any` opcode:  
  
-   ILGenerator.Emit (OpCode, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que um endereço atualmente sobre a pilha de avaliação pode ser volátil e os resultados da leitura daquele local não podem ser armazenados em cache ou não é possível suprimir vários repositórios para esse local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 13|volátil.|Indica que a referência de ponteiro subsequente é volátil.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço será enviado para a pilha.  
  
 `volatile`. Especifica que o endereço é um endereço voláteis (ou seja, ele pode ser referenciado externamente para o thread atual de execução) e os resultados de leitura de que local não pode ser armazenado em cache ou que vários repositórios para esse local não podem ser suprimidos. Marcar um acesso como `volatile` afeta apenas que o único acesso; outros acessos no mesmo local devem ser marcados separadamente. Acesso a locais volátil não precisa ser executado atomicamente.  
  
 O <xref:System.Reflection.Emit.OpCodes.Unaligned> e `volatile` prefixos podem ser combinados em qualquer ordem. Deve preceder imediatamente um `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, ou `cpblk` instrução. Somente o `volatile` é permitido um prefixo para o <xref:System.Reflection.Emit.OpCodes.Ldsfld> e <xref:System.Reflection.Emit.OpCodes.Stsfld> instruções.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `volatile` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Calcula o XOR bit a bit dos dois valores superiores na pilha de avaliação, efetuando o push do resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly de Microsoft Intermediate Language (MSIL), juntamente com um resumo breve de referência:  
  
|Formatar|Formato do assembly|Descrição|  
|------------|---------------------|-----------------|  
|61|xor|Calcula o XOR bit a bit de dois valores inteiros e retorna um inteiro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1` é enviado para a pilha.  
  
2.  `value2` é enviado para a pilha.  
  
3.  `value2` e `value1` são removidos da pilha e seus bit a bit XOR computado.  
  
4.  XOR bit a bit de `value2` e `value1` é enviado para a pilha.  
  
 O `xor` instrução calcula o XOR bit a bit dos dois primeiros valores na pilha e deixa o resultado na pilha.  
  
 `Xor` é uma operação de inteiro específico.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `xor` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>